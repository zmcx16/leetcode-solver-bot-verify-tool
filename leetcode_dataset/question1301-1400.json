{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1300,"row":{"number":1630,"difficulty":1,"question":"class Solution:\n    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:\n        \"\"\"\n        A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.\n        For example, these are arithmetic sequences:\n        1, 3, 5, 7, 9\n        7, 7, 7, 7\n        3, -1, -5, -9\n        The following sequence is not arithmetic:\n        1, 1, 2, 5, 7\n        You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.\n        Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.\n        Example 1:\n        Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]\n        Output: [true,false,true]\n        Explanation:\n        In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.\n        In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.\n        In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.\n        Example 2:\n        Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\n        Output: [false,true,false,false,true,true]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1301,"row":{"number":1631,"difficulty":1,"question":"class Solution:\r\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        \"\"\"\n        You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.\r\n        A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.\r\n        Return the minimum effort required to travel from the top-left cell to the bottom-right cell.\r\n        Example 1:\r\n        Input: heights = [[1,2,2],[3,8,2],[5,3,5]]\r\n        Output: 2\r\n        Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.\r\n        This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.\r\n        Example 2:\r\n        Input: heights = [[1,2,3],[3,8,4],[5,3,5]]\r\n        Output: 1\r\n        Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].\r\n        Example 3:\r\n        Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\r\n        Output: 0\r\n        Explanation: This route does not require any effort.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1302,"row":{"number":1652,"difficulty":0,"question":"class Solution:\n    def decrypt(self, code: List[int], k: int) -> List[int]:\n        \"\"\"\n        You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.\n        To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.\n            If k > 0, replace the ith number with the sum of the next k numbers.\n            If k < 0, replace the ith number with the sum of the previous k numbers.\n            If k == 0, replace the ith number with 0.\n        As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].\n        Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!\n        Example 1:\n        Input: code = [5,7,1,4], k = 3\n        Output: [12,10,16,13]\n        Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.\n        Example 2:\n        Input: code = [1,2,3,4], k = 0\n        Output: [0,0,0,0]\n        Explanation: When k is zero, the numbers are replaced by 0. \n        Example 3:\n        Input: code = [2,4,9,3], k = -2\n        Output: [12,5,6,13]\n        Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1303,"row":{"number":1653,"difficulty":1,"question":"class Solution:\n    def minimumDeletions(self, s: str) -> int:\n        \"\"\"\n        You are given a string s consisting only of characters 'a' and 'b'​​​​.\n        You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.\n        Return the minimum number of deletions needed to make s balanced.\n        Example 1:\n        Input: s = \"aababbab\"\n        Output: 2\n        Explanation: You can either:\n        Delete the characters at 0-indexed positions 2 and 6 (\"aababbab\" -> \"aaabbb\"), or\n        Delete the characters at 0-indexed positions 3 and 6 (\"aababbab\" -> \"aabbbb\").\n        Example 2:\n        Input: s = \"bbaaaaabb\"\n        Output: 2\n        Explanation: The only solution is to delete the first two characters.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1304,"row":{"number":1654,"difficulty":1,"question":"class Solution:\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n        \"\"\"\n        A certain bug's home is on the x-axis at position x. Help them get there from position 0.\n        The bug jumps according to the following rules:\n            It can jump exactly a positions forward (to the right).\n            It can jump exactly b positions backward (to the left).\n            It cannot jump backward twice in a row.\n            It cannot jump to any forbidden positions.\n        The bug may jump forward beyond its home, but it cannot jump to positions numbered with negative integers.\n        Given an array of integers forbidden, where forbidden[i] means that the bug cannot jump to the position forbidden[i], and integers a, b, and x, return the minimum number of jumps needed for the bug to reach its home. If there is no possible sequence of jumps that lands the bug on position x, return -1.\n        Example 1:\n        Input: forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\n        Output: 3\n        Explanation: 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.\n        Example 2:\n        Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\n        Output: -1\n        Example 3:\n        Input: forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\n        Output: 2\n        Explanation: One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1305,"row":{"number":1655,"difficulty":2,"question":"class Solution:\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n        \"\"\"\n        You are given an array of n integers, nums, where there are at most 50 unique values in the array. You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. Determine if it is possible to distribute nums such that:\n            The ith customer gets exactly quantity[i] integers,\n            The integers the ith customer gets are all equal, and\n            Every customer is satisfied.\n        Return true if it is possible to distribute nums according to the above conditions.\n        Example 1:\n        Input: nums = [1,2,3,4], quantity = [2]\n        Output: false\n        Explanation: The 0th customer cannot be given two different integers.\n        Example 2:\n        Input: nums = [1,2,3,3], quantity = [2]\n        Output: true\n        Explanation: The 0th customer is given [3,3]. The integers [1,2] are not used.\n        Example 3:\n        Input: nums = [1,1,2,2], quantity = [2,2]\n        Output: true\n        Explanation: The 0th customer is given [1,1], and the 1st customer is given [2,2].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1306,"row":{"number":1640,"difficulty":0,"question":"class Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        \"\"\"\n        You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\n        Return true if it is possible to form the array arr from pieces. Otherwise, return false.\n        Example 1:\n        Input: arr = [15,88], pieces = [[88],[15]]\n        Output: true\n        Explanation: Concatenate [15] then [88]\n        Example 2:\n        Input: arr = [49,18,16], pieces = [[16,18,49]]\n        Output: false\n        Explanation: Even though the numbers match, we cannot reorder pieces[0].\n        Example 3:\n        Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\n        Output: true\n        Explanation: Concatenate [91] then [4,64] then [78]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1307,"row":{"number":1641,"difficulty":1,"question":"class Solution:\n    def countVowelStrings(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n        A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.\n        Example 1:\n        Input: n = 1\n        Output: 5\n        Explanation: The 5 sorted strings that consist of vowels only are [\"a\",\"e\",\"i\",\"o\",\"u\"].\n        Example 2:\n        Input: n = 2\n        Output: 15\n        Explanation: The 15 sorted strings that consist of vowels only are\n        [\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"].\n        Note that \"ea\" is not a valid string since 'e' comes after 'a' in the alphabet.\n        Example 3:\n        Input: n = 33\n        Output: 66045\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1308,"row":{"number":1642,"difficulty":1,"question":"class Solution:\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\n        \"\"\"\n        You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.\n        You start your journey from building 0 and move to the next building by possibly using bricks or ladders.\n        While moving from building i to building i+1 (0-indexed),\n            If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.\n            If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.\n        Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.\n        Example 1:\n        Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n        Output: 4\n        Explanation: Starting at building 0, you can follow these steps:\n        - Go to building 1 without using ladders nor bricks since 4 >= 2.\n        - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n        - Go to building 3 without using ladders nor bricks since 7 >= 6.\n        - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\n        It is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n        Example 2:\n        Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n        Output: 7\n        Example 3:\n        Input: heights = [14,3,19,3], bricks = 17, ladders = 0\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1309,"row":{"number":1668,"difficulty":0,"question":"class Solution:\n    def maxRepeating(self, sequence: str, word: str) -> int:\n        \"\"\"\n        For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word's maximum k-repeating value is 0.\n        Given strings sequence and word, return the maximum k-repeating value of word in sequence.\n        Example 1:\n        Input: sequence = \"ababc\", word = \"ab\"\n        Output: 2\n        Explanation: \"abab\" is a substring in \"ababc\".\n        Example 2:\n        Input: sequence = \"ababc\", word = \"ba\"\n        Output: 1\n        Explanation: \"ba\" is a substring in \"ababc\". \"baba\" is not a substring in \"ababc\".\n        Example 3:\n        Input: sequence = \"ababc\", word = \"ac\"\n        Output: 0\n        Explanation: \"ac\" is not a substring in \"ababc\". \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1310,"row":{"number":1669,"difficulty":1,"question":"class Solution:\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\n        \"\"\"\n        You are given two linked lists: list1 and list2 of sizes n and m respectively.\n        Remove list1's nodes from the ath node to the bth node, and put list2 in their place.\n        The blue edges and nodes in the following figure indicate the result:\n        Build the result list and return its head.\n        Example 1:\n        Input: list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n        Output: [0,1,2,1000000,1000001,1000002,5]\n        Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.\n        Example 2:\n        Input: list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\n        Output: [0,1,1000000,1000001,1000002,1000003,1000004,6]\n        Explanation: The blue edges and nodes in the above figure indicate the result.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1311,"row":{"number":1671,"difficulty":2,"question":"class Solution:\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\n        \"\"\"\n        You may recall that an array arr is a mountain array if and only if:\n            arr.length >= 3\n            There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n                arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n                arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n        Given an integer array nums​​​, return the minimum number of elements to remove to make nums​​​ a mountain array.\n        Example 1:\n        Input: nums = [1,3,1]\n        Output: 0\n        Explanation: The array itself is a mountain array so we do not need to remove any elements.\n        Example 2:\n        Input: nums = [2,1,1,5,6,2,3,1]\n        Output: 3\n        Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1312,"row":{"number":1670,"difficulty":1,"question":"class FrontMiddleBackQueue:\n    def __init__(self):\n    def pushFront(self, val: int) -> None:\n    def pushMiddle(self, val: int) -> None:\n    def pushBack(self, val: int) -> None:\n    def popFront(self) -> int:\n    def popMiddle(self) -> int:\n    def popBack(self) -> int:\n        \"\"\"\n        Design a queue that supports push and pop operations in the front, middle, and back.\n        Implement the FrontMiddleBack class:\n            FrontMiddleBack() Initializes the queue.\n            void pushFront(int val) Adds val to the front of the queue.\n            void pushMiddle(int val) Adds val to the middle of the queue.\n            void pushBack(int val) Adds val to the back of the queue.\n            int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.\n            int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.\n            int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.\n        Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:\n            Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].\n            Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].\n        Example 1:\n        Input:\n        [\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"]\n        [[], [1], [2], [3], [4], [], [], [], [], []]\n        Output:\n        [null, null, null, null, null, 1, 3, 4, 2, -1]\n        Explanation:\n        FrontMiddleBackQueue q = new FrontMiddleBackQueue();\n        q.pushFront(1);   // [1]\n        q.pushBack(2);    // [1, 2]\n        q.pushMiddle(3);  // [1, 3, 2]\n        q.pushMiddle(4);  // [1, 4, 3, 2]\n        q.popFront();     // return 1 -> [4, 3, 2]\n        q.popMiddle();    // return 3 -> [4, 2]\n        q.popMiddle();    // return 4 -> [2]\n        q.popBack();      // return 2 -> []\n        q.popFront();     // return -1 -> [] (The queue is empty)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1313,"row":{"number":1646,"difficulty":0,"question":"class Solution:\n    def getMaximumGenerated(self, n: int) -> int:\n        \"\"\"\n        You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n            nums[0] = 0\n            nums[1] = 1\n            nums[2 * i] = nums[i] when 2 <= 2 * i <= n\n            nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\n        Return the maximum integer in the array nums​​​.\n        Example 1:\n        Input: n = 7\n        Output: 3\n        Explanation: According to the given rules:\n          nums[0] = 0\n          nums[1] = 1\n          nums[(1 * 2) = 2] = nums[1] = 1\n          nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n          nums[(2 * 2) = 4] = nums[2] = 1\n          nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n          nums[(3 * 2) = 6] = nums[3] = 2\n          nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\n        Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\n        Example 2:\n        Input: n = 2\n        Output: 1\n        Explanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\n        Example 3:\n        Input: n = 3\n        Output: 2\n        Explanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1314,"row":{"number":1647,"difficulty":1,"question":"class Solution:\n    def minDeletions(self, s: str) -> int:\n        \"\"\"\n        A string s is called good if there are no two different characters in s that have the same frequency.\n        Given a string s, return the minimum number of characters you need to delete to make s good.\n        The frequency of a character in a string is the number of times it appears in the string. For example, in the string \"aab\", the frequency of 'a' is 2, while the frequency of 'b' is 1.\n        Example 1:\n        Input: s = \"aab\"\n        Output: 0\n        Explanation: s is already good.\n        Example 2:\n        Input: s = \"aaabbbcc\"\n        Output: 2\n        Explanation: You can delete two 'b's resulting in the good string \"aaabcc\".\n        Another way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\".\n        Example 3:\n        Input: s = \"ceabaacb\"\n        Output: 2\n        Explanation: You can delete both 'c's resulting in the good string \"eabaab\".\n        Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1315,"row":{"number":1648,"difficulty":1,"question":"class Solution:\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\n        \"\"\"\n        You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.\n        The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer).\n        You are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order.\n        Return the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: inventory = [2,5], orders = 4\n        Output: 14\n        Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\n        The maximum total value is 2 + 5 + 4 + 3 = 14.\n        Example 2:\n        Input: inventory = [3,5], orders = 6\n        Output: 19\n        Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\n        The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1316,"row":{"number":1649,"difficulty":2,"question":"class Solution:\n    def createSortedArray(self, instructions: List[int]) -> int:\n        \"\"\"\n        Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:\r\n            The number of elements currently in nums that are strictly less than instructions[i].\r\n            The number of elements currently in nums that are strictly greater than instructions[i].\r\n        For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2, 1) (elements 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5].\r\n        Return the total cost to insert all elements from instructions into nums. Since the answer may be large, return it modulo 109 + 7\r\n        Example 1:\r\n        Input: instructions = [1,5,6,2]\r\n        Output: 1\r\n        Explanation: Begin with nums = [].\r\n        Insert 1 with cost min(0, 0) = 0, now nums = [1].\r\n        Insert 5 with cost min(1, 0) = 0, now nums = [1,5].\r\n        Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6].\r\n        Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].\r\n        The total cost is 0 + 0 + 0 + 1 = 1.\r\n        Example 2:\r\n        Input: instructions = [1,2,3,6,5,4]\r\n        Output: 3\r\n        Explanation: Begin with nums = [].\r\n        Insert 1 with cost min(0, 0) = 0, now nums = [1].\r\n        Insert 2 with cost min(1, 0) = 0, now nums = [1,2].\r\n        Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3].\r\n        Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].\r\n        Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].\r\n        Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].\r\n        The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.\r\n        Example 3:\r\n        Input: instructions = [1,3,3,3,2,4,2,1,2]\r\n        Output: 4\r\n        Explanation: Begin with nums = [].\r\n        Insert 1 with cost min(0, 0) = 0, now nums = [1].\r\n        Insert 3 with cost min(1, 0) = 0, now nums = [1,3].\r\n        Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3].\r\n        Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].\r\n        Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].\r\n        Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].\r\n        ​​​​​​​Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].\r\n        ​​​​​​​Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].\r\n        ​​​​​​​Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].\r\n        The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1317,"row":{"number":1656,"difficulty":0,"question":"class OrderedStream:\n    def __init__(self, n: int):\n    def insert(self, idKey: int, value: str) -> List[str]:\n        \"\"\"\n        There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id.\n        Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.\n        Implement the OrderedStream class:\n            OrderedStream(int n) Constructs the stream to take n values.\n            String[] insert(int idKey, String value) Inserts the pair (idKey, value) into the stream, then returns the largest possible chunk of currently inserted values that appear next in the order.\n        Example:\n        Input\n        [\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"]\n        [[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]]\n        Output\n        [null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]]\n        Explanation\n        // Note that the values ordered by ID is [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"].\n        OrderedStream os = new OrderedStream(5);\n        os.insert(3, \"ccccc\"); // Inserts (3, \"ccccc\"), returns [].\n        os.insert(1, \"aaaaa\"); // Inserts (1, \"aaaaa\"), returns [\"aaaaa\"].\n        os.insert(2, \"bbbbb\"); // Inserts (2, \"bbbbb\"), returns [\"bbbbb\", \"ccccc\"].\n        os.insert(5, \"eeeee\"); // Inserts (5, \"eeeee\"), returns [].\n        os.insert(4, \"ddddd\"); // Inserts (4, \"ddddd\"), returns [\"ddddd\", \"eeeee\"].\n        // Concatentating all the chunks returned:\n        // [] + [\"aaaaa\"] + [\"bbbbb\", \"ccccc\"] + [] + [\"ddddd\", \"eeeee\"] = [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"]\n        // The resulting order is the same as the order above.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1318,"row":{"number":1658,"difficulty":1,"question":"class Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.\n        Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.\n        Example 1:\n        Input: nums = [1,1,4,2,3], x = 5\n        Output: 2\n        Explanation: The optimal solution is to remove the last two elements to reduce x to zero.\n        Example 2:\n        Input: nums = [5,6,7,8,9], x = 4\n        Output: -1\n        Example 3:\n        Input: nums = [3,2,20,1,1,3], x = 10\n        Output: 5\n        Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1319,"row":{"number":1657,"difficulty":1,"question":"class Solution:\n    def closeStrings(self, word1: str, word2: str) -> bool:\n        \"\"\"\n        Two strings are considered close if you can attain one from the other using the following operations:\n            Operation 1: Swap any two existing characters.\n                For example, abcde -> aecdb\n            Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\n                For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)\n        You can use the operations on either string as many times as necessary.\n        Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.\n        Example 1:\n        Input: word1 = \"abc\", word2 = \"bca\"\n        Output: true\n        Explanation: You can attain word2 from word1 in 2 operations.\n        Apply Operation 1: \"abc\" -> \"acb\"\n        Apply Operation 1: \"acb\" -> \"bca\"\n        Example 2:\n        Input: word1 = \"a\", word2 = \"aa\"\n        Output: false\n        Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.\n        Example 3:\n        Input: word1 = \"cabbba\", word2 = \"abbccc\"\n        Output: true\n        Explanation: You can attain word2 from word1 in 3 operations.\n        Apply Operation 1: \"cabbba\" -> \"caabbb\"\n        Apply Operation 2: \"caabbb\" -> \"baaccc\"\n        Apply Operation 2: \"baaccc\" -> \"abbccc\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1320,"row":{"number":1659,"difficulty":2,"question":"class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\n        \"\"\"\n        You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.\n        You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\n        The happiness of each person is calculated as follows:\n            Introverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).\n            Extroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).\n        Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\n        The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.\n        Example 1:\n        Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n        Output: 240\n        Explanation: Assume the grid is 1-indexed with coordinates (row, column).\n        We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n        - Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n        - Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n        - Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n        The grid happiness is 120 + 60 + 60 = 240.\n        The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n        Example 2:\n        Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n        Output: 260\n        Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n        - Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n        - Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n        - Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n        The grid happiness is 90 + 80 + 90 = 260.\n        Example 3:\n        Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n        Output: 240\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1321,"row":{"number":1662,"difficulty":0,"question":"class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        \"\"\"\n        Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\n        A string is represented by an array if the array elements concatenated in order forms the string.\n        Example 1:\n        Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\n        Output: true\n        Explanation:\n        word1 represents string \"ab\" + \"c\" -> \"abc\"\n        word2 represents string \"a\" + \"bc\" -> \"abc\"\n        The strings are the same, so return true.\n        Example 2:\n        Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\n        Output: false\n        Example 3:\n        Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1322,"row":{"number":1663,"difficulty":1,"question":"class Solution:\n    def getSmallestString(self, n: int, k: int) -> str:\n        \"\"\"\n        The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.\n        The numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string \"abe\" is equal to 1 + 2 + 5 = 8.\n        You are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to k.\n        Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.\n        Example 1:\n        Input: n = 3, k = 27\n        Output: \"aay\"\n        Explanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3.\n        Example 2:\n        Input: n = 5, k = 73\n        Output: \"aaszz\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1323,"row":{"number":1664,"difficulty":1,"question":"class Solution:\n    def waysToMakeFair(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. Notice that the index of the elements may change after the removal.\n        For example, if nums = [6,1,7,4,1]:\n            Choosing to remove index 1 results in nums = [6,7,4,1].\n            Choosing to remove index 2 results in nums = [6,1,4,1].\n            Choosing to remove index 4 results in nums = [6,1,7,4].\n        An array is fair if the sum of the odd-indexed values equals the sum of the even-indexed values.\n        Return the number of indices that you could choose such that after the removal, nums is fair. \n        Example 1:\n        Input: nums = [2,1,6,4]\n        Output: 1\n        Explanation:\n        Remove index 0: [1,6,4] -> Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.\n        Remove index 1: [2,6,4] -> Even sum: 2 + 4 = 6. Odd sum: 6. Fair.\n        Remove index 2: [2,1,4] -> Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.\n        Remove index 3: [2,1,6] -> Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.\n        There is 1 index that you can remove to make nums fair.\n        Example 2:\n        Input: nums = [1,1,1]\n        Output: 3\n        Explanation: You can remove any index and the remaining array is fair.\n        Example 3:\n        Input: nums = [1,2,3]\n        Output: 0\n        Explanation: You cannot make a fair array after removing any index.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1324,"row":{"number":1665,"difficulty":2,"question":"class Solution:\n    def minimumEffort(self, tasks: List[List[int]]) -> int:\n        \"\"\"\n        You are given an array tasks where tasks[i] = [actuali, minimumi]:\n            actuali is the actual amount of energy you spend to finish the ith task.\n            minimumi is the minimum amount of energy you require to begin the ith task.\n        For example, if the task is [10, 12] and your current energy is 11, you cannot start this task. However, if your current energy is 13, you can complete this task, and your energy will be 3 after finishing it.\n        You can finish the tasks in any order you like.\n        Return the minimum initial amount of energy you will need to finish all the tasks.\n        Example 1:\n        Input: tasks = [[1,2],[2,4],[4,8]]\n        Output: 8\n        Explanation:\n        Starting with 8 energy, we finish the tasks in the following order:\n            - 3rd task. Now energy = 8 - 4 = 4.\n            - 2nd task. Now energy = 4 - 2 = 2.\n            - 1st task. Now energy = 2 - 1 = 1.\n        Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n        Example 2:\n        Input: tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]\n        Output: 32\n        Explanation:\n        Starting with 32 energy, we finish the tasks in the following order:\n            - 1st task. Now energy = 32 - 1 = 31.\n            - 2nd task. Now energy = 31 - 2 = 29.\n            - 3rd task. Now energy = 29 - 10 = 19.\n            - 4th task. Now energy = 19 - 10 = 9.\n            - 5th task. Now energy = 9 - 8 = 1.\n        Example 3:\n        Input: tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]\n        Output: 27\n        Explanation:\n        Starting with 27 energy, we finish the tasks in the following order:\n            - 5th task. Now energy = 27 - 5 = 22.\n            - 2nd task. Now energy = 22 - 2 = 20.\n            - 3rd task. Now energy = 20 - 3 = 17.\n            - 1st task. Now energy = 17 - 1 = 16.\n            - 4th task. Now energy = 16 - 4 = 12.\n            - 6th task. Now energy = 12 - 6 = 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1325,"row":{"number":1684,"difficulty":0,"question":"class Solution:\n    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:\n        \"\"\"\n        You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.\n        Return the number of consistent strings in the array words.\n        Example 1:\n        Input: allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n        Output: 2\n        Explanation: Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'.\n        Example 2:\n        Input: allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\n        Output: 7\n        Explanation: All strings are consistent.\n        Example 3:\n        Input: allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n        Output: 4\n        Explanation: Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1326,"row":{"number":1685,"difficulty":1,"question":"class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer array nums sorted in non-decreasing order.\n        Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\n        In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).\n        Example 1:\n        Input: nums = [2,3,5]\n        Output: [4,3,5]\n        Explanation: Assuming the arrays are 0-indexed, then\n        result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\n        result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\n        result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.\n        Example 2:\n        Input: nums = [1,4,6,8,10]\n        Output: [24,15,13,15,21]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1327,"row":{"number":1686,"difficulty":1,"question":"class Solution:\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\n        \"\"\"\n        Alice and Bob take turns playing a game, with Alice starting first.\n        There are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.\n        You are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.\n        The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally. Both players know the other's values.\n        Determine the result of the game, and:\n            If Alice wins, return 1.\n            If Bob wins, return -1.\n            If the game results in a draw, return 0.\n        Example 1:\n        Input: aliceValues = [1,3], bobValues = [2,1]\n        Output: 1\n        Explanation:\n        If Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\n        Bob can only choose stone 0, and will only receive 2 points.\n        Alice wins.\n        Example 2:\n        Input: aliceValues = [1,2], bobValues = [3,1]\n        Output: 0\n        Explanation:\n        If Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\n        Draw.\n        Example 3:\n        Input: aliceValues = [2,4,3], bobValues = [1,6,7]\n        Output: -1\n        Explanation:\n        Regardless of how Alice plays, Bob will be able to have more points than Alice.\n        For example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\n        Bob wins.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1328,"row":{"number":1687,"difficulty":2,"question":"class Solution:\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n        \"\"\"\n        You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.\n        You are given an array boxes, where boxes[i] = [ports​​i​, weighti], and three integers portsCount, maxBoxes, and maxWeight.\n            ports​​i is the port where you need to deliver the ith box and weightsi is the weight of the ith box.\n            portsCount is the number of ports.\n            maxBoxes and maxWeight are the respective box and weight limits of the ship.\n        The boxes need to be delivered in the order they are given. The ship will follow these steps:\n            The ship will take some number of boxes from the boxes queue, not violating the maxBoxes and maxWeight constraints.\n            For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.\n            The ship then makes a return trip to storage to take more boxes from the queue.\n        The ship must end at storage after all the boxes have been delivered.\n        Return the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.\n        Example 1:\n        Input: boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3\n        Output: 4\n        Explanation: The optimal strategy is as follows: \n        - The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\n        So the total number of trips is 4.\n        Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n        Example 2:\n        Input: boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6\n        Output: 6\n        Explanation: The optimal strategy is as follows: \n        - The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n        - The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n        - The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\n        So the total number of trips is 2 + 2 + 2 = 6.\n        Example 3:\n        Input: boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7\n        Output: 6\n        Explanation: The optimal strategy is as follows:\n        - The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n        - The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n        - The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\n        So the total number of trips is 2 + 2 + 2 = 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1329,"row":{"number":1672,"difficulty":0,"question":"class Solution:\n    def maximumWealth(self, accounts: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.\n        A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.\n        Example 1:\n        Input: accounts = [[1,2,3],[3,2,1]]\n        Output: 6\n        Explanation:\n        1st customer has wealth = 1 + 2 + 3 = 6\n        2nd customer has wealth = 3 + 2 + 1 = 6\n        Both customers are considered the richest with a wealth of 6 each, so return 6.\n        Example 2:\n        Input: accounts = [[1,5],[7,3],[3,5]]\n        Output: 10\n        Explanation: \n        1st customer has wealth = 6\n        2nd customer has wealth = 10 \n        3rd customer has wealth = 8\n        The 2nd customer is the richest with a wealth of 10.\n        Example 3:\n        Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]\n        Output: 17\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1330,"row":{"number":1673,"difficulty":1,"question":"class Solution:\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k.\n        An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.\n        We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5.\n        Example 1:\n        Input: nums = [3,5,2,6], k = 2\n        Output: [2,6]\n        Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.\n        Example 2:\n        Input: nums = [2,4,3,3,5,4,9,6], k = 4\n        Output: [2,3,3,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1331,"row":{"number":1674,"difficulty":1,"question":"class Solution:\n    def minMoves(self, nums: List[int], limit: int) -> int:\n        \"\"\"\n        You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.\n        The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.\n        Return the minimum number of moves required to make nums complementary.\n        Example 1:\n        Input: nums = [1,2,4,3], limit = 4\n        Output: 1\n        Explanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed).\n        nums[0] + nums[3] = 1 + 3 = 4.\n        nums[1] + nums[2] = 2 + 2 = 4.\n        nums[2] + nums[1] = 2 + 2 = 4.\n        nums[3] + nums[0] = 3 + 1 = 4.\n        Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.\n        Example 2:\n        Input: nums = [1,2,2,1], limit = 2\n        Output: 2\n        Explanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit.\n        Example 3:\n        Input: nums = [1,2,1,2], limit = 2\n        Output: 0\n        Explanation: nums is already complementary.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1332,"row":{"number":1675,"difficulty":2,"question":"class Solution:\n    def minimumDeviation(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums of n positive integers.\n        You can perform two types of operations on any element of the array any number of times:\n            If the element is even, divide it by 2.\n                For example, if the array is [1,2,3,4], then you can do this operation on the last element, and the array will be [1,2,3,2].\n            If the element is odd, multiply it by 2.\n                For example, if the array is [1,2,3,4], then you can do this operation on the first element, and the array will be [2,2,3,4].\n        The deviation of the array is the maximum difference between any two elements in the array.\n        Return the minimum deviation the array can have after performing some number of operations.\n        Example 1:\n        Input: nums = [1,2,3,4]\n        Output: 1\n        Explanation: You can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.\n        Example 2:\n        Input: nums = [4,1,5,20,3]\n        Output: 3\n        Explanation: You can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.\n        Example 3:\n        Input: nums = [2,10,8]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1333,"row":{"number":1678,"difficulty":0,"question":"class Solution:\n    def interpret(self, command: str) -> str:\n        \"\"\"\n        You own a Goal Parser that can interpret a string command. The command consists of an alphabet of \"G\", \"()\" and/or \"(al)\" in some order. The Goal Parser will interpret \"G\" as the string \"G\", \"()\" as the string \"o\", and \"(al)\" as the string \"al\". The interpreted strings are then concatenated in the original order.\n        Given the string command, return the Goal Parser's interpretation of command.\n        Example 1:\n        Input: command = \"G()(al)\"\n        Output: \"Goal\"\n        Explanation: The Goal Parser interprets the command as follows:\n        G -> G\n        () -> o\n        (al) -> al\n        The final concatenated result is \"Goal\".\n        Example 2:\n        Input: command = \"G()()()()(al)\"\n        Output: \"Gooooal\"\n        Example 3:\n        Input: command = \"(al)G(al)()()G\"\n        Output: \"alGalooG\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1334,"row":{"number":1679,"difficulty":1,"question":"class Solution:\n    def maxOperations(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer k.\n        In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.\n        Return the maximum number of operations you can perform on the array.\n        Example 1:\n        Input: nums = [1,2,3,4], k = 5\n        Output: 2\n        Explanation: Starting with nums = [1,2,3,4]:\n        - Remove numbers 1 and 4, then nums = [2,3]\n        - Remove numbers 2 and 3, then nums = []\n        There are no more pairs that sum up to 5, hence a total of 2 operations.\n        Example 2:\n        Input: nums = [3,1,3,4,3], k = 6\n        Output: 1\n        Explanation: Starting with nums = [3,1,3,4,3]:\n        - Remove the first two 3's, then nums = [1,4,3]\n        There are no more pairs that sum up to 6, hence a total of 1 operation.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1335,"row":{"number":1681,"difficulty":2,"question":"class Solution:\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums​​​ and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.\n        A subset's incompatibility is the difference between the maximum and minimum elements in that array.\n        Return the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.\n        A subset is a group integers that appear in the array with no particular order.\n        Example 1:\n        Input: nums = [1,2,1,4], k = 2\n        Output: 4\n        Explanation: The optimal distribution of subsets is [1,2] and [1,4].\n        The incompatibility is (2-1) + (4-1) = 4.\n        Note that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.\n        Example 2:\n        Input: nums = [6,3,8,1,3,1,2,2], k = 4\n        Output: 6\n        Explanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].\n        The incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.\n        Example 3:\n        Input: nums = [5,3,3,6,3,3], k = 3\n        Output: -1\n        Explanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1336,"row":{"number":1680,"difficulty":1,"question":"class Solution:\n    def concatenatedBinary(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.\n        Example 1:\n        Input: n = 1\n        Output: 1\n        Explanation: \"1\" in binary corresponds to the decimal value 1. \n        Example 2:\n        Input: n = 3\n        Output: 27\n        Explanation: In binary, 1, 2, and 3 corresponds to \"1\", \"10\", and \"11\".\n        After concatenating them, we have \"11011\", which corresponds to the decimal value 27.\n        Example 3:\n        Input: n = 12\n        Output: 505379714\n        Explanation: The concatenation results in \"1101110010111011110001001101010111100\".\n        The decimal value of that is 118505380540.\n        After modulo 109 + 7, the result is 505379714.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1337,"row":{"number":1700,"difficulty":0,"question":"class Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\n        \"\"\"\n        The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.\n        The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:\n            If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.\n            Otherwise, they will leave it and go to the queue's end.\n        This continues until none of the queue students want to take the top sandwich and are thus unable to eat.\n        You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.\n        Example 1:\n        Input: students = [1,1,0,0], sandwiches = [0,1,0,1]\n        Output: 0 \n        Explanation:\n        - Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].\n        - Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].\n        - Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].\n        - Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].\n        - Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].\n        - Front student leaves the top sandwich and returns to the end of the line making students = [0,1].\n        - Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].\n        - Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].\n        Hence all students are able to eat.\n        Example 2:\n        Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1338,"row":{"number":1701,"difficulty":1,"question":"class Solution:\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\n        \"\"\"\n        There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:\n            arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.\n            timei is the time needed to prepare the order of the ith customer.\n        When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input.\n        Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted.\n        Example 1:\n        Input: customers = [[1,2],[2,5],[4,3]]\n        Output: 5.00000\n        Explanation:\n        1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.\n        2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.\n        3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.\n        So the average waiting time = (2 + 6 + 7) / 3 = 5.\n        Example 2:\n        Input: customers = [[5,2],[5,4],[10,3],[20,1]]\n        Output: 3.25000\n        Explanation:\n        1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.\n        2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.\n        3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.\n        4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.\n        So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1339,"row":{"number":1702,"difficulty":1,"question":"class Solution:\n    def maximumBinaryString(self, binary: str) -> str:\n        \"\"\"\n        You are given a binary string binary consisting of only 0's or 1's. You can apply each of the following operations any number of times:\n            Operation 1: If the number contains the substring \"00\", you can replace it with \"10\".\n                For example, \"00010\" -> \"10010\"\n            Operation 2: If the number contains the substring \"10\", you can replace it with \"01\".\n                For example, \"00010\" -> \"00001\"\n        Return the maximum binary string you can obtain after any number of operations. Binary string x is greater than binary string y if x's decimal representation is greater than y's decimal representation.\n        Example 1:\n        Input: binary = \"000110\"\n        Output: \"111011\"\n        Explanation: A valid transformation sequence can be:\n        \"000110\" -> \"000101\" \n        \"000101\" -> \"100101\" \n        \"100101\" -> \"110101\" \n        \"110101\" -> \"110011\" \n        \"110011\" -> \"111011\"\n        Example 2:\n        Input: binary = \"01\"\n        Output: \"01\"\n        Explanation: \"01\" cannot be transformed any further.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1340,"row":{"number":1703,"difficulty":2,"question":"class Solution:\n    def minMoves(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array, nums, and an integer k. nums comprises of only 0's and 1's. In one move, you can choose two adjacent indices and swap their values.\n        Return the minimum number of moves required so that nums has k consecutive 1's.\n        Example 1:\n        Input: nums = [1,0,0,1,0,1], k = 2\n        Output: 1\n        Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.\n        Example 2:\n        Input: nums = [1,0,0,0,0,0,1,1], k = 3\n        Output: 5\n        Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].\n        Example 3:\n        Input: nums = [1,1,0,1], k = 2\n        Output: 0\n        Explanation: nums already has 2 consecutive 1's.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1341,"row":{"number":1688,"difficulty":0,"question":"class Solution:\n    def numberOfMatches(self, n: int) -> int:\n        \"\"\"\n        You are given an integer n, the number of teams in a tournament that has strange rules:\n            If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.\n            If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.\n        Return the number of matches played in the tournament until a winner is decided.\n        Example 1:\n        Input: n = 7\n        Output: 6\n        Explanation: Details of the tournament: \n        - 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n        - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n        - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\n        Total number of matches = 3 + 2 + 1 = 6.\n        Example 2:\n        Input: n = 14\n        Output: 13\n        Explanation: Details of the tournament:\n        - 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n        - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n        - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n        - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\n        Total number of matches = 7 + 3 + 2 + 1 = 13.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1342,"row":{"number":1689,"difficulty":1,"question":"class Solution:\n    def minPartitions(self, n: str) -> int:\n        \"\"\"\n        A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.\n        Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.\n        Example 1:\n        Input: n = \"32\"\n        Output: 3\n        Explanation: 10 + 11 + 11 = 32\n        Example 2:\n        Input: n = \"82734\"\n        Output: 8\n        Example 3:\n        Input: n = \"27346209830709182346\"\n        Output: 9\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1343,"row":{"number":1690,"difficulty":1,"question":"class Solution:\n    def stoneGameVII(self, stones: List[int]) -> int:\n        \"\"\"\n        Alice and Bob take turns playing a game, with Alice starting first.\n        There are n stones arranged in a row. On each player's turn, they can remove either the leftmost stone or the rightmost stone from the row and receive points equal to the sum of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.\n        Bob found that he will always lose this game (poor Bob, he always loses), so he decided to minimize the score's difference. Alice's goal is to maximize the difference in the score.\n        Given an array of integers stones where stones[i] represents the value of the ith stone from the left, return the difference in Alice and Bob's score if they both play optimally.\n        Example 1:\n        Input: stones = [5,3,1,4,2]\n        Output: 6\n        Explanation: \n        - Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4].\n        - Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4].\n        - Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4].\n        - Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4].\n        - Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = [].\n        The score difference is 18 - 12 = 6.\n        Example 2:\n        Input: stones = [7,90,5,1,100,10,10,2]\n        Output: 122\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1344,"row":{"number":1694,"difficulty":0,"question":"class Solution:\n    def reformatNumber(self, number: str) -> str:\n        \"\"\"\n        You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'.\n        You would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows:\n            2 digits: A single block of length 2.\n            3 digits: A single block of length 3.\n            4 digits: Two blocks of length 2 each.\n        The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2.\n        Return the phone number after formatting.\n        Example 1:\n        Input: number = \"1-23-45 6\"\n        Output: \"123-456\"\n        Explanation: The digits are \"123456\".\n        Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\".\n        Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is \"456\".\n        Joining the blocks gives \"123-456\".\n        Example 2:\n        Input: number = \"123 4-567\"\n        Output: \"123-45-67\"\n        Explanation: The digits are \"1234567\".\n        Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\".\n        Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are \"45\" and \"67\".\n        Joining the blocks gives \"123-45-67\".\n        Example 3:\n        Input: number = \"123 4-5678\"\n        Output: \"123-456-78\"\n        Explanation: The digits are \"12345678\".\n        Step 1: The 1st block is \"123\".\n        Step 2: The 2nd block is \"456\".\n        Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is \"78\".\n        Joining the blocks gives \"123-456-78\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1345,"row":{"number":1695,"difficulty":1,"question":"class Solution:\n    def maximumUniqueSubarray(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.\n        Return the maximum score you can get by erasing exactly one subarray.\n        An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r).\n        Example 1:\n        Input: nums = [4,2,4,5,6]\n        Output: 17\n        Explanation: The optimal subarray here is [2,4,5,6].\n        Example 2:\n        Input: nums = [5,2,1,2,5,2,1,2,5]\n        Output: 8\n        Explanation: The optimal subarray here is [5,2,1] or [1,2,5].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1346,"row":{"number":1696,"difficulty":1,"question":"class Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums and an integer k.\n        You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.\n        You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array.\n        Return the maximum score you can get.\n        Example 1:\n        Input: nums = [1,-1,-2,4,-7,3], k = 2\n        Output: 7\n        Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.\n        Example 2:\n        Input: nums = [10,-5,-2,4,0,3], k = 3\n        Output: 17\n        Explanation: You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.\n        Example 3:\n        Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1347,"row":{"number":1697,"difficulty":2,"question":"class Solution:\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        \"\"\"\n        An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. Note that there may be multiple edges between two nodes.\n        Given an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj .\n        Return a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise.\n        Example 1:\n        Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n        Output: [false,true]\n        Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.\n        For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.\n        For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.\n        Example 2:\n        Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n        Output: [true,false]\n        Exaplanation: The above figure shows the given graph.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1348,"row":{"number":1716,"difficulty":0,"question":"class Solution:\n    def totalMoney(self, n: int) -> int:\n        \"\"\"\n        Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.\n        He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \n        Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.\n        Example 1:\n        Input: n = 4\n        Output: 10\n        Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.\n        Example 2:\n        Input: n = 10\n        Output: 37\n        Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.\n        Example 3:\n        Input: n = 20\n        Output: 96\n        Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1349,"row":{"number":1717,"difficulty":1,"question":"class Solution:\n    def maximumGain(self, s: str, x: int, y: int) -> int:\n        \"\"\"\n        You are given a string s and two integers x and y. You can perform two types of operations any number of times.\n            Remove substring \"ab\" and gain x points.\n                For example, when removing \"ab\" from \"cabxbae\" it becomes \"cxbae\".\n            Remove substring \"ba\" and gain y points.\n                For example, when removing \"ba\" from \"cabxbae\" it becomes \"cabxe\".\n        Return the maximum points you can gain after applying the above operations on s.\n        Example 1:\n        Input: s = \"cdbcbbaaabab\", x = 4, y = 5\n        Output: 19\n        Explanation:\n        - Remove the \"ba\" underlined in \"cdbcbbaaabab\". Now, s = \"cdbcbbaaab\" and 5 points are added to the score.\n        - Remove the \"ab\" underlined in \"cdbcbbaaab\". Now, s = \"cdbcbbaa\" and 4 points are added to the score.\n        - Remove the \"ba\" underlined in \"cdbcbbaa\". Now, s = \"cdbcba\" and 5 points are added to the score.\n        - Remove the \"ba\" underlined in \"cdbcba\". Now, s = \"cdbc\" and 5 points are added to the score.\n        Total score = 5 + 4 + 5 + 5 = 19.\n        Example 2:\n        Input: s = \"aabbaaxybbaabb\", x = 5, y = 4\n        Output: 20\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1350,"row":{"number":1718,"difficulty":1,"question":"class Solution:\n    def constructDistancedSequence(self, n: int) -> List[int]:\n        \"\"\"\n        Given an integer n, find a sequence that satisfies all of the following:\n            The integer 1 occurs once in the sequence.\n            Each integer between 2 and n occurs twice in the sequence.\n            For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.\n        The distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.\n        Return the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution. \n        A sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.\n        Example 1:\n        Input: n = 3\n        Output: [3,1,2,3,2]\n        Explanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.\n        Example 2:\n        Input: n = 5\n        Output: [5,3,1,4,3,5,2,4,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1351,"row":{"number":1719,"difficulty":2,"question":"class Solution:\n    def checkWays(self, pairs: List[List[int]]) -> int:\n        \"\"\"\n        You are given an array pairs, where pairs[i] = [xi, yi], and:\n            There are no duplicates.\n            xi < yi\n        Let ways be the number of rooted trees that satisfy the following conditions:\n            The tree consists of nodes whose values appeared in pairs.\n            A pair [xi, yi] exists in pairs if and only if xi is an ancestor of yi or yi is an ancestor of xi.\n            Note: the tree does not have to be a binary tree.\n        Two ways are considered to be different if there is at least one node that has different parents in both ways.\n        Return:\n            0 if ways == 0\n            1 if ways == 1\n            2 if ways > 1\n        A rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root.\n        An ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.\n        Example 1:\n        Input: pairs = [[1,2],[2,3]]\n        Output: 1\n        Explanation: There is exactly one valid rooted tree, which is shown in the above figure.\n        Example 2:\n        Input: pairs = [[1,2],[2,3],[1,3]]\n        Output: 2\n        Explanation: There are multiple valid rooted trees. Three of them are shown in the above figures.\n        Example 3:\n        Input: pairs = [[1,2],[2,3],[2,4],[1,5]]\n        Output: 0\n        Explanation: There are no valid rooted trees.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1352,"row":{"number":1704,"difficulty":0,"question":"class Solution:\n    def halvesAreAlike(self, s: str) -> bool:\n        \"\"\"\n        You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.\n        Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.\n        Return true if a and b are alike. Otherwise, return false.\n        Example 1:\n        Input: s = \"book\"\n        Output: true\n        Explanation: a = \"bo\" and b = \"ok\". a has 1 vowel and b has 1 vowel. Therefore, they are alike.\n        Example 2:\n        Input: s = \"textbook\"\n        Output: false\n        Explanation: a = \"text\" and b = \"book\". a has 1 vowel whereas b has 2. Therefore, they are not alike.\n        Notice that the vowel o is counted twice.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1353,"row":{"number":1705,"difficulty":1,"question":"class Solution:\n    def eatenApples(self, apples: List[int], days: List[int]) -> int:\n        \"\"\"\n        There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.\n        You decided to eat at most one apple a day (to keep the doctors away). Note that you can keep eating after the first n days.\n        Given two integer arrays days and apples of length n, return the maximum number of apples you can eat.\n        Example 1:\n        Input: apples = [1,2,3,5,2], days = [3,2,1,4,2]\n        Output: 7\n        Explanation: You can eat 7 apples:\n        - On the first day, you eat an apple that grew on the first day.\n        - On the second day, you eat an apple that grew on the second day.\n        - On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.\n        - On the fourth to the seventh days, you eat apples that grew on the fourth day.\n        Example 2:\n        Input: apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]\n        Output: 5\n        Explanation: You can eat 5 apples:\n        - On the first to the third day you eat apples that grew on the first day.\n        - Do nothing on the fouth and fifth days.\n        - On the sixth and seventh days you eat apples that grew on the sixth day.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1354,"row":{"number":1723,"difficulty":2,"question":"class Solution:\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job.\n        There are k workers that you can assign jobs to. Each job should be assigned to exactly one worker. The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized.\n        Return the minimum possible maximum working time of any assignment. \n        Example 1:\n        Input: jobs = [3,2,3], k = 3\n        Output: 3\n        Explanation: By assigning each person one job, the maximum time is 3.\n        Example 2:\n        Input: jobs = [1,2,4,7,8], k = 2\n        Output: 11\n        Explanation: Assign the jobs the following way:\n        Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\n        Worker 2: 4, 7 (working time = 4 + 7 = 11)\n        The maximum working time is 11.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1355,"row":{"number":1707,"difficulty":2,"question":"class Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an array nums consisting of non-negative integers. You are also given a queries array, where queries[i] = [xi, mi].\n        The answer to the ith query is the maximum bitwise XOR value of xi and any element of nums that does not exceed mi. In other words, the answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If all elements in nums are larger than mi, then the answer is -1.\n        Return an integer array answer where answer.length == queries.length and answer[i] is the answer to the ith query.\n        Example 1:\n        Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n        Output: [3,3,7]\n        Explanation:\n        1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.\n        2) 1 XOR 2 = 3.\n        3) 5 XOR 2 = 7.\n        Example 2:\n        Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n        Output: [15,-1,5]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1356,"row":{"number":1710,"difficulty":0,"question":"class Solution:\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\n        \"\"\"\n        You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:\n            numberOfBoxesi is the number of boxes of type i.\n            numberOfUnitsPerBoxi is the number of units in each box of the type i.\n        You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize.\n        Return the maximum total number of units that can be put on the truck.\n        Example 1:\n        Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4\n        Output: 8\n        Explanation: There are:\n        - 1 box of the first type that contains 3 units.\n        - 2 boxes of the second type that contain 2 units each.\n        - 3 boxes of the third type that contain 1 unit each.\n        You can take all the boxes of the first and second types, and one box of the third type.\n        The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.\n        Example 2:\n        Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10\n        Output: 91\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1357,"row":{"number":1711,"difficulty":1,"question":"class Solution:\n    def countPairs(self, deliciousness: List[int]) -> int:\n        \"\"\"\n        A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.\n        You can pick any two different foods to make a good meal.\n        Given an array of integers deliciousness where deliciousness[i] is the deliciousness of the i​​​​​​th​​​​​​​​ item of food, return the number of different good meals you can make from this list modulo 109 + 7.\n        Note that items with different indices are considered different even if they have the same deliciousness value.\n        Example 1:\n        Input: deliciousness = [1,3,5,7,9]\n        Output: 4\n        Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).\n        Their respective sums are 4, 8, 8, and 16, all of which are powers of 2.\n        Example 2:\n        Input: deliciousness = [1,1,1,3,3,3,7]\n        Output: 15\n        Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1358,"row":{"number":1712,"difficulty":1,"question":"class Solution:\n    def waysToSplit(self, nums: List[int]) -> int:\n        \"\"\"\n        A split of an integer array is good if:\n            The array is split into three non-empty contiguous subarrays - named left, mid, right respectively from left to right.\n            The sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right.\n        Given nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: nums = [1,1,1]\n        Output: 1\n        Explanation: The only good way to split nums is [1] [1] [1].\n        Example 2:\n        Input: nums = [1,2,2,2,5,0]\n        Output: 3\n        Explanation: There are three good ways of splitting nums:\n        [1] [2] [2,2,5,0]\n        [1] [2,2] [2,5,0]\n        [1,2] [2,2] [5,0]\n        Example 3:\n        Input: nums = [3,2,1]\n        Output: 0\n        Explanation: There is no good way to split nums.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1359,"row":{"number":1713,"difficulty":2,"question":"class Solution:\n    def minOperations(self, target: List[int], arr: List[int]) -> int:\n        \"\"\"\n        You are given an array target that consists of distinct integers and another integer array arr that can have duplicates.\n        In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the array.\n        Return the minimum number of operations needed to make target a subsequence of arr.\n        A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\n        Example 1:\n        Input: target = [5,1,3], arr = [9,4,2,3,4]\n        Output: 2\n        Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.\n        Example 2:\n        Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1360,"row":{"number":1732,"difficulty":0,"question":"class Solution:\n    def largestAltitude(self, gain: List[int]) -> int:\n        \"\"\"\n        There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\n        You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\n        Example 1:\n        Input: gain = [-5,1,5,0,-7]\n        Output: 1\n        Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n        Example 2:\n        Input: gain = [-4,-3,-2,-1,4,3,2]\n        Output: 0\n        Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1361,"row":{"number":1733,"difficulty":1,"question":"class Solution:\n    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:\n        \"\"\"\n        On a social network consisting of m users and some friendships between users, two users can communicate with each other if they know a common language.\n        You are given an integer n, an array languages, and an array friendships where:\n            There are n languages numbered 1 through n,\n            languages[i] is the set of languages the i​​​​​​th​​​​ user knows, and\n            friendships[i] = [u​​​​​​i​​​, v​​​​​​i] denotes a friendship between the users u​​​​​​​​​​​i​​​​​ and vi.\n        You can choose one language and teach it to some users so that all friends can communicate with each other. Return the minimum number of users you need to teach.\n        Note that friendships are not transitive, meaning if x is a friend of y and y is a friend of z, this doesn't guarantee that x is a friend of z.\n        Example 1:\n        Input: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]\n        Output: 1\n        Explanation: You can either teach user 1 the second language or user 2 the first language.\n        Example 2:\n        Input: n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]\n        Output: 2\n        Explanation: Teach the third language to users 1 and 3, yielding two users to teach.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1362,"row":{"number":1734,"difficulty":1,"question":"class Solution:\n    def decode(self, encoded: List[int]) -> List[int]:\n        \"\"\"\n        There is an integer array perm that is a permutation of the first n positive integers, where n is always odd.\n        It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1].\n        Given the encoded array, return the original array perm. It is guaranteed that the answer exists and is unique.\n        Example 1:\n        Input: encoded = [3,1]\n        Output: [1,2,3]\n        Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]\n        Example 2:\n        Input: encoded = [6,5,4,6]\n        Output: [2,4,1,5,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1363,"row":{"number":1735,"difficulty":2,"question":"class Solution:\n    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given a 2D integer array, queries. For each queries[i], where queries[i] = [ni, ki], find the number of different ways you can place positive integers into an array of size ni such that the product of the integers is ki. As the number of ways may be too large, the answer to the ith query is the number of ways modulo 109 + 7.\n        Return an integer array answer where answer.length == queries.length, and answer[i] is the answer to the ith query.\n        Example 1:\n        Input: queries = [[2,6],[5,1],[73,660]]\n        Output: [4,1,50734910]\n        Explanation: Each query is independent.\n        [2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1].\n        [5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1].\n        [73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.\n        Example 2:\n        Input: queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n        Output: [1,2,3,10,5]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1364,"row":{"number":1720,"difficulty":0,"question":"class Solution:\n    def decode(self, encoded: List[int], first: int) -> List[int]:\n        \"\"\"\n        There is a hidden integer array arr that consists of n non-negative integers.\n        It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].\n        You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].\n        Return the original array arr. It can be proved that the answer exists and is unique.\n        Example 1:\n        Input: encoded = [1,2,3], first = 1\n        Output: [1,0,2,1]\n        Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n        Example 2:\n        Input: encoded = [6,2,7,3], first = 4\n        Output: [4,2,0,7,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1365,"row":{"number":1722,"difficulty":1,"question":"class Solution:\n    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        \"\"\"\n        You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order.\n        The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed).\n        Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source.\n        Example 1:\n        Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]\n        Output: 1\n        Explanation: source can be transformed the following way:\n        - Swap indices 0 and 1: source = [2,1,3,4]\n        - Swap indices 2 and 3: source = [2,1,4,3]\n        The Hamming distance of source and target is 1 as they differ in 1 position: index 3.\n        Example 2:\n        Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []\n        Output: 2\n        Explanation: There are no allowed swaps.\n        The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.\n        Example 3:\n        Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1366,"row":{"number":1725,"difficulty":0,"question":"class Solution:\n    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:\n        \"\"\"\n        You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.\r\n        You can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.\r\n        Let maxLen be the side length of the largest square you can obtain from any of the given rectangles.\r\n        Return the number of rectangles that can make a square with a side length of maxLen.\r\n        Example 1:\r\n        Input: rectangles = [[5,8],[3,9],[5,12],[16,5]]\r\n        Output: 3\r\n        Explanation: The largest squares you can get from each rectangle are of lengths [5,3,5,5].\r\n        The largest possible square is of length 5, and you can get it out of 3 rectangles.\r\n        Example 2:\r\n        Input: rectangles = [[2,3],[3,7],[4,3],[3,7]]\r\n        Output: 3\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1367,"row":{"number":1742,"difficulty":0,"question":"class Solution:\n    def countBalls(self, lowLimit: int, highLimit: int) -> int:\n        \"\"\"\n        You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity.\n        Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1.\n        Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls.\n        Example 1:\n        Input: lowLimit = 1, highLimit = 10\n        Output: 2\n        Explanation:\n        Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...\n        Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...\n        Box 1 has the most number of balls with 2 balls.\n        Example 2:\n        Input: lowLimit = 5, highLimit = 15\n        Output: 2\n        Explanation:\n        Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...\n        Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...\n        Boxes 5 and 6 have the most number of balls with 2 balls in each.\n        Example 3:\n        Input: lowLimit = 19, highLimit = 28\n        Output: 2\n        Explanation:\n        Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...\n        Ball Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...\n        Box 10 has the most number of balls with 2 balls.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1368,"row":{"number":1727,"difficulty":1,"question":"class Solution:\n    def largestSubmatrix(self, matrix: List[List[int]]) -> int:\n        \"\"\"\n        You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.\n        Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.\n        Example 1:\n        Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]\n        Output: 4\n        Explanation: You can rearrange the columns as shown above.\n        The largest submatrix of 1s, in bold, has an area of 4.\n        Example 2:\n        Input: matrix = [[1,0,1,0,1]]\n        Output: 3\n        Explanation: You can rearrange the columns as shown above.\n        The largest submatrix of 1s, in bold, has an area of 3.\n        Example 3:\n        Input: matrix = [[1,1,0],[1,0,1]]\n        Output: 2\n        Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1369,"row":{"number":1748,"difficulty":0,"question":"class Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.\n        Return the sum of all the unique elements of nums.\n        Example 1:\n        Input: nums = [1,2,3,2]\n        Output: 4\n        Explanation: The unique elements are [1,3], and the sum is 4.\n        Example 2:\n        Input: nums = [1,1,1,1,1]\n        Output: 0\n        Explanation: There are no unique elements, and the sum is 0.\n        Example 3:\n        Input: nums = [1,2,3,4,5]\n        Output: 15\n        Explanation: The unique elements are [1,2,3,4,5], and the sum is 15.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1370,"row":{"number":1749,"difficulty":1,"question":"class Solution:\n    def maxAbsoluteSum(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).\n        Return the maximum absolute sum of any (possibly empty) subarray of nums.\n        Note that abs(x) is defined as follows:\n            If x is a negative integer, then abs(x) = -x.\n            If x is a non-negative integer, then abs(x) = x.\n        Example 1:\n        Input: nums = [1,-3,2,3,-4]\n        Output: 5\n        Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.\n        Example 2:\n        Input: nums = [2,-5,1,-4,3,-2]\n        Output: 8\n        Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1371,"row":{"number":1750,"difficulty":1,"question":"class Solution:\n    def minimumLength(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:\n            Pick a non-empty prefix from the string s where all the characters in the prefix are equal.\n            Pick a non-empty suffix from the string s where all the characters in this suffix are equal.\n            The prefix and the suffix should not intersect at any index.\n            The characters from the prefix and suffix must be the same.\n            Delete both the prefix and the suffix.\n        Return the minimum length of s after performing the above operation any number of times (possibly zero times).\n        Example 1:\n        Input: s = \"ca\"\n        Output: 2\n        Explanation: You can't remove any characters, so the string stays as is.\n        Example 2:\n        Input: s = \"cabaabac\"\n        Output: 0\n        Explanation: An optimal sequence of operations is:\n        - Take prefix = \"c\" and suffix = \"c\" and remove them, s = \"abaaba\".\n        - Take prefix = \"a\" and suffix = \"a\" and remove them, s = \"baab\".\n        - Take prefix = \"b\" and suffix = \"b\" and remove them, s = \"aa\".\n        - Take prefix = \"a\" and suffix = \"a\" and remove them, s = \"\".\n        Example 3:\n        Input: s = \"aabccabba\"\n        Output: 3\n        Explanation: An optimal sequence of operations is:\n        - Take prefix = \"aa\" and suffix = \"a\" and remove them, s = \"bccabb\".\n        - Take prefix = \"b\" and suffix = \"bb\" and remove them, s = \"cca\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1372,"row":{"number":1751,"difficulty":2,"question":"class Solution:\n    def maxValue(self, events: List[List[int]], k: int) -> int:\n        \"\"\"\n        You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend.\n        You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n        Return the maximum sum of values that you can receive by attending events.\n        Example 1:\n        Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\n        Output: 7\n        Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n        Example 2:\n        Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\n        Output: 10\n        Explanation: Choose event 2 for a total value of 10.\n        Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events.\n        Example 3:\n        Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\n        Output: 9\n        Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1373,"row":{"number":1736,"difficulty":0,"question":"class Solution:\n    def maximumTime(self, time: str) -> str:\n        \"\"\"\n        You are given a string time in the form of  hh:mm, where some of the digits in the string are hidden (represented by ?).\n        The valid times are those inclusively between 00:00 and 23:59.\n        Return the latest valid time you can get from time by replacing the hidden digits.\n        Example 1:\n        Input: time = \"2?:?0\"\n        Output: \"23:50\"\n        Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.\n        Example 2:\n        Input: time = \"0?:3?\"\n        Output: \"09:39\"\n        Example 3:\n        Input: time = \"1?:22\"\n        Output: \"19:22\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1374,"row":{"number":1737,"difficulty":1,"question":"class Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        \"\"\"\n        You are given two strings a and b that consist of lowercase letters. In one operation, you can change any character in a or b to any lowercase letter.\n        Your goal is to satisfy one of the following three conditions:\n            Every letter in a is strictly less than every letter in b in the alphabet.\n            Every letter in b is strictly less than every letter in a in the alphabet.\n            Both a and b consist of only one distinct letter.\n        Return the minimum number of operations needed to achieve your goal.\n        Example 1:\n        Input: a = \"aba\", b = \"caa\"\n        Output: 2\n        Explanation: Consider the best way to make each condition true:\n        1) Change b to \"ccc\" in 2 operations, then every letter in a is less than every letter in b.\n        2) Change a to \"bbb\" and b to \"aaa\" in 3 operations, then every letter in b is less than every letter in a.\n        3) Change a to \"aaa\" and b to \"aaa\" in 2 operations, then a and b consist of one distinct letter.\n        The best way was done in 2 operations (either condition 1 or condition 3).\n        Example 2:\n        Input: a = \"dabadd\", b = \"cda\"\n        Output: 3\n        Explanation: The best way is to make condition 1 true by changing b to \"eee\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1375,"row":{"number":1738,"difficulty":1,"question":"class Solution:\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n        \"\"\"\n        You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.\n        The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).\n        Find the kth largest value (1-indexed) of all the coordinates of matrix.\n        Example 1:\n        Input: matrix = [[5,2],[1,6]], k = 1\n        Output: 7\n        Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.\n        Example 2:\n        Input: matrix = [[5,2],[1,6]], k = 2\n        Output: 5\n        Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.\n        Example 3:\n        Input: matrix = [[5,2],[1,6]], k = 3\n        Output: 4\n        Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1376,"row":{"number":1739,"difficulty":2,"question":"class Solution:\n    def minimumBoxes(self, n: int) -> int:\n        \"\"\"\n        You have a cubic storeroom where the width, length, and height of the room are all equal to n units. You are asked to place n boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:\n            You can place the boxes anywhere on the floor.\n            If box x is placed on top of the box y, then each side of the four vertical sides of the box y must either be adjacent to another box or to a wall.\n        Given an integer n, return the minimum possible number of boxes touching the floor.\n        Example 1:\n        Input: n = 3\n        Output: 3\n        Explanation: The figure above is for the placement of the three boxes.\n        These boxes are placed in the corner of the room, where the corner is on the left side.\n        Example 2:\n        Input: n = 4\n        Output: 3\n        Explanation: The figure above is for the placement of the four boxes.\n        These boxes are placed in the corner of the room, where the corner is on the left side.\n        Example 3:\n        Input: n = 10\n        Output: 6\n        Explanation: The figure above is for the placement of the ten boxes.\n        These boxes are placed in the corner of the room, where the corner is on the back side.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1377,"row":{"number":1743,"difficulty":1,"question":"class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        \"\"\"\n        There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.\n        You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.\n        It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.\n        Return the original array nums. If there are multiple solutions, return any of them.\n        Example 1:\n        Input: adjacentPairs = [[2,1],[3,4],[3,2]]\n        Output: [1,2,3,4]\n        Explanation: This array has all its adjacent pairs in adjacentPairs.\n        Notice that adjacentPairs[i] may not be in left-to-right order.\n        Example 2:\n        Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]\n        Output: [-2,4,1,-3]\n        Explanation: There can be negative numbers.\n        Another solution is [-3,1,4,-2], which would also be accepted.\n        Example 3:\n        Input: adjacentPairs = [[100000,-100000]]\n        Output: [100000,-100000]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1378,"row":{"number":1745,"difficulty":2,"question":"class Solution:\n    def checkPartitioning(self, s: str) -> bool:\n        \"\"\"\n        Given a string s, return true if it is possible to split the string s into three non-empty palindromic substrings. Otherwise, return false.​​​​​\n        A string is said to be palindrome if it the same string when reversed.\n        Example 1:\n        Input: s = \"abcbdd\"\n        Output: true\n        Explanation: \"abcbdd\" = \"a\" + \"bcb\" + \"dd\", and all three substrings are palindromes.\n        Example 2:\n        Input: s = \"bcbddxy\"\n        Output: false\n        Explanation: s cannot be split into 3 palindromes.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1379,"row":{"number":1744,"difficulty":1,"question":"class Solution:\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\n        \"\"\"\n        You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi].\n        You play a game with the following rules:\n            You start eating candies on day 0.\n            You cannot eat any candy of type i unless you have eaten all candies of type i - 1.\n            You must eat at least one candy per day until you have eaten all the candies.\n        Construct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypei on day favoriteDayi without eating more than dailyCapi candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2.\n        Return the constructed array answer.\n        Example 1:\n        Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n        Output: [true,false,true]\n        Explanation:\n        1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.\n        2- You can eat at most 4 candies each day.\n           If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.\n           On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.\n        3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.\n        Example 2:\n        Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n        Output: [false,true,true,false,false]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1380,"row":{"number":1763,"difficulty":0,"question":"class Solution:\n    def longestNiceSubstring(self, s: str) -> str:\n        \"\"\"\n        A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, \"abABB\" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, \"abA\" is not because 'b' appears, but 'B' does not.\n        Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. If there are none, return an empty string.\n        Example 1:\n        Input: s = \"YazaAay\"\n        Output: \"aAa\"\n        Explanation: \"aAa\" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.\n        \"aAa\" is the longest nice substring.\n        Example 2:\n        Input: s = \"Bb\"\n        Output: \"Bb\"\n        Explanation: \"Bb\" is a nice string because both 'B' and 'b' appear. The whole string is a substring.\n        Example 3:\n        Input: s = \"c\"\n        Output: \"\"\n        Explanation: There are no nice substrings.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1381,"row":{"number":1764,"difficulty":1,"question":"class Solution:\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\n        \"\"\"\n        You are given a 2D integer array groups of length n. You are also given an integer array nums.\n        You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).\n        Return true if you can do this task, and false otherwise.\n        Note that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.\n        Example 1:\n        Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]\n        Output: true\n        Explanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].\n        These subarrays are disjoint as they share no common nums[k] element.\n        Example 2:\n        Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]\n        Output: false\n        Explanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.\n        [10,-2] must come before [1,2,3,4].\n        Example 3:\n        Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]\n        Output: false\n        Explanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.\n        They share a common elements nums[4] (0-indexed).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1382,"row":{"number":1766,"difficulty":2,"question":"class Solution:\n    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. Each node has a value associated with it, and the root of the tree is node 0.\n        To represent this tree, you are given an integer array nums and a 2D array edges. Each nums[i] represents the ith node's value, and each edges[j] = [uj, vj] represents an edge between nodes uj and vj in the tree.\n        Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the greatest common divisor of x and y.\n        An ancestor of a node i is any other node on the shortest path from node i to the root. A node is not considered an ancestor of itself.\n        Return an array ans of size n, where ans[i] is the closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is no such ancestor.\n        Example 1:\n        Input: nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\n        Output: [-1,0,0,1]\n        Explanation: In the above figure, each node's value is in parentheses.\n        - Node 0 has no coprime ancestors.\n        - Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).\n        - Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's\n          value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.\n        - Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its\n          closest valid ancestor.\n        Example 2:\n        Input: nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\n        Output: [-1,0,-1,0,0,0,-1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1383,"row":{"number":1765,"difficulty":1,"question":"class Solution:\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given an integer matrix isWater of size m x n that represents a map of land and water cells.\n            If isWater[i][j] == 0, cell (i, j) is a land cell.\n            If isWater[i][j] == 1, cell (i, j) is a water cell.\n        You must assign each cell a height in a way that follows these rules:\n            The height of each cell must be non-negative.\n            If the cell is a water cell, its height must be 0.\n            Any two adjacent cells must have an absolute height difference of at most 1. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n        Find an assignment of heights such that the maximum height in the matrix is maximized.\n        Return an integer matrix height of size m x n where height[i][j] is cell (i, j)'s height. If there are multiple solutions, return any of them.\n        Example 1:\n        Input: isWater = [[0,1],[0,0]]\n        Output: [[1,0],[2,1]]\n        Explanation: The image shows the assigned heights of each cell.\n        The blue cell is the water cell, and the green cells are the land cells.\n        Example 2:\n        Input: isWater = [[0,0,1],[1,0,0],[0,0,0]]\n        Output: [[1,1,0],[0,1,1],[1,2,2]]\n        Explanation: A height of 2 is the maximum possible height of any assignment.\n        Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1384,"row":{"number":1752,"difficulty":0,"question":"class Solution:\n    def check(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.\n        There may be duplicates in the original array.\n        Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.\n        Example 1:\n        Input: nums = [3,4,5,1,2]\n        Output: true\n        Explanation: [1,2,3,4,5] is the original sorted array.\n        You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].\n        Example 2:\n        Input: nums = [2,1,3,4]\n        Output: false\n        Explanation: There is no sorted array once rotated that can make nums.\n        Example 3:\n        Input: nums = [1,2,3]\n        Output: true\n        Explanation: [1,2,3] is the original sorted array.\n        You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1385,"row":{"number":1753,"difficulty":1,"question":"class Solution:\n    def maximumScore(self, a: int, b: int, c: int) -> int:\n        \"\"\"\n        You are playing a solitaire game with three piles of stones of sizes a​​​​​​, b,​​​​​​ and c​​​​​​ respectively. Each turn you choose two different non-empty piles, take one stone from each, and add 1 point to your score. The game stops when there are fewer than two non-empty piles (meaning there are no more available moves).\n        Given three integers a​​​​​, b,​​​​​ and c​​​​​, return the maximum score you can get.\n        Example 1:\n        Input: a = 2, b = 4, c = 6\n        Output: 6\n        Explanation: The starting state is (2, 4, 6). One optimal set of moves is:\n        - Take from 1st and 3rd piles, state is now (1, 4, 5)\n        - Take from 1st and 3rd piles, state is now (0, 4, 4)\n        - Take from 2nd and 3rd piles, state is now (0, 3, 3)\n        - Take from 2nd and 3rd piles, state is now (0, 2, 2)\n        - Take from 2nd and 3rd piles, state is now (0, 1, 1)\n        - Take from 2nd and 3rd piles, state is now (0, 0, 0)\n        There are fewer than two non-empty piles, so the game ends. Total: 6 points.\n        Example 2:\n        Input: a = 4, b = 4, c = 6\n        Output: 7\n        Explanation: The starting state is (4, 4, 6). One optimal set of moves is:\n        - Take from 1st and 2nd piles, state is now (3, 3, 6)\n        - Take from 1st and 3rd piles, state is now (2, 3, 5)\n        - Take from 1st and 3rd piles, state is now (1, 3, 4)\n        - Take from 1st and 3rd piles, state is now (0, 3, 3)\n        - Take from 2nd and 3rd piles, state is now (0, 2, 2)\n        - Take from 2nd and 3rd piles, state is now (0, 1, 1)\n        - Take from 2nd and 3rd piles, state is now (0, 0, 0)\n        There are fewer than two non-empty piles, so the game ends. Total: 7 points.\n        Example 3:\n        Input: a = 1, b = 8, c = 8\n        Output: 8\n        Explanation: One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\n        After that, there are fewer than two non-empty piles, so the game ends.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1386,"row":{"number":1754,"difficulty":1,"question":"class Solution:\n    def largestMerge(self, word1: str, word2: str) -> str:\n        \"\"\"\n        You are given two strings word1 and word2. You want to construct a string merge in the following way: while either word1 or word2 are non-empty, choose one of the following options:\n            If word1 is non-empty, append the first character in word1 to merge and delete it from word1.\n                For example, if word1 = \"abc\" and merge = \"dv\", then after choosing this operation, word1 = \"bc\" and merge = \"dva\".\n            If word2 is non-empty, append the first character in word2 to merge and delete it from word2.\n                For example, if word2 = \"abc\" and merge = \"\", then after choosing this operation, word2 = \"bc\" and merge = \"a\".\n        Return the lexicographically largest merge you can construct.\n        A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b. For example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c.\n        Example 1:\n        Input: word1 = \"cabaa\", word2 = \"bcaaa\"\n        Output: \"cbcabaaaaa\"\n        Explanation: One way to get the lexicographically largest merge is:\n        - Take from word1: merge = \"c\", word1 = \"abaa\", word2 = \"bcaaa\"\n        - Take from word2: merge = \"cb\", word1 = \"abaa\", word2 = \"caaa\"\n        - Take from word2: merge = \"cbc\", word1 = \"abaa\", word2 = \"aaa\"\n        - Take from word1: merge = \"cbca\", word1 = \"baa\", word2 = \"aaa\"\n        - Take from word1: merge = \"cbcab\", word1 = \"aa\", word2 = \"aaa\"\n        - Append the remaining 5 a's from word1 and word2 at the end of merge.\n        Example 2:\n        Input: word1 = \"abcabc\", word2 = \"abdcaba\"\n        Output: \"abdcabcabcaba\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1387,"row":{"number":1755,"difficulty":2,"question":"class Solution:\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer goal.\n        You want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\n        Return the minimum possible value of abs(sum - goal).\n        Note that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.\n        Example 1:\n        Input: nums = [5,-7,3,5], goal = 6\n        Output: 0\n        Explanation: Choose the whole array as a subsequence, with a sum of 6.\n        This is equal to the goal, so the absolute difference is 0.\n        Example 2:\n        Input: nums = [7,-9,15,-2], goal = -5\n        Output: 1\n        Explanation: Choose the subsequence [7,-9,-2], with a sum of -4.\n        The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.\n        Example 3:\n        Input: nums = [1,2,3], goal = -7\n        Output: 7\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1388,"row":{"number":1758,"difficulty":0,"question":"class Solution:\n    def minOperations(self, s: str) -> int:\n        \"\"\"\n        You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\n        The string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\n        Return the minimum number of operations needed to make s alternating.\n        Example 1:\n        Input: s = \"0100\"\n        Output: 1\n        Explanation: If you change the last character to '1', s will be \"0101\", which is alternating.\n        Example 2:\n        Input: s = \"10\"\n        Output: 0\n        Explanation: s is already alternating.\n        Example 3:\n        Input: s = \"1111\"\n        Output: 2\n        Explanation: You need two operations to reach \"0101\" or \"1010\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1389,"row":{"number":1759,"difficulty":1,"question":"class Solution:\n    def countHomogenous(self, s: str) -> int:\n        \"\"\"\n        Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.\r\n        A string is homogenous if all the characters of the string are the same.\r\n        A substring is a contiguous sequence of characters within a string.\r\n        Example 1:\r\n        Input: s = \"abbcccaa\"\r\n        Output: 13\r\n        Explanation: The homogenous substrings are listed as below:\r\n        \"a\"   appears 3 times.\r\n        \"aa\"  appears 1 time.\r\n        \"b\"   appears 2 times.\r\n        \"bb\"  appears 1 time.\r\n        \"c\"   appears 3 times.\r\n        \"cc\"  appears 2 times.\r\n        \"ccc\" appears 1 time.\r\n        3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.\r\n        Example 2:\r\n        Input: s = \"xy\"\r\n        Output: 2\r\n        Explanation: The homogenous substrings are \"x\" and \"y\".\r\n        Example 3:\r\n        Input: s = \"zzzzz\"\r\n        Output: 15\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1390,"row":{"number":1760,"difficulty":1,"question":"class Solution:\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\n        \"\"\"\n        You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations.\n        You can perform the following operation at most maxOperations times:\n            Take any bag of balls and divide it into two new bags with a positive number of balls.\n                For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.\n        Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.\n        Return the minimum possible penalty after performing the operations.\n        Example 1:\n        Input: nums = [9], maxOperations = 2\n        Output: 3\n        Explanation: \n        - Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -> [6,3].\n        - Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -> [3,3,3].\n        The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.\n        Example 2:\n        Input: nums = [2,4,8,2], maxOperations = 4\n        Output: 2\n        Explanation:\n        - Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -> [2,4,4,4,2].\n        - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -> [2,2,2,4,4,2].\n        - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -> [2,2,2,2,2,4,2].\n        - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2].\n        The bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1391,"row":{"number":1761,"difficulty":2,"question":"class Solution:\n    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\n        \"\"\"\n        You are given an undirected graph. You are given an integer n which is the number of nodes in the graph and an array edges, where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi.\n        A connected trio is a set of three nodes where there is an edge between every pair of them.\n        The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.\n        Return the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios.\n        Example 1:\n        Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\n        Output: 3\n        Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.\n        Example 2:\n        Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\n        Output: 0\n        Explanation: There are exactly three trios:\n        1) [1,4,3] with degree 0.\n        2) [2,5,6] with degree 2.\n        3) [5,6,7] with degree 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1392,"row":{"number":1779,"difficulty":0,"question":"class Solution:\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\n        \"\"\"\n        You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.\n        Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.\n        The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).\n        Example 1:\n        Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]\n        Output: 2\n        Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.\n        Example 2:\n        Input: x = 3, y = 4, points = [[3,4]]\n        Output: 0\n        Explanation: The answer is allowed to be on the same location as your current location.\n        Example 3:\n        Input: x = 3, y = 4, points = [[2,3]]\n        Output: -1\n        Explanation: There are no valid points.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1393,"row":{"number":1780,"difficulty":1,"question":"class Solution:\n    def checkPowersOfThree(self, n: int) -> bool:\n        \"\"\"\n        Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false.\n        An integer y is a power of three if there exists an integer x such that y == 3x.\n        Example 1:\n        Input: n = 12\n        Output: true\n        Explanation: 12 = 31 + 32\n        Example 2:\n        Input: n = 91\n        Output: true\n        Explanation: 91 = 30 + 32 + 34\n        Example 3:\n        Input: n = 21\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1394,"row":{"number":1781,"difficulty":1,"question":"class Solution:\n    def beautySum(self, s: str) -> int:\n        \"\"\"\n        The beauty of a string is the difference in frequencies between the most frequent and least frequent characters.\n            For example, the beauty of \"abaacc\" is 3 - 1 = 2.\n        Given a string s, return the sum of beauty of all of its substrings.\n        Example 1:\n        Input: s = \"aabcb\"\n        Output: 5\n        Explanation: The substrings with non-zero beauty are [\"aab\",\"aabc\",\"aabcb\",\"abcb\",\"bcb\"], each with beauty equal to 1.\n        Example 2:\n        Input: s = \"aabcbaa\"\n        Output: 17\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1395,"row":{"number":1782,"difficulty":2,"question":"class Solution:\n    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n        \"\"\"\n        You are given an undirected graph defined by an integer n, the number of nodes, and a 2D integer array edges, the edges in the graph, where edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi. You are also given an integer array queries.\n        Let incident(a, b) be defined as the number of edges that are connected to either node a or b.\n        The answer to the jth query is the number of pairs of nodes (a, b) that satisfy both of the following conditions:\n            a < b\n            incident(a, b) > queries[j]\n        Return an array answers such that answers.length == queries.length and answers[j] is the answer of the jth query.\n        Note that there can be multiple edges between the same two nodes.\n        Example 1:\n        Input: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]\n        Output: [6,5]\n        Explanation: The calculations for incident(a, b) are shown in the table above.\n        The answers for each of the queries are as follows:\n        - answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.\n        - answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.\n        Example 2:\n        Input: n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]\n        Output: [10,10,9,8,6]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1396,"row":{"number":1768,"difficulty":0,"question":"class Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        \"\"\"\n        You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.\r\n        Return the merged string.\r\n        Example 1:\r\n        Input: word1 = \"abc\", word2 = \"pqr\"\r\n        Output: \"apbqcr\"\r\n        Explanation: The merged string will be merged as so:\r\n        word1:  a   b   c\r\n        word2:    p   q   r\r\n        merged: a p b q c r\r\n        Example 2:\r\n        Input: word1 = \"ab\", word2 = \"pqrs\"\r\n        Output: \"apbqrs\"\r\n        Explanation: Notice that as word2 is longer, \"rs\" is appended to the end.\r\n        word1:  a   b \r\n        word2:    p   q   r   s\r\n        merged: a p b q   r   s\r\n        Example 3:\r\n        Input: word1 = \"abcd\", word2 = \"pq\"\r\n        Output: \"apbqcd\"\r\n        Explanation: Notice that as word1 is longer, \"cd\" is appended to the end.\r\n        word1:  a   b   c   d\r\n        word2:    p   q \r\n        merged: a p b q c   d\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1397,"row":{"number":1769,"difficulty":1,"question":"class Solution:\n    def minOperations(self, boxes: str) -> List[int]:\n        \"\"\"\n        You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.\n        In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes.\n        Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.\n        Each answer[i] is calculated considering the initial state of the boxes.\n        Example 1:\n        Input: boxes = \"110\"\n        Output: [1,1,3]\n        Explanation: The answer for each box is as follows:\n        1) First box: you will have to move one ball from the second box to the first box in one operation.\n        2) Second box: you will have to move one ball from the first box to the second box in one operation.\n        3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.\n        Example 2:\n        Input: boxes = \"001011\"\n        Output: [11,8,5,4,3,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1398,"row":{"number":1770,"difficulty":2,"question":"class Solution:\n    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:\n        \"\"\"\n        You are given two 0-indexed integer arrays nums and multipliers of size n and m respectively, where n >= m.\n        You begin with a score of 0. You want to perform exactly m operations. On the ith operation (0-indexed) you will:\n            Choose one integer x from either the start or the end of the array nums.\n            Add multipliers[i] * x to your score.\n                Note that multipliers[0] corresponds to the first operation, multipliers[1] to the second operation, and so on.\n            Remove x from nums.\n        Return the maximum score after performing m operations.\n        Example 1:\n        Input: nums = [1,2,3], multipliers = [3,2,1]\n        Output: 14\n        Explanation: An optimal solution is as follows:\n        - Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.\n        - Choose from the end, [1,2], adding 2 * 2 = 4 to the score.\n        - Choose from the end, [1], adding 1 * 1 = 1 to the score.\n        The total score is 9 + 4 + 1 = 14.\n        Example 2:\n        Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]\n        Output: 102\n        Explanation: An optimal solution is as follows:\n        - Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.\n        - Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.\n        - Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.\n        - Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.\n        - Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. \n        The total score is 50 + 15 - 9 + 4 + 42 = 102.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1399,"row":{"number":1771,"difficulty":2,"question":"class Solution:\n    def longestPalindrome(self, word1: str, word2: str) -> int:\n        \"\"\"\n        You are given two strings, word1 and word2. You want to construct a string in the following manner:\n            Choose some non-empty subsequence subsequence1 from word1.\n            Choose some non-empty subsequence subsequence2 from word2.\n            Concatenate the subsequences: subsequence1 + subsequence2, to make the string.\n        Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0.\n        A subsequence of a string s is a string that can be made by deleting some (possibly none) characters from s without changing the order of the remaining characters.\n        A palindrome is a string that reads the same forward as well as backward.\n        Example 1:\n        Input: word1 = \"cacb\", word2 = \"cbba\"\n        Output: 5\n        Explanation: Choose \"ab\" from word1 and \"cba\" from word2 to make \"abcba\", which is a palindrome.\n        Example 2:\n        Input: word1 = \"ab\", word2 = \"ab\"\n        Output: 3\n        Explanation: Choose \"ab\" from word1 and \"a\" from word2 to make \"aba\", which is a palindrome.\n        Example 3:\n        Input: word1 = \"aa\", word2 = \"bb\"\n        Output: 0\n        Explanation: You cannot construct a palindrome from the described method, so return 0.\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}