{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1600,"row":{"number":2048,"difficulty":1,"question":"class Solution:\n    def nextBeautifulNumber(self, n: int) -> int:\n        \"\"\"\n        An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x.\n        Given an integer n, return the smallest numerically balanced number strictly greater than n.\n        Example 1:\n        Input: n = 1\n        Output: 22\n        Explanation: \n        22 is numerically balanced since:\n        - The digit 2 occurs 2 times. \n        It is also the smallest numerically balanced number strictly greater than 1.\n        Example 2:\n        Input: n = 1000\n        Output: 1333\n        Explanation: \n        1333 is numerically balanced since:\n        - The digit 1 occurs 1 time.\n        - The digit 3 occurs 3 times. \n        It is also the smallest numerically balanced number strictly greater than 1000.\n        Note that 1022 cannot be the answer because 0 appeared more than 0 times.\n        Example 3:\n        Input: n = 3000\n        Output: 3133\n        Explanation: \n        3133 is numerically balanced since:\n        - The digit 1 occurs 1 time.\n        - The digit 3 occurs 3 times.\n        It is also the smallest numerically balanced number strictly greater than 3000.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1601,"row":{"number":2049,"difficulty":1,"question":"class Solution:\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\n        \"\"\"\n        There is a binary tree rooted at 0 consisting of n nodes. The nodes are labeled from 0 to n - 1. You are given a 0-indexed integer array parents representing the tree, where parents[i] is the parent of node i. Since node 0 is the root, parents[0] == -1.\n        Each node has a score. To find the score of a node, consider if the node and the edges connected to it were removed. The tree would become one or more non-empty subtrees. The size of a subtree is the number of the nodes in it. The score of the node is the product of the sizes of all those subtrees.\n        Return the number of nodes that have the highest score.\n        Example 1:\n        Input: parents = [-1,2,0,2,0]\n        Output: 3\n        Explanation:\n        - The score of node 0 is: 3 * 1 = 3\n        - The score of node 1 is: 4 = 4\n        - The score of node 2 is: 1 * 1 * 2 = 2\n        - The score of node 3 is: 4 = 4\n        - The score of node 4 is: 4 = 4\n        The highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.\n        Example 2:\n        Input: parents = [-1,2,0]\n        Output: 2\n        Explanation:\n        - The score of node 0 is: 2 = 2\n        - The score of node 1 is: 2 = 2\n        - The score of node 2 is: 1 * 1 = 1\n        The highest score is 2, and two nodes (node 0 and node 1) have the highest score.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1602,"row":{"number":2050,"difficulty":2,"question":"class Solution:\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\n        \"\"\"\n        You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.\n        You must find the minimum number of months needed to complete all the courses following these rules:\n            You may start taking a course at any time if the prerequisites are met.\n            Any number of courses can be taken at the same time.\n        Return the minimum number of months needed to complete all the courses.\n        Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n        Example 1:\n        Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]\n        Output: 8\n        Explanation: The figure above represents the given graph and the time required to complete each course. \n        We start course 1 and course 2 simultaneously at month 0.\n        Course 1 takes 3 months and course 2 takes 2 months to complete respectively.\n        Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n        Example 2:\n        Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]\n        Output: 12\n        Explanation: The figure above represents the given graph and the time required to complete each course.\n        You can start courses 1, 2, and 3 at month 0.\n        You can complete them after 1, 2, and 3 months respectively.\n        Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\n        Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\n        Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1603,"row":{"number":2068,"difficulty":0,"question":"class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        \"\"\"\n        Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\n        Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\n        The frequency of a letter x is the number of times it occurs in the string.\n        Example 1:\n        Input: word1 = \"aaaa\", word2 = \"bccb\"\n        Output: false\n        Explanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\n        The difference is 4, which is more than the allowed 3.\n        Example 2:\n        Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\n        Output: true\n        Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n        - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n        - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n        - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n        - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n        - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n        - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.\n        Example 3:\n        Input: word1 = \"cccddabba\", word2 = \"babababab\"\n        Output: true\n        Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n        - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n        - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n        - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n        - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1604,"row":{"number":2069,"difficulty":1,"question":"class Robot:\n    def __init__(self, width: int, height: int):\n    def step(self, num: int) -> None:\n    def getPos(self) -> List[int]:\n    def getDir(self) -> str:\n        \"\"\"\n        A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and the top-right cell at (width - 1, height - 1). The grid is aligned with the four cardinal directions (\"North\", \"East\", \"South\", and \"West\"). A robot is initially at cell (0, 0) facing direction \"East\".\n        The robot can be instructed to move for a specific number of steps. For each step, it does the following.\n            Attempts to move forward one cell in the direction it is facing.\n            If the cell the robot is moving to is out of bounds, the robot instead turns 90 degrees counterclockwise and retries the step.\n        After the robot finishes moving the number of steps required, it stops and awaits the next instruction.\n        Implement the Robot class:\n            Robot(int width, int height) Initializes the width x height grid with the robot at (0, 0) facing \"East\".\n            void step(int num) Instructs the robot to move forward num steps.\n            int[] getPos() Returns the current cell the robot is at, as an array of length 2, [x, y].\n            String getDir() Returns the current direction of the robot, \"North\", \"East\", \"South\", or \"West\".\n        Example 1:\n        Input\n        [\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"]\n        [[6, 3], [2], [2], [], [], [2], [1], [4], [], []]\n        Output\n        [null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"]\n        Explanation\n        Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East.\n        robot.step(2);  // It moves two steps East to (2, 0), and faces East.\n        robot.step(2);  // It moves two steps East to (4, 0), and faces East.\n        robot.getPos(); // return [4, 0]\n        robot.getDir(); // return \"East\"\n        robot.step(2);  // It moves one step East to (5, 0), and faces East.\n                        // Moving the next step East would be out of bounds, so it turns and faces North.\n                        // Then, it moves one step North to (5, 1), and faces North.\n        robot.step(1);  // It moves one step North to (5, 2), and faces North (not West).\n        robot.step(4);  // Moving the next step North would be out of bounds, so it turns and faces West.\n                        // Then, it moves four steps West to (1, 2), and faces West.\n        robot.getPos(); // return [1, 2]\n        robot.getDir(); // return \"West\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1605,"row":{"number":2070,"difficulty":1,"question":"class Solution:\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\n        You are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\n        Return an array answer of the same length as queries where answer[j] is the answer to the jth query.\n        Example 1:\n        Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\n        Output: [2,4,5,5,6,6]\n        Explanation:\n        - For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n        - For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n          The maximum beauty among them is 4.\n        - For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n          The maximum beauty among them is 5.\n        - For queries[4]=5 and queries[5]=6, all items can be considered.\n          Hence, the answer for them is the maximum beauty of all items, i.e., 6.\n        Example 2:\n        Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\n        Output: [4]\n        Explanation: \n        The price of every item is equal to 1, so we choose the item with the maximum beauty 4. \n        Note that multiple items can have the same price and/or beauty.  \n        Example 3:\n        Input: items = [[10,1000]], queries = [5]\n        Output: [0]\n        Explanation:\n        No item has a price less than or equal to 5, so no item can be chosen.\n        Hence, the answer to the query is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1606,"row":{"number":2071,"difficulty":2,"question":"class Solution:\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\n        \"\"\"\n        You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]).\n        Additionally, you have pills magical pills that will increase a worker's strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill.\n        Given the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed.\n        Example 1:\n        Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1\n        Output: 3\n        Explanation:\n        We can assign the magical pill and tasks as follows:\n        - Give the magical pill to worker 0.\n        - Assign worker 0 to task 2 (0 + 1 >= 1)\n        - Assign worker 1 to task 1 (3 >= 2)\n        - Assign worker 2 to task 0 (3 >= 3)\n        Example 2:\n        Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5\n        Output: 1\n        Explanation:\n        We can assign the magical pill and tasks as follows:\n        - Give the magical pill to worker 0.\n        - Assign worker 0 to task 0 (0 + 5 >= 5)\n        Example 3:\n        Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\n        Output: 2\n        Explanation:\n        We can assign the magical pills and tasks as follows:\n        - Give the magical pill to worker 0 and worker 1.\n        - Assign worker 0 to task 0 (0 + 10 >= 10)\n        - Assign worker 1 to task 1 (10 + 10 >= 15)\n        The last pill is not given because it will not make any worker strong enough for the last task.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1607,"row":{"number":2057,"difficulty":0,"question":"class Solution:\n    def smallestEqual(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.\n        x mod y denotes the remainder when x is divided by y.\n        Example 1:\n        Input: nums = [0,1,2]\n        Output: 0\n        Explanation: \n        i=0: 0 mod 10 = 0 == nums[0].\n        i=1: 1 mod 10 = 1 == nums[1].\n        i=2: 2 mod 10 = 2 == nums[2].\n        All indices have i mod 10 == nums[i], so we return the smallest index 0.\n        Example 2:\n        Input: nums = [4,3,2,1]\n        Output: 2\n        Explanation: \n        i=0: 0 mod 10 = 0 != nums[0].\n        i=1: 1 mod 10 = 1 != nums[1].\n        i=2: 2 mod 10 = 2 == nums[2].\n        i=3: 3 mod 10 = 3 != nums[3].\n        2 is the only index which has i mod 10 == nums[i].\n        Example 3:\n        Input: nums = [1,2,3,4,5,6,7,8,9,0]\n        Output: -1\n        Explanation: No index satisfies i mod 10 == nums[i].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1608,"row":{"number":2058,"difficulty":1,"question":"class Solution:\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\n        \"\"\"\n        A critical point in a linked list is defined as either a local maxima or a local minima.\n        A node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\n        A node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\n        Note that a node can only be a local maxima/minima if there exists both a previous node and a next node.\n        Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].\n        Example 1:\n        Input: head = [3,1]\n        Output: [-1,-1]\n        Explanation: There are no critical points in [3,1].\n        Example 2:\n        Input: head = [5,3,1,2,5,1,2]\n        Output: [1,3]\n        Explanation: There are three critical points:\n        - [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n        - [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n        - [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\n        The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\n        The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.\n        Example 3:\n        Input: head = [1,3,2,2,3,2,2,2,7]\n        Output: [3,3]\n        Explanation: There are two critical points:\n        - [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n        - [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\n        Both the minimum and maximum distances are between the second and the fifth node.\n        Thus, minDistance and maxDistance is 5 - 2 = 3.\n        Note that the last node is not considered a local maxima because it does not have a next node.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1609,"row":{"number":2059,"difficulty":1,"question":"class Solution:\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. You can perform the following operation repeatedly on the number x:\n        If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following:\n            x + nums[i]\n            x - nums[i]\n            x ^ nums[i] (bitwise-XOR)\n        Note that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward.\n        Return the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible.\n        Example 1:\n        Input: nums = [2,4,12], start = 2, goal = 12\n        Output: 2\n        Explanation: We can go from 2 → 14 → 12 with the following 2 operations.\n        - 2 + 12 = 14\n        - 14 - 2 = 12\n        Example 2:\n        Input: nums = [3,5,7], start = 0, goal = -4\n        Output: 2\n        Explanation: We can go from 0 → 3 → -4 with the following 2 operations. \n        - 0 + 3 = 3\n        - 3 - 7 = -4\n        Note that the last operation sets x out of the range 0 <= x <= 1000, which is valid.\n        Example 3:\n        Input: nums = [2,8,16], start = 0, goal = 1\n        Output: -1\n        Explanation: There is no way to convert 0 into 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1610,"row":{"number":2060,"difficulty":2,"question":"class Solution:\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\n        \"\"\"\n        An original string, consisting of lowercase English letters, can be encoded by the following steps:\n            Arbitrarily split it into a sequence of some number of non-empty substrings.\n            Arbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string).\n            Concatenate the sequence as the encoded string.\n        For example, one way to encode an original string \"abcdefghijklmnop\" might be:\n            Split it as a sequence: [\"ab\", \"cdefghijklmn\", \"o\", \"p\"].\n            Choose the second and third elements to be replaced by their lengths, respectively. The sequence becomes [\"ab\", \"12\", \"1\", \"p\"].\n            Concatenate the elements of the sequence to get the encoded string: \"ab121p\".\n        Given two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false.\n        Note: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3.\n        Example 1:\n        Input: s1 = \"internationalization\", s2 = \"i18n\"\n        Output: true\n        Explanation: It is possible that \"internationalization\" was the original string.\n        - \"internationalization\" \n          -> Split:       [\"internationalization\"]\n          -> Do not replace any element\n          -> Concatenate:  \"internationalization\", which is s1.\n        - \"internationalization\"\n          -> Split:       [\"i\", \"nternationalizatio\", \"n\"]\n          -> Replace:     [\"i\", \"18\",                 \"n\"]\n          -> Concatenate:  \"i18n\", which is s2\n        Example 2:\n        Input: s1 = \"l123e\", s2 = \"44\"\n        Output: true\n        Explanation: It is possible that \"leetcode\" was the original string.\n        - \"leetcode\" \n          -> Split:      [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n          -> Replace:    [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n          -> Concatenate: \"l123e\", which is s1.\n        - \"leetcode\" \n          -> Split:      [\"leet\", \"code\"]\n          -> Replace:    [\"4\",    \"4\"]\n          -> Concatenate: \"44\", which is s2.\n        Example 3:\n        Input: s1 = \"a5b\", s2 = \"c5b\"\n        Output: false\n        Explanation: It is impossible.\n        - The original string encoded as s1 must start with the letter 'a'.\n        - The original string encoded as s2 must start with the letter 'c'.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1611,"row":{"number":2062,"difficulty":0,"question":"class Solution:\n    def countVowelSubstrings(self, word: str) -> int:\n        \"\"\"\n        A substring is a contiguous (non-empty) sequence of characters within a string.\n        A vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it.\n        Given a string word, return the number of vowel substrings in word.\n        Example 1:\n        Input: word = \"aeiouu\"\n        Output: 2\n        Explanation: The vowel substrings of word are as follows (underlined):\n        - \"aeiouu\"\n        - \"aeiouu\"\n        Example 2:\n        Input: word = \"unicornarihan\"\n        Output: 0\n        Explanation: Not all 5 vowels are present, so there are no vowel substrings.\n        Example 3:\n        Input: word = \"cuaieuouac\"\n        Output: 7\n        Explanation: The vowel substrings of word are as follows (underlined):\n        - \"cuaieuouac\"\n        - \"cuaieuouac\"\n        - \"cuaieuouac\"\n        - \"cuaieuouac\"\n        - \"cuaieuouac\"\n        - \"cuaieuouac\"\n        - \"cuaieuouac\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1612,"row":{"number":2063,"difficulty":1,"question":"class Solution:\n    def countVowels(self, word: str) -> int:\n        \"\"\"\n        Given a string word, return the sum of the number of vowels ('a', 'e', 'i', 'o', and 'u') in every substring of word.\n        A substring is a contiguous (non-empty) sequence of characters within a string.\n        Note: Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.\n        Example 1:\n        Input: word = \"aba\"\n        Output: 6\n        Explanation: \n        All possible substrings are: \"a\", \"ab\", \"aba\", \"b\", \"ba\", and \"a\".\n        - \"b\" has 0 vowels in it\n        - \"a\", \"ab\", \"ba\", and \"a\" have 1 vowel each\n        - \"aba\" has 2 vowels in it\n        Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6. \n        Example 2:\n        Input: word = \"abc\"\n        Output: 3\n        Explanation: \n        All possible substrings are: \"a\", \"ab\", \"abc\", \"b\", \"bc\", and \"c\".\n        - \"a\", \"ab\", and \"abc\" have 1 vowel each\n        - \"b\", \"bc\", and \"c\" have 0 vowels each\n        Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3.\n        Example 3:\n        Input: word = \"ltcd\"\n        Output: 0\n        Explanation: There are no vowels in any substring of \"ltcd\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1613,"row":{"number":2064,"difficulty":1,"question":"class Solution:\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\n        \"\"\"\n        You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type.\n        You need to distribute all products to the retail stores following these rules:\n            A store can only be given at most one product type but can be given any amount of it.\n            After distribution, each store will have been given some number of products (possibly 0). Let x represent the maximum number of products given to any store. You want x to be as small as possible, i.e., you want to minimize the maximum number of products that are given to any store.\n        Return the minimum possible x.\n        Example 1:\n        Input: n = 6, quantities = [11,6]\n        Output: 3\n        Explanation: One optimal way is:\n        - The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3\n        - The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3\n        The maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.\n        Example 2:\n        Input: n = 7, quantities = [15,10,10]\n        Output: 5\n        Explanation: One optimal way is:\n        - The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5\n        - The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5\n        - The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5\n        The maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.\n        Example 3:\n        Input: n = 1, quantities = [100000]\n        Output: 100000\n        Explanation: The only optimal way is:\n        - The 100000 products of type 0 are distributed to the only store.\n        The maximum number of products given to any store is max(100000) = 100000.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1614,"row":{"number":2065,"difficulty":2,"question":"class Solution:\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\n        \"\"\"\n        There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime.\n        A valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node's value is added at most once to the sum).\n        Return the maximum quality of a valid path.\n        Note: There are at most four edges connected to each node.\n        Example 1:\n        Input: values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49\n        Output: 75\n        Explanation:\n        One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.\n        The nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.\n        Example 2:\n        Input: values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30\n        Output: 25\n        Explanation:\n        One possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.\n        The nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.\n        Example 3:\n        Input: values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50\n        Output: 7\n        Explanation:\n        One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.\n        The nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1615,"row":{"number":2085,"difficulty":0,"question":"class Solution:\n    def countWords(self, words1: List[str], words2: List[str]) -> int:\n        \"\"\"\n        Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.\n        Example 1:\n        Input: words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\n        Output: 2\n        Explanation:\n        - \"leetcode\" appears exactly once in each of the two arrays. We count this string.\n        - \"amazing\" appears exactly once in each of the two arrays. We count this string.\n        - \"is\" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.\n        - \"as\" appears once in words1, but does not appear in words2. We do not count this string.\n        Thus, there are 2 strings that appear exactly once in each of the two arrays.\n        Example 2:\n        Input: words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\n        Output: 0\n        Explanation: There are no strings that appear in each of the two arrays.\n        Example 3:\n        Input: words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\n        Output: 1\n        Explanation: The only string that appears exactly once in each of the two arrays is \"ab\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1616,"row":{"number":2086,"difficulty":1,"question":"class Solution:\n    def minimumBuckets(self, hamsters: str) -> int:\n        \"\"\"\n        You are given a 0-indexed string hamsters where hamsters[i] is either:\n            'H' indicating that there is a hamster at index i, or\n            '.' indicating that index i is empty.\n        You will add some number of food buckets at the empty indices in order to feed the hamsters. A hamster can be fed if there is at least one food bucket to its left or to its right. More formally, a hamster at index i can be fed if you place a food bucket at index i - 1 and/or at index i + 1.\n        Return the minimum number of food buckets you should place at empty indices to feed all the hamsters or -1 if it is impossible to feed all of them.\n        Example 1:\n        Input: hamsters = \"H..H\"\n        Output: 2\n        Explanation: We place two food buckets at indices 1 and 2.\n        It can be shown that if we place only one food bucket, one of the hamsters will not be fed.\n        Example 2:\n        Input: hamsters = \".H.H.\"\n        Output: 1\n        Explanation: We place one food bucket at index 2.\n        Example 3:\n        Input: hamsters = \".HHH.\"\n        Output: -1\n        Explanation: If we place a food bucket at every empty index as shown, the hamster at index 2 will not be able to eat.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1617,"row":{"number":2087,"difficulty":1,"question":"class Solution:\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\n        \"\"\"\n        There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1) is the bottom-right cell. You are given an integer array startPos where startPos = [startrow, startcol] indicates that initially, a robot is at the cell (startrow, startcol). You are also given an integer array homePos where homePos = [homerow, homecol] indicates that its home is at the cell (homerow, homecol).\n        The robot needs to go to its home. It can move one cell in four directions: left, right, up, or down, and it can not move outside the boundary. Every move incurs some cost. You are further given two 0-indexed integer arrays: rowCosts of length m and colCosts of length n.\n            If the robot moves up or down into a cell whose row is r, then this move costs rowCosts[r].\n            If the robot moves left or right into a cell whose column is c, then this move costs colCosts[c].\n        Return the minimum total cost for this robot to return home.\n        Example 1:\n        Input: startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]\n        Output: 18\n        Explanation: One optimal path is that:\n        Starting from (1, 0)\n        -> It goes down to (2, 0). This move costs rowCosts[2] = 3.\n        -> It goes right to (2, 1). This move costs colCosts[1] = 2.\n        -> It goes right to (2, 2). This move costs colCosts[2] = 6.\n        -> It goes right to (2, 3). This move costs colCosts[3] = 7.\n        The total cost is 3 + 2 + 6 + 7 = 18\n        Example 2:\n        Input: startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]\n        Output: 0\n        Explanation: The robot is already at its home. Since no moves occur, the total cost is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1618,"row":{"number":2088,"difficulty":2,"question":"class Solution:\n    def countPyramids(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.\n        A pyramidal plot of land can be defined as a set of cells with the following criteria:\n            The number of cells in the set has to be greater than 1 and all cells must be fertile.\n            The apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).\n        An inverse pyramidal plot of land can be defined as a set of cells with similar criteria:\n            The number of cells in the set has to be greater than 1 and all cells must be fertile.\n            The apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).\n        Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n        Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.\n        Example 1:\n        Input: grid = [[0,1,1,0],[1,1,1,1]]\n        Output: 2\n        Explanation: The 2 possible pyramidal plots are shown in blue and red respectively.\n        There are no inverse pyramidal plots in this grid. \n        Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n        Example 2:\n        Input: grid = [[1,1,1],[1,1,1]]\n        Output: 2\n        Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \n        Hence the total number of plots is 1 + 1 = 2.\n        Example 3:\n        Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\n        Output: 13\n        Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\n        There are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\n        The total number of plots is 7 + 6 = 13.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1619,"row":{"number":2073,"difficulty":0,"question":"class Solution:\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\n        \"\"\"\n        There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.\n        You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].\n        Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.\n        Return the time taken for the person at position k (0-indexed) to finish buying tickets.\n        Example 1:\n        Input: tickets = [2,3,2], k = 2\n        Output: 6\n        Explanation: \n        - In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\n        - In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\n        The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n        Example 2:\n        Input: tickets = [5,1,1,1], k = 0\n        Output: 8\n        Explanation:\n        - In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].\n        - In the next 4 passes, only the person in position 0 is buying tickets.\n        The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1620,"row":{"number":2074,"difficulty":1,"question":"class Solution:\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the head of a linked list.\n        The nodes in the linked list are sequentially assigned to non-empty groups whose lengths form the sequence of the natural numbers (1, 2, 3, 4, ...). The length of a group is the number of nodes assigned to it. In other words,\n            The 1st node is assigned to the first group.\n            The 2nd and the 3rd nodes are assigned to the second group.\n            The 4th, 5th, and 6th nodes are assigned to the third group, and so on.\n        Note that the length of the last group may be less than or equal to 1 + the length of the second to last group.\n        Reverse the nodes in each group with an even length, and return the head of the modified linked list.\n        Example 1:\n        Input: head = [5,2,6,3,9,1,7,3,8,4]\n        Output: [5,6,2,3,9,1,4,8,3,7]\n        Explanation:\n        - The length of the first group is 1, which is odd, hence no reversal occurs.\n        - The length of the second group is 2, which is even, hence the nodes are reversed.\n        - The length of the third group is 3, which is odd, hence no reversal occurs.\n        - The length of the last group is 4, which is even, hence the nodes are reversed.\n        Example 2:\n        Input: head = [1,1,0,6]\n        Output: [1,0,1,6]\n        Explanation:\n        - The length of the first group is 1. No reversal occurs.\n        - The length of the second group is 2. The nodes are reversed.\n        - The length of the last group is 1. No reversal occurs.\n        Example 3:\n        Input: head = [1,1,0,6,5]\n        Output: [1,0,1,5,6]\n        Explanation:\n        - The length of the first group is 1. No reversal occurs.\n        - The length of the second group is 2. The nodes are reversed.\n        - The length of the last group is 2. The nodes are reversed.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1621,"row":{"number":2075,"difficulty":1,"question":"class Solution:\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n        \"\"\"\n        A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\n        originalText is placed first in a top-left to bottom-right manner.\n        The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        encodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n        The characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\n        For example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n        The blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\n        Given the encoded string encodedText and number of rows rows, return the original string originalText.\n        Note: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.\n        Example 1:\n        Input: encodedText = \"ch   ie   pr\", rows = 3\n        Output: \"cipher\"\n        Explanation: This is the same example described in the problem description.\n        Example 2:\n        Input: encodedText = \"iveo    eed   l te   olc\", rows = 4\n        Output: \"i love leetcode\"\n        Explanation: The figure above denotes the matrix that was used to encode originalText. \n        The blue arrows show how we can find originalText from encodedText.\n        Example 3:\n        Input: encodedText = \"coding\", rows = 1\n        Output: \"coding\"\n        Explanation: Since there is only 1 row, both originalText and encodedText are the same.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1622,"row":{"number":2076,"difficulty":2,"question":"class Solution:\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n        \"\"\"\n        You are given an integer n indicating the number of people in a network. Each person is labeled from 0 to n - 1.\n        You are also given a 0-indexed 2D integer array restrictions, where restrictions[i] = [xi, yi] means that person xi and person yi cannot become friends, either directly or indirectly through other people.\n        Initially, no one is friends with each other. You are given a list of friend requests as a 0-indexed 2D integer array requests, where requests[j] = [uj, vj] is a friend request between person uj and person vj.\n        A friend request is successful if uj and vj can be friends. Each friend request is processed in the given order (i.e., requests[j] occurs before requests[j + 1]), and upon a successful request, uj and vj become direct friends for all future friend requests.\n        Return a boolean array result, where each result[j] is true if the jth friend request is successful or false if it is not.\n        Note: If uj and vj are already direct friends, the request is still successful.\n        Example 1:\n        Input: n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\n        Output: [true,false]\n        Explanation:\n        Request 0: Person 0 and person 2 can be friends, so they become direct friends. \n        Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).\n        Example 2:\n        Input: n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\n        Output: [true,false]\n        Explanation:\n        Request 0: Person 1 and person 2 can be friends, so they become direct friends.\n        Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).\n        Example 3:\n        Input: n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\n        Output: [true,false,true,false]\n        Explanation:\n        Request 0: Person 0 and person 4 can be friends, so they become direct friends.\n        Request 1: Person 1 and person 2 cannot be friends since they are directly restricted.\n        Request 2: Person 3 and person 1 can be friends, so they become direct friends.\n        Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1623,"row":{"number":2078,"difficulty":0,"question":"class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        \"\"\"\n        There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\n        Return the maximum distance between two houses with different colors.\n        The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.\n        Example 1:\n        Input: colors = [1,1,1,6,1,1,1]\n        Output: 3\n        Explanation: In the above image, color 1 is blue, and color 6 is red.\n        The furthest two houses with different colors are house 0 and house 3.\n        House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\n        Note that houses 3 and 6 can also produce the optimal answer.\n        Example 2:\n        Input: colors = [1,8,3,8,3]\n        Output: 4\n        Explanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\n        The furthest two houses with different colors are house 0 and house 4.\n        House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.\n        Example 3:\n        Input: colors = [0,1]\n        Output: 1\n        Explanation: The furthest two houses with different colors are house 0 and house 1.\n        House 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1624,"row":{"number":2132,"difficulty":2,"question":"class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        \"\"\"\n        You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).\n        You are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:\n            Cover all the empty cells.\n            Do not cover any of the occupied cells.\n            We can put as many stamps as we want.\n            Stamps can overlap with each other.\n            Stamps are not allowed to be rotated.\n            Stamps must stay completely inside the grid.\n        Return true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.\n        Example 1:\n        Input: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\n        Output: true\n        Explanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n        Example 2:\n        Input: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \n        Output: false \n        Explanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1625,"row":{"number":2097,"difficulty":2,"question":"class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\n        Return any valid arrangement of pairs.\n        Note: The inputs will be generated such that there exists a valid arrangement of pairs.\n        Example 1:\n        Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\n        Output: [[11,9],[9,4],[4,5],[5,1]]\n        Explanation:\n        This is a valid arrangement since endi-1 always equals starti.\n        end0 = 9 == 9 = start1 \n        end1 = 4 == 4 = start2\n        end2 = 5 == 5 = start3\n        Example 2:\n        Input: pairs = [[1,3],[3,2],[2,1]]\n        Output: [[1,3],[3,2],[2,1]]\n        Explanation:\n        This is a valid arrangement since endi-1 always equals starti.\n        end0 = 3 == 3 = start1\n        end1 = 2 == 2 = start2\n        The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.\n        Example 3:\n        Input: pairs = [[1,2],[1,3],[2,1]]\n        Output: [[1,2],[2,1],[1,3]]\n        Explanation:\n        This is a valid arrangement since endi-1 always equals starti.\n        end0 = 2 == 2 = start1\n        end1 = 1 == 1 = start2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1626,"row":{"number":2081,"difficulty":2,"question":"class Solution:\n    def kMirror(self, k: int, n: int) -> int:\n        \"\"\"\n        A k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k.\n            For example, 9 is a 2-mirror number. The representation of 9 in base-10 and base-2 are 9 and 1001 respectively, which read the same both forward and backward.\n            On the contrary, 4 is not a 2-mirror number. The representation of 4 in base-2 is 100, which does not read the same both forward and backward.\n        Given the base k and the number n, return the sum of the n smallest k-mirror numbers.\n        Example 1:\n        Input: k = 2, n = 5\n        Output: 25\n        Explanation:\n        The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:\n          base-10    base-2\n            1          1\n            3          11\n            5          101\n            7          111\n            9          1001\n        Their sum = 1 + 3 + 5 + 7 + 9 = 25. \n        Example 2:\n        Input: k = 3, n = 7\n        Output: 499\n        Explanation:\n        The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:\n          base-10    base-3\n            1          1\n            2          2\n            4          11\n            8          22\n            121        11111\n            151        12121\n            212        21212\n        Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.\n        Example 3:\n        Input: k = 7, n = 17\n        Output: 20379000\n        Explanation: The 17 smallest 7-mirror numbers are:\n        1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1627,"row":{"number":2099,"difficulty":0,"question":"class Solution:\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum.\n        Return any such subsequence as an integer array of length k.\n        A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: nums = [2,1,3,3], k = 2\n        Output: [3,3]\n        Explanation:\n        The subsequence has the largest sum of 3 + 3 = 6.\n        Example 2:\n        Input: nums = [-1,-2,3,4], k = 3\n        Output: [-1,3,4]\n        Explanation: \n        The subsequence has the largest sum of -1 + 3 + 4 = 6.\n        Example 3:\n        Input: nums = [3,4,3,3], k = 2\n        Output: [3,4]\n        Explanation:\n        The subsequence has the largest sum of 3 + 4 = 7. \n        Another possible subsequence is [4, 3].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1628,"row":{"number":2100,"difficulty":1,"question":"class Solution:\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\n        \"\"\"\n        You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.\n        The ith day is a good day to rob the bank if:\n            There are at least time days before and after the ith day,\n            The number of guards at the bank for the time days before i are non-increasing, and\n            The number of guards at the bank for the time days after i are non-decreasing.\n        More formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].\n        Return a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.\n        Example 1:\n        Input: security = [5,3,3,3,5,6,2], time = 2\n        Output: [2,3]\n        Explanation:\n        On day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].\n        On day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].\n        No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.\n        Example 2:\n        Input: security = [1,1,1,1,1], time = 0\n        Output: [0,1,2,3,4]\n        Explanation:\n        Since time equals 0, every day is a good day to rob the bank, so return every day.\n        Example 3:\n        Input: security = [1,2,3,4,5,6], time = 2\n        Output: []\n        Explanation:\n        No day has 2 days before it that have a non-increasing number of guards.\n        Thus, no day is a good day to rob the bank, so return an empty list.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1629,"row":{"number":2101,"difficulty":1,"question":"class Solution:\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\n        \"\"\"\n        You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.\n        The bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi denote the X-coordinate and Y-coordinate of the location of the ith bomb, whereas ri denotes the radius of its range.\n        You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.\n        Given the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.\n        Example 1:\n        Input: bombs = [[2,1,3],[6,1,4]]\n        Output: 2\n        Explanation:\n        The above figure shows the positions and ranges of the 2 bombs.\n        If we detonate the left bomb, the right bomb will not be affected.\n        But if we detonate the right bomb, both bombs will be detonated.\n        So the maximum bombs that can be detonated is max(1, 2) = 2.\n        Example 2:\n        Input: bombs = [[1,1,5],[10,10,5]]\n        Output: 1\n        Explanation:\n        Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.\n        Example 3:\n        Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\n        Output: 5\n        Explanation:\n        The best bomb to detonate is bomb 0 because:\n        - Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.\n        - Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.\n        - Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.\n        Thus all 5 bombs are detonated.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1630,"row":{"number":2102,"difficulty":2,"question":"class SORTracker:\n    def __init__(self):\n    def add(self, name: str, score: int) -> None:\n    def get(self) -> str:\n        \"\"\"\n        A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better.\n        You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:\n            Adding scenic locations, one at a time.\n            Querying the ith best location of all locations already added, where i is the number of times the system has been queried (including the current query).\n                For example, when the system is queried for the 4th time, it returns the 4th best location of all locations already added.\n        Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.\n        Implement the SORTracker class:\n            SORTracker() Initializes the tracker system.\n            void add(string name, int score) Adds a scenic location with name and score to the system.\n            string get() Queries and returns the ith best location, where i is the number of times this method has been invoked (including this invocation).\n        Example 1:\n        Input\n        [\"SORTracker\", \"add\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"get\"]\n        [[], [\"bradford\", 2], [\"branford\", 3], [], [\"alps\", 2], [], [\"orland\", 2], [], [\"orlando\", 3], [], [\"alpine\", 2], [], []]\n        Output\n        [null, null, null, \"branford\", null, \"alps\", null, \"bradford\", null, \"bradford\", null, \"bradford\", \"orland\"]\n        Explanation\n        SORTracker tracker = new SORTracker(); // Initialize the tracker system.\n        tracker.add(\"bradford\", 2); // Add location with name=\"bradford\" and score=2 to the system.\n        tracker.add(\"branford\", 3); // Add location with name=\"branford\" and score=3 to the system.\n        tracker.get();              // The sorted locations, from best to worst, are: branford, bradford.\n                                    // Note that branford precedes bradford due to its higher score (3 > 2).\n                                    // This is the 1st time get() is called, so return the best location: \"branford\".\n        tracker.add(\"alps\", 2);     // Add location with name=\"alps\" and score=2 to the system.\n        tracker.get();              // Sorted locations: branford, alps, bradford.\n                                    // Note that alps precedes bradford even though they have the same score (2).\n                                    // This is because \"alps\" is lexicographically smaller than \"bradford\".\n                                    // Return the 2nd best location \"alps\", as it is the 2nd time get() is called.\n        tracker.add(\"orland\", 2);   // Add location with name=\"orland\" and score=2 to the system.\n        tracker.get();              // Sorted locations: branford, alps, bradford, orland.\n                                    // Return \"bradford\", as it is the 3rd time get() is called.\n        tracker.add(\"orlando\", 3);  // Add location with name=\"orlando\" and score=3 to the system.\n        tracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.\n                                    // Return \"bradford\".\n        tracker.add(\"alpine\", 2);   // Add location with name=\"alpine\" and score=2 to the system.\n        tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.\n                                    // Return \"bradford\".\n        tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.\n                                    // Return \"orland\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1631,"row":{"number":2089,"difficulty":0,"question":"class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed integer array nums and a target element target.\n        A target index is an index i such that nums[i] == target.\n        Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.\n        Example 1:\n        Input: nums = [1,2,5,2,3], target = 2\n        Output: [1,2]\n        Explanation: After sorting, nums is [1,2,2,3,5].\n        The indices where nums[i] == 2 are 1 and 2.\n        Example 2:\n        Input: nums = [1,2,5,2,3], target = 3\n        Output: [3]\n        Explanation: After sorting, nums is [1,2,2,3,5].\n        The index where nums[i] == 3 is 3.\n        Example 3:\n        Input: nums = [1,2,5,2,3], target = 5\n        Output: [4]\n        Explanation: After sorting, nums is [1,2,2,3,5].\n        The index where nums[i] == 5 is 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1632,"row":{"number":2090,"difficulty":1,"question":"class Solution:\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array nums of n integers, and an integer k.\n        The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.\n        Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.\n        The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.\n            For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.\n        Example 1:\n        Input: nums = [7,4,3,9,1,8,5,2,6], k = 3\n        Output: [-1,-1,-1,5,4,4,-1,-1,-1]\n        Explanation:\n        - avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.\n        - The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.\n          Using integer division, avg[3] = 37 / 7 = 5.\n        - For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.\n        - For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.\n        - avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.\n        Example 2:\n        Input: nums = [100000], k = 0\n        Output: [100000]\n        Explanation:\n        - The sum of the subarray centered at index 0 with radius 0 is: 100000.\n          avg[0] = 100000 / 1 = 100000.\n        Example 3:\n        Input: nums = [8], k = 100000\n        Output: [-1]\n        Explanation: \n        - avg[0] is -1 because there are less than k elements before and after index 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1633,"row":{"number":2091,"difficulty":1,"question":"class Solution:\n    def minimumDeletions(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of distinct integers nums.\n        There is an element in nums that has the lowest value and an element that has the highest value. We call them the minimum and maximum respectively. Your goal is to remove both these elements from the array.\n        A deletion is defined as either removing an element from the front of the array or removing an element from the back of the array.\n        Return the minimum number of deletions it would take to remove both the minimum and maximum element from the array.\n        Example 1:\n        Input: nums = [2,10,7,5,4,1,8,6]\n        Output: 5\n        Explanation: \n        The minimum element in the array is nums[5], which is 1.\n        The maximum element in the array is nums[1], which is 10.\n        We can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.\n        This results in 2 + 3 = 5 deletions, which is the minimum number possible.\n        Example 2:\n        Input: nums = [0,-4,19,1,8,-2,-3,5]\n        Output: 3\n        Explanation: \n        The minimum element in the array is nums[1], which is -4.\n        The maximum element in the array is nums[2], which is 19.\n        We can remove both the minimum and maximum by removing 3 elements from the front.\n        This results in only 3 deletions, which is the minimum number possible.\n        Example 3:\n        Input: nums = [101]\n        Output: 1\n        Explanation:  \n        There is only one element in the array, which makes it both the minimum and maximum element.\n        We can remove it with 1 deletion.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1634,"row":{"number":2092,"difficulty":2,"question":"class Solution:\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n        \"\"\"\n        You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.\n        Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.\n        The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\n        Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.\n        Example 1:\n        Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\n        Output: [0,1,2,3,5]\n        Explanation:\n        At time 0, person 0 shares the secret with person 1.\n        At time 5, person 1 shares the secret with person 2.\n        At time 8, person 2 shares the secret with person 3.\n        At time 10, person 1 shares the secret with person 5.​​​​\n        Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.\n        Example 2:\n        Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\n        Output: [0,1,3]\n        Explanation:\n        At time 0, person 0 shares the secret with person 3.\n        At time 2, neither person 1 nor person 2 know the secret.\n        At time 3, person 3 shares the secret with person 0 and person 1.\n        Thus, people 0, 1, and 3 know the secret after all the meetings.\n        Example 3:\n        Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\n        Output: [0,1,2,3,4]\n        Explanation:\n        At time 0, person 0 shares the secret with person 1.\n        At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\n        Note that person 2 can share the secret at the same time as receiving it.\n        At time 2, person 3 shares the secret with person 4.\n        Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1635,"row":{"number":2094,"difficulty":0,"question":"class Solution:\n    def findEvenNumbers(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer array digits, where each element is a digit. The array may contain duplicates.\n        You need to find all the unique integers that follow the given requirements:\n            The integer consists of the concatenation of three elements from digits in any arbitrary order.\n            The integer does not have leading zeros.\n            The integer is even.\n        For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.\n        Return a sorted array of the unique integers.\n        Example 1:\n        Input: digits = [2,1,3,0]\n        Output: [102,120,130,132,210,230,302,310,312,320]\n        Explanation: All the possible integers that follow the requirements are in the output array. \n        Notice that there are no odd integers or integers with leading zeros.\n        Example 2:\n        Input: digits = [2,2,8,8,2]\n        Output: [222,228,282,288,822,828,882]\n        Explanation: The same digit can be used as many times as it appears in digits. \n        In this example, the digit 8 is used twice each time in 288, 828, and 882. \n        Example 3:\n        Input: digits = [3,7,5]\n        Output: []\n        Explanation: No even integers can be formed using the given digits.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1636,"row":{"number":2095,"difficulty":1,"question":"class Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\n        The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.\n            For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\n        Example 1:\n        Input: head = [1,3,4,7,1,2,6]\n        Output: [1,3,4,1,2,6]\n        Explanation:\n        The above figure represents the given linked list. The indices of the nodes are written below.\n        Since n = 7, node 3 with value 7 is the middle node, which is marked in red.\n        We return the new list after removing this node. \n        Example 2:\n        Input: head = [1,2,3,4]\n        Output: [1,2,4]\n        Explanation:\n        The above figure represents the given linked list.\n        For n = 4, node 2 with value 3 is the middle node, which is marked in red.\n        Example 3:\n        Input: head = [2,1]\n        Output: [2]\n        Explanation:\n        The above figure represents the given linked list.\n        For n = 2, node 1 with value 1 is the middle node, which is marked in red.\n        Node 0 with value 2 is the only node remaining after removing node 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1637,"row":{"number":2096,"difficulty":1,"question":"class Solution:\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\n        \"\"\"\n        You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.\n        Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:\n            'L' means to go from a node to its left child node.\n            'R' means to go from a node to its right child node.\n            'U' means to go from a node to its parent node.\n        Return the step-by-step directions of the shortest path from node s to node t.\n        Example 1:\n        Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6\n        Output: \"UURL\"\n        Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6.\n        Example 2:\n        Input: root = [2,1], startValue = 2, destValue = 1\n        Output: \"L\"\n        Explanation: The shortest path is: 2 → 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1638,"row":{"number":2114,"difficulty":0,"question":"class Solution:\n    def mostWordsFound(self, sentences: List[str]) -> int:\n        \"\"\"\n        A sentence is a list of words that are separated by a single space with no leading or trailing spaces.\n        You are given an array of strings sentences, where each sentences[i] represents a single sentence.\n        Return the maximum number of words that appear in a single sentence.\n        Example 1:\n        Input: sentences = [\"alice and bob love leetcode\", \"i think so too\", \"this is great thanks very much\"]\n        Output: 6\n        Explanation: \n        - The first sentence, \"alice and bob love leetcode\", has 5 words in total.\n        - The second sentence, \"i think so too\", has 4 words in total.\n        - The third sentence, \"this is great thanks very much\", has 6 words in total.\n        Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words.\n        Example 2:\n        Input: sentences = [\"please wait\", \"continue to fight\", \"continue to win\"]\n        Output: 3\n        Explanation: It is possible that multiple sentences contain the same number of words. \n        In this example, the second and third sentences (underlined) have the same number of words.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1639,"row":{"number":2115,"difficulty":1,"question":"class Solution:\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        \"\"\"\n        You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\n        You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\n        Return a list of all the recipes that you can create. You may return the answer in any order.\n        Note that two recipes may contain each other in their ingredients.\n        Example 1:\n        Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\n        Output: [\"bread\"]\n        Explanation:\n        We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\n        Example 2:\n        Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n        Output: [\"bread\",\"sandwich\"]\n        Explanation:\n        We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\n        We can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\n        Example 3:\n        Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n        Output: [\"bread\",\"sandwich\",\"burger\"]\n        Explanation:\n        We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\n        We can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\n        We can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1640,"row":{"number":2116,"difficulty":1,"question":"class Solution:\n    def canBeValid(self, s: str, locked: str) -> bool:\n        \"\"\"\n        A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:\n            It is ().\n            It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.\n            It can be written as (A), where A is a valid parentheses string.\n        You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked,\n            If locked[i] is '1', you cannot change s[i].\n            But if locked[i] is '0', you can change s[i] to either '(' or ')'.\n        Return true if you can make s a valid parentheses string. Otherwise, return false.\n        Example 1:\n        Input: s = \"))()))\", locked = \"010100\"\n        Output: true\n        Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].\n        We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid.\n        Example 2:\n        Input: s = \"()()\", locked = \"0000\"\n        Output: true\n        Explanation: We do not need to make any changes because s is already valid.\n        Example 3:\n        Input: s = \")\", locked = \"0\"\n        Output: false\n        Explanation: locked permits us to change s[0]. \n        Changing s[0] to either '(' or ')' will not make s valid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1641,"row":{"number":2117,"difficulty":2,"question":"class Solution:\n    def abbreviateProduct(self, left: int, right: int) -> str:\n        \"\"\"\n        You are given two positive integers left and right with left <= right. Calculate the product of all integers in the inclusive range [left, right].\n        Since the product may be very large, you will abbreviate it following these steps:\n            Count all trailing zeros in the product and remove them. Let us denote this count as C.\n                For example, there are 3 trailing zeros in 1000, and there are 0 trailing zeros in 546.\n            Denote the remaining number of digits in the product as d. If d > 10, then express the product as <pre>...<suf> where <pre> denotes the first 5 digits of the product, and <suf> denotes the last 5 digits of the product after removing all trailing zeros. If d <= 10, we keep it unchanged.\n                For example, we express 1234567654321 as 12345...54321, but 1234567 is represented as 1234567.\n            Finally, represent the product as a string \"<pre>...<suf>eC\".\n                For example, 12345678987600000 will be represented as \"12345...89876e5\".\n        Return a string denoting the abbreviated product of all integers in the inclusive range [left, right].\n        Example 1:\n        Input: left = 1, right = 4\n        Output: \"24e0\"\n        Explanation: The product is 1 × 2 × 3 × 4 = 24.\n        There are no trailing zeros, so 24 remains the same. The abbreviation will end with \"e0\".\n        Since the number of digits is 2, which is less than 10, we do not have to abbreviate it further.\n        Thus, the final representation is \"24e0\".\n        Example 2:\n        Input: left = 2, right = 11\n        Output: \"399168e2\"\n        Explanation: The product is 39916800.\n        There are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with \"e2\".\n        The number of digits after removing the trailing zeros is 6, so we do not abbreviate it further.\n        Hence, the abbreviated product is \"399168e2\".\n        Example 3:\n        Input: left = 371, right = 375\n        Output: \"7219856259e3\"\n        Explanation: The product is 7219856259000.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1642,"row":{"number":2103,"difficulty":0,"question":"class Solution:\n    def countPoints(self, rings: str) -> int:\n        \"\"\"\n        There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.\n        You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:\n            The first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').\n            The second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').\n        For example, \"R3G2B1\" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n        Return the number of rods that have all three colors of rings on them.\n        Example 1:\n        Input: rings = \"B0B6G0R6R0R6G9\"\n        Output: 1\n        Explanation: \n        - The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n        - The rod labeled 6 holds 3 rings, but it only has red and blue.\n        - The rod labeled 9 holds only a green ring.\n        Thus, the number of rods with all three colors is 1.\n        Example 2:\n        Input: rings = \"B0R0G0R9R0B0G0\"\n        Output: 1\n        Explanation: \n        - The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n        - The rod labeled 9 holds only a red ring.\n        Thus, the number of rods with all three colors is 1.\n        Example 3:\n        Input: rings = \"G4\"\n        Output: 0\n        Explanation: \n        Only one ring is given. Thus, no rods have all three colors.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1643,"row":{"number":2104,"difficulty":1,"question":"class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\n        Return the sum of all subarray ranges of nums.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: 4\n        Explanation: The 6 subarrays of nums are the following:\n        [1], range = largest - smallest = 1 - 1 = 0 \n        [2], range = 2 - 2 = 0\n        [3], range = 3 - 3 = 0\n        [1,2], range = 2 - 1 = 1\n        [2,3], range = 3 - 2 = 1\n        [1,2,3], range = 3 - 1 = 2\n        So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.\n        Example 2:\n        Input: nums = [1,3,3]\n        Output: 4\n        Explanation: The 6 subarrays of nums are the following:\n        [1], range = largest - smallest = 1 - 1 = 0\n        [3], range = 3 - 3 = 0\n        [3], range = 3 - 3 = 0\n        [1,3], range = 3 - 1 = 2\n        [3,3], range = 3 - 3 = 0\n        [1,3,3], range = 3 - 1 = 2\n        So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.\n        Example 3:\n        Input: nums = [4,-2,-3,4,1]\n        Output: 59\n        Explanation: The sum of all subarray ranges of nums is 59.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1644,"row":{"number":2105,"difficulty":1,"question":"class Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        \"\"\"\n        Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.\n        Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:\n            Alice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.\n            It takes the same amount of time to water each plant regardless of how much water it needs.\n            Alice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.\n            In case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n        Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.\n        Example 1:\n        Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5\n        Output: 1\n        Explanation:\n        - Initially, Alice and Bob have 5 units of water each in their watering cans.\n        - Alice waters plant 0, Bob waters plant 3.\n        - Alice and Bob now have 3 units and 2 units of water respectively.\n        - Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\n        So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.\n        Example 2:\n        Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4\n        Output: 2\n        Explanation:\n        - Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n        - Alice waters plant 0, Bob waters plant 3.\n        - Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n        - Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\n        So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.\n        Example 3:\n        Input: plants = [5], capacityA = 10, capacityB = 8\n        Output: 0\n        Explanation:\n        - There is only one plant.\n        - Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\n        So, the total number of times they have to refill is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1645,"row":{"number":2106,"difficulty":2,"question":"class Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        \"\"\"\n        Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique.\n        You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n        Return the maximum total number of fruits you can harvest.\n        Example 1:\n        Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n        Output: 9\n        Explanation: \n        The optimal way is to:\n        - Move right to position 6 and harvest 3 fruits\n        - Move right to position 8 and harvest 6 fruits\n        You moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n        Example 2:\n        Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n        Output: 14\n        Explanation: \n        You can move at most k = 4 steps, so you cannot reach position 0 nor 10.\n        The optimal way is to:\n        - Harvest the 7 fruits at the starting position 5\n        - Move left to position 4 and harvest 1 fruit\n        - Move right to position 6 and harvest 2 fruits\n        - Move right to position 7 and harvest 4 fruits\n        You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n        Example 3:\n        Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n        Output: 0\n        Explanation:\n        You can move at most k = 2 steps and cannot reach any position with fruits.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1646,"row":{"number":2108,"difficulty":0,"question":"class Solution:\n    def firstPalindrome(self, words: List[str]) -> str:\n        \"\"\"\n        Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\n        A string is palindromic if it reads the same forward and backward.\n        Example 1:\n        Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\n        Output: \"ada\"\n        Explanation: The first string that is palindromic is \"ada\".\n        Note that \"racecar\" is also palindromic, but it is not the first.\n        Example 2:\n        Input: words = [\"notapalindrome\",\"racecar\"]\n        Output: \"racecar\"\n        Explanation: The first and only string that is palindromic is \"racecar\".\n        Example 3:\n        Input: words = [\"def\",\"ghi\"]\n        Output: \"\"\n        Explanation: There are no palindromic strings, so the empty string is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1647,"row":{"number":2109,"difficulty":1,"question":"class Solution:\n    def addSpaces(self, s: str, spaces: List[int]) -> str:\n        \"\"\"\n        You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index.\n            For example, given s = \"EnjoyYourCoffee\" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain \"Enjoy Your Coffee\".\n        Return the modified string after the spaces have been added.\n        Example 1:\n        Input: s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15]\n        Output: \"Leetcode Helps Me Learn\"\n        Explanation: \n        The indices 8, 13, and 15 correspond to the underlined characters in \"LeetcodeHelpsMeLearn\".\n        We then place spaces before those characters.\n        Example 2:\n        Input: s = \"icodeinpython\", spaces = [1,5,7,9]\n        Output: \"i code in py thon\"\n        Explanation:\n        The indices 1, 5, 7, and 9 correspond to the underlined characters in \"icodeinpython\".\n        We then place spaces before those characters.\n        Example 3:\n        Input: s = \"spacing\", spaces = [0,1,2,3,4,5,6]\n        Output: \" s p a c i n g\"\n        Explanation:\n        We are also able to place spaces before the first character of the string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1648,"row":{"number":2110,"difficulty":1,"question":"class Solution:\n    def getDescentPeriods(self, prices: List[int]) -> int:\n        \"\"\"\n        You are given an integer array prices representing the daily price history of a stock, where prices[i] is the stock price on the ith day.\n        A smooth descent period of a stock consists of one or more contiguous days such that the price on each day is lower than the price on the preceding day by exactly 1. The first day of the period is exempted from this rule.\n        Return the number of smooth descent periods.\n        Example 1:\n        Input: prices = [3,2,1,4]\n        Output: 7\n        Explanation: There are 7 smooth descent periods:\n        [3], [2], [1], [4], [3,2], [2,1], and [3,2,1]\n        Note that a period with one day is a smooth descent period by the definition.\n        Example 2:\n        Input: prices = [8,6,7,7]\n        Output: 4\n        Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7]\n        Note that [8,6] is not a smooth descent period as 8 - 6 ≠ 1.\n        Example 3:\n        Input: prices = [1]\n        Output: 1\n        Explanation: There is 1 smooth descent period: [1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1649,"row":{"number":2111,"difficulty":2,"question":"class Solution:\n    def kIncreasing(self, arr: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed array arr consisting of n positive integers, and a positive integer k.\n        The array arr is called K-increasing if arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1.\n            For example, arr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2 because:\n                arr[0] <= arr[2] (4 <= 5)\n                arr[1] <= arr[3] (1 <= 2)\n                arr[2] <= arr[4] (5 <= 6)\n                arr[3] <= arr[5] (2 <= 2)\n            However, the same arr is not K-increasing for k = 1 (because arr[0] > arr[1]) or k = 3 (because arr[0] > arr[3]).\n        In one operation, you can choose an index i and change arr[i] into any positive integer.\n        Return the minimum number of operations required to make the array K-increasing for the given k.\n        Example 1:\n        Input: arr = [5,4,3,2,1], k = 1\n        Output: 4\n        Explanation:\n        For k = 1, the resultant array has to be non-decreasing.\n        Some of the K-increasing arrays that can be formed are [5,6,7,8,9], [1,1,1,1,1], [2,2,3,4,4]. All of them require 4 operations.\n        It is suboptimal to change the array to, for example, [6,7,8,9,10] because it would take 5 operations.\n        It can be shown that we cannot make the array K-increasing in less than 4 operations.\n        Example 2:\n        Input: arr = [4,1,5,2,6,2], k = 2\n        Output: 0\n        Explanation:\n        This is the same example as the one in the problem description.\n        Here, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i].\n        Since the given array is already K-increasing, we do not need to perform any operations.\n        Example 3:\n        Input: arr = [4,1,5,2,6,2], k = 3\n        Output: 2\n        Explanation:\n        Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5.\n        One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5.\n        The array will now be [4,1,5,4,6,5].\n        Note that there can be other ways to make the array K-increasing, but none of them require less than 2 operations.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1650,"row":{"number":2129,"difficulty":0,"question":"class Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        \"\"\"\n        You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n            If the length of the word is 1 or 2 letters, change all letters to lowercase.\n            Otherwise, change the first letter to uppercase and the remaining letters to lowercase.\n        Return the capitalized title.\n        Example 1:\n        Input: title = \"capiTalIze tHe titLe\"\n        Output: \"Capitalize The Title\"\n        Explanation:\n        Since all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.\n        Example 2:\n        Input: title = \"First leTTeR of EACH Word\"\n        Output: \"First Letter of Each Word\"\n        Explanation:\n        The word \"of\" has length 2, so it is all lowercase.\n        The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.\n        Example 3:\n        Input: title = \"i lOve leetcode\"\n        Output: \"i Love Leetcode\"\n        Explanation:\n        The word \"i\" has length 1, so it is lowercase.\n        The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1651,"row":{"number":2130,"difficulty":1,"question":"class Solution:\n    def pairSum(self, head: Optional[ListNode]) -> int:\n        \"\"\"\n        In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.\n            For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.\n        The twin sum is defined as the sum of a node and its twin.\n        Given the head of a linked list with even length, return the maximum twin sum of the linked list.\n        Example 1:\n        Input: head = [5,4,2,1]\n        Output: 6\n        Explanation:\n        Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.\n        There are no other nodes with twins in the linked list.\n        Thus, the maximum twin sum of the linked list is 6. \n        Example 2:\n        Input: head = [4,2,2,3]\n        Output: 7\n        Explanation:\n        The nodes with twins present in this linked list are:\n        - Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.\n        - Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.\n        Thus, the maximum twin sum of the linked list is max(7, 4) = 7. \n        Example 3:\n        Input: head = [1,100000]\n        Output: 100001\n        Explanation:\n        There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1652,"row":{"number":2131,"difficulty":1,"question":"class Solution:\n    def longestPalindrome(self, words: List[str]) -> int:\n        \"\"\"\n        You are given an array of strings words. Each element of words consists of two lowercase English letters.\n        Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.\n        Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.\n        A palindrome is a string that reads the same forward and backward.\n        Example 1:\n        Input: words = [\"lc\",\"cl\",\"gg\"]\n        Output: 6\n        Explanation: One longest palindrome is \"lc\" + \"gg\" + \"cl\" = \"lcggcl\", of length 6.\n        Note that \"clgglc\" is another longest palindrome that can be created.\n        Example 2:\n        Input: words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]\n        Output: 8\n        Explanation: One longest palindrome is \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\", of length 8.\n        Note that \"lcyttycl\" is another longest palindrome that can be created.\n        Example 3:\n        Input: words = [\"cc\",\"ll\",\"xx\"]\n        Output: 2\n        Explanation: One longest palindrome is \"cc\", of length 2.\n        Note that \"ll\" is another longest palindrome that can be created, and so is \"xx\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1653,"row":{"number":2119,"difficulty":0,"question":"class Solution:\n    def isSameAfterReversals(self, num: int) -> bool:\n        \"\"\"\n        Reversing an integer means to reverse all its digits.\n            For example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.\n        Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.\n        Example 1:\n        Input: num = 526\n        Output: true\n        Explanation: Reverse num to get 625, then reverse 625 to get 526, which equals num.\n        Example 2:\n        Input: num = 1800\n        Output: false\n        Explanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num.\n        Example 3:\n        Input: num = 0\n        Output: true\n        Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals num.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1654,"row":{"number":2120,"difficulty":1,"question":"class Solution:\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\n        \"\"\"\n        There is an n x n grid, with the top-left cell at (0, 0) and the bottom-right cell at (n - 1, n - 1). You are given the integer n and an integer array startPos where startPos = [startrow, startcol] indicates that a robot is initially at cell (startrow, startcol).\n        You are also given a 0-indexed string s of length m where s[i] is the ith instruction for the robot: 'L' (move left), 'R' (move right), 'U' (move up), and 'D' (move down).\n        The robot can begin executing from any ith instruction in s. It executes the instructions one by one towards the end of s but it stops if either of these conditions is met:\n            The next instruction will move the robot off the grid.\n            There are no more instructions left to execute.\n        Return an array answer of length m where answer[i] is the number of instructions the robot can execute if the robot begins executing from the ith instruction in s.\n        Example 1:\n        Input: n = 3, startPos = [0,1], s = \"RRDDLU\"\n        Output: [1,5,4,3,1,0]\n        Explanation: Starting from startPos and beginning execution from the ith instruction:\n        - 0th: \"RRDDLU\". Only one instruction \"R\" can be executed before it moves off the grid.\n        - 1st:  \"RDDLU\". All five instructions can be executed while it stays in the grid and ends at (1, 1).\n        - 2nd:   \"DDLU\". All four instructions can be executed while it stays in the grid and ends at (1, 0).\n        - 3rd:    \"DLU\". All three instructions can be executed while it stays in the grid and ends at (0, 0).\n        - 4th:     \"LU\". Only one instruction \"L\" can be executed before it moves off the grid.\n        - 5th:      \"U\". If moving up, it would move off the grid.\n        Example 2:\n        Input: n = 2, startPos = [1,1], s = \"LURD\"\n        Output: [4,1,0,0]\n        Explanation:\n        - 0th: \"LURD\".\n        - 1st:  \"URD\".\n        - 2nd:   \"RD\".\n        - 3rd:    \"D\".\n        Example 3:\n        Input: n = 1, startPos = [0,0], s = \"LRUD\"\n        Output: [0,0,0,0]\n        Explanation: No matter which instruction the robot begins execution from, it would move off the grid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1655,"row":{"number":2121,"difficulty":1,"question":"class Solution:\n    def getDistances(self, arr: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array of n integers arr.\n        The interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|.\n        Return an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i].\n        Note: |x| is the absolute value of x.\n        Example 1:\n        Input: arr = [2,1,3,1,2,3,3]\n        Output: [4,2,7,2,4,4,5]\n        Explanation:\n        - Index 0: Another 2 is found at index 4. |0 - 4| = 4\n        - Index 1: Another 1 is found at index 3. |1 - 3| = 2\n        - Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7\n        - Index 3: Another 1 is found at index 1. |3 - 1| = 2\n        - Index 4: Another 2 is found at index 0. |4 - 0| = 4\n        - Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4\n        - Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5\n        Example 2:\n        Input: arr = [10,5,10,10]\n        Output: [5,0,3,4]\n        Explanation:\n        - Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5\n        - Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.\n        - Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3\n        - Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1656,"row":{"number":2122,"difficulty":2,"question":"class Solution:\n    def recoverArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner:\n            lower[i] = arr[i] - k, for every index i where 0 <= i < n\n            higher[i] = arr[i] + k, for every index i where 0 <= i < n\n        Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array.\n        Given an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array.\n        Note: The test cases are generated such that there exists at least one valid array arr.\n        Example 1:\n        Input: nums = [2,10,6,4,8,12]\n        Output: [3,7,11]\n        Explanation:\n        If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12].\n        Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums.\n        Another valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. \n        Example 2:\n        Input: nums = [1,1,3,3]\n        Output: [2,2]\n        Explanation:\n        If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3].\n        Combining lower and higher gives us [1,1,3,3], which is equal to nums.\n        Note that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0.\n        This is invalid since k must be positive.\n        Example 3:\n        Input: nums = [5,435]\n        Output: [220]\n        Explanation:\n        The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1657,"row":{"number":2124,"difficulty":0,"question":"class Solution:\n    def checkString(self, s: str) -> bool:\n        \"\"\"\n        Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, return false.\n        Example 1:\n        Input: s = \"aaabbb\"\n        Output: true\n        Explanation:\n        The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5.\n        Hence, every 'a' appears before every 'b' and we return true.\n        Example 2:\n        Input: s = \"abab\"\n        Output: false\n        Explanation:\n        There is an 'a' at index 2 and a 'b' at index 1.\n        Hence, not every 'a' appears before every 'b' and we return false.\n        Example 3:\n        Input: s = \"bbb\"\n        Output: true\n        Explanation:\n        There are no 'a's, hence, every 'a' appears before every 'b' and we return true.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1658,"row":{"number":2125,"difficulty":1,"question":"class Solution:\n    def numberOfBeams(self, bank: List[str]) -> int:\n        \"\"\"\n        Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\n        There is one laser beam between any two security devices if both conditions are met:\n            The two devices are located on two different rows: r1 and r2, where r1 < r2.\n            For each row i where r1 < i < r2, there are no security devices in the ith row.\n        Laser beams are independent, i.e., one beam does not interfere nor join with another.\n        Return the total number of laser beams in the bank.\n        Example 1:\n        Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\n        Output: 8\n        Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n         * bank[0][1] -- bank[2][1]\n         * bank[0][1] -- bank[2][3]\n         * bank[0][2] -- bank[2][1]\n         * bank[0][2] -- bank[2][3]\n         * bank[0][5] -- bank[2][1]\n         * bank[0][5] -- bank[2][3]\n         * bank[2][1] -- bank[3][2]\n         * bank[2][3] -- bank[3][2]\n        Note that there is no beam between any device on the 0th row with any on the 3rd row.\n        This is because the 2nd row contains security devices, which breaks the second condition.\n        Example 2:\n        Input: bank = [\"000\",\"111\",\"000\"]\n        Output: 0\n        Explanation: There does not exist two devices located on two different rows.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1659,"row":{"number":2126,"difficulty":1,"question":"class Solution:\n    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:\n        \"\"\"\n        You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.\n        You can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.\n        Return true if all asteroids can be destroyed. Otherwise, return false.\n        Example 1:\n        Input: mass = 10, asteroids = [3,9,19,5,21]\n        Output: true\n        Explanation: One way to order the asteroids is [9,19,5,3,21]:\n        - The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19\n        - The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38\n        - The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43\n        - The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46\n        - The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67\n        All asteroids are destroyed.\n        Example 2:\n        Input: mass = 5, asteroids = [4,9,23,4]\n        Output: false\n        Explanation: \n        The planet cannot ever gain enough mass to destroy the asteroid with a mass of 23.\n        After the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.\n        This is less than 23, so a collision would not destroy the last asteroid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1660,"row":{"number":2127,"difficulty":2,"question":"class Solution:\n    def maximumInvitations(self, favorite: List[int]) -> int:\n        \"\"\"\n        A company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.\n        The employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.\n        Given a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting.\n        Example 1:\n        Input: favorite = [2,2,1,2]\n        Output: 3\n        Explanation:\n        The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.\n        All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.\n        Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.\n        The maximum number of employees that can be invited to the meeting is 3. \n        Example 2:\n        Input: favorite = [1,2,0]\n        Output: 3\n        Explanation: \n        Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.\n        The seating arrangement will be the same as that in the figure given in example 1:\n        - Employee 0 will sit between employees 2 and 1.\n        - Employee 1 will sit between employees 0 and 2.\n        - Employee 2 will sit between employees 1 and 0.\n        The maximum number of employees that can be invited to the meeting is 3.\n        Example 3:\n        Input: favorite = [3,0,1,4,1]\n        Output: 4\n        Explanation:\n        The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.\n        Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\n        So the company leaves them out of the meeting.\n        The maximum number of employees that can be invited to the meeting is 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1661,"row":{"number":2144,"difficulty":0,"question":"class Solution:\n    def minimumCost(self, cost: List[int]) -> int:\n        \"\"\"\n        A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.\n        The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.\n            For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.\n        Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.\n        Example 1:\n        Input: cost = [1,2,3]\n        Output: 5\n        Explanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.\n        The total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies.\n        Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.\n        The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.\n        Example 2:\n        Input: cost = [6,5,7,9,2,2]\n        Output: 23\n        Explanation: The way in which we can get the minimum cost is described below:\n        - Buy candies with costs 9 and 7\n        - Take the candy with cost 6 for free\n        - We buy candies with costs 5 and 2\n        - Take the last remaining candy with cost 2 for free\n        Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.\n        Example 3:\n        Input: cost = [5,5]\n        Output: 10\n        Explanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.\n        Hence, the minimum cost to buy all candies is 5 + 5 = 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1662,"row":{"number":2145,"difficulty":1,"question":"class Solution:\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\n        \"\"\"\n        You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i].\n        You are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain.\n            For example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive).\n                [3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.\n                [5, 6, 3, 7] is not possible since it contains an element greater than 6.\n                [1, 2, 3, 4] is not possible since the differences are not correct.\n        Return the number of possible hidden sequences there are. If there are no possible sequences, return 0.\n        Example 1:\n        Input: differences = [1,-3,4], lower = 1, upper = 6\n        Output: 2\n        Explanation: The possible hidden sequences are:\n        - [3, 4, 1, 5]\n        - [4, 5, 2, 6]\n        Thus, we return 2.\n        Example 2:\n        Input: differences = [3,-4,5,1,-2], lower = -4, upper = 5\n        Output: 4\n        Explanation: The possible hidden sequences are:\n        - [-3, 0, -4, 1, 2, 0]\n        - [-2, 1, -3, 2, 3, 1]\n        - [-1, 2, -2, 3, 4, 2]\n        - [0, 3, -1, 4, 5, 3]\n        Thus, we return 4.\n        Example 3:\n        Input: differences = [4,-7,2], lower = 3, upper = 6\n        Output: 0\n        Explanation: There are no possible hidden sequences. Thus, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1663,"row":{"number":2146,"difficulty":1,"question":"class Solution:\n    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n        \"\"\"\n        You are given a 0-indexed 2D integer array grid of size m x n that represents a map of the items in a shop. The integers in the grid represent the following:\n            0 represents a wall that you cannot pass through.\n            1 represents an empty cell that you can freely move to and from.\n            All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\n        It takes 1 step to travel between adjacent grid cells.\n        You are also given integer arrays pricing and start where pricing = [low, high] and start = [row, col] indicates that you start at the position (row, col) and are interested only in items with a price in the range of [low, high] (inclusive). You are further given an integer k.\n        You are interested in the positions of the k highest-ranked items whose prices are within the given price range. The rank is determined by the first of these criteria that is different:\n            Distance, defined as the length of the shortest path from the start (shorter distance has a higher rank).\n            Price (lower price has a higher rank, but it must be in the price range).\n            The row number (smaller row number has a higher rank).\n            The column number (smaller column number has a higher rank).\n        Return the k highest-ranked items within the price range sorted by their rank (highest to lowest). If there are fewer than k reachable items within the price range, return all of them.\n        Example 1:\n        Input: grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3\n        Output: [[0,1],[1,1],[2,1]]\n        Explanation: You start at (0,0).\n        With a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2).\n        The ranks of these items are:\n        - (0,1) with distance 1\n        - (1,1) with distance 2\n        - (2,1) with distance 3\n        - (2,2) with distance 4\n        Thus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).\n        Example 2:\n        Input: grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2\n        Output: [[2,1],[1,2]]\n        Explanation: You start at (2,3).\n        With a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1).\n        The ranks of these items are:\n        - (2,1) with distance 2, price 2\n        - (1,2) with distance 2, price 3\n        - (1,1) with distance 3\n        - (0,1) with distance 4\n        Thus, the 2 highest ranked items in the price range are (2,1) and (1,2).\n        Example 3:\n        Input: grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3\n        Output: [[2,1],[2,0]]\n        Explanation: You start at (0,0).\n        With a price range of [2,3], we can take items from (2,0) and (2,1). \n        The ranks of these items are: \n        - (2,1) with distance 5\n        - (2,0) with distance 6\n        Thus, the 2 highest ranked items in the price range are (2,1) and (2,0). \n        Note that k = 3 but there are only 2 reachable items within the price range.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1664,"row":{"number":2147,"difficulty":2,"question":"class Solution:\n    def numberOfWays(self, corridor: str) -> int:\n        \"\"\"\n        Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.\n        One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.\n        Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.\n        Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.\n        Example 1:\n        Input: corridor = \"SSPPSPS\"\n        Output: 3\n        Explanation: There are 3 different ways to divide the corridor.\n        The black bars in the above image indicate the two room dividers already installed.\n        Note that in each of the ways, each section has exactly two seats.\n        Example 2:\n        Input: corridor = \"PPSPSP\"\n        Output: 1\n        Explanation: There is only 1 way to divide the corridor, by not installing any additional dividers.\n        Installing any would create some section that does not have exactly two seats.\n        Example 3:\n        Input: corridor = \"S\"\n        Output: 0\n        Explanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1665,"row":{"number":2133,"difficulty":0,"question":"class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n        \"\"\"\n        An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\n        Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.\n        Example 1:\n        Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\n        Output: true\n        Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\n        Hence, we return true.\n        Example 2:\n        Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\n        Output: false\n        Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\n        Hence, we return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1666,"row":{"number":2134,"difficulty":1,"question":"class Solution:\n    def minSwaps(self, nums: List[int]) -> int:\n        \"\"\"\n        A swap is defined as taking two distinct positions in an array and swapping the values in them.\n        A circular array is defined as an array where we consider the first element and the last element to be adjacent.\n        Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.\n        Example 1:\n        Input: nums = [0,1,0,1,1,0,0]\n        Output: 1\n        Explanation: Here are a few of the ways to group all the 1's together:\n        [0,0,1,1,1,0,0] using 1 swap.\n        [0,1,1,1,0,0,0] using 1 swap.\n        [1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).\n        There is no way to group all 1's together with 0 swaps.\n        Thus, the minimum number of swaps required is 1.\n        Example 2:\n        Input: nums = [0,1,1,1,0,0,1,1,0]\n        Output: 2\n        Explanation: Here are a few of the ways to group all the 1's together:\n        [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).\n        [1,1,1,1,1,0,0,0,0] using 2 swaps.\n        There is no way to group all 1's together with 0 or 1 swaps.\n        Thus, the minimum number of swaps required is 2.\n        Example 3:\n        Input: nums = [1,1,0,0,1]\n        Output: 0\n        Explanation: All the 1's are already grouped together due to the circular property of the array.\n        Thus, the minimum number of swaps required is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1667,"row":{"number":2135,"difficulty":1,"question":"class Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\n        \"\"\"\n        You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.\n        For each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.\n        The conversion operation is described in the following two steps:\n            Append any lowercase letter that is not present in the string to its end.\n                For example, if the string is \"abc\", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be \"abcd\".\n            Rearrange the letters of the new string in any arbitrary order.\n                For example, \"abcd\" can be rearranged to \"acbd\", \"bacd\", \"cbda\", and so on. Note that it can also be rearranged to \"abcd\" itself.\n        Return the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.\n        Note that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.\n        Example 1:\n        Input: startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\n        Output: 2\n        Explanation:\n        - In order to form targetWords[0] = \"tack\", we use startWords[1] = \"act\", append 'k' to it, and rearrange \"actk\" to \"tack\".\n        - There is no string in startWords that can be used to obtain targetWords[1] = \"act\".\n          Note that \"act\" does exist in startWords, but we must append one letter to the string before rearranging it.\n        - In order to form targetWords[2] = \"acti\", we use startWords[1] = \"act\", append 'i' to it, and rearrange \"acti\" to \"acti\" itself.\n        Example 2:\n        Input: startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]\n        Output: 1\n        Explanation:\n        - In order to form targetWords[0] = \"abc\", we use startWords[0] = \"ab\", add 'c' to it, and rearrange it to \"abc\".\n        - There is no string in startWords that can be used to obtain targetWords[1] = \"abcd\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1668,"row":{"number":2136,"difficulty":2,"question":"class Solution:\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\n        \"\"\"\n        You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:\n            plantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total.\n            growTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.\n        From the beginning of day 0, you can plant the seeds in any order.\n        Return the earliest possible day where all seeds are blooming.\n        Example 1:\n        Input: plantTime = [1,4,3], growTime = [2,3,1]\n        Output: 9\n        Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\n        One optimal way is:\n        On day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\n        On days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\n        On days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\n        Thus, on day 9, all the seeds are blooming.\n        Example 2:\n        Input: plantTime = [1,2,3,2], growTime = [2,1,2,1]\n        Output: 9\n        Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\n        One optimal way is:\n        On day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\n        On days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\n        On days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\n        On days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\n        Thus, on day 9, all the seeds are blooming.\n        Example 3:\n        Input: plantTime = [1], growTime = [1]\n        Output: 2\n        Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\n        Thus, on day 2, all the seeds are blooming.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1669,"row":{"number":2138,"difficulty":0,"question":"class Solution:\n    def divideString(self, s: str, k: int, fill: str) -> List[str]:\n        \"\"\"\n        A string s can be partitioned into groups of size k using the following procedure:\n            The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group.\n            For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.\n        Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.\n        Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.\n        Example 1:\n        Input: s = \"abcdefghi\", k = 3, fill = \"x\"\n        Output: [\"abc\",\"def\",\"ghi\"]\n        Explanation:\n        The first 3 characters \"abc\" form the first group.\n        The next 3 characters \"def\" form the second group.\n        The last 3 characters \"ghi\" form the third group.\n        Since all groups can be completely filled by characters from the string, we do not need to use fill.\n        Thus, the groups formed are \"abc\", \"def\", and \"ghi\".\n        Example 2:\n        Input: s = \"abcdefghij\", k = 3, fill = \"x\"\n        Output: [\"abc\",\"def\",\"ghi\",\"jxx\"]\n        Explanation:\n        Similar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\".\n        For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.\n        Thus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1670,"row":{"number":2155,"difficulty":1,"question":"class Solution:\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed binary array nums of length n. nums can be divided at index i (where 0 <= i <= n) into two arrays (possibly empty) numsleft and numsright:\n            numsleft has all the elements of nums between index 0 and i - 1 (inclusive), while numsright has all the elements of nums between index i and n - 1 (inclusive).\n            If i == 0, numsleft is empty, while numsright has all the elements of nums.\n            If i == n, numsleft has all the elements of nums, while numsright is empty.\n        The division score of an index i is the sum of the number of 0's in numsleft and the number of 1's in numsright.\n        Return all distinct indices that have the highest possible division score. You may return the answer in any order.\n        Example 1:\n        Input: nums = [0,0,1,0]\n        Output: [2,4]\n        Explanation: Division at index\n        - 0: numsleft is []. numsright is [0,0,1,0]. The score is 0 + 1 = 1.\n        - 1: numsleft is [0]. numsright is [0,1,0]. The score is 1 + 1 = 2.\n        - 2: numsleft is [0,0]. numsright is [1,0]. The score is 2 + 1 = 3.\n        - 3: numsleft is [0,0,1]. numsright is [0]. The score is 2 + 0 = 2.\n        - 4: numsleft is [0,0,1,0]. numsright is []. The score is 3 + 0 = 3.\n        Indices 2 and 4 both have the highest possible division score 3.\n        Note the answer [4,2] would also be accepted.\n        Example 2:\n        Input: nums = [0,0,0]\n        Output: [3]\n        Explanation: Division at index\n        - 0: numsleft is []. numsright is [0,0,0]. The score is 0 + 0 = 0.\n        - 1: numsleft is [0]. numsright is [0,0]. The score is 1 + 0 = 1.\n        - 2: numsleft is [0,0]. numsright is [0]. The score is 2 + 0 = 2.\n        - 3: numsleft is [0,0,0]. numsright is []. The score is 3 + 0 = 3.\n        Only index 3 has the highest possible division score 3.\n        Example 3:\n        Input: nums = [1,1]\n        Output: [0]\n        Explanation: Division at index\n        - 0: numsleft is []. numsright is [1,1]. The score is 0 + 2 = 2.\n        - 1: numsleft is [1]. numsright is [1]. The score is 0 + 1 = 1.\n        - 2: numsleft is [1,1]. numsright is []. The score is 0 + 0 = 0.\n        Only index 0 has the highest possible division score 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1671,"row":{"number":2140,"difficulty":1,"question":"class Solution:\n    def mostPoints(self, questions: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].\n        The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.\n            For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:\n                If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.\n                If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.\n        Return the maximum points you can earn for the exam.\n        Example 1:\n        Input: questions = [[3,2],[4,3],[4,4],[2,5]]\n        Output: 5\n        Explanation: The maximum points can be earned by solving questions 0 and 3.\n        - Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n        - Unable to solve questions 1 and 2\n        - Solve question 3: Earn 2 points\n        Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n        Example 2:\n        Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n        Output: 7\n        Explanation: The maximum points can be earned by solving questions 1 and 4.\n        - Skip question 0\n        - Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\n        - Unable to solve questions 2 and 3\n        - Solve question 4: Earn 5 points\n        Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1672,"row":{"number":2141,"difficulty":2,"question":"class Solution:\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\n        \"\"\"\n        You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.\n        Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n        Note that the batteries cannot be recharged.\n        Return the maximum number of minutes you can run all the n computers simultaneously.\n        Example 1:\n        Input: n = 2, batteries = [3,3,3]\n        Output: 4\n        Explanation: \n        Initially, insert battery 0 into the first computer and battery 1 into the second computer.\n        After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\n        At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\n        By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\n        We can run the two computers simultaneously for at most 4 minutes, so we return 4.\n        Example 2:\n        Input: n = 2, batteries = [1,1,1,1]\n        Output: 2\n        Explanation: \n        Initially, insert battery 0 into the first computer and battery 2 into the second computer. \n        After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \n        After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\n        We can run the two computers simultaneously for at most 2 minutes, so we return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1673,"row":{"number":2160,"difficulty":0,"question":"class Solution:\n    def minimumSum(self, num: int) -> int:\n        \"\"\"\n        You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used.\n            For example, given num = 2932, you have the following digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329].\n        Return the minimum possible sum of new1 and new2.\n        Example 1:\n        Input: num = 2932\n        Output: 52\n        Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.\n        The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52.\n        Example 2:\n        Input: num = 4009\n        Output: 13\n        Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. \n        The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1674,"row":{"number":2161,"difficulty":1,"question":"class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n            Every element less than pivot appears before every element greater than pivot.\n            Every element equal to pivot appears in between the elements less than and greater than pivot.\n            The relative order of the elements less than pivot and the elements greater than pivot is maintained.\n                More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n        Return nums after the rearrangement.\n        Example 1:\n        Input: nums = [9,12,5,10,14,3,10], pivot = 10\n        Output: [9,5,3,10,10,12,14]\n        Explanation: \n        The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\n        The elements 12 and 14 are greater than the pivot so they are on the right side of the array.\n        The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.\n        Example 2:\n        Input: nums = [-3,4,3,2], pivot = 2\n        Output: [-3,2,4,3]\n        Explanation: \n        The element -3 is less than the pivot so it is on the left side of the array.\n        The elements 4 and 3 are greater than the pivot so they are on the right side of the array.\n        The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1675,"row":{"number":2162,"difficulty":1,"question":"class Solution:\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\n        \"\"\"\n        A generic microwave supports cooking times for:\n            at least 1 second.\n            at most 99 minutes and 99 seconds.\n        To set the cooking time, you push at most four digits. The microwave normalizes what you push as four digits by prepending zeroes. It interprets the first two digits as the minutes and the last two digits as the seconds. It then adds them up as the cooking time. For example,\n            You push 9 5 4 (three digits). It is normalized as 0954 and interpreted as 9 minutes and 54 seconds.\n            You push 0 0 0 8 (four digits). It is interpreted as 0 minutes and 8 seconds.\n            You push 8 0 9 0. It is interpreted as 80 minutes and 90 seconds.\n            You push 8 1 3 0. It is interpreted as 81 minutes and 30 seconds.\n        You are given integers startAt, moveCost, pushCost, and targetSeconds. Initially, your finger is on the digit startAt. Moving the finger above any specific digit costs moveCost units of fatigue. Pushing the digit below the finger once costs pushCost units of fatigue.\n        There can be multiple ways to set the microwave to cook for targetSeconds seconds but you are interested in the way with the minimum cost.\n        Return the minimum cost to set targetSeconds seconds of cooking time.\n        Remember that one minute consists of 60 seconds.\n        Example 1:\n        Input: startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600\n        Output: 6\n        Explanation: The following are the possible ways to set the cooking time.\n        - 1 0 0 0, interpreted as 10 minutes and 0 seconds.\n          The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).\n          The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.\n        - 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.\n          The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n          The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.\n        - 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.\n          The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n          The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.\n        Example 2:\n        Input: startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76\n        Output: 6\n        Explanation: The optimal way is to push two digits: 7 6, interpreted as 76 seconds.\n        The finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6\n        Note other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1676,"row":{"number":2163,"difficulty":2,"question":"class Solution:\n    def minimumDifference(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums consisting of 3 * n elements.\n        You are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts:\n            The first n elements belonging to the first part and their sum is sumfirst.\n            The next n elements belonging to the second part and their sum is sumsecond.\n        The difference in sums of the two parts is denoted as sumfirst - sumsecond.\n            For example, if sumfirst = 3 and sumsecond = 2, their difference is 1.\n            Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.\n        Return the minimum difference possible between the sums of the two parts after the removal of n elements.\n        Example 1:\n        Input: nums = [3,1,2]\n        Output: -1\n        Explanation: Here, nums has 3 elements, so n = 1. \n        Thus we have to remove 1 element from nums and divide the array into two equal parts.\n        - If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1.\n        - If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1.\n        - If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2.\n        The minimum difference between sums of the two parts is min(-1,1,2) = -1. \n        Example 2:\n        Input: nums = [7,9,5,8,1,3]\n        Output: 1\n        Explanation: Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\n        If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12.\n        To obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\n        It can be shown that it is not possible to obtain a difference smaller than 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1677,"row":{"number":2148,"difficulty":0,"question":"class Solution:\n    def countElements(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.\n        Example 1:\n        Input: nums = [11,7,2,15]\n        Output: 2\n        Explanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\n        Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\n        In total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.\n        Example 2:\n        Input: nums = [-3,3,3,90]\n        Output: 2\n        Explanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.\n        Since there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1678,"row":{"number":2150,"difficulty":1,"question":"class Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\n        Return all lonely numbers in nums. You may return the answer in any order.\n        Example 1:\n        Input: nums = [10,6,5,8]\n        Output: [10,8]\n        Explanation: \n        - 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.\n        - 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.\n        - 5 is not a lonely number since 6 appears in nums and vice versa.\n        Hence, the lonely numbers in nums are [10, 8].\n        Note that [8, 10] may also be returned.\n        Example 2:\n        Input: nums = [1,3,5,3]\n        Output: [1,5]\n        Explanation: \n        - 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.\n        - 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.\n        - 3 is not a lonely number since it appears twice.\n        Hence, the lonely numbers in nums are [1, 5].\n        Note that [5, 1] may also be returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1679,"row":{"number":2149,"difficulty":1,"question":"class Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\n        You should rearrange the elements of nums such that the modified array follows the given conditions:\n            Every consecutive pair of integers have opposite signs.\n            For all integers with the same sign, the order in which they were present in nums is preserved.\n            The rearranged array begins with a positive integer.\n        Return the modified array after rearranging the elements to satisfy the aforementioned conditions.\n        Example 1:\n        Input: nums = [3,1,-2,-5,2,-4]\n        Output: [3,-2,1,-5,2,-4]\n        Explanation:\n        The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\n        The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\n        Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  \n        Example 2:\n        Input: nums = [-1,1]\n        Output: [1,-1]\n        Explanation:\n        1 is the only positive integer and -1 the only negative integer in nums.\n        So nums is rearranged to [1,-1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1680,"row":{"number":2151,"difficulty":2,"question":"class Solution:\n    def maximumGood(self, statements: List[List[int]]) -> int:\n        \"\"\"\n        There are two types of persons:\n            The good person: The person who always tells the truth.\n            The bad person: The person who might tell the truth and might lie.\n        You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following:\n            0 which represents a statement made by person i that person j is a bad person.\n            1 which represents a statement made by person i that person j is a good person.\n            2 represents that no statement is made by person i about person j.\n        Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n.\n        Return the maximum number of people who can be good based on the statements made by the n people.\n        Example 1:\n        Input: statements = [[2,1,2],[1,2,2],[2,0,2]]\n        Output: 2\n        Explanation: Each person makes a single statement.\n        - Person 0 states that person 1 is good.\n        - Person 1 states that person 0 is good.\n        - Person 2 states that person 1 is bad.\n        Let's take person 2 as the key.\n        - Assuming that person 2 is a good person:\n            - Based on the statement made by person 2, person 1 is a bad person.\n            - Now we know for sure that person 1 is bad and person 2 is good.\n            - Based on the statement made by person 1, and since person 1 is bad, they could be:\n                - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n                - lying. In this case, person 0 is also a bad person and lied in their statement.\n            - Following that person 2 is a good person, there will be only one good person in the group.\n        - Assuming that person 2 is a bad person:\n            - Based on the statement made by person 2, and since person 2 is bad, they could be:\n                - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.\n                    - Following that person 2 is bad but told the truth, there will be no good persons in the group.\n                - lying. In this case person 1 is a good person.\n                    - Since person 1 is a good person, person 0 is also a good person.\n                    - Following that person 2 is bad and lied, there will be two good persons in the group.\n        We can see that at most 2 persons are good in the best case, so we return 2.\n        Note that there is more than one way to arrive at this conclusion.\n        Example 2:\n        Input: statements = [[2,0],[0,2]]\n        Output: 1\n        Explanation: Each person makes a single statement.\n        - Person 0 states that person 1 is bad.\n        - Person 1 states that person 0 is bad.\n        Let's take person 0 as the key.\n        - Assuming that person 0 is a good person:\n            - Based on the statement made by person 0, person 1 is a bad person and was lying.\n            - Following that person 0 is a good person, there will be only one good person in the group.\n        - Assuming that person 0 is a bad person:\n            - Based on the statement made by person 0, and since person 0 is bad, they could be:\n                - telling the truth. Following this scenario, person 0 and 1 are both bad.\n                    - Following that person 0 is bad but told the truth, there will be no good persons in the group.\n                - lying. In this case person 1 is a good person.\n                    - Following that person 0 is bad and lied, there will be only one good person in the group.\n        We can see that at most, one person is good in the best case, so we return 1.\n        Note that there is more than one way to arrive at this conclusion.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1681,"row":{"number":2154,"difficulty":0,"question":"class Solution:\n    def findFinalValue(self, nums: List[int], original: int) -> int:\n        \"\"\"\n        You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.\n        You then do the following steps:\n            If original is found in nums, multiply it by two (i.e., set original = 2 * original).\n            Otherwise, stop the process.\n            Repeat this process with the new number as long as you keep finding the number.\n        Return the final value of original.\n        Example 1:\n        Input: nums = [5,3,6,1,12], original = 3\n        Output: 24\n        Explanation: \n        - 3 is found in nums. 3 is multiplied by 2 to obtain 6.\n        - 6 is found in nums. 6 is multiplied by 2 to obtain 12.\n        - 12 is found in nums. 12 is multiplied by 2 to obtain 24.\n        - 24 is not found in nums. Thus, 24 is returned.\n        Example 2:\n        Input: nums = [2,7,9], original = 4\n        Output: 4\n        Explanation:\n        - 4 is not found in nums. Thus, 4 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1682,"row":{"number":2156,"difficulty":2,"question":"class Solution:\n    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\n        \"\"\"\n        The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function:\n            hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\n        Where val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26.\n        You are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue.\n        The test cases will be generated such that an answer always exists.\n        A substring is a contiguous non-empty sequence of characters within a string.\n        Example 1:\n        Input: s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0\n        Output: \"ee\"\n        Explanation: The hash of \"ee\" can be computed to be hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. \n        \"ee\" is the first substring of length 2 with hashValue 0. Hence, we return \"ee\".\n        Example 2:\n        Input: s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32\n        Output: \"fbx\"\n        Explanation: The hash of \"fbx\" can be computed to be hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. \n        The hash of \"bxz\" can be computed to be hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. \n        \"fbx\" is the first substring of length 3 with hashValue 32. Hence, we return \"fbx\".\n        Note that \"bxz\" also has a hash of 32 but it appears later than \"fbx\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1683,"row":{"number":2157,"difficulty":2,"question":"class Solution:\n    def groupStrings(self, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words.\n        Two strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations:\n            Adding exactly one letter to the set of the letters of s1.\n            Deleting exactly one letter from the set of the letters of s1.\n            Replacing exactly one letter from the set of the letters of s1 with any letter, including itself.\n        The array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true:\n            It is connected to at least one other string of the group.\n            It is the only string present in the group.\n        Note that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.\n        Return an array ans of size 2 where:\n            ans[0] is the maximum number of groups words can be divided into, and\n            ans[1] is the size of the largest group.\n        Example 1:\n        Input: words = [\"a\",\"b\",\"ab\",\"cde\"]\n        Output: [2,3]\n        Explanation:\n        - words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2].\n        - words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2].\n        - words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1].\n        - words[3] is not connected to any string in words.\n        Thus, words can be divided into 2 groups [\"a\",\"b\",\"ab\"] and [\"cde\"]. The size of the largest group is 3.  \n        Example 2:\n        Input: words = [\"a\",\"ab\",\"abc\"]\n        Output: [1,3]\n        Explanation:\n        - words[0] is connected to words[1].\n        - words[1] is connected to words[0] and words[2].\n        - words[2] is connected to words[1].\n        Since all strings are connected to each other, they should be grouped together.\n        Thus, the size of the largest group is 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1684,"row":{"number":2176,"difficulty":0,"question":"class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.\n        Example 1:\n        Input: nums = [3,1,2,2,2,1,3], k = 2\n        Output: 4\n        Explanation:\n        There are 4 pairs that meet all the requirements:\n        - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.\n        - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.\n        - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.\n        - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.\n        Example 2:\n        Input: nums = [1,2,3,4], k = 1\n        Output: 0\n        Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1685,"row":{"number":2177,"difficulty":1,"question":"class Solution:\n    def sumOfThree(self, num: int) -> List[int]:\n        \"\"\"\n        Given an integer num, return three consecutive integers (as a sorted array) that sum to num. If num cannot be expressed as the sum of three consecutive integers, return an empty array.\n        Example 1:\n        Input: num = 33\n        Output: [10,11,12]\n        Explanation: 33 can be expressed as 10 + 11 + 12 = 33.\n        10, 11, 12 are 3 consecutive integers, so we return [10, 11, 12].\n        Example 2:\n        Input: num = 4\n        Output: []\n        Explanation: There is no way to express 4 as the sum of 3 consecutive integers.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1686,"row":{"number":2178,"difficulty":1,"question":"class Solution:\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\n        \"\"\"\n        You are given an integer finalSum. Split it into a sum of a maximum number of unique positive even integers.\n            For example, given finalSum = 12, the following splits are valid (unique positive even integers summing up to finalSum): (12), (2 + 10), (2 + 4 + 6), and (4 + 8). Among them, (2 + 4 + 6) contains the maximum number of integers. Note that finalSum cannot be split into (2 + 2 + 4 + 4) as all the numbers should be unique.\n        Return a list of integers that represent a valid split containing a maximum number of integers. If no valid split exists for finalSum, return an empty list. You may return the integers in any order.\n        Example 1:\n        Input: finalSum = 12\n        Output: [2,4,6]\n        Explanation: The following are valid splits: (12), (2 + 10), (2 + 4 + 6), and (4 + 8).\n        (2 + 4 + 6) has the maximum number of integers, which is 3. Thus, we return [2,4,6].\n        Note that [2,6,4], [6,2,4], etc. are also accepted.\n        Example 2:\n        Input: finalSum = 7\n        Output: []\n        Explanation: There are no valid splits for the given finalSum.\n        Thus, we return an empty array.\n        Example 3:\n        Input: finalSum = 28\n        Output: [6,8,2,12]\n        Explanation: The following are valid splits: (2 + 26), (6 + 8 + 2 + 12), and (4 + 24). \n        (6 + 8 + 2 + 12) has the maximum number of integers, which is 4. Thus, we return [6,8,2,12].\n        Note that [10,2,4,12], [6,2,4,16], etc. are also accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1687,"row":{"number":2179,"difficulty":2,"question":"class Solution:\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1].\n        A good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z.\n        Return the total number of good triplets.\n        Example 1:\n        Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3]\n        Output: 1\n        Explanation: \n        There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). \n        Out of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.\n        Example 2:\n        Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\n        Output: 4\n        Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1688,"row":{"number":2164,"difficulty":0,"question":"class Solution:\n    def sortEvenOdd(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\n            Sort the values at odd indices of nums in non-increasing order.\n                For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\n            Sort the values at even indices of nums in non-decreasing order.\n                For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\n        Return the array formed after rearranging the values of nums.\n        Example 1:\n        Input: nums = [4,1,2,3]\n        Output: [2,3,4,1]\n        Explanation: \n        First, we sort the values present at odd indices (1 and 3) in non-increasing order.\n        So, nums changes from [4,1,2,3] to [4,3,2,1].\n        Next, we sort the values present at even indices (0 and 2) in non-decreasing order.\n        So, nums changes from [4,1,2,3] to [2,3,4,1].\n        Thus, the array formed after rearranging the values is [2,3,4,1].\n        Example 2:\n        Input: nums = [2,1]\n        Output: [2,1]\n        Explanation: \n        Since there is exactly one odd index and one even index, no rearrangement of values takes place.\n        The resultant array formed is [2,1], which is the same as the initial array. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1689,"row":{"number":2165,"difficulty":1,"question":"class Solution:\n    def smallestNumber(self, num: int) -> int:\n        \"\"\"\n        You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.\n        Return the rearranged number with minimal value.\n        Note that the sign of the number does not change after rearranging the digits.\n        Example 1:\n        Input: num = 310\n        Output: 103\n        Explanation: The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310. \n        The arrangement with the smallest value that does not contain any leading zeros is 103.\n        Example 2:\n        Input: num = -7605\n        Output: -7650\n        Explanation: Some possible arrangements for the digits of -7605 are -7650, -6705, -5076, -0567.\n        The arrangement with the smallest value that does not contain any leading zeros is -7650.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1690,"row":{"number":2166,"difficulty":1,"question":"class Bitset:\n    def __init__(self, size: int):\n    def fix(self, idx: int) -> None:\n    def unfix(self, idx: int) -> None:\n    def flip(self) -> None:\n    def all(self) -> bool:\n    def one(self) -> bool:\n    def count(self) -> int:\n    def toString(self) -> str:\n        \"\"\"\n        A Bitset is a data structure that compactly stores bits.\n        Implement the Bitset class:\n            Bitset(int size) Initializes the Bitset with size bits, all of which are 0.\n            void fix(int idx) Updates the value of the bit at the index idx to 1. If the value was already 1, no change occurs.\n            void unfix(int idx) Updates the value of the bit at the index idx to 0. If the value was already 0, no change occurs.\n            void flip() Flips the values of each bit in the Bitset. In other words, all bits with value 0 will now have value 1 and vice versa.\n            boolean all() Checks if the value of each bit in the Bitset is 1. Returns true if it satisfies the condition, false otherwise.\n            boolean one() Checks if there is at least one bit in the Bitset with value 1. Returns true if it satisfies the condition, false otherwise.\n            int count() Returns the total number of bits in the Bitset which have value 1.\n            String toString() Returns the current composition of the Bitset. Note that in the resultant string, the character at the ith index should coincide with the value at the ith bit of the Bitset.\n        Example 1:\n        Input\n        [\"Bitset\", \"fix\", \"fix\", \"flip\", \"all\", \"unfix\", \"flip\", \"one\", \"unfix\", \"count\", \"toString\"]\n        [[5], [3], [1], [], [], [0], [], [], [0], [], []]\n        Output\n        [null, null, null, null, false, null, null, true, null, 2, \"01010\"]\n        Explanation\n        Bitset bs = new Bitset(5); // bitset = \"00000\".\n        bs.fix(3);     // the value at idx = 3 is updated to 1, so bitset = \"00010\".\n        bs.fix(1);     // the value at idx = 1 is updated to 1, so bitset = \"01010\". \n        bs.flip();     // the value of each bit is flipped, so bitset = \"10101\". \n        bs.all();      // return False, as not all values of the bitset are 1.\n        bs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = \"00101\".\n        bs.flip();     // the value of each bit is flipped, so bitset = \"11010\". \n        bs.one();      // return True, as there is at least 1 index with value 1.\n        bs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = \"01010\".\n        bs.count();    // return 2, as there are 2 bits with value 1.\n        bs.toString(); // return \"01010\", which is the composition of bitset.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1691,"row":{"number":2167,"difficulty":2,"question":"class Solution:\n    def minimumTime(self, s: str) -> int:\n        \"\"\"\n        You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods.\n        As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times:\n            Remove a train car from the left end (i.e., remove s[0]) which takes 1 unit of time.\n            Remove a train car from the right end (i.e., remove s[s.length - 1]) which takes 1 unit of time.\n            Remove a train car from anywhere in the sequence which takes 2 units of time.\n        Return the minimum time to remove all the cars containing illegal goods.\n        Note that an empty sequence of cars is considered to have no cars containing illegal goods.\n        Example 1:\n        Input: s = \"1100101\"\n        Output: 5\n        Explanation: \n        One way to remove all the cars containing illegal goods from the sequence is to\n        - remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n        - remove a car from the right end. Time taken is 1.\n        - remove the car containing illegal goods found in the middle. Time taken is 2.\n        This obtains a total time of 2 + 1 + 2 = 5. \n        An alternative way is to\n        - remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n        - remove a car from the right end 3 times. Time taken is 3 * 1 = 3.\n        This also obtains a total time of 2 + 3 = 5.\n        5 is the minimum time taken to remove all the cars containing illegal goods. \n        There are no other ways to remove them with less time.\n        Example 2:\n        Input: s = \"0010\"\n        Output: 2\n        Explanation:\n        One way to remove all the cars containing illegal goods from the sequence is to\n        - remove a car from the left end 3 times. Time taken is 3 * 1 = 3.\n        This obtains a total time of 3.\n        Another way to remove all the cars containing illegal goods from the sequence is to\n        - remove the car containing illegal goods found in the middle. Time taken is 2.\n        This obtains a total time of 2.\n        Another way to remove all the cars containing illegal goods from the sequence is to \n        - remove a car from the right end 2 times. Time taken is 2 * 1 = 2. \n        This obtains a total time of 2.\n        2 is the minimum time taken to remove all the cars containing illegal goods. \n        There are no other ways to remove them with less time.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1692,"row":{"number":2169,"difficulty":0,"question":"class Solution:\n    def countOperations(self, num1: int, num2: int) -> int:\n        \"\"\"\n        You are given two non-negative integers num1 and num2.\n        In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.\n            For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.\n        Return the number of operations required to make either num1 = 0 or num2 = 0.\n        Example 1:\n        Input: num1 = 2, num2 = 3\n        Output: 3\n        Explanation: \n        - Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.\n        - Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1.\n        - Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1.\n        Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations.\n        So the total number of operations required is 3.\n        Example 2:\n        Input: num1 = 10, num2 = 10\n        Output: 1\n        Explanation: \n        - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0.\n        Now num1 = 0 and num2 = 10. Since num1 == 0, we are done.\n        So the total number of operations required is 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1693,"row":{"number":2170,"difficulty":1,"question":"class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array nums consisting of n positive integers.\n        The array nums is called alternating if:\n            nums[i - 2] == nums[i], where 2 <= i <= n - 1.\n            nums[i - 1] != nums[i], where 1 <= i <= n - 1.\n        In one operation, you can choose an index i and change nums[i] into any positive integer.\n        Return the minimum number of operations required to make the array alternating.\n        Example 1:\n        Input: nums = [3,1,3,2,4,3]\n        Output: 3\n        Explanation:\n        One way to make the array alternating is by converting it to [3,1,3,1,3,1].\n        The number of operations required in this case is 3.\n        It can be proven that it is not possible to make the array alternating in less than 3 operations. \n        Example 2:\n        Input: nums = [1,2,2,2,2]\n        Output: 2\n        Explanation:\n        One way to make the array alternating is by converting it to [1,2,1,2,1].\n        The number of operations required in this case is 2.\n        Note that the array cannot be converted to [2,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1694,"row":{"number":2171,"difficulty":1,"question":"class Solution:\n    def minimumRemoval(self, beans: List[int]) -> int:\n        \"\"\"\n        You are given an array of positive integers beans, where each integer represents the number of magic beans found in a particular magic bag.\n        Remove any number of beans (possibly none) from each bag such that the number of beans in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it to any of the bags.\n        Return the minimum number of magic beans that you have to remove.\n        Example 1:\n        Input: beans = [4,1,6,5]\n        Output: 4\n        Explanation: \n        - We remove 1 bean from the bag with only 1 bean.\n          This results in the remaining bags: [4,0,6,5]\n        - Then we remove 2 beans from the bag with 6 beans.\n          This results in the remaining bags: [4,0,4,5]\n        - Then we remove 1 bean from the bag with 5 beans.\n          This results in the remaining bags: [4,0,4,4]\n        We removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.\n        There are no other solutions that remove 4 beans or fewer.\n        Example 2:\n        Input: beans = [2,10,3,2]\n        Output: 7\n        Explanation:\n        - We remove 2 beans from one of the bags with 2 beans.\n          This results in the remaining bags: [0,10,3,2]\n        - Then we remove 2 beans from the other bag with 2 beans.\n          This results in the remaining bags: [0,10,3,0]\n        - Then we remove 3 beans from the bag with 3 beans. \n          This results in the remaining bags: [0,10,0,0]\n        We removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.\n        There are no other solutions that removes 7 beans or fewer.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1695,"row":{"number":2172,"difficulty":2,"question":"class Solution:\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\n        \"\"\"\n        You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots.\n        You have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number.\n            For example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.\n        Return the maximum possible AND sum of nums given numSlots slots.\n        Example 1:\n        Input: nums = [1,2,3,4,5,6], numSlots = 3\n        Output: 9\n        Explanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. \n        This gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.\n        Example 2:\n        Input: nums = [1,3,10,4,7,1], numSlots = 9\n        Output: 24\n        Explanation: One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9.\n        This gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.\n        Note that slots 2, 5, 6, and 8 are empty which is permitted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1696,"row":{"number":2185,"difficulty":0,"question":"class Solution:\n    def prefixCount(self, words: List[str], pref: str) -> int:\n        \"\"\"\n        You are given an array of strings words and a string pref.\n        Return the number of strings in words that contain pref as a prefix.\n        A prefix of a string s is any leading contiguous substring of s.\n        Example 1:\n        Input: words = [\"pay\",\"attention\",\"practice\",\"attend\"], pref = \"at\"\n        Output: 2\n        Explanation: The 2 strings that contain \"at\" as a prefix are: \"attention\" and \"attend\".\n        Example 2:\n        Input: words = [\"leetcode\",\"win\",\"loops\",\"success\"], pref = \"code\"\n        Output: 0\n        Explanation: There are no strings that contain \"code\" as a prefix.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1697,"row":{"number":2186,"difficulty":1,"question":"class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \"\"\"\n        You are given two strings s and t. In one step, you can append any character to either s or t.\n        Return the minimum number of steps to make s and t anagrams of each other.\n        An anagram of a string is a string that contains the same characters with a different (or the same) ordering.\n        Example 1:\n        Input: s = \"leetcode\", t = \"coats\"\n        Output: 7\n        Explanation: \n        - In 2 steps, we can append the letters in \"as\" onto s = \"leetcode\", forming s = \"leetcodeas\".\n        - In 5 steps, we can append the letters in \"leede\" onto t = \"coats\", forming t = \"coatsleede\".\n        \"leetcodeas\" and \"coatsleede\" are now anagrams of each other.\n        We used a total of 2 + 5 = 7 steps.\n        It can be shown that there is no way to make them anagrams of each other with less than 7 steps.\n        Example 2:\n        Input: s = \"night\", t = \"thing\"\n        Output: 0\n        Explanation: The given strings are already anagrams of each other. Thus, we do not need any further steps.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1698,"row":{"number":2187,"difficulty":1,"question":"class Solution:\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        \"\"\"\n        You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\n        Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\n        You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.\n        Example 1:\n        Input: time = [1,2,3], totalTrips = 5\n        Output: 3\n        Explanation:\n        - At time t = 1, the number of trips completed by each bus are [1,0,0]. \n          The total number of trips completed is 1 + 0 + 0 = 1.\n        - At time t = 2, the number of trips completed by each bus are [2,1,0]. \n          The total number of trips completed is 2 + 1 + 0 = 3.\n        - At time t = 3, the number of trips completed by each bus are [3,1,1]. \n          The total number of trips completed is 3 + 1 + 1 = 5.\n        So the minimum time needed for all buses to complete at least 5 trips is 3.\n        Example 2:\n        Input: time = [2], totalTrips = 1\n        Output: 2\n        Explanation:\n        There is only one bus, and it will complete its first trip at t = 2.\n        So the minimum time needed to complete 1 trip is 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1699,"row":{"number":2188,"difficulty":2,"question":"class Solution:\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\n        \"\"\"\n        You are given a 0-indexed 2D integer array tires where tires[i] = [fi, ri] indicates that the ith tire can finish its xth successive lap in fi * ri(x-1) seconds.\n            For example, if fi = 3 and ri = 2, then the tire would finish its 1st lap in 3 seconds, its 2nd lap in 3 * 2 = 6 seconds, its 3rd lap in 3 * 22 = 12 seconds, etc.\n        You are also given an integer changeTime and an integer numLaps.\n        The race consists of numLaps laps and you may start the race with any tire. You have an unlimited supply of each tire and after every lap, you may change to any given tire (including the current tire type) if you wait changeTime seconds.\n        Return the minimum time to finish the race.\n        Example 1:\n        Input: tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4\n        Output: 21\n        Explanation: \n        Lap 1: Start with tire 0 and finish the lap in 2 seconds.\n        Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.\n        Lap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds.\n        Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.\n        Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds.\n        The minimum time to complete the race is 21 seconds.\n        Example 2:\n        Input: tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5\n        Output: 25\n        Explanation: \n        Lap 1: Start with tire 1 and finish the lap in 2 seconds.\n        Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\n        Lap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds.\n        Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\n        Lap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second.\n        Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds.\n        The minimum time to complete the race is 25 seconds. \n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}