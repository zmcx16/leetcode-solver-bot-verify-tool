{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":500,"row":{"number":684,"difficulty":1,"question":"class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        In this problem, a tree is an undirected graph that is connected and has no cycles.\n        You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\n        Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\n        Example 1:\n        Input: edges = [[1,2],[1,3],[2,3]]\n        Output: [2,3]\n        Example 2:\n        Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\n        Output: [1,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":501,"row":{"number":685,"difficulty":2,"question":"class Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n        The given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed.\n        The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [ui, vi] that represents a directed edge connecting nodes ui and vi, where ui is a parent of child vi.\n        Return an edge that can be removed so that the resulting graph is a rooted tree of n nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.\n        Example 1:\n        Input: edges = [[1,2],[1,3],[2,3]]\n        Output: [2,3]\n        Example 2:\n        Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n        Output: [4,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":502,"row":{"number":686,"difficulty":1,"question":"class Solution:\n    def repeatedStringMatch(self, a: str, b: str) -> int:\n        \"\"\"\n        Given two strings a and b, return the minimum number of times you should repeat string a so that string b is a substring of it. If it is impossible for b​​​​​​ to be a substring of a after repeating it, return -1.\n        Notice: string \"abc\" repeated 0 times is \"\", repeated 1 time is \"abc\" and repeated 2 times is \"abcabc\".\n        Example 1:\n        Input: a = \"abcd\", b = \"cdabcdab\"\n        Output: 3\n        Explanation: We return 3 because by repeating a three times \"abcdabcdabcd\", b is a substring of it.\n        Example 2:\n        Input: a = \"a\", b = \"aa\"\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":503,"row":{"number":687,"difficulty":1,"question":"class Solution:\n    def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root.\n        The length of the path between two nodes is represented by the number of edges between them.\n        Example 1:\n        Input: root = [5,4,5,1,1,null,5]\n        Output: 2\n        Explanation: The shown image shows that the longest path of the same value (i.e. 5).\n        Example 2:\n        Input: root = [1,4,5,4,4,null,5]\n        Output: 2\n        Explanation: The shown image shows that the longest path of the same value (i.e. 4).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":504,"row":{"number":688,"difficulty":1,"question":"class Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        \"\"\"\n        On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).\n        A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n        Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n        The knight continues moving until it has made exactly k moves or has moved off the chessboard.\n        Return the probability that the knight remains on the board after it has stopped moving.\n        Example 1:\n        Input: n = 3, k = 2, row = 0, column = 0\n        Output: 0.06250\n        Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\n        From each of those positions, there are also two moves that will keep the knight on the board.\n        The total probability the knight stays on the board is 0.0625.\n        Example 2:\n        Input: n = 1, k = 0, row = 0, column = 0\n        Output: 1.00000\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":505,"row":{"number":689,"difficulty":2,"question":"class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them.\n        Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.\n        Example 1:\n        Input: nums = [1,2,1,2,6,7,5,1], k = 2\n        Output: [0,3,5]\n        Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\n        We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\n        Example 2:\n        Input: nums = [1,2,1,2,1,2,1,2,1], k = 2\n        Output: [0,2,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":506,"row":{"number":690,"difficulty":1,"question":"\n        \"\"\"\nclass Employee:\n    def __init__(self, id: int, importance: int, subordinates: List[int]):\n        self.id = id\n        self.importance = importance\n        self.subordinates = subordinates\n        You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs.\n        You are given an array of employees employees where:\n            employees[i].id is the ID of the ith employee.\n            employees[i].importance is the importance value of the ith employee.\n            employees[i].subordinates is a list of the IDs of the direct subordinates of the ith employee.\n        Given an integer id that represents an employee's ID, return the total importance value of this employee and all their direct and indirect subordinates.\n        Example 1:\n        Input: employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1\n        Output: 11\n        Explanation: Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.\n        They both have an importance value of 3.\n        Thus, the total importance value of employee 1 is 5 + 3 + 3 = 11.\n        Example 2:\n        Input: employees = [[1,2,[5]],[5,-3,[]]], id = 5\n        Output: -3\n        Explanation: Employee 5 has an importance value of -3 and has no direct subordinates.\n        Thus, the total importance value of employee 5 is -3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":507,"row":{"number":691,"difficulty":2,"question":"class Solution:\n    def minStickers(self, stickers: List[str], target: str) -> int:\n        \"\"\"\n        We are given n different types of stickers. Each sticker has a lowercase English word on it.\n        You would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.\n        Return the minimum number of stickers that you need to spell out target. If the task is impossible, return -1.\n        Note: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words.\n        Example 1:\n        Input: stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\n        Output: 3\n        Explanation:\n        We can use 2 \"with\" stickers, and 1 \"example\" sticker.\n        After cutting and rearrange the letters of those stickers, we can form the target \"thehat\".\n        Also, this is the minimum number of stickers necessary to form the target string.\n        Example 2:\n        Input: stickers = [\"notice\",\"possible\"], target = \"basicbasic\"\n        Output: -1\n        Explanation:\n        We cannot form the target \"basicbasic\" from cutting letters from the given stickers.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":508,"row":{"number":692,"difficulty":1,"question":"class Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and an integer k, return the k most frequent strings.\n        Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.\n        Example 1:\n        Input: words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n        Output: [\"i\",\"love\"]\n        Explanation: \"i\" and \"love\" are the two most frequent words.\n        Note that \"i\" comes before \"love\" due to a lower alphabetical order.\n        Example 2:\n        Input: words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\n        Output: [\"the\",\"is\",\"sunny\",\"day\"]\n        Explanation: \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":509,"row":{"number":693,"difficulty":0,"question":"class Solution:\n    def hasAlternatingBits(self, n: int) -> bool:\n        \"\"\"\n        Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\n        Example 1:\n        Input: n = 5\n        Output: true\n        Explanation: The binary representation of 5 is: 101\n        Example 2:\n        Input: n = 7\n        Output: false\n        Explanation: The binary representation of 7 is: 111.\n        Example 3:\n        Input: n = 11\n        Output: false\n        Explanation: The binary representation of 11 is: 1011.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":510,"row":{"number":695,"difficulty":1,"question":"class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n        The area of an island is the number of cells with a value 1 in the island.\n        Return the maximum area of an island in grid. If there is no island, return 0.\n        Example 1:\n        Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n        Output: 6\n        Explanation: The answer is not 11, because the island must be connected 4-directionally.\n        Example 2:\n        Input: grid = [[0,0,0,0,0,0,0,0]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":511,"row":{"number":696,"difficulty":0,"question":"class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        \"\"\"\n        Given a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n        Substrings that occur multiple times are counted the number of times they occur.\n        Example 1:\n        Input: s = \"00110011\"\n        Output: 6\n        Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n        Notice that some of these substrings repeat and are counted the number of times they occur.\n        Also, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.\n        Example 2:\n        Input: s = \"10101\"\n        Output: 4\n        Explanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":512,"row":{"number":697,"difficulty":0,"question":"class Solution:\n    def findShortestSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\n        Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.\n        Example 1:\n        Input: nums = [1,2,2,3,1]\n        Output: 2\n        Explanation: \n        The input array has a degree of 2 because both elements 1 and 2 appear twice.\n        Of the subarrays that have the same degree:\n        [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\n        The shortest length is 2. So return 2.\n        Example 2:\n        Input: nums = [1,2,2,3,1,4,2]\n        Output: 6\n        Explanation: \n        The degree is 3 because the element 2 is repeated 3 times.\n        So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":513,"row":{"number":698,"difficulty":1,"question":"class Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        \"\"\"\n        Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.\n        Example 1:\n        Input: nums = [4,3,2,3,5,2,1], k = 4\n        Output: true\n        Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n        Example 2:\n        Input: nums = [1,2,3,4], k = 3\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":514,"row":{"number":699,"difficulty":2,"question":"class Solution:\n    def fallingSquares(self, positions: List[List[int]]) -> List[int]:\n        \"\"\"\n        There are several squares being dropped onto the X-axis of a 2D plane.\n        You are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.\n        Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n        After each square is dropped, you must record the height of the current tallest stack of squares.\n        Return an integer array ans where ans[i] represents the height described above after dropping the ith square.\n        Example 1:\n        Input: positions = [[1,2],[2,3],[6,1]]\n        Output: [2,5,5]\n        Explanation:\n        After the first drop, the tallest stack is square 1 with a height of 2.\n        After the second drop, the tallest stack is squares 1 and 2 with a height of 5.\n        After the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\n        Thus, we return an answer of [2, 5, 5].\n        Example 2:\n        Input: positions = [[100,100],[200,100]]\n        Output: [100,100]\n        Explanation:\n        After the first drop, the tallest stack is square 1 with a height of 100.\n        After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\n        Thus, we return an answer of [100, 100].\n        Note that square 2 only brushes the right side of square 1, which does not count as landing on it.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":515,"row":{"number":712,"difficulty":1,"question":"class Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        \"\"\"\n        Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.\n        Example 1:\n        Input: s1 = \"sea\", s2 = \"eat\"\n        Output: 231\n        Explanation: Deleting \"s\" from \"sea\" adds the ASCII value of \"s\" (115) to the sum.\n        Deleting \"t\" from \"eat\" adds 116 to the sum.\n        At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n        Example 2:\n        Input: s1 = \"delete\", s2 = \"leet\"\n        Output: 403\n        Explanation: Deleting \"dee\" from \"delete\" to turn the string into \"let\",\n        adds 100[d] + 101[e] + 101[e] to the sum.\n        Deleting \"e\" from \"leet\" adds 101[e] to the sum.\n        At the end, both strings are equal to \"let\", and the answer is 100+101+101+101 = 403.\n        If instead we turned both strings into \"lee\" or \"eet\", we would get answers of 433 or 417, which are higher.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":516,"row":{"number":713,"difficulty":1,"question":"class Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\n        Example 1:\n        Input: nums = [10,5,2,6], k = 100\n        Output: 8\n        Explanation: The 8 subarrays that have product less than 100 are:\n        [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\n        Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n        Example 2:\n        Input: nums = [1,2,3], k = 0\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":517,"row":{"number":714,"difficulty":1,"question":"class Solution:\n    def maxProfit(self, prices: List[int], fee: int) -> int:\n        \"\"\"\n        You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\n        Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n        Example 1:\n        Input: prices = [1,3,2,8,4,9], fee = 2\n        Output: 8\n        Explanation: The maximum profit can be achieved by:\n        - Buying at prices[0] = 1\n        - Selling at prices[3] = 8\n        - Buying at prices[4] = 4\n        - Selling at prices[5] = 9\n        The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n        Example 2:\n        Input: prices = [1,3,7,5,10,3], fee = 3\n        Output: 6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":518,"row":{"number":715,"difficulty":2,"question":"class RangeModule:\n    def __init__(self):\n    def addRange(self, left: int, right: int) -> None:\n    def queryRange(self, left: int, right: int) -> bool:\n    def removeRange(self, left: int, right: int) -> None:\n        \"\"\"\n        A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as half-open intervals and query about them.\n        A half-open interval [left, right) denotes all the real numbers x where left <= x < right.\n        Implement the RangeModule class:\n            RangeModule() Initializes the object of the data structure.\n            void addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.\n            boolean queryRange(int left, int right) Returns true if every real number in the interval [left, right) is currently being tracked, and false otherwise.\n            void removeRange(int left, int right) Stops tracking every real number currently being tracked in the half-open interval [left, right).\n        Example 1:\n        Input\n        [\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"]\n        [[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\n        Output\n        [null, null, null, true, false, true]\n        Explanation\n        RangeModule rangeModule = new RangeModule();\n        rangeModule.addRange(10, 20);\n        rangeModule.removeRange(14, 16);\n        rangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked)\n        rangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\n        rangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":519,"row":{"number":717,"difficulty":0,"question":"class Solution:\n    def isOneBitCharacter(self, bits: List[int]) -> bool:\n        \"\"\"\n        We have two special characters:\n            The first character can be represented by one bit 0.\n            The second character can be represented by two bits (10 or 11).\n        Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.\n        Example 1:\n        Input: bits = [1,0,0]\n        Output: true\n        Explanation: The only way to decode it is two-bit character and one-bit character.\n        So the last character is one-bit character.\n        Example 2:\n        Input: bits = [1,1,1,0]\n        Output: false\n        Explanation: The only way to decode it is two-bit character and two-bit character.\n        So the last character is not one-bit character.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":520,"row":{"number":718,"difficulty":1,"question":"class Solution:\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.\n        Example 1:\n        Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n        Output: 3\n        Explanation: The repeated subarray with maximum length is [3,2,1].\n        Example 2:\n        Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n        Output: 5\n        Explanation: The repeated subarray with maximum length is [0,0,0,0,0].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":521,"row":{"number":719,"difficulty":2,"question":"class Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        The distance of a pair of integers a and b is defined as the absolute difference between a and b.\n        Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.\n        Example 1:\n        Input: nums = [1,3,1], k = 1\n        Output: 0\n        Explanation: Here are all the pairs:\n        (1,3) -> 2\n        (1,1) -> 0\n        (3,1) -> 2\n        Then the 1st smallest distance pair is (1,1), and its distance is 0.\n        Example 2:\n        Input: nums = [1,1,1], k = 2\n        Output: 0\n        Example 3:\n        Input: nums = [1,6,1], k = 3\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":522,"row":{"number":720,"difficulty":1,"question":"class Solution:\n    def longestWord(self, words: List[str]) -> str:\n        \"\"\"\n        Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.\n        If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\n        Note that the word should be built from left to right with each additional character being added to the end of a previous word. \n        Example 1:\n        Input: words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]\n        Output: \"world\"\n        Explanation: The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\".\n        Example 2:\n        Input: words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]\n        Output: \"apple\"\n        Explanation: Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":523,"row":{"number":721,"difficulty":1,"question":"class Solution:\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\n        \"\"\"\n        Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\n        Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n        After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\n        Example 1:\n        Input: accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n        Output: [[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n        Explanation:\n        The first and second John's are the same person as they have the common email \"johnsmith@mail.com\".\n        The third John and Mary are different people as none of their email addresses are used by other accounts.\n        We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \n        ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\n        Example 2:\n        Input: accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n        Output: [[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":524,"row":{"number":722,"difficulty":1,"question":"class Solution:\n    def removeComments(self, source: List[str]) -> List[str]:\n        \"\"\"\n        Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. This represents the result of splitting the original source code string by the newline character '\\n'.\n        In C++, there are two types of comments, line comments, and block comments.\n            The string \"//\" denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.\n            The string \"/*\" denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of \"*/\" should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string \"/*/\" does not yet end the block comment, as the ending would be overlapping the beginning.\n        The first effective comment takes precedence over others.\n            For example, if the string \"//\" occurs in a block comment, it is ignored.\n            Similarly, if the string \"/*\" occurs in a line or block comment, it is also ignored.\n        If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\n        There will be no control characters, single quote, or double quote characters.\n            For example, source = \"string s = \"/* Not a comment. */\";\" will not be a test case.\n        Also, nothing else such as defines or macros will interfere with the comments.\n        It is guaranteed that every open block comment will eventually be closed, so \"/*\" outside of a line or block comment always starts a new comment.\n        Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details.\n        After removing the comments from the source code, return the source code in the same format.\n        Example 1:\n        Input: source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]\n        Output: [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]\n        Explanation: The line by line code is visualized as below:\n        /*Test program */\n        int main()\n        { \n          // variable declaration \n        int a, b, c;\n        /* This is a test\n           multiline  \n           comment for \n           testing */\n        a = b + c;\n        }\n        The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.\n        The line by line output code is visualized as below:\n        int main()\n        { \n        int a, b, c;\n        a = b + c;\n        }\n        Example 2:\n        Input: source = [\"a/*comment\", \"line\", \"more_comment*/b\"]\n        Output: [\"ab\"]\n        Explanation: The original source string is \"a/*comment\\nline\\nmore_comment*/b\", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string \"ab\", which when delimited by newline characters becomes [\"ab\"].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":525,"row":{"number":724,"difficulty":0,"question":"class Solution:\n    def pivotIndex(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array of integers nums, calculate the pivot index of this array.\n        The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\n        If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\n        Return the leftmost pivot index. If no such index exists, return -1.\n        Example 1:\n        Input: nums = [1,7,3,6,5,6]\n        Output: 3\n        Explanation:\n        The pivot index is 3.\n        Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\n        Right sum = nums[4] + nums[5] = 5 + 6 = 11\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: -1\n        Explanation:\n        There is no index that satisfies the conditions in the problem statement.\n        Example 3:\n        Input: nums = [2,1,-1]\n        Output: 0\n        Explanation:\n        The pivot index is 0.\n        Left sum = 0 (no elements to the left of index 0)\n        Right sum = nums[1] + nums[2] = 1 + -1 = 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":526,"row":{"number":725,"difficulty":1,"question":"class Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n        \"\"\"\n        Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\n        The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\n        The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\n        Return an array of the k parts.\n        Example 1:\n        Input: head = [1,2,3], k = 5\n        Output: [[1],[2],[3],[],[]]\n        Explanation:\n        The first element output[0] has output[0].val = 1, output[0].next = null.\n        The last element output[4] is null, but its string representation as a ListNode is [].\n        Example 2:\n        Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\n        Output: [[1,2,3,4],[5,6,7],[8,9,10]]\n        Explanation:\n        The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":527,"row":{"number":726,"difficulty":2,"question":"class Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        \"\"\"\n        Given a string formula representing a chemical formula, return the count of each atom.\n        The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n        One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n            For example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\n        Two formulas are concatenated together to produce another formula.\n            For example, \"H2O2He3Mg4\" is also a formula.\n        A formula placed in parentheses, and a count (optionally added) is also a formula.\n            For example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\n        Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\n        The test cases are generated so that all the values in the output fit in a 32-bit integer.\n        Example 1:\n        Input: formula = \"H2O\"\n        Output: \"H2O\"\n        Explanation: The count of elements are {'H': 2, 'O': 1}.\n        Example 2:\n        Input: formula = \"Mg(OH)2\"\n        Output: \"H2MgO2\"\n        Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n        Example 3:\n        Input: formula = \"K4(ON(SO3)2)2\"\n        Output: \"K4N2O14S4\"\n        Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":528,"row":{"number":728,"difficulty":0,"question":"class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        \"\"\"\n        A self-dividing number is a number that is divisible by every digit it contains.\n            For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n        A self-dividing number is not allowed to contain the digit zero.\n        Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].\n        Example 1:\n        Input: left = 1, right = 22\n        Output: [1,2,3,4,5,6,7,8,9,11,12,15,22]\n        Example 2:\n        Input: left = 47, right = 85\n        Output: [48,55,66,77]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":529,"row":{"number":729,"difficulty":1,"question":"class MyCalendar:\n    def __init__(self):\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"\n        You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.\n        A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).\n        The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.\n        Implement the MyCalendar class:\n            MyCalendar() Initializes the calendar object.\n            boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.\n        Example 1:\n        Input\n        [\"MyCalendar\", \"book\", \"book\", \"book\"]\n        [[], [10, 20], [15, 25], [20, 30]]\n        Output\n        [null, true, false, true]\n        Explanation\n        MyCalendar myCalendar = new MyCalendar();\n        myCalendar.book(10, 20); // return True\n        myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.\n        myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":530,"row":{"number":730,"difficulty":2,"question":"class Solution:\n    def countPalindromicSubsequences(self, s: str) -> int:\n        \"\"\"\n        Given a string s, return the number of different non-empty palindromic subsequences in s. Since the answer may be very large, return it modulo 109 + 7.\n        A subsequence of a string is obtained by deleting zero or more characters from the string.\n        A sequence is palindromic if it is equal to the sequence reversed.\n        Two sequences a1, a2, ... and b1, b2, ... are different if there is some i for which ai != bi.\n        Example 1:\n        Input: s = \"bccb\"\n        Output: 6\n        Explanation: The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\n        Note that 'bcb' is counted only once, even though it occurs twice.\n        Example 2:\n        Input: s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"\n        Output: 104860361\n        Explanation: There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":531,"row":{"number":731,"difficulty":1,"question":"class MyCalendarTwo:\n    def __init__(self):\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"\n        You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.\n        A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).\n        The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.\n        Implement the MyCalendarTwo class:\n            MyCalendarTwo() Initializes the calendar object.\n            boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.\n        Example 1:\n        Input\n        [\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"]\n        [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\n        Output\n        [null, true, true, true, false, true, true]\n        Explanation\n        MyCalendarTwo myCalendarTwo = new MyCalendarTwo();\n        myCalendarTwo.book(10, 20); // return True, The event can be booked. \n        myCalendarTwo.book(50, 60); // return True, The event can be booked. \n        myCalendarTwo.book(10, 40); // return True, The event can be double booked. \n        myCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.\n        myCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.\n        myCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":532,"row":{"number":732,"difficulty":2,"question":"class MyCalendarThree:\n    def __init__(self):\n    def book(self, startTime: int, endTime: int) -> int:\n        \"\"\"\n        A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.)\n        You are given some events [startTime, endTime), after each given event, return an integer k representing the maximum k-booking between all the previous events.\n        Implement the MyCalendarThree class:\n            MyCalendarThree() Initializes the object.\n            int book(int startTime, int endTime) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar.\n        Example 1:\n        Input\n        [\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"]\n        [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\n        Output\n        [null, 1, 1, 2, 3, 3, 3]\n        Explanation\n        MyCalendarThree myCalendarThree = new MyCalendarThree();\n        myCalendarThree.book(10, 20); // return 1\n        myCalendarThree.book(50, 60); // return 1\n        myCalendarThree.book(10, 40); // return 2\n        myCalendarThree.book(5, 15); // return 3\n        myCalendarThree.book(5, 10); // return 3\n        myCalendarThree.book(25, 55); // return 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":533,"row":{"number":733,"difficulty":0,"question":"class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        \"\"\"\n        An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\n        You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\n        To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\n        Return the modified image after performing the flood fill.\n        Example 1:\n        Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\n        Output: [[2,2,2],[2,2,0],[2,0,1]]\n        Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n        Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n        Example 2:\n        Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\n        Output: [[0,0,0],[0,0,0]]\n        Explanation: The starting pixel is already colored 0, so no changes are made to the image.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":534,"row":{"number":735,"difficulty":1,"question":"class Solution:\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        \"\"\"\n        We are given an array asteroids of integers representing asteroids in a row.\n        For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\n        Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\n        Example 1:\n        Input: asteroids = [5,10,-5]\n        Output: [5,10]\n        Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\n        Example 2:\n        Input: asteroids = [8,-8]\n        Output: []\n        Explanation: The 8 and -8 collide exploding each other.\n        Example 3:\n        Input: asteroids = [10,2,-5]\n        Output: [10]\n        Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":535,"row":{"number":736,"difficulty":2,"question":"class Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        You are given a string expression representing a Lisp-like expression to return the integer value of.\n        The syntax for these expressions is given as follows.\n            An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.\n            (An integer could be positive or negative.)\n            A let expression takes the form \"(let v1 e1 v2 e2 ... vn en expr)\", where let is always the string \"let\", then there are one or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let expression is the value of the expression expr.\n            An add expression takes the form \"(add e1 e2)\" where add is always the string \"add\", there are always two expressions e1, e2 and the result is the addition of the evaluation of e1 and the evaluation of e2.\n            A mult expression takes the form \"(mult e1 e2)\" where mult is always the string \"mult\", there are always two expressions e1, e2 and the result is the multiplication of the evaluation of e1 and the evaluation of e2.\n            For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names \"add\", \"let\", and \"mult\" are protected and will never be used as variable names.\n            Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.\n        Example 1:\n        Input: expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"\n        Output: 14\n        Explanation: In the expression (add x y), when checking for the value of the variable x,\n        we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\n        Since x = 3 is found first, the value of x is 3.\n        Example 2:\n        Input: expression = \"(let x 3 x 2 x)\"\n        Output: 2\n        Explanation: Assignment in let statements is processed sequentially.\n        Example 3:\n        Input: expression = \"(let x 1 y 2 x (add x y) (add x y))\"\n        Output: 5\n        Explanation: The first (add x y) evaluates as 3, and is assigned to x.\n        The second (add x y) evaluates as 3+2 = 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":536,"row":{"number":738,"difficulty":1,"question":"class Solution:\n    def monotoneIncreasingDigits(self, n: int) -> int:\n        \"\"\"\n        An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x <= y.\n        Given an integer n, return the largest number that is less than or equal to n with monotone increasing digits.\n        Example 1:\n        Input: n = 10\n        Output: 9\n        Example 2:\n        Input: n = 1234\n        Output: 1234\n        Example 3:\n        Input: n = 332\n        Output: 299\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":537,"row":{"number":739,"difficulty":1,"question":"class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        \"\"\"\n        Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n        Example 1:\n        Input: temperatures = [73,74,75,71,69,72,76,73]\n        Output: [1,1,4,2,1,1,0,0]\n        Example 2:\n        Input: temperatures = [30,40,50,60]\n        Output: [1,1,1,0]\n        Example 3:\n        Input: temperatures = [30,60,90]\n        Output: [1,1,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":538,"row":{"number":740,"difficulty":1,"question":"class Solution:\n    def deleteAndEarn(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:\n            Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.\n        Return the maximum number of points you can earn by applying the above operation some number of times.\n        Example 1:\n        Input: nums = [3,4,2]\n        Output: 6\n        Explanation: You can perform the following operations:\n        - Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].\n        - Delete 2 to earn 2 points. nums = [].\n        You earn a total of 6 points.\n        Example 2:\n        Input: nums = [2,2,3,3,3,4]\n        Output: 9\n        Explanation: You can perform the following operations:\n        - Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].\n        - Delete a 3 again to earn 3 points. nums = [3].\n        - Delete a 3 once more to earn 3 points. nums = [].\n        You earn a total of 9 points.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":539,"row":{"number":741,"difficulty":2,"question":"class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n grid representing a field of cherries, each cell is one of three possible integers.\n            0 means the cell is empty, so you can pass through,\n            1 means the cell contains a cherry that you can pick up and pass through, or\n            -1 means the cell contains a thorn that blocks your way.\n        Return the maximum number of cherries you can collect by following the rules below:\n            Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1).\n            After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells.\n            When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\n            If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected.\n        Example 1:\n        Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]]\n        Output: 5\n        Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).\n        4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\n        Then, the player went left, up, up, left to return home, picking up one more cherry.\n        The total number of cherries picked up is 5, and this is the maximum possible.\n        Example 2:\n        Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":540,"row":{"number":709,"difficulty":0,"question":"class Solution:\n    def toLowerCase(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.\n        Example 1:\n        Input: s = \"Hello\"\n        Output: \"hello\"\n        Example 2:\n        Input: s = \"here\"\n        Output: \"here\"\n        Example 3:\n        Input: s = \"LOVELY\"\n        Output: \"lovely\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":541,"row":{"number":743,"difficulty":1,"question":"class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        \"\"\"\n        You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\n        We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.\n        Example 1:\n        Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n        Output: 2\n        Example 2:\n        Input: times = [[1,2,1]], n = 2, k = 1\n        Output: 1\n        Example 3:\n        Input: times = [[1,2,1]], n = 2, k = 2\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":542,"row":{"number":744,"difficulty":0,"question":"class Solution:\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\n        \"\"\"\n        You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.\n        Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.\n        Example 1:\n        Input: letters = [\"c\",\"f\",\"j\"], target = \"a\"\n        Output: \"c\"\n        Explanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.\n        Example 2:\n        Input: letters = [\"c\",\"f\",\"j\"], target = \"c\"\n        Output: \"f\"\n        Explanation: The smallest character that is lexicographically greater than 'c' in letters is 'f'.\n        Example 3:\n        Input: letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"\n        Output: \"x\"\n        Explanation: There are no characters in letters that is lexicographically greater than 'z' so we return letters[0].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":543,"row":{"number":745,"difficulty":2,"question":"class WordFilter:\n    def __init__(self, words: List[str]):\n    def f(self, pref: str, suff: str) -> int:\n        \"\"\"\n        Design a special dictionary that searches the words in it by a prefix and a suffix.\n        Implement the WordFilter class:\n            WordFilter(string[] words) Initializes the object with the words in the dictionary.\n            f(string pref, string suff) Returns the index of the word in the dictionary, which has the prefix pref and the suffix suff. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1.\n        Example 1:\n        Input\n        [\"WordFilter\", \"f\"]\n        [[[\"apple\"]], [\"a\", \"e\"]]\n        Output\n        [null, 0]\n        Explanation\n        WordFilter wordFilter = new WordFilter([\"apple\"]);\n        wordFilter.f(\"a\", \"e\"); // return 0, because the word at index 0 has prefix = \"a\" and suffix = \"e\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":544,"row":{"number":746,"difficulty":0,"question":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        \"\"\"\n        You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\n        You can either start from the step with index 0, or the step with index 1.\n        Return the minimum cost to reach the top of the floor.\n        Example 1:\n        Input: cost = [10,15,20]\n        Output: 15\n        Explanation: You will start at index 1.\n        - Pay 15 and climb two steps to reach the top.\n        The total cost is 15.\n        Example 2:\n        Input: cost = [1,100,1,1,1,100,1,1,100,1]\n        Output: 6\n        Explanation: You will start at index 0.\n        - Pay 1 and climb two steps to reach index 2.\n        - Pay 1 and climb two steps to reach index 4.\n        - Pay 1 and climb two steps to reach index 6.\n        - Pay 1 and climb one step to reach index 7.\n        - Pay 1 and climb two steps to reach index 9.\n        - Pay 1 and climb one step to reach the top.\n        The total cost is 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":545,"row":{"number":747,"difficulty":0,"question":"class Solution:\n    def dominantIndex(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums where the largest integer is unique.\n        Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.\n        Example 1:\n        Input: nums = [3,6,1,0]\n        Output: 1\n        Explanation: 6 is the largest integer.\n        For every other number in the array x, 6 is at least twice as big as x.\n        The index of value 6 is 1, so we return 1.\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: -1\n        Explanation: 4 is less than twice the value of 3, so we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":546,"row":{"number":748,"difficulty":0,"question":"class Solution:\n    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:\n        \"\"\"\n        Given a string licensePlate and an array of strings words, find the shortest completing word in words.\n        A completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more.\n        For example, if licensePlate = \"aBc 12c\", then it contains letters 'a', 'b' (ignoring case), and 'c' twice. Possible completing words are \"abccdef\", \"caaacab\", and \"cbca\".\n        Return the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words.\n        Example 1:\n        Input: licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]\n        Output: \"steps\"\n        Explanation: licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'.\n        \"step\" contains 't' and 'p', but only contains 1 's'.\n        \"steps\" contains 't', 'p', and both 's' characters.\n        \"stripe\" is missing an 's'.\n        \"stepple\" is missing an 's'.\n        Since \"steps\" is the only word containing all the letters, that is the answer.\n        Example 2:\n        Input: licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]\n        Output: \"pest\"\n        Explanation: licensePlate only contains the letter 's'. All the words contain 's', but among these \"pest\", \"stew\", and \"show\" are shortest. The answer is \"pest\" because it is the word that appears earliest of the 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":547,"row":{"number":749,"difficulty":2,"question":"class Solution:\n    def containVirus(self, isInfected: List[List[int]]) -> int:\n        \"\"\"\n        A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n        The world is modeled as an m x n binary grid isInfected, where isInfected[i][j] == 0 represents uninfected cells, and isInfected[i][j] == 1 represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\n        Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There will never be a tie.\n        Return the number of walls used to quarantine all the infected regions. If the world will become fully infected, return the number of walls used.\n        Example 1:\n        Input: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\n        Output: 10\n        Explanation: There are 2 contaminated regions.\n        On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n        On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n        Example 2:\n        Input: isInfected = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: 4\n        Explanation: Even though there is only one cell saved, there are 4 walls built.\n        Notice that walls are only built on the shared boundary of two different cells.\n        Example 3:\n        Input: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\n        Output: 13\n        Explanation: The region on the left only builds two new walls.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":548,"row":{"number":752,"difficulty":1,"question":"class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        \"\"\"\n        You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\n        The lock initially starts at '0000', a string representing the state of the 4 wheels.\n        You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n        Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n        Example 1:\n        Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n        Output: 6\n        Explanation: \n        A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\n        Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\n        because the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n        Example 2:\n        Input: deadends = [\"8888\"], target = \"0009\"\n        Output: 1\n        Explanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n        Example 3:\n        Input: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n        Output: -1\n        Explanation: We cannot reach the target without getting stuck.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":549,"row":{"number":753,"difficulty":2,"question":"class Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        \"\"\"\n        There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].\n        The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.\n            For example, the correct password is \"345\" and you enter in \"012345\":\n                After typing 0, the most recent 3 digits is \"0\", which is incorrect.\n                After typing 1, the most recent 3 digits is \"01\", which is incorrect.\n                After typing 2, the most recent 3 digits is \"012\", which is incorrect.\n                After typing 3, the most recent 3 digits is \"123\", which is incorrect.\n                After typing 4, the most recent 3 digits is \"234\", which is incorrect.\n                After typing 5, the most recent 3 digits is \"345\", which is correct and the safe unlocks.\n        Return any string of minimum length that will unlock the safe at some point of entering it.\n        Example 1:\n        Input: n = 1, k = 2\n        Output: \"10\"\n        Explanation: The password is a single digit, so enter each digit. \"01\" would also unlock the safe.\n        Example 2:\n        Input: n = 2, k = 2\n        Output: \"01100\"\n        Explanation: For each possible password:\n        - \"00\" is typed in starting from the 4th digit.\n        - \"01\" is typed in starting from the 1st digit.\n        - \"10\" is typed in starting from the 3rd digit.\n        - \"11\" is typed in starting from the 2nd digit.\n        Thus \"01100\" will unlock the safe. \"10011\", and \"11001\" would also unlock the safe.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":550,"row":{"number":754,"difficulty":1,"question":"class Solution:\n    def reachNumber(self, target: int) -> int:\n        \"\"\"\n        You are standing at position 0 on an infinite number line. There is a destination at position target.\n        You can make some number of moves numMoves so that:\n            On each move, you can either go left or right.\n            During the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.\n        Given the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.\n        Example 1:\n        Input: target = 2\n        Output: 3\n        Explanation:\n        On the 1st move, we step from 0 to 1 (1 step).\n        On the 2nd move, we step from 1 to -1 (2 steps).\n        On the 3rd move, we step from -1 to 2 (3 steps).\n        Example 2:\n        Input: target = 3\n        Output: 2\n        Explanation:\n        On the 1st move, we step from 0 to 1 (1 step).\n        On the 2nd move, we step from 1 to 3 (2 steps).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":551,"row":{"number":756,"difficulty":1,"question":"class Solution:\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\n        \"\"\"\n        You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top.\n        To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given as a list of three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.\n            For example, \"ABC\" represents a triangular pattern with a 'C' block stacked on top of an 'A' (left) and 'B' (right) block. Note that this is different from \"BAC\" where 'B' is on the left bottom and 'A' is on the right bottom.\n        You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid.\n        Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.\n        Example 1:\n        Input: bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\n        Output: true\n        Explanation: The allowed triangular patterns are shown on the right.\n        Starting from the bottom (level 3), we can build \"CE\" on level 2 and then build \"A\" on level 1.\n        There are three triangular patterns in the pyramid, which are \"BCC\", \"CDE\", and \"CEA\". All are allowed.\n        Example 2:\n        Input: bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\n        Output: false\n        Explanation: The allowed triangular patterns are shown on the right.\n        Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":552,"row":{"number":757,"difficulty":2,"question":"class Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the integers from starti to endi inclusively.\n        A containing set is an array nums where each interval from intervals has at least two integers in nums.\n            For example, if intervals = [[1,3], [3,7], [8,9]], then [1,2,4,7,8,9] and [2,3,4,8,9] are containing sets.\n        Return the minimum possible size of a containing set.\n        Example 1:\n        Input: intervals = [[1,3],[3,7],[8,9]]\n        Output: 5\n        Explanation: let nums = [2, 3, 4, 8, 9].\n        It can be shown that there cannot be any containing array of size 4.\n        Example 2:\n        Input: intervals = [[1,3],[1,4],[2,5],[3,5]]\n        Output: 3\n        Explanation: let nums = [2, 3, 4].\n        It can be shown that there cannot be any containing array of size 2.\n        Example 3:\n        Input: intervals = [[1,2],[2,3],[2,4],[4,5]]\n        Output: 5\n        Explanation: let nums = [1, 2, 3, 4, 5].\n        It can be shown that there cannot be any containing array of size 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":553,"row":{"number":761,"difficulty":2,"question":"class Solution:\n    def makeLargestSpecial(self, s: str) -> str:\n        \"\"\"\n        Special binary strings are binary strings with the following two properties:\n            The number of 0's is equal to the number of 1's.\n            Every prefix of the binary string has at least as many 1's as 0's.\n        You are given a special binary string s.\n        A move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\n        Return the lexicographically largest resulting string possible after applying the mentioned operations on the string.\n        Example 1:\n        Input: s = \"11011000\"\n        Output: \"11100100\"\n        Explanation: The strings \"10\" [occuring at s[1]] and \"1100\" [at s[3]] are swapped.\n        This is the lexicographically largest string possible after some number of swaps.\n        Example 2:\n        Input: s = \"10\"\n        Output: \"10\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":554,"row":{"number":429,"difficulty":1,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n        Given an n-ary tree, return the level order traversal of its nodes' values.\n        Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n        Example 1:\n        Input: root = [1,null,3,2,4,null,5,6]\n        Output: [[1],[3,2,4],[5,6]]\n        Example 2:\n        Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n        Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":555,"row":{"number":430,"difficulty":1,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n        You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.\n        Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.\n        Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.\n        Example 1:\n        Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n        Output: [1,2,3,7,8,11,12,9,10,4,5,6]\n        Explanation: The multilevel linked list in the input is shown.\n        After flattening the multilevel linked list it becomes:\n        Example 2:\n        Input: head = [1,2,null,3]\n        Output: [1,3,2]\n        Explanation: The multilevel linked list in the input is shown.\n        After flattening the multilevel linked list it becomes:\n        Example 3:\n        Input: head = []\n        Output: []\n        Explanation: There could be empty list in the input.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":556,"row":{"number":762,"difficulty":0,"question":"class Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        \"\"\"\n        Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation.\n        Recall that the number of set bits an integer has is the number of 1's present when written in binary.\n            For example, 21 written in binary is 10101, which has 3 set bits.\n        Example 1:\n        Input: left = 6, right = 10\n        Output: 4\n        Explanation:\n        6  -> 110 (2 set bits, 2 is prime)\n        7  -> 111 (3 set bits, 3 is prime)\n        8  -> 1000 (1 set bit, 1 is not prime)\n        9  -> 1001 (2 set bits, 2 is prime)\n        10 -> 1010 (2 set bits, 2 is prime)\n        4 numbers have a prime number of set bits.\n        Example 2:\n        Input: left = 10, right = 15\n        Output: 5\n        Explanation:\n        10 -> 1010 (2 set bits, 2 is prime)\n        11 -> 1011 (3 set bits, 3 is prime)\n        12 -> 1100 (2 set bits, 2 is prime)\n        13 -> 1101 (3 set bits, 3 is prime)\n        14 -> 1110 (3 set bits, 3 is prime)\n        15 -> 1111 (4 set bits, 4 is not prime)\n        5 numbers have a prime number of set bits.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":557,"row":{"number":763,"difficulty":1,"question":"class Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        \"\"\"\n        You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n        Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\n        Return a list of integers representing the size of these parts.\n        Example 1:\n        Input: s = \"ababcbacadefegdehijhklij\"\n        Output: [9,7,8]\n        Explanation:\n        The partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\n        This is a partition so that each letter appears in at most one part.\n        A partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n        Example 2:\n        Input: s = \"eccbbbbdec\"\n        Output: [10]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":558,"row":{"number":764,"difficulty":1,"question":"class Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        \"\"\"\n        You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.\n        Return the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.\n        An axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.\n        Example 1:\n        Input: n = 5, mines = [[4,2]]\n        Output: 2\n        Explanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n        Example 2:\n        Input: n = 1, mines = [[0,0]]\n        Output: 0\n        Explanation: There is no plus sign, so return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":559,"row":{"number":765,"difficulty":2,"question":"class Solution:\n    def minSwapsCouples(self, row: List[int]) -> int:\n        \"\"\"\n        There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n        The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).\n        Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.\n        Example 1:\n        Input: row = [0,2,1,3]\n        Output: 1\n        Explanation: We only need to swap the second (row[1]) and third (row[2]) person.\n        Example 2:\n        Input: row = [3,2,0,1]\n        Output: 0\n        Explanation: All couples are already seated side by side.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":560,"row":{"number":427,"difficulty":1,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n        Given a n * n matrix grid of 0's and 1's only. We want to represent the grid with a Quad-Tree.\n        Return the root of the Quad-Tree representing the grid.\n        Notice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer.\n        A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n            val: True if the node represents a grid of 1's or False if the node represents a grid of 0's.\n            isLeaf: True if the node is leaf node on the tree or False if the node has the four children.\n        class Node {\n            public boolean val;\n            public boolean isLeaf;\n            public Node topLeft;\n            public Node topRight;\n            public Node bottomLeft;\n            public Node bottomRight;\n        }\n        We can construct a Quad-Tree from a two-dimensional area using the following steps:\n            If the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\n            If the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\n            Recurse for each of the children with the proper sub-grid.\n        If you want to know more about the Quad-Tree, you can refer to the wiki.\n        Quad-Tree format:\n        The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\n        It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\n        If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n        Example 1:\n        Input: grid = [[0,1],[1,0]]\n        Output: [[0,1],[1,0],[1,1],[1,1],[1,0]]\n        Explanation: The explanation of this example is shown below:\n        Notice that 0 represnts False and 1 represents True in the photo representing the Quad-Tree.\n        Example 2:\n        Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\n        Output: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n        Explanation: All values in the grid are not the same. We divide the grid into four sub-grids.\n        The topLeft, bottomLeft and bottomRight each has the same value.\n        The topRight have different values so we divide it into 4 sub-grids where each has the same value.\n        Explanation is shown in the photo below:\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":561,"row":{"number":558,"difficulty":1,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n        A Binary Matrix is a matrix in which all the elements are either 0 or 1.\n        Given quadTree1 and quadTree2. quadTree1 represents a n * n binary matrix and quadTree2 represents another n * n binary matrix.\n        Return a Quad-Tree representing the n * n binary matrix which is the result of logical bitwise OR of the two binary matrixes represented by quadTree1 and quadTree2.\n        Notice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer.\n        A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n            val: True if the node represents a grid of 1's or False if the node represents a grid of 0's.\n            isLeaf: True if the node is leaf node on the tree or False if the node has the four children.\n        class Node {\n            public boolean val;\n            public boolean isLeaf;\n            public Node topLeft;\n            public Node topRight;\n            public Node bottomLeft;\n            public Node bottomRight;\n        }\n        We can construct a Quad-Tree from a two-dimensional area using the following steps:\n            If the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\n            If the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\n            Recurse for each of the children with the proper sub-grid.\n        If you want to know more about the Quad-Tree, you can refer to the wiki.\n        Quad-Tree format:\n        The input/output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\n        It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\n        If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n        Example 1:\n        Input: quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\n        , quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n        Output: [[0,0],[1,1],[1,1],[1,1],[1,0]]\n        Explanation: quadTree1 and quadTree2 are shown above. You can see the binary matrix which is represented by each Quad-Tree.\n        If we apply logical bitwise OR on the two binary matrices we get the binary matrix below which is represented by the result Quad-Tree.\n        Notice that the binary matrices shown are only for illustration, you don't have to construct the binary matrix to get the result tree.\n        Example 2:\n        Input: quadTree1 = [[1,0]], quadTree2 = [[1,0]]\n        Output: [[1,0]]\n        Explanation: Each tree represents a binary matrix of size 1*1. Each matrix contains only zero.\n        The resulting matrix is of size 1*1 with also zero.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":562,"row":{"number":559,"difficulty":0,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n        Given a n-ary tree, find its maximum depth.\n        The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n        Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n        Example 1:\n        Input: root = [1,null,3,2,4,null,5,6]\n        Output: 3\n        Example 2:\n        Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":563,"row":{"number":589,"difficulty":0,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n        Given the root of an n-ary tree, return the preorder traversal of its nodes' values.\n        Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\n        Example 1:\n        Input: root = [1,null,3,2,4,null,5,6]\n        Output: [1,3,5,6,2,4]\n        Example 2:\n        Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n        Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":564,"row":{"number":590,"difficulty":0,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n        Given the root of an n-ary tree, return the postorder traversal of its nodes' values.\n        Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\n        Example 1:\n        Input: root = [1,null,3,2,4,null,5,6]\n        Output: [5,6,3,2,4,1]\n        Example 2:\n        Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n        Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":565,"row":{"number":766,"difficulty":0,"question":"class Solution:\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\n        \"\"\"\n        Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.\n        A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.\n        Example 1:\n        Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]\n        Output: true\n        Explanation:\n        In the above grid, the diagonals are:\n        \"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\".\n        In each diagonal all elements are the same, so the answer is True.\n        Example 2:\n        Input: matrix = [[1,2],[2,2]]\n        Output: false\n        Explanation:\n        The diagonal \"[1, 2]\" has different elements.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":566,"row":{"number":767,"difficulty":1,"question":"class Solution:\n    def reorganizeString(self, s: str) -> str:\n        \"\"\"\n        Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.\n        Return any possible rearrangement of s or return \"\" if not possible.\n        Example 1:\n        Input: s = \"aab\"\n        Output: \"aba\"\n        Example 2:\n        Input: s = \"aaab\"\n        Output: \"\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":567,"row":{"number":768,"difficulty":2,"question":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \"\"\"\n        You are given an integer array arr.\n        We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\n        Return the largest number of chunks we can make to sort the array.\n        Example 1:\n        Input: arr = [5,4,3,2,1]\n        Output: 1\n        Explanation:\n        Splitting into two or more chunks will not return the required result.\n        For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.\n        Example 2:\n        Input: arr = [2,1,3,4,4]\n        Output: 4\n        Explanation:\n        We can split into two chunks, such as [2, 1], [3, 4, 4].\n        However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":568,"row":{"number":769,"difficulty":1,"question":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \"\"\"\n        You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1].\n        We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\n        Return the largest number of chunks we can make to sort the array.\n        Example 1:\n        Input: arr = [4,3,2,1,0]\n        Output: 1\n        Explanation:\n        Splitting into two or more chunks will not return the required result.\n        For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.\n        Example 2:\n        Input: arr = [1,0,2,3,4]\n        Output: 4\n        Explanation:\n        We can split into two chunks, such as [1, 0], [2, 3, 4].\n        However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":569,"row":{"number":770,"difficulty":2,"question":"class Solution:\n    def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n        \"\"\"\n        Given an expression such as expression = \"e + 8 - a + 5\" and an evaluation map such as {\"e\": 1} (given in terms of evalvars = [\"e\"] and evalints = [1]), return a list of tokens representing the simplified expression, such as [\"-1*a\",\"14\"]\n            An expression alternates chunks and symbols, with a space separating each chunk and symbol.\n            A chunk is either an expression in parentheses, a variable, or a non-negative integer.\n            A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like \"2x\" or \"-x\".\n        Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.\n            For example, expression = \"1 + 2 * 3\" has an answer of [\"7\"].\n        The format of the output is as follows:\n            For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.\n                For example, we would never write a term like \"b*a*c\", only \"a*b*c\".\n            Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.\n                For example, \"a*a*b*c\" has degree 4.\n            The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\n            An example of a well-formatted answer is [\"-2*a*a*a\", \"3*a*a*b\", \"3*b*b\", \"4*a\", \"5*c\", \"-6\"].\n            Terms (including constant terms) with coefficient 0 are not included.\n                For example, an expression of \"0\" has an output of [].\n        Note: You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].\n        Example 1:\n        Input: expression = \"e + 8 - a + 5\", evalvars = [\"e\"], evalints = [1]\n        Output: [\"-1*a\",\"14\"]\n        Example 2:\n        Input: expression = \"e - 8 + temperature - pressure\", evalvars = [\"e\", \"temperature\"], evalints = [1, 12]\n        Output: [\"-1*pressure\",\"5\"]\n        Example 3:\n        Input: expression = \"(e + 8) * (e - 8)\", evalvars = [], evalints = []\n        Output: [\"1*e*e\",\"-64\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":570,"row":{"number":771,"difficulty":0,"question":"class Solution:\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\n        \"\"\"\n        You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\n        Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n        Example 1:\n        Input: jewels = \"aA\", stones = \"aAAbbbb\"\n        Output: 3\n        Example 2:\n        Input: jewels = \"z\", stones = \"ZZ\"\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":571,"row":{"number":700,"difficulty":0,"question":"class Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        \"\"\"\n        You are given the root of a binary search tree (BST) and an integer val.\n        Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n        Example 1:\n        Input: root = [4,2,7,1,3], val = 2\n        Output: [2,1,3]\n        Example 2:\n        Input: root = [4,2,7,1,3], val = 5\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":572,"row":{"number":701,"difficulty":1,"question":"class Solution:\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        \"\"\"\n        You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\n        Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\n        Example 1:\n        Input: root = [4,2,7,1,3], val = 5\n        Output: [4,2,7,1,3,5]\n        Explanation: Another accepted tree is:\n        Example 2:\n        Input: root = [40,20,60,10,30,50,70], val = 25\n        Output: [40,20,60,10,30,50,70,null,null,25]\n        Example 3:\n        Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n        Output: [4,2,7,1,3,5]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":573,"row":{"number":773,"difficulty":2,"question":"class Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        \"\"\"\n        On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.\n        The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\n        Given the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\n        Example 1:\n        Input: board = [[1,2,3],[4,0,5]]\n        Output: 1\n        Explanation: Swap the 0 and the 5 in one move.\n        Example 2:\n        Input: board = [[1,2,3],[5,4,0]]\n        Output: -1\n        Explanation: No number of moves will make the board solved.\n        Example 3:\n        Input: board = [[4,1,2],[5,0,3]]\n        Output: 5\n        Explanation: 5 is the smallest number of moves that solves the board.\n        An example path:\n        After move 0: [[4,1,2],[5,0,3]]\n        After move 1: [[4,1,2],[0,5,3]]\n        After move 2: [[0,1,2],[4,5,3]]\n        After move 3: [[1,0,2],[4,5,3]]\n        After move 4: [[1,2,0],[4,5,3]]\n        After move 5: [[1,2,3],[4,5,0]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":574,"row":{"number":703,"difficulty":0,"question":"class KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n    def add(self, val: int) -> int:\n        \"\"\"\n        Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n        Implement KthLargest class:\n            KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\n            int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.\n        Example 1:\n        Input\n        [\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n        [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n        Output\n        [null, 4, 5, 5, 8, 8]\n        Explanation\n        KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\n        kthLargest.add(3);   // return 4\n        kthLargest.add(5);   // return 5\n        kthLargest.add(10);  // return 5\n        kthLargest.add(9);   // return 8\n        kthLargest.add(4);   // return 8\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":575,"row":{"number":775,"difficulty":1,"question":"class Solution:\n    def isIdealPermutation(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums of length n which represents a permutation of all the integers in the range [0, n - 1].\n        The number of global inversions is the number of the different pairs (i, j) where:\n            0 <= i < j < n\n            nums[i] > nums[j]\n        The number of local inversions is the number of indices i where:\n            0 <= i < n - 1\n            nums[i] > nums[i + 1]\n        Return true if the number of global inversions is equal to the number of local inversions.\n        Example 1:\n        Input: nums = [1,0,2]\n        Output: true\n        Explanation: There is 1 global inversion and 1 local inversion.\n        Example 2:\n        Input: nums = [1,2,0]\n        Output: false\n        Explanation: There are 2 global inversions and 1 local inversion.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":576,"row":{"number":704,"difficulty":0,"question":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [-1,0,3,5,9,12], target = 9\n        Output: 4\n        Explanation: 9 exists in nums and its index is 4\n        Example 2:\n        Input: nums = [-1,0,3,5,9,12], target = 2\n        Output: -1\n        Explanation: 2 does not exist in nums so return -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":577,"row":{"number":777,"difficulty":1,"question":"class Solution:\n    def canTransform(self, start: str, end: str) -> bool:\n        \"\"\"\n        In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.\n        Example 1:\n        Input: start = \"RXXLRXRXL\", end = \"XRLXXRRLX\"\n        Output: true\n        Explanation: We can transform start to end following these steps:\n        RXXLRXRXL ->\n        XRXLRXRXL ->\n        XRLXRXRXL ->\n        XRLXXRRXL ->\n        XRLXXRRLX\n        Example 2:\n        Input: start = \"X\", end = \"L\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":578,"row":{"number":778,"difficulty":2,"question":"class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\n        The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n        Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n        Example 1:\n        Input: grid = [[0,2],[1,3]]\n        Output: 3\n        Explanation:\n        At time 0, you are in grid location (0, 0).\n        You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\n        You cannot reach point (1, 1) until time 3.\n        When the depth of water is 3, we can swim anywhere inside the grid.\n        Example 2:\n        Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n        Output: 16\n        Explanation: The final route is shown.\n        We need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":579,"row":{"number":779,"difficulty":1,"question":"class Solution:\n    def kthGrammar(self, n: int, k: int) -> int:\n        \"\"\"\n        We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.\n            For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.\n        Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.\n        Example 1:\n        Input: n = 1, k = 1\n        Output: 0\n        Explanation: row 1: 0\n        Example 2:\n        Input: n = 2, k = 1\n        Output: 0\n        Explanation: \n        row 1: 0\n        row 2: 01\n        Example 3:\n        Input: n = 2, k = 2\n        Output: 1\n        Explanation: \n        row 1: 0\n        row 2: 01\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":580,"row":{"number":780,"difficulty":2,"question":"class Solution:\n    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n        \"\"\"\n        Given four integers sx, sy, tx, and ty, return true if it is possible to convert the point (sx, sy) to the point (tx, ty) through some operations, or false otherwise.\n        The allowed operation on some point (x, y) is to convert it to either (x, x + y) or (x + y, y).\n        Example 1:\n        Input: sx = 1, sy = 1, tx = 3, ty = 5\n        Output: true\n        Explanation:\n        One series of moves that transforms the starting point to the target is:\n        (1, 1) -> (1, 2)\n        (1, 2) -> (3, 2)\n        (3, 2) -> (3, 5)\n        Example 2:\n        Input: sx = 1, sy = 1, tx = 2, ty = 2\n        Output: false\n        Example 3:\n        Input: sx = 1, sy = 1, tx = 1, ty = 1\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":581,"row":{"number":781,"difficulty":1,"question":"class Solution:\n    def numRabbits(self, answers: List[int]) -> int:\n        \"\"\"\n        There is a forest with an unknown number of rabbits. We asked n rabbits \"How many rabbits have the same color as you?\" and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit.\n        Given the array answers, return the minimum number of rabbits that could be in the forest.\n        Example 1:\n        Input: answers = [1,1,2]\n        Output: 5\n        Explanation:\n        The two rabbits that answered \"1\" could both be the same color, say red.\n        The rabbit that answered \"2\" can't be red or the answers would be inconsistent.\n        Say the rabbit that answered \"2\" was blue.\n        Then there should be 2 other blue rabbits in the forest that didn't answer into the array.\n        The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.\n        Example 2:\n        Input: answers = [10,10,10]\n        Output: 11\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":582,"row":{"number":782,"difficulty":2,"question":"class Solution:\n    def movesToChessboard(self, board: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n binary grid board. In each move, you can swap any two rows with each other, or any two columns with each other.\n        Return the minimum number of moves to transform the board into a chessboard board. If the task is impossible, return -1.\n        A chessboard board is a board where no 0's and no 1's are 4-directionally adjacent.\n        Example 1:\n        Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\n        Output: 2\n        Explanation: One potential sequence of moves is shown.\n        The first move swaps the first and second column.\n        The second move swaps the second and third row.\n        Example 2:\n        Input: board = [[0,1],[1,0]]\n        Output: 0\n        Explanation: Also note that the board with 0 in the top left corner, is also a valid chessboard.\n        Example 3:\n        Input: board = [[1,0],[1,0]]\n        Output: -1\n        Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":583,"row":{"number":783,"difficulty":0,"question":"class Solution:\n    def minDiffInBST(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.\n        Example 1:\n        Input: root = [4,2,6,1,3]\n        Output: 1\n        Example 2:\n        Input: root = [1,0,48,null,null,12,49]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":584,"row":{"number":784,"difficulty":1,"question":"class Solution:\n    def letterCasePermutation(self, s: str) -> List[str]:\n        \"\"\"\n        Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.\n        Return a list of all possible strings we could create. Return the output in any order.\n        Example 1:\n        Input: s = \"a1b2\"\n        Output: [\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]\n        Example 2:\n        Input: s = \"3z4\"\n        Output: [\"3z4\",\"3Z4\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":585,"row":{"number":785,"difficulty":1,"question":"class Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        \"\"\"\n        There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n            There are no self-edges (graph[u] does not contain u).\n            There are no parallel edges (graph[u] does not contain duplicate values).\n            If v is in graph[u], then u is in graph[v] (the graph is undirected).\n            The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n        A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\n        Return true if and only if it is bipartite.\n        Example 1:\n        Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n        Output: false\n        Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n        Example 2:\n        Input: graph = [[1,3],[0,2],[1,3],[0,2]]\n        Output: true\n        Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":586,"row":{"number":786,"difficulty":1,"question":"class Solution:\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n        \"\"\"\n        You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.\n        For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].\n        Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].\n        Example 1:\n        Input: arr = [1,2,3,5], k = 3\n        Output: [2,5]\n        Explanation: The fractions to be considered in sorted order are:\n        1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.\n        The third fraction is 2/5.\n        Example 2:\n        Input: arr = [1,7], k = 1\n        Output: [1,7]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":587,"row":{"number":787,"difficulty":1,"question":"class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        \"\"\"\n        There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\n        You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\n        Example 1:\n        Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\n        Output: 700\n        Explanation:\n        The graph is shown above.\n        The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\n        Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\n        Example 2:\n        Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\n        Output: 200\n        Explanation:\n        The graph is shown above.\n        The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n        Example 3:\n        Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\n        Output: 500\n        Explanation:\n        The graph is shown above.\n        The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":588,"row":{"number":788,"difficulty":1,"question":"class Solution:\n    def rotatedDigits(self, n: int) -> int:\n        \"\"\"\n        An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone.\n        A number is valid if each digit remains a digit after rotation. For example:\n            0, 1, and 8 rotate to themselves,\n            2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored),\n            6 and 9 rotate to each other, and\n            the rest of the numbers do not rotate to any other number and become invalid.\n        Given an integer n, return the number of good integers in the range [1, n].\n        Example 1:\n        Input: n = 10\n        Output: 4\n        Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\n        Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n        Example 2:\n        Input: n = 1\n        Output: 0\n        Example 3:\n        Input: n = 2\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":589,"row":{"number":789,"difficulty":1,"question":"class Solution:\n    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:\n        \"\"\"\n        You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point [0, 0], and you are given a destination point target = [xtarget, ytarget] that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array ghosts, where ghosts[i] = [xi, yi] represents the starting position of the ith ghost. All inputs are integral coordinates.\n        Each turn, you and all the ghosts may independently choose to either move 1 unit in any of the four cardinal directions: north, east, south, or west, or stay still. All actions happen simultaneously.\n        You escape if and only if you can reach the target before any ghost reaches you. If you reach any square (including the target) at the same time as a ghost, it does not count as an escape.\n        Return true if it is possible to escape regardless of how the ghosts move, otherwise return false.\n        Example 1:\n        Input: ghosts = [[1,0],[0,3]], target = [0,1]\n        Output: true\n        Explanation: You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you.\n        Example 2:\n        Input: ghosts = [[1,0]], target = [2,0]\n        Output: false\n        Explanation: You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.\n        Example 3:\n        Input: ghosts = [[2,0]], target = [1,0]\n        Output: false\n        Explanation: The ghost can reach the target at the same time as you.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":590,"row":{"number":790,"difficulty":1,"question":"class Solution:\n    def numTilings(self, n: int) -> int:\n        \"\"\"\n        You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n        Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\n        In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n        Example 1:\n        Input: n = 3\n        Output: 5\n        Explanation: The five different ways are show above.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":591,"row":{"number":791,"difficulty":1,"question":"class Solution:\n    def customSortString(self, order: str, s: str) -> str:\n        \"\"\"\n        You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.\n        Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.\n        Return any permutation of s that satisfies this property.\n        Example 1:\n        Input: order = \"cba\", s = \"abcd\"\n        Output: \"cbad\"\n        Explanation: \n        \"a\", \"b\", \"c\" appear in order, so the order of \"a\", \"b\", \"c\" should be \"c\", \"b\", and \"a\". \n        Since \"d\" does not appear in order, it can be at any position in the returned string. \"dcba\", \"cdba\", \"cbda\" are also valid outputs.\n        Example 2:\n        Input: order = \"cbafg\", s = \"abcd\"\n        Output: \"cbad\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":592,"row":{"number":792,"difficulty":1,"question":"class Solution:\n    def numMatchingSubseq(self, s: str, words: List[str]) -> int:\n        \"\"\"\n        Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\n        A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n            For example, \"ace\" is a subsequence of \"abcde\".\n        Example 1:\n        Input: s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\n        Output: 3\n        Explanation: There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".\n        Example 2:\n        Input: s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":593,"row":{"number":793,"difficulty":2,"question":"class Solution:\n    def preimageSizeFZF(self, k: int) -> int:\n        \"\"\"\n        Let f(x) be the number of zeroes at the end of x!. Recall that x! = 1 * 2 * 3 * ... * x and by convention, 0! = 1.\n            For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has two zeroes at the end.\n        Given an integer k, return the number of non-negative integers x have the property that f(x) = k.\n        Example 1:\n        Input: k = 0\n        Output: 5\n        Explanation: 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.\n        Example 2:\n        Input: k = 5\n        Output: 0\n        Explanation: There is no x such that x! ends in k = 5 zeroes.\n        Example 3:\n        Input: k = 3\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":594,"row":{"number":794,"difficulty":1,"question":"class Solution:\n    def validTicTacToe(self, board: List[str]) -> bool:\n        \"\"\"\n        Given a Tic-Tac-Toe board as a string array board, return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\n        The board is a 3 x 3 array that consists of characters ' ', 'X', and 'O'. The ' ' character represents an empty square.\n        Here are the rules of Tic-Tac-Toe:\n            Players take turns placing characters into empty squares ' '.\n            The first player always places 'X' characters, while the second player always places 'O' characters.\n            'X' and 'O' characters are always placed into empty squares, never filled ones.\n            The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n            The game also ends if all squares are non-empty.\n            No more moves can be played if the game is over.\n        Example 1:\n        Input: board = [\"O  \",\"   \",\"   \"]\n        Output: false\n        Explanation: The first player always plays \"X\".\n        Example 2:\n        Input: board = [\"XOX\",\" X \",\"   \"]\n        Output: false\n        Explanation: Players take turns making moves.\n        Example 3:\n        Input: board = [\"XOX\",\"O O\",\"XOX\"]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":595,"row":{"number":795,"difficulty":1,"question":"class Solution:\n    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:\n        \"\"\"\n        Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right].\n        The test cases are generated so that the answer will fit in a 32-bit integer.\n        Example 1:\n        Input: nums = [2,1,4,3], left = 2, right = 3\n        Output: 3\n        Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].\n        Example 2:\n        Input: nums = [2,9,2,5,6], left = 2, right = 8\n        Output: 7\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":596,"row":{"number":796,"difficulty":0,"question":"class Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        \"\"\"\n        Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n        A shift on s consists of moving the leftmost character of s to the rightmost position.\n            For example, if s = \"abcde\", then it will be \"bcdea\" after one shift.\n        Example 1:\n        Input: s = \"abcde\", goal = \"cdeab\"\n        Output: true\n        Example 2:\n        Input: s = \"abcde\", goal = \"abced\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":597,"row":{"number":797,"difficulty":1,"question":"class Solution:\n    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.\n        The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).\n        Example 1:\n        Input: graph = [[1,2],[3],[3],[]]\n        Output: [[0,1,3],[0,2,3]]\n        Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n        Example 2:\n        Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]\n        Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":598,"row":{"number":798,"difficulty":2,"question":"class Solution:\n    def bestRotation(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point.\n            For example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4]. This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\n        Return the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k.\n        Example 1:\n        Input: nums = [2,3,1,4,0]\n        Output: 3\n        Explanation: Scores for each k are listed below: \n        k = 0,  nums = [2,3,1,4,0],    score 2\n        k = 1,  nums = [3,1,4,0,2],    score 3\n        k = 2,  nums = [1,4,0,2,3],    score 3\n        k = 3,  nums = [4,0,2,3,1],    score 4\n        k = 4,  nums = [0,2,3,1,4],    score 3\n        So we should choose k = 3, which has the highest score.\n        Example 2:\n        Input: nums = [1,3,0,2,4]\n        Output: 0\n        Explanation: nums will always have 3 points no matter how it shifts.\n        So we will choose the smallest k, which is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":599,"row":{"number":799,"difficulty":1,"question":"class Solution:\n    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:\n        \"\"\"\n        We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup of champagne.\r\n        Then, some champagne is poured into the first glass at the top.  When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has its excess champagne fall on the floor.)\r\n        For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\r\n        Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.)\r\n        Example 1:\r\n        Input: poured = 1, query_row = 1, query_glass = 1\r\n        Output: 0.00000\r\n        Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\r\n        Example 2:\r\n        Input: poured = 2, query_row = 1, query_glass = 1\r\n        Output: 0.50000\r\n        Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\r\n        Example 3:\r\n        Input: poured = 100000009, query_row = 33, query_glass = 17\r\n        Output: 1.00000\r\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}