{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1500,"row":{"number":1926,"difficulty":1,"question":"class Solution:\n    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n        \"\"\"\n        You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.\n        In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.\n        Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.\n        Example 1:\n        Input: maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\n        Output: 1\n        Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].\n        Initially, you are at the entrance cell [1,2].\n        - You can reach [1,0] by moving 2 steps left.\n        - You can reach [0,2] by moving 1 step up.\n        It is impossible to reach [2,3] from the entrance.\n        Thus, the nearest exit is [0,2], which is 1 step away.\n        Example 2:\n        Input: maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\n        Output: 2\n        Explanation: There is 1 exit in this maze at [1,2].\n        [1,0] does not count as an exit since it is the entrance cell.\n        Initially, you are at the entrance cell [1,0].\n        - You can reach [1,2] by moving 2 steps right.\n        Thus, the nearest exit is [1,2], which is 2 steps away.\n        Example 3:\n        Input: maze = [[\".\",\"+\"]], entrance = [0,0]\n        Output: -1\n        Explanation: There are no exits in this maze.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1501,"row":{"number":1927,"difficulty":1,"question":"class Solution:\n    def sumGame(self, num: str) -> bool:\n        \"\"\"\n        Alice and Bob take turns playing a game, with Alice starting first.\n        You are given a string num of even length consisting of digits and '?' characters. On each turn, a player will do the following if there is still at least one '?' in num:\n            Choose an index i where num[i] == '?'.\n            Replace num[i] with any digit between '0' and '9'.\n        The game ends when there are no more '?' characters in num.\n        For Bob to win, the sum of the digits in the first half of num must be equal to the sum of the digits in the second half. For Alice to win, the sums must not be equal.\n            For example, if the game ended with num = \"243801\", then Bob wins because 2+4+3 = 8+0+1. If the game ended with num = \"243803\", then Alice wins because 2+4+3 != 8+0+3.\n        Assuming Alice and Bob play optimally, return true if Alice will win and false if Bob will win.\n        Example 1:\n        Input: num = \"5023\"\n        Output: false\n        Explanation: There are no moves to be made.\n        The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3.\n        Example 2:\n        Input: num = \"25??\"\n        Output: true\n        Explanation: Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal.\n        Example 3:\n        Input: num = \"?3295???\"\n        Output: false\n        Explanation: It can be proven that Bob will always win. One possible outcome is:\n        - Alice replaces the first '?' with '9'. num = \"93295???\".\n        - Bob replaces one of the '?' in the right half with '9'. num = \"932959??\".\n        - Alice replaces one of the '?' in the right half with '2'. num = \"9329592?\".\n        - Bob replaces the last '?' in the right half with '7'. num = \"93295927\".\n        Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1502,"row":{"number":1928,"difficulty":2,"question":"class Solution:\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n        \"\"\"\n        There is a country of n cities numbered from 0 to n - 1 where all the cities are connected by bi-directional roads. The roads are represented as a 2D integer array edges where edges[i] = [xi, yi, timei] denotes a road between cities xi and yi that takes timei minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n        Each time you pass through a city, you must pay a passing fee. This is represented as a 0-indexed integer array passingFees of length n where passingFees[j] is the amount of dollars you must pay when you pass through city j.\n        In the beginning, you are at city 0 and want to reach city n - 1 in maxTime minutes or less. The cost of your journey is the summation of passing fees for each city that you passed through at some moment of your journey (including the source and destination cities).\n        Given maxTime, edges, and passingFees, return the minimum cost to complete your journey, or -1 if you cannot complete it within maxTime minutes.\n        Example 1:\n        Input: maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n        Output: 11\n        Explanation: The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n        Example 2:\n        Input: maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n        Output: 48\n        Explanation: The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\n        You cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n        Example 3:\n        Input: maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n        Output: -1\n        Explanation: There is no way to reach city 5 from city 0 within 25 minutes.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1503,"row":{"number":1913,"difficulty":0,"question":"class Solution:\r\n    def maxProductDifference(self, nums: List[int]) -> int:\n        \"\"\"\n        The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).\r\n            For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.\r\n        Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.\r\n        Return the maximum such product difference.\r\n        Example 1:\r\n        Input: nums = [5,6,2,7,4]\r\n        Output: 34\r\n        Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\r\n        The product difference is (6 * 7) - (2 * 4) = 34.\r\n        Example 2:\r\n        Input: nums = [4,2,5,9,7,4,8]\r\n        Output: 64\r\n        Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\r\n        The product difference is (9 * 8) - (2 * 4) = 64.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1504,"row":{"number":1914,"difficulty":1,"question":"class Solution:\r\n    def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        \"\"\"\n        You are given an m x n integer matrix grid​​​, where m and n are both even integers, and an integer k.\r\n        The matrix is composed of several layers, which is shown in the below image, where each color is its own layer:\r\n        A cyclic rotation of the matrix is done by cyclically rotating each layer in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the counter-clockwise direction. An example rotation is shown below:\r\n        Return the matrix after applying k cyclic rotations to it.\r\n        Example 1:\r\n        Input: grid = [[40,10],[30,20]], k = 1\r\n        Output: [[10,20],[40,30]]\r\n        Explanation: The figures above represent the grid at every state.\r\n        Example 2:\r\n        Input: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2\r\n        Output: [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]\r\n        Explanation: The figures above represent the grid at every state.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1505,"row":{"number":1915,"difficulty":1,"question":"class Solution:\r\n    def wonderfulSubstrings(self, word: str) -> int:\n        \"\"\"\n        A wonderful string is a string where at most one letter appears an odd number of times.\r\n            For example, \"ccjjc\" and \"abab\" are wonderful, but \"ab\" is not.\r\n        Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately.\r\n        A substring is a contiguous sequence of characters in a string.\r\n        Example 1:\r\n        Input: word = \"aba\"\r\n        Output: 4\r\n        Explanation: The four wonderful substrings are underlined below:\r\n        - \"aba\" -> \"a\"\r\n        - \"aba\" -> \"b\"\r\n        - \"aba\" -> \"a\"\r\n        - \"aba\" -> \"aba\"\r\n        Example 2:\r\n        Input: word = \"aabb\"\r\n        Output: 9\r\n        Explanation: The nine wonderful substrings are underlined below:\r\n        - \"aabb\" -> \"a\"\r\n        - \"aabb\" -> \"aa\"\r\n        - \"aabb\" -> \"aab\"\r\n        - \"aabb\" -> \"aabb\"\r\n        - \"aabb\" -> \"a\"\r\n        - \"aabb\" -> \"abb\"\r\n        - \"aabb\" -> \"b\"\r\n        - \"aabb\" -> \"bb\"\r\n        - \"aabb\" -> \"b\"\r\n        Example 3:\r\n        Input: word = \"he\"\r\n        Output: 2\r\n        Explanation: The two wonderful substrings are underlined below:\r\n        - \"he\" -> \"h\"\r\n        - \"he\" -> \"e\"\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1506,"row":{"number":1901,"difficulty":1,"question":"class Solution:\n    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:\n        \"\"\"\n        A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.\n        Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].\n        You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.\n        You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.\n        Example 1:\n        Input: mat = [[1,4],[3,2]]\n        Output: [0,1]\n        Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.\n        Example 2:\n        Input: mat = [[10,20,15],[21,30,14],[7,16,32]]\n        Output: [1,1]\n        Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1507,"row":{"number":1920,"difficulty":0,"question":"class Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\n        A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).\n        Example 1:\n        Input: nums = [0,2,1,5,3,4]\n        Output: [0,1,2,4,5,3]\n        Explanation: The array ans is built as follows: \n        ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n            = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n            = [0,1,2,4,5,3]\n        Example 2:\n        Input: nums = [5,0,1,2,3,4]\n        Output: [4,5,0,1,2,3]\n        Explanation: The array ans is built as follows:\n        ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n            = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n            = [4,5,0,1,2,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1508,"row":{"number":1921,"difficulty":1,"question":"class Solution:\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\n        \"\"\"\n        You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.\n        The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.\n        You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge.The weapon is fully charged at the very start.\n        You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.\n        Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.\n        Example 1:\n        Input: dist = [1,3,4], speed = [1,1,1]\n        Output: 3\n        Explanation:\n        In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.\n        After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.\n        After a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster.\n        All 3 monsters can be eliminated.\n        Example 2:\n        Input: dist = [1,1,2,3], speed = [1,1,1,1]\n        Output: 1\n        Explanation:\n        In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.\n        After a minute, the distances of the monsters are [X,0,1,2], so you lose.\n        You can only eliminate 1 monster.\n        Example 3:\n        Input: dist = [3,2,4], speed = [5,3,2]\n        Output: 1\n        Explanation:\n        In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.\n        After a minute, the distances of the monsters are [X,0,2], so you lose.\n        You can only eliminate 1 monster.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1509,"row":{"number":1922,"difficulty":1,"question":"class Solution:\n    def countGoodNumbers(self, n: int) -> int:\n        \"\"\"\n        A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\n            For example, \"2582\" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, \"3245\" is not good because 3 is at an even index but is not even.\n        Given an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\n        A digit string is a string consisting of digits 0 through 9 that may contain leading zeros.\n        Example 1:\n        Input: n = 1\n        Output: 5\n        Explanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".\n        Example 2:\n        Input: n = 4\n        Output: 400\n        Example 3:\n        Input: n = 50\n        Output: 564908303\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1510,"row":{"number":1923,"difficulty":2,"question":"class Solution:\n    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n        \"\"\"\n        There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities.\n        There are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively.\n        Given an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all.\n        A subpath of a path is a contiguous sequence of cities within that path.\n        Example 1:\n        Input: n = 5, paths = [[0,1,2,3,4],\n                               [2,3,4],\n                               [4,0,1,2,3]]\n        Output: 2\n        Explanation: The longest common subpath is [2,3].\n        Example 2:\n        Input: n = 3, paths = [[0],[1],[2]]\n        Output: 0\n        Explanation: There is no common subpath shared by the three paths.\n        Example 3:\n        Input: n = 5, paths = [[0,1,2,3,4],\n                               [4,3,2,1,0]]\n        Output: 1\n        Explanation: The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1511,"row":{"number":1941,"difficulty":0,"question":"class Solution:\n    def areOccurrencesEqual(self, s: str) -> bool:\n        \"\"\"\n        Given a string s, return true if s is a good string, or false otherwise.\n        A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).\n        Example 1:\n        Input: s = \"abacbc\"\n        Output: true\n        Explanation: The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s.\n        Example 2:\n        Input: s = \"aaabb\"\n        Output: false\n        Explanation: The characters that appear in s are 'a' and 'b'.\n        'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1512,"row":{"number":1942,"difficulty":1,"question":"class Solution:\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\n        \"\"\"\n        There is a party where n friends numbered from 0 to n - 1 are attending. There is an infinite number of chairs in this party that are numbered from 0 to infinity. When a friend arrives at the party, they sit on the unoccupied chair with the smallest number.\n            For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2.\n        When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair.\n        You are given a 0-indexed 2D integer array times where times[i] = [arrivali, leavingi], indicating the arrival and leaving times of the ith friend respectively, and an integer targetFriend. All arrival times are distinct.\n        Return the chair number that the friend numbered targetFriend will sit on.\n        Example 1:\n        Input: times = [[1,4],[2,3],[4,6]], targetFriend = 1\n        Output: 1\n        Explanation: \n        - Friend 0 arrives at time 1 and sits on chair 0.\n        - Friend 1 arrives at time 2 and sits on chair 1.\n        - Friend 1 leaves at time 3 and chair 1 becomes empty.\n        - Friend 0 leaves at time 4 and chair 0 becomes empty.\n        - Friend 2 arrives at time 4 and sits on chair 0.\n        Since friend 1 sat on chair 1, we return 1.\n        Example 2:\n        Input: times = [[3,10],[1,5],[2,6]], targetFriend = 0\n        Output: 2\n        Explanation: \n        - Friend 1 arrives at time 1 and sits on chair 0.\n        - Friend 2 arrives at time 2 and sits on chair 1.\n        - Friend 0 arrives at time 3 and sits on chair 2.\n        - Friend 1 leaves at time 5 and chair 0 becomes empty.\n        - Friend 2 leaves at time 6 and chair 1 becomes empty.\n        - Friend 0 leaves at time 10 and chair 2 becomes empty.\n        Since friend 0 sat on chair 2, we return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1513,"row":{"number":1943,"difficulty":1,"question":"class Solution:\n    def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a unique color. You are given a 2D integer array segments, where segments[i] = [starti, endi, colori] represents the half-closed segment [starti, endi) with colori as the color.\n        The colors in the overlapping segments of the painting were mixed when it was painted. When two or more colors mix, they form a new color that can be represented as a set of mixed colors.\n            For example, if colors 2, 4, and 6 are mixed, then the resulting mixed color is {2,4,6}.\n        For the sake of simplicity, you should only output the sum of the elements in the set rather than the full set.\n        You want to describe the painting with the minimum number of non-overlapping half-closed segments of these mixed colors. These segments can be represented by the 2D array painting where painting[j] = [leftj, rightj, mixj] describes a half-closed segment [leftj, rightj) with the mixed color sum of mixj.\n            For example, the painting created with segments = [[1,4,5],[1,7,7]] can be described by painting = [[1,4,12],[4,7,7]] because:\n                [1,4) is colored {5,7} (with a sum of 12) from both the first and second segments.\n                [4,7) is colored {7} from only the second segment.\n        Return the 2D array painting describing the finished painting (excluding any parts that are not painted). You may return the segments in any order.\n        A half-closed segment [a, b) is the section of the number line between points a and b including point a and not including point b.\n        Example 1:\n        Input: segments = [[1,4,5],[4,7,7],[1,7,9]]\n        Output: [[1,4,14],[4,7,16]]\n        Explanation: The painting can be described as follows:\n        - [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.\n        - [4,7) is colored {7,9} (with a sum of 16) from the second and third segments.\n        Example 2:\n        Input: segments = [[1,7,9],[6,8,15],[8,10,7]]\n        Output: [[1,6,9],[6,7,24],[7,8,15],[8,10,7]]\n        Explanation: The painting can be described as follows:\n        - [1,6) is colored 9 from the first segment.\n        - [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.\n        - [7,8) is colored 15 from the second segment.\n        - [8,10) is colored 7 from the third segment.\n        Example 3:\n        Input: segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]\n        Output: [[1,4,12],[4,7,12]]\n        Explanation: The painting can be described as follows:\n        - [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.\n        - [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.\n        Note that returning a single segment [1,7) is incorrect because the mixed color sets are different.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1514,"row":{"number":1929,"difficulty":0,"question":"class Solution:\n    def getConcatenation(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).\n        Specifically, ans is the concatenation of two nums arrays.\n        Return the array ans.\n        Example 1:\n        Input: nums = [1,2,1]\n        Output: [1,2,1,1,2,1]\n        Explanation: The array ans is formed as follows:\n        - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n        - ans = [1,2,1,1,2,1]\n        Example 2:\n        Input: nums = [1,3,2,1]\n        Output: [1,3,2,1,1,3,2,1]\n        Explanation: The array ans is formed as follows:\n        - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n        - ans = [1,3,2,1,1,3,2,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1515,"row":{"number":1930,"difficulty":1,"question":"class Solution:\n    def countPalindromicSubsequence(self, s: str) -> int:\n        \"\"\"\n        Given a string s, return the number of unique palindromes of length three that are a subsequence of s.\n        Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.\n        A palindrome is a string that reads the same forwards and backwards.\n        A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n            For example, \"ace\" is a subsequence of \"abcde\".\n        Example 1:\n        Input: s = \"aabca\"\n        Output: 3\n        Explanation: The 3 palindromic subsequences of length 3 are:\n        - \"aba\" (subsequence of \"aabca\")\n        - \"aaa\" (subsequence of \"aabca\")\n        - \"aca\" (subsequence of \"aabca\")\n        Example 2:\n        Input: s = \"adc\"\n        Output: 0\n        Explanation: There are no palindromic subsequences of length 3 in \"adc\".\n        Example 3:\n        Input: s = \"bbcbaba\"\n        Output: 4\n        Explanation: The 4 palindromic subsequences of length 3 are:\n        - \"bbb\" (subsequence of \"bbcbaba\")\n        - \"bcb\" (subsequence of \"bbcbaba\")\n        - \"bab\" (subsequence of \"bbcbaba\")\n        - \"aba\" (subsequence of \"bbcbaba\")\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1516,"row":{"number":1932,"difficulty":2,"question":"class Solution:\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\n        \"\"\"\n        You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can:\n            Select two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j].\n            Replace the leaf node in trees[i] with trees[j].\n            Remove trees[j] from trees.\n        Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST.\n        A BST (binary search tree) is a binary tree where each node satisfies the following property:\n            Every node in the node's left subtree has a value strictly less than the node's value.\n            Every node in the node's right subtree has a value strictly greater than the node's value.\n        A leaf is a node that has no children.\n        Example 1:\n        Input: trees = [[2,1],[3,2,5],[5,4]]\n        Output: [3,2,5,1,null,4]\n        Explanation:\n        In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].\n        Delete trees[0], so trees = [[3,2,5,1],[5,4]].\n        In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].\n        Delete trees[1], so trees = [[3,2,5,1,null,4]].\n        The resulting tree, shown above, is a valid BST, so return its root.\n        Example 2:\n        Input: trees = [[5,3,8],[3,2,6]]\n        Output: []\n        Explanation:\n        Pick i=0 and j=1 and merge trees[1] into trees[0].\n        Delete trees[1], so trees = [[5,3,8,2,6]].\n        The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.\n        Example 3:\n        Input: trees = [[5,4],[3]]\n        Output: []\n        Explanation: It is impossible to perform any operations.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1517,"row":{"number":1931,"difficulty":2,"question":"class Solution:\n    def colorTheGrid(self, m: int, n: int) -> int:\n        \"\"\"\n        You are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted.\n        Return the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: m = 1, n = 1\n        Output: 3\n        Explanation: The three possible colorings are shown in the image above.\n        Example 2:\n        Input: m = 1, n = 2\n        Output: 6\n        Explanation: The six possible colorings are shown in the image above.\n        Example 3:\n        Input: m = 5, n = 5\n        Output: 580986\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1518,"row":{"number":1936,"difficulty":1,"question":"class Solution:\n    def addRungs(self, rungs: List[int], dist: int) -> int:\n        \"\"\"\n        You are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung.\n        You are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. You are able to insert rungs at any positive integer height if a rung is not already there.\n        Return the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.\n        Example 1:\n        Input: rungs = [1,3,5,10], dist = 2\n        Output: 2\n        Explanation:\n        You currently cannot reach the last rung.\n        Add rungs at heights 7 and 8 to climb this ladder. \n        The ladder will now have rungs at [1,3,5,7,8,10].\n        Example 2:\n        Input: rungs = [3,6,8,10], dist = 3\n        Output: 0\n        Explanation:\n        This ladder can be climbed without adding additional rungs.\n        Example 3:\n        Input: rungs = [3,4,6,7], dist = 2\n        Output: 1\n        Explanation:\n        You currently cannot reach the first rung from the ground.\n        Add a rung at height 1 to climb this ladder.\n        The ladder will now have rungs at [1,3,4,6,7].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1519,"row":{"number":1937,"difficulty":1,"question":"class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix.\n        To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score.\n        However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.\n        Return the maximum number of points you can achieve.\n        abs(x) is defined as:\n            x for x >= 0.\n            -x for x < 0.\n        Example 1: \n        Input: points = [[1,2,3],[1,5,1],[3,1,1]]\n        Output: 9\n        Explanation:\n        The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\n        You add 3 + 5 + 3 = 11 to your score.\n        However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\n        Your final score is 11 - 2 = 9.\n        Example 2:\n        Input: points = [[1,5],[2,3],[4,2]]\n        Output: 11\n        Explanation:\n        The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\n        You add 5 + 3 + 4 = 12 to your score.\n        However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\n        Your final score is 12 - 1 = 11.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1520,"row":{"number":1938,"difficulty":2,"question":"class Solution:\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        There is a rooted tree consisting of n nodes numbered 0 to n - 1. Each node's number denotes its unique genetic value (i.e. the genetic value of node x is x). The genetic difference between two genetic values is defined as the bitwise-XOR of their values. You are given the integer array parents, where parents[i] is the parent for node i. If node x is the root of the tree, then parents[x] == -1.\n        You are also given the array queries where queries[i] = [nodei, vali]. For each query i, find the maximum genetic difference between vali and pi, where pi is the genetic value of any node that is on the path between nodei and the root (including nodei and the root). More formally, you want to maximize vali XOR pi.\n        Return an array ans where ans[i] is the answer to the ith query.\n        Example 1:\n        Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]\n        Output: [2,3,7]\n        Explanation: The queries are processed as follows:\n        - [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.\n        - [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.\n        - [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n        Example 2:\n        Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]\n        Output: [6,14,7]\n        Explanation: The queries are processed as follows:\n        - [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.\n        - [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.\n        - [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1521,"row":{"number":1945,"difficulty":0,"question":"class Solution:\n    def getLucky(self, s: str, k: int) -> int:\n        \"\"\"\n        You are given a string s consisting of lowercase English letters, and an integer k.\n        First, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.\n        For example, if s = \"zbax\" and k = 2, then the resulting integer would be 8 by the following operations:\n            Convert: \"zbax\" ➝ \"(26)(2)(1)(24)\" ➝ \"262124\" ➝ 262124\n            Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17\n            Transform #2: 17 ➝ 1 + 7 ➝ 8\n        Return the resulting integer after performing the operations described above.\n        Example 1:\n        Input: s = \"iiii\", k = 1\n        Output: 36\n        Explanation: The operations are as follows:\n        - Convert: \"iiii\" ➝ \"(9)(9)(9)(9)\" ➝ \"9999\" ➝ 9999\n        - Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36\n        Thus the resulting integer is 36.\n        Example 2:\n        Input: s = \"leetcode\", k = 2\n        Output: 6\n        Explanation: The operations are as follows:\n        - Convert: \"leetcode\" ➝ \"(12)(5)(5)(20)(3)(15)(4)(5)\" ➝ \"12552031545\" ➝ 12552031545\n        - Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33\n        - Transform #2: 33 ➝ 3 + 3 ➝ 6\n        Thus the resulting integer is 6.\n        Example 3:\n        Input: s = \"zbax\", k = 2\n        Output: 8\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1522,"row":{"number":1946,"difficulty":1,"question":"class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        \"\"\"\n        You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\n        You may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\n        Return a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\n        A substring is a contiguous sequence of characters within the string.\n        Example 1:\n        Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\n        Output: \"832\"\n        Explanation: Replace the substring \"1\":\n        - 1 maps to change[1] = 8.\n        Thus, \"132\" becomes \"832\".\n        \"832\" is the largest number that can be created, so return it.\n        Example 2:\n        Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\n        Output: \"934\"\n        Explanation: Replace the substring \"021\":\n        - 0 maps to change[0] = 9.\n        - 2 maps to change[2] = 3.\n        - 1 maps to change[1] = 4.\n        Thus, \"021\" becomes \"934\".\n        \"934\" is the largest number that can be created, so return it.\n        Example 3:\n        Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\n        Output: \"5\"\n        Explanation: \"5\" is already the largest number that can be created, so return it.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1523,"row":{"number":1947,"difficulty":1,"question":"class Solution:\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\n        \"\"\"\n        There is a survey that consists of n questions where each question's answer is either 0 (no) or 1 (yes).\n        The survey was given to m students numbered from 0 to m - 1 and m mentors numbered from 0 to m - 1. The answers of the students are represented by a 2D integer array students where students[i] is an integer array that contains the answers of the ith student (0-indexed). The answers of the mentors are represented by a 2D integer array mentors where mentors[j] is an integer array that contains the answers of the jth mentor (0-indexed).\n        Each student will be assigned to one mentor, and each mentor will have one student assigned to them. The compatibility score of a student-mentor pair is the number of answers that are the same for both the student and the mentor.\n            For example, if the student's answers were [1, 0, 1] and the mentor's answers were [0, 0, 1], then their compatibility score is 2 because only the second and the third answers are the same.\n        You are tasked with finding the optimal student-mentor pairings to maximize the sum of the compatibility scores.\n        Given students and mentors, return the maximum compatibility score sum that can be achieved.\n        Example 1:\n        Input: students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]\n        Output: 8\n        Explanation: We assign students to mentors in the following way:\n        - student 0 to mentor 2 with a compatibility score of 3.\n        - student 1 to mentor 0 with a compatibility score of 2.\n        - student 2 to mentor 1 with a compatibility score of 3.\n        The compatibility score sum is 3 + 2 + 3 = 8.\n        Example 2:\n        Input: students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]\n        Output: 0\n        Explanation: The compatibility score of any student-mentor pair is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1524,"row":{"number":1948,"difficulty":2,"question":"class Solution:\n    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:\n        \"\"\"\n        Due to a bug, there are many duplicate folders in a file system. You are given a 2D array paths, where paths[i] is an array representing an absolute path to the ith folder in the file system.\n            For example, [\"one\", \"two\", \"three\"] represents the path \"/one/two/three\".\n        Two folders (not necessarily on the same level) are identical if they contain the same non-empty set of identical subfolders and underlying subfolder structure. The folders do not need to be at the root level to be identical. If two or more folders are identical, then mark the folders as well as all their subfolders.\n            For example, folders \"/a\" and \"/b\" in the file structure below are identical. They (as well as their subfolders) should all be marked:\n                /a\n                /a/x\n                /a/x/y\n                /a/z\n                /b\n                /b/x\n                /b/x/y\n                /b/z\n            However, if the file structure also included the path \"/b/w\", then the folders \"/a\" and \"/b\" would not be identical. Note that \"/a/x\" and \"/b/x\" would still be considered identical even with the added folder.\n        Once all the identical folders and their subfolders have been marked, the file system will delete all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted.\n        Return the 2D array ans containing the paths of the remaining folders after deleting all the marked folders. The paths may be returned in any order.\n        Example 1:\n        Input: paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]\n        Output: [[\"d\"],[\"d\",\"a\"]]\n        Explanation: The file structure is as shown.\n        Folders \"/a\" and \"/c\" (and their subfolders) are marked for deletion because they both contain an empty\n        folder named \"b\".\n        Example 2:\n        Input: paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]\n        Output: [[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]]\n        Explanation: The file structure is as shown. \n        Folders \"/a/b/x\" and \"/w\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"y\".\n        Note that folders \"/a\" and \"/c\" are identical after the deletion, but they are not deleted because they were not marked beforehand.\n        Example 3:\n        Input: paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]\n        Output: [[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]]\n        Explanation: All folders are unique in the file system.\n        Note that the returned array can be in a different order as the order does not matter.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1525,"row":{"number":1958,"difficulty":1,"question":"class Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\n        \"\"\"\n        You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. On the board, free cells are represented by '.', white cells are represented by 'W', and black cells are represented by 'B'.\n        Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal).\n        A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, and the remaining cells in the middle are the opposite color (no cells in the line are free). You can find examples for good lines in the figure below:\n        Given two integers rMove and cMove and a character color representing the color you are playing as (white or black), return true if changing cell (rMove, cMove) to color color is a legal move, or false if it is not legal.\n        Example 1:\n        Input: board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\"\n        Output: true\n        Explanation: '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'.\n        The two good lines with the chosen cell as an endpoint are annotated above with the red rectangles.\n        Example 2:\n        Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\"\n        Output: false\n        Explanation: While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1526,"row":{"number":1959,"difficulty":1,"question":"class Solution:\n    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are currently designing a dynamic array. You are given a 0-indexed integer array nums, where nums[i] is the number of elements that will be in the array at time i. In addition, you are given an integer k, the maximum number of times you can resize the array (to any size).\n        The size of the array at time t, sizet, must be at least nums[t] because there needs to be enough space in the array to hold all the elements. The space wasted at time t is defined as sizet - nums[t], and the total space wasted is the sum of the space wasted across every time t where 0 <= t < nums.length.\n        Return the minimum total space wasted if you can resize the array at most k times.\n        Note: The array can have any size at the start and does not count towards the number of resizing operations.\n        Example 1:\n        Input: nums = [10,20], k = 0\n        Output: 10\n        Explanation: size = [20,20].\n        We can set the initial size to be 20.\n        The total wasted space is (20 - 10) + (20 - 20) = 10.\n        Example 2:\n        Input: nums = [10,20,30], k = 1\n        Output: 10\n        Explanation: size = [20,20,30].\n        We can set the initial size to be 20 and resize to 30 at time 2. \n        The total wasted space is (20 - 10) + (20 - 20) + (30 - 30) = 10.\n        Example 3:\n        Input: nums = [10,20,15,30,20], k = 2\n        Output: 15\n        Explanation: size = [10,20,20,30,30].\n        We can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3.\n        The total wasted space is (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1527,"row":{"number":1952,"difficulty":0,"question":"class Solution:\n    def isThree(self, n: int) -> bool:\n        \"\"\"\n        Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.\n        An integer m is a divisor of n if there exists an integer k such that n = k * m.\n        Example 1:\n        Input: n = 2\n        Output: false\n        Explantion: 2 has only two divisors: 1 and 2.\n        Example 2:\n        Input: n = 4\n        Output: true\n        Explantion: 4 has three divisors: 1, 2, and 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1528,"row":{"number":1953,"difficulty":1,"question":"class Solution:\n    def numberOfWeeks(self, milestones: List[int]) -> int:\n        \"\"\"\n        There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has.\n        You can work on the projects following these two rules:\n            Every week, you will finish exactly one milestone of one project. You must work every week.\n            You cannot work on two milestones from the same project for two consecutive weeks.\n        Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints.\n        Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.\n        Example 1:\n        Input: milestones = [1,2,3]\n        Output: 6\n        Explanation: One possible scenario is:\n        ​​​​- During the 1st week, you will work on a milestone of project 0.\n        - During the 2nd week, you will work on a milestone of project 2.\n        - During the 3rd week, you will work on a milestone of project 1.\n        - During the 4th week, you will work on a milestone of project 2.\n        - During the 5th week, you will work on a milestone of project 1.\n        - During the 6th week, you will work on a milestone of project 2.\n        The total number of weeks is 6.\n        Example 2:\n        Input: milestones = [5,2,1]\n        Output: 7\n        Explanation: One possible scenario is:\n        - During the 1st week, you will work on a milestone of project 0.\n        - During the 2nd week, you will work on a milestone of project 1.\n        - During the 3rd week, you will work on a milestone of project 0.\n        - During the 4th week, you will work on a milestone of project 1.\n        - During the 5th week, you will work on a milestone of project 0.\n        - During the 6th week, you will work on a milestone of project 2.\n        - During the 7th week, you will work on a milestone of project 0.\n        The total number of weeks is 7.\n        Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules.\n        Thus, one milestone in project 0 will remain unfinished.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1529,"row":{"number":1968,"difficulty":1,"question":"class Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\n        More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\n        Return any rearrangement of nums that meets the requirements.\n        Example 1:\n        Input: nums = [1,2,3,4,5]\n        Output: [1,2,4,5,3]\n        Explanation:\n        When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\n        When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\n        When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.\n        Example 2:\n        Input: nums = [6,2,0,9,7]\n        Output: [9,7,6,2,0]\n        Explanation:\n        When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\n        When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\n        When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1530,"row":{"number":1955,"difficulty":2,"question":"class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        \"\"\"\n        A sequence is special if it consists of a positive number of 0s, followed by a positive number of 1s, then a positive number of 2s.\n            For example, [0,1,2] and [0,0,1,1,1,2] are special.\n            In contrast, [2,1,0], [1], and [0,1,2,0] are not special.\n        Given an array nums (consisting of only integers 0, 1, and 2), return the number of different subsequences that are special. Since the answer may be very large, return it modulo 109 + 7.\n        A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are different if the set of indices chosen are different.\n        Example 1:\n        Input: nums = [0,1,2,2]\n        Output: 3\n        Explanation: The special subsequences are bolded [0,1,2,2], [0,1,2,2], and [0,1,2,2].\n        Example 2:\n        Input: nums = [2,2,0,0]\n        Output: 0\n        Explanation: There are no special subsequences in [2,2,0,0].\n        Example 3:\n        Input: nums = [0,1,2,0,1,2]\n        Output: 7\n        Explanation: The special subsequences are bolded:\n        - [0,1,2,0,1,2]\n        - [0,1,2,0,1,2]\n        - [0,1,2,0,1,2]\n        - [0,1,2,0,1,2]\n        - [0,1,2,0,1,2]\n        - [0,1,2,0,1,2]\n        - [0,1,2,0,1,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1531,"row":{"number":1974,"difficulty":0,"question":"class Solution:\n    def minTimeToType(self, word: str) -> int:\n        \"\"\"\n        There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'.\n        Each second, you may perform one of the following operations:\n            Move the pointer one character counterclockwise or clockwise.\n            Type the character the pointer is currently on.\n        Given a string word, return the minimum number of seconds to type out the characters in word.\n        Example 1:\n        Input: word = \"abc\"\n        Output: 5\n        Explanation: \n        The characters are printed as follows:\n        - Type the character 'a' in 1 second since the pointer is initially on 'a'.\n        - Move the pointer clockwise to 'b' in 1 second.\n        - Type the character 'b' in 1 second.\n        - Move the pointer clockwise to 'c' in 1 second.\n        - Type the character 'c' in 1 second.\n        Example 2:\n        Input: word = \"bza\"\n        Output: 7\n        Explanation:\n        The characters are printed as follows:\n        - Move the pointer clockwise to 'b' in 1 second.\n        - Type the character 'b' in 1 second.\n        - Move the pointer counterclockwise to 'z' in 2 seconds.\n        - Type the character 'z' in 1 second.\n        - Move the pointer clockwise to 'a' in 1 second.\n        - Type the character 'a' in 1 second.\n        Example 3:\n        Input: word = \"zjpc\"\n        Output: 34\n        Explanation:\n        The characters are printed as follows:\n        - Move the pointer counterclockwise to 'z' in 1 second.\n        - Type the character 'z' in 1 second.\n        - Move the pointer clockwise to 'j' in 10 seconds.\n        - Type the character 'j' in 1 second.\n        - Move the pointer clockwise to 'p' in 6 seconds.\n        - Type the character 'p' in 1 second.\n        - Move the pointer counterclockwise to 'c' in 13 seconds.\n        - Type the character 'c' in 1 second.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1532,"row":{"number":1975,"difficulty":1,"question":"class Solution:\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n integer matrix. You can do the following operation any number of times:\n            Choose any two adjacent elements of matrix and multiply each of them by -1.\n        Two elements are considered adjacent if and only if they share a border.\n        Your goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.\n        Example 1:\n        Input: matrix = [[1,-1],[-1,1]]\n        Output: 4\n        Explanation: We can follow the following steps to reach sum equals 4:\n        - Multiply the 2 elements in the first row by -1.\n        - Multiply the 2 elements in the first column by -1.\n        Example 2:\n        Input: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\n        Output: 16\n        Explanation: We can follow the following step to reach sum equals 16:\n        - Multiply the 2 last elements in the second row by -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1533,"row":{"number":1976,"difficulty":1,"question":"class Solution:\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\n        \"\"\"\n        You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n        You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.\n        Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\n        Output: 4\n        Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\n        The four ways to get there in 7 minutes are:\n        - 0 ➝ 6\n        - 0 ➝ 4 ➝ 6\n        - 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n        - 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\n        Example 2:\n        Input: n = 2, roads = [[1,0,10]]\n        Output: 1\n        Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1534,"row":{"number":1977,"difficulty":2,"question":"class Solution:\n    def numberOfCombinations(self, num: str) -> int:\n        \"\"\"\n        You wrote down many positive integers in a string called num. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was non-decreasing and that no integer had leading zeros.\n        Return the number of possible lists of integers that you could have written down to get the string num. Since the answer may be large, return it modulo 109 + 7.\n        Example 1:\n        Input: num = \"327\"\n        Output: 2\n        Explanation: You could have written down the numbers:\n        3, 27\n        327\n        Example 2:\n        Input: num = \"094\"\n        Output: 0\n        Explanation: No numbers can have leading zeros and all numbers must be positive.\n        Example 3:\n        Input: num = \"0\"\n        Output: 0\n        Explanation: No numbers can have leading zeros and all numbers must be positive.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1535,"row":{"number":1961,"difficulty":0,"question":"class Solution:\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\n        \"\"\"\n        Given a string s and an array of strings words, determine whether s is a prefix string of words.\n        A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.\n        Return true if s is a prefix string of words, or false otherwise.\n        Example 1:\n        Input: s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"]\n        Output: true\n        Explanation:\n        s can be made by concatenating \"i\", \"love\", and \"leetcode\" together.\n        Example 2:\n        Input: s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"]\n        Output: false\n        Explanation:\n        It is impossible to make s using a prefix of arr.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1536,"row":{"number":1962,"difficulty":1,"question":"class Solution:\n    def minStoneSum(self, piles: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:\n            Choose any piles[i] and remove floor(piles[i] / 2) stones from it.\n        Notice that you can apply the operation on the same pile more than once.\n        Return the minimum possible total number of stones remaining after applying the k operations.\n        floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\n        Example 1:\n        Input: piles = [5,4,9], k = 2\n        Output: 12\n        Explanation: Steps of a possible scenario are:\n        - Apply the operation on pile 2. The resulting piles are [5,4,5].\n        - Apply the operation on pile 0. The resulting piles are [3,4,5].\n        The total number of stones in [3,4,5] is 12.\n        Example 2:\n        Input: piles = [4,3,6,7], k = 3\n        Output: 12\n        Explanation: Steps of a possible scenario are:\n        - Apply the operation on pile 2. The resulting piles are [4,3,3,7].\n        - Apply the operation on pile 3. The resulting piles are [4,3,3,4].\n        - Apply the operation on pile 0. The resulting piles are [2,3,3,4].\n        The total number of stones in [2,3,3,4] is 12.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1537,"row":{"number":1963,"difficulty":1,"question":"class Solution:\n    def minSwaps(self, s: str) -> int:\n        \"\"\"\n        You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\n        A string is called balanced if and only if:\n            It is the empty string, or\n            It can be written as AB, where both A and B are balanced strings, or\n            It can be written as [C], where C is a balanced string.\n        You may swap the brackets at any two indices any number of times.\n        Return the minimum number of swaps to make s balanced.\n        Example 1:\n        Input: s = \"][][\"\n        Output: 1\n        Explanation: You can make the string balanced by swapping index 0 with index 3.\n        The resulting string is \"[[]]\".\n        Example 2:\n        Input: s = \"]]][[[\"\n        Output: 2\n        Explanation: You can do the following to make the string balanced:\n        - Swap index 0 with index 4. s = \"[]][][\".\n        - Swap index 1 with index 5. s = \"[[][]]\".\n        The resulting string is \"[[][]]\".\n        Example 3:\n        Input: s = \"[]\"\n        Output: 0\n        Explanation: The string is already balanced.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1538,"row":{"number":1964,"difficulty":2,"question":"class Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        \"\"\"\n        You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\n        For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n            You choose any number of obstacles between 0 and i inclusive.\n            You must include the ith obstacle in the course.\n            You must put the chosen obstacles in the same order as they appear in obstacles.\n            Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\n        Return an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.\n        Example 1:\n        Input: obstacles = [1,2,3,2]\n        Output: [1,2,3,3]\n        Explanation: The longest valid obstacle course at each position is:\n        - i = 0: [1], [1] has length 1.\n        - i = 1: [1,2], [1,2] has length 2.\n        - i = 2: [1,2,3], [1,2,3] has length 3.\n        - i = 3: [1,2,3,2], [1,2,2] has length 3.\n        Example 2:\n        Input: obstacles = [2,2,1]\n        Output: [1,2,1]\n        Explanation: The longest valid obstacle course at each position is:\n        - i = 0: [2], [2] has length 1.\n        - i = 1: [2,2], [2,2] has length 2.\n        - i = 2: [2,2,1], [1] has length 1.\n        Example 3:\n        Input: obstacles = [3,1,5,6,4,2]\n        Output: [1,1,2,3,2,2]\n        Explanation: The longest valid obstacle course at each position is:\n        - i = 0: [3], [3] has length 1.\n        - i = 1: [3,1], [1] has length 1.\n        - i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n        - i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n        - i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n        - i = 5: [3,1,5,6,4,2], [1,2] has length 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1539,"row":{"number":1967,"difficulty":0,"question":"class Solution:\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\n        \"\"\"\n        Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\"\n        Output: 3\n        Explanation:\n        - \"a\" appears as a substring in \"abc\".\n        - \"abc\" appears as a substring in \"abc\".\n        - \"bc\" appears as a substring in \"abc\".\n        - \"d\" does not appear as a substring in \"abc\".\n        3 of the strings in patterns appear as a substring in word.\n        Example 2:\n        Input: patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\"\n        Output: 2\n        Explanation:\n        - \"a\" appears as a substring in \"aaaaabbbbb\".\n        - \"b\" appears as a substring in \"aaaaabbbbb\".\n        - \"c\" does not appear as a substring in \"aaaaabbbbb\".\n        2 of the strings in patterns appear as a substring in word.\n        Example 3:\n        Input: patterns = [\"a\",\"a\",\"a\"], word = \"ab\"\n        Output: 3\n        Explanation: Each of the patterns appears as a substring in word \"ab\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1540,"row":{"number":1969,"difficulty":1,"question":"class Solution:\n    def minNonZeroProduct(self, p: int) -> int:\n        \"\"\"\n        You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2p - 1] in their binary representations. You are allowed to do the following operation any number of times:\n            Choose two elements x and y from nums.\n            Choose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.\n        For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.\n        Find the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.\n        Note: The answer should be the minimum product before the modulo operation is done.\n        Example 1:\n        Input: p = 1\n        Output: 1\n        Explanation: nums = [1].\n        There is only one element, so the product equals that element.\n        Example 2:\n        Input: p = 2\n        Output: 6\n        Explanation: nums = [01, 10, 11].\n        Any swap would either make the product 0 or stay the same.\n        Thus, the array product of 1 * 2 * 3 = 6 is already minimized.\n        Example 3:\n        Input: p = 3\n        Output: 1512\n        Explanation: nums = [001, 010, 011, 100, 101, 110, 111]\n        - In the first operation we can swap the leftmost bit of the second and fifth elements.\n            - The resulting array is [001, 110, 011, 100, 001, 110, 111].\n        - In the second operation we can swap the middle bit of the third and fourth elements.\n            - The resulting array is [001, 110, 001, 110, 001, 110, 111].\n        The array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1541,"row":{"number":1970,"difficulty":2,"question":"class Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:\n        \"\"\"\n        There is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively.\n        Initially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1).\n        You want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down).\n        Return the last day where it is possible to walk from the top to the bottom by only walking on land cells.\n        Example 1:\n        Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\n        Output: 2\n        Explanation: The above image depicts how the matrix changes each day starting from day 0.\n        The last day where it is possible to cross from top to bottom is on day 2.\n        Example 2:\n        Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\n        Output: 1\n        Explanation: The above image depicts how the matrix changes each day starting from day 0.\n        The last day where it is possible to cross from top to bottom is on day 1.\n        Example 3:\n        Input: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\n        Output: 3\n        Explanation: The above image depicts how the matrix changes each day starting from day 0.\n        The last day where it is possible to cross from top to bottom is on day 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1542,"row":{"number":1991,"difficulty":0,"question":"class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\n        A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\n        If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\n        Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.\n        Example 1:\n        Input: nums = [2,3,-1,8,4]\n        Output: 3\n        Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\n        The sum of the numbers after index 3 is: 4 = 4\n        Example 2:\n        Input: nums = [1,-1,4]\n        Output: 2\n        Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0\n        The sum of the numbers after index 2 is: 0\n        Example 3:\n        Input: nums = [2,5]\n        Output: -1\n        Explanation: There is no valid middleIndex.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1543,"row":{"number":1992,"difficulty":1,"question":"class Solution:\n    def findFarmland(self, land: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\n        To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\n        land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\n        Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\n        Example 1:\n        Input: land = [[1,0,0],[0,1,1],[0,1,1]]\n        Output: [[0,0,0,0],[1,1,2,2]]\n        Explanation:\n        The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].\n        The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].\n        Example 2:\n        Input: land = [[1,1],[1,1]]\n        Output: [[0,0,1,1]]\n        Explanation:\n        The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].\n        Example 3:\n        Input: land = [[0]]\n        Output: []\n        Explanation:\n        There are no groups of farmland.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1544,"row":{"number":1993,"difficulty":1,"question":"class LockingTree:\n    def __init__(self, parent: List[int]):\n    def lock(self, num: int, user: int) -> bool:\n    def unlock(self, num: int, user: int) -> bool:\n    def upgrade(self, num: int, user: int) -> bool:\n        \"\"\"\n        You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of the ith node. The root of the tree is node 0, so parent[0] = -1 since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.\n        The data structure should support the following functions:\n            Lock: Locks the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.\n            Unlock: Unlocks the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.\n            Upgrade: Locks the given node for the given user and unlocks all of its descendants regardless of who locked it. You may only upgrade a node if all 3 conditions are true:\n                The node is unlocked,\n                It has at least one locked descendant (by any user), and\n                It does not have any locked ancestors.\n        Implement the LockingTree class:\n            LockingTree(int[] parent) initializes the data structure with the parent array.\n            lock(int num, int user) returns true if it is possible for the user with id user to lock the node num, or false otherwise. If it is possible, the node num will become locked by the user with id user.\n            unlock(int num, int user) returns true if it is possible for the user with id user to unlock the node num, or false otherwise. If it is possible, the node num will become unlocked.\n            upgrade(int num, int user) returns true if it is possible for the user with id user to upgrade the node num, or false otherwise. If it is possible, the node num will be upgraded.\n        Example 1:\n        Input\n        [\"LockingTree\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\"]\n        [[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n        Output\n        [null, true, false, true, true, true, false]\n        Explanation\n        LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\n        lockingTree.lock(2, 2);    // return true because node 2 is unlocked.\n                                   // Node 2 will now be locked by user 2.\n        lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.\n        lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.\n                                   // Node 2 will now be unlocked.\n        lockingTree.lock(4, 5);    // return true because node 4 is unlocked.\n                                   // Node 4 will now be locked by user 5.\n        lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                                   // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\n        lockingTree.lock(0, 1);    // return false because node 0 is already locked.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1545,"row":{"number":1994,"difficulty":2,"question":"class Solution:\n    def numberOfGoodSubsets(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers.\n            For example, if nums = [1, 2, 3, 4]:\n                [2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3, 6 = 2*3, and 3 = 3 respectively.\n                [1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2 respectively.\n        Return the number of different good subsets in nums modulo 109 + 7.\n        A subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\n        Example 1:\n        Input: nums = [1,2,3,4]\n        Output: 6\n        Explanation: The good subsets are:\n        - [1,2]: product is 2, which is the product of distinct prime 2.\n        - [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.\n        - [1,3]: product is 3, which is the product of distinct prime 3.\n        - [2]: product is 2, which is the product of distinct prime 2.\n        - [2,3]: product is 6, which is the product of distinct primes 2 and 3.\n        - [3]: product is 3, which is the product of distinct prime 3.\n        Example 2:\n        Input: nums = [4,2,3,15]\n        Output: 5\n        Explanation: The good subsets are:\n        - [2]: product is 2, which is the product of distinct prime 2.\n        - [2,3]: product is 6, which is the product of distinct primes 2 and 3.\n        - [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.\n        - [3]: product is 3, which is the product of distinct prime 3.\n        - [15]: product is 15, which is the product of distinct primes 3 and 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1546,"row":{"number":1979,"difficulty":0,"question":"class Solution:\n    def findGCD(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.\n        The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.\n        Example 1:\n        Input: nums = [2,5,6,9,10]\n        Output: 2\n        Explanation:\n        The smallest number in nums is 2.\n        The largest number in nums is 10.\n        The greatest common divisor of 2 and 10 is 2.\n        Example 2:\n        Input: nums = [7,5,6,8,3]\n        Output: 1\n        Explanation:\n        The smallest number in nums is 3.\n        The largest number in nums is 8.\n        The greatest common divisor of 3 and 8 is 1.\n        Example 3:\n        Input: nums = [3,3]\n        Output: 3\n        Explanation:\n        The smallest number in nums is 3.\n        The largest number in nums is 3.\n        The greatest common divisor of 3 and 3 is 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1547,"row":{"number":1980,"difficulty":1,"question":"class Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\n        \"\"\"\n        Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.\n        Example 1:\n        Input: nums = [\"01\",\"10\"]\n        Output: \"11\"\n        Explanation: \"11\" does not appear in nums. \"00\" would also be correct.\n        Example 2:\n        Input: nums = [\"00\",\"01\"]\n        Output: \"11\"\n        Explanation: \"11\" does not appear in nums. \"10\" would also be correct.\n        Example 3:\n        Input: nums = [\"111\",\"011\",\"001\"]\n        Output: \"101\"\n        Explanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1548,"row":{"number":1981,"difficulty":1,"question":"class Solution:\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\n        \"\"\"\n        You are given an m x n integer matrix mat and an integer target.\n        Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized.\n        Return the minimum absolute difference.\n        The absolute difference between two numbers a and b is the absolute value of a - b.\n        Example 1:\n        Input: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13\n        Output: 0\n        Explanation: One possible choice is to:\n        - Choose 1 from the first row.\n        - Choose 5 from the second row.\n        - Choose 7 from the third row.\n        The sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.\n        Example 2:\n        Input: mat = [[1],[2],[3]], target = 100\n        Output: 94\n        Explanation: The best possible choice is to:\n        - Choose 1 from the first row.\n        - Choose 2 from the second row.\n        - Choose 3 from the third row.\n        The sum of the chosen elements is 6, and the absolute difference is 94.\n        Example 3:\n        Input: mat = [[1,2,9,8,7]], target = 6\n        Output: 1\n        Explanation: The best choice is to choose 7 from the first row.\n        The absolute difference is 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1549,"row":{"number":1982,"difficulty":2,"question":"class Solution:\n    def recoverArray(self, n: int, sums: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer n representing the length of an unknown array that you are trying to recover. You are also given an array sums containing the values of all 2n subset sums of the unknown array (in no particular order).\n        Return the array ans of length n representing the unknown array. If multiple answers exist, return any of them.\n        An array sub is a subset of an array arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. The sum of the elements in sub is one possible subset sum of arr. The sum of an empty array is considered to be 0.\n        Note: Test cases are generated such that there will always be at least one correct answer.\n        Example 1:\n        Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3]\n        Output: [1,2,-3]\n        Explanation: [1,2,-3] is able to achieve the given subset sums:\n        - []: sum is 0\n        - [1]: sum is 1\n        - [2]: sum is 2\n        - [1,2]: sum is 3\n        - [-3]: sum is -3\n        - [1,-3]: sum is -2\n        - [2,-3]: sum is -1\n        - [1,2,-3]: sum is 0\n        Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted.\n        Example 2:\n        Input: n = 2, sums = [0,0,0,0]\n        Output: [0,0]\n        Explanation: The only correct answer is [0,0].\n        Example 3:\n        Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]\n        Output: [0,-1,4,5]\n        Explanation: [0,-1,4,5] is able to achieve the given subset sums.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1550,"row":{"number":1984,"difficulty":0,"question":"class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\n        Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\n        Return the minimum possible difference.\n        Example 1:\n        Input: nums = [90], k = 1\n        Output: 0\n        Explanation: There is one way to pick score(s) of one student:\n        - [90]. The difference between the highest and lowest score is 90 - 90 = 0.\n        The minimum possible difference is 0.\n        Example 2:\n        Input: nums = [9,4,1,7], k = 2\n        Output: 2\n        Explanation: There are six ways to pick score(s) of two students:\n        - [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n        - [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n        - [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n        - [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n        - [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n        - [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\n        The minimum possible difference is 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1551,"row":{"number":1985,"difficulty":1,"question":"class Solution:\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        \"\"\"\n        You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.\n        Return the string that represents the kth largest integer in nums.\n        Note: Duplicate numbers should be counted distinctly. For example, if nums is [\"1\",\"2\",\"2\"], \"2\" is the first largest integer, \"2\" is the second-largest integer, and \"1\" is the third-largest integer.\n        Example 1:\n        Input: nums = [\"3\",\"6\",\"7\",\"10\"], k = 4\n        Output: \"3\"\n        Explanation:\n        The numbers in nums sorted in non-decreasing order are [\"3\",\"6\",\"7\",\"10\"].\n        The 4th largest integer in nums is \"3\".\n        Example 2:\n        Input: nums = [\"2\",\"21\",\"12\",\"1\"], k = 3\n        Output: \"2\"\n        Explanation:\n        The numbers in nums sorted in non-decreasing order are [\"1\",\"2\",\"12\",\"21\"].\n        The 3rd largest integer in nums is \"2\".\n        Example 3:\n        Input: nums = [\"0\",\"0\"], k = 2\n        Output: \"0\"\n        Explanation:\n        The numbers in nums sorted in non-decreasing order are [\"0\",\"0\"].\n        The 2nd largest integer in nums is \"0\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1552,"row":{"number":1986,"difficulty":1,"question":"class Solution:\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\n        \"\"\"\n        There are n tasks assigned to you. The task times are represented as an integer array tasks of length n, where the ith task takes tasks[i] hours to finish. A work session is when you work for at most sessionTime consecutive hours and then take a break.\n        You should finish the given tasks in a way that satisfies the following conditions:\n            If you start a task in a work session, you must complete it in the same work session.\n            You can start a new task immediately after finishing the previous one.\n            You may complete the tasks in any order.\n        Given tasks and sessionTime, return the minimum number of work sessions needed to finish all the tasks following the conditions above.\n        The tests are generated such that sessionTime is greater than or equal to the maximum element in tasks[i].\n        Example 1:\n        Input: tasks = [1,2,3], sessionTime = 3\n        Output: 2\n        Explanation: You can finish the tasks in two work sessions.\n        - First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n        - Second work session: finish the third task in 3 hours.\n        Example 2:\n        Input: tasks = [3,1,3,1,1], sessionTime = 8\n        Output: 2\n        Explanation: You can finish the tasks in two work sessions.\n        - First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n        - Second work session: finish the last task in 1 hour.\n        Example 3:\n        Input: tasks = [1,2,3,4,5], sessionTime = 15\n        Output: 1\n        Explanation: You can finish all the tasks in one work session.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1553,"row":{"number":1987,"difficulty":2,"question":"class Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        \"\"\"\n        You are given a binary string binary. A subsequence of binary is considered good if it is not empty and has no leading zeros (with the exception of \"0\").\n        Find the number of unique good subsequences of binary.\n            For example, if binary = \"001\", then all the good subsequences are [\"0\", \"0\", \"1\"], so the unique good subsequences are \"0\" and \"1\". Note that subsequences \"00\", \"01\", and \"001\" are not good because they have leading zeros.\n        Return the number of unique good subsequences of binary. Since the answer may be very large, return it modulo 109 + 7.\n        A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: binary = \"001\"\n        Output: 2\n        Explanation: The good subsequences of binary are [\"0\", \"0\", \"1\"].\n        The unique good subsequences are \"0\" and \"1\".\n        Example 2:\n        Input: binary = \"11\"\n        Output: 2\n        Explanation: The good subsequences of binary are [\"1\", \"1\", \"11\"].\n        The unique good subsequences are \"1\" and \"11\".\n        Example 3:\n        Input: binary = \"101\"\n        Output: 5\n        Explanation: The good subsequences of binary are [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"]. \n        The unique good subsequences are \"0\", \"1\", \"10\", \"11\", and \"101\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1554,"row":{"number":2006,"difficulty":0,"question":"class Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.\n        The value of |x| is defined as:\n            x if x >= 0.\n            -x if x < 0.\n        Example 1:\n        Input: nums = [1,2,2,1], k = 1\n        Output: 4\n        Explanation: The pairs with an absolute difference of 1 are:\n        - [1,2,2,1]\n        - [1,2,2,1]\n        - [1,2,2,1]\n        - [1,2,2,1]\n        Example 2:\n        Input: nums = [1,3], k = 3\n        Output: 0\n        Explanation: There are no pairs with an absolute difference of 3.\n        Example 3:\n        Input: nums = [3,2,1,5,4], k = 2\n        Output: 3\n        Explanation: The pairs with an absolute difference of 2 are:\n        - [3,2,1,5,4]\n        - [3,2,1,5,4]\n        - [3,2,1,5,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1555,"row":{"number":2007,"difficulty":1,"question":"class Solution:\n    def findOriginalArray(self, changed: List[int]) -> List[int]:\n        \"\"\"\n        An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.\n        Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.\n        Example 1:\n        Input: changed = [1,3,4,2,6,8]\n        Output: [1,3,4]\n        Explanation: One possible original array could be [1,3,4]:\n        - Twice the value of 1 is 1 * 2 = 2.\n        - Twice the value of 3 is 3 * 2 = 6.\n        - Twice the value of 4 is 4 * 2 = 8.\n        Other original arrays could be [4,3,1] or [3,1,4].\n        Example 2:\n        Input: changed = [6,3,0,1]\n        Output: []\n        Explanation: changed is not a doubled array.\n        Example 3:\n        Input: changed = [1]\n        Output: []\n        Explanation: changed is not a doubled array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1556,"row":{"number":2008,"difficulty":1,"question":"class Solution:\n    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:\n        \"\"\"\n        There are n points on a road you are driving your taxi on. The n points on the road are labeled from 1 to n in the direction you are going, and you want to drive from point 1 to point n to make money by picking up passengers. You cannot change the direction of the taxi.\n        The passengers are represented by a 0-indexed 2D integer array rides, where rides[i] = [starti, endi, tipi] denotes the ith passenger requesting a ride from point starti to point endi who is willing to give a tipi dollar tip.\n        For each passenger i you pick up, you earn endi - starti + tipi dollars. You may only drive at most one passenger at a time.\n        Given n and rides, return the maximum number of dollars you can earn by picking up the passengers optimally.\n        Note: You may drop off a passenger and pick up a different passenger at the same point.\n        Example 1:\n        Input: n = 5, rides = [[2,5,4],[1,5,1]]\n        Output: 7\n        Explanation: We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.\n        Example 2:\n        Input: n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]\n        Output: 20\n        Explanation: We will pick up the following passengers:\n        - Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.\n        - Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.\n        - Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.\n        We earn 9 + 5 + 6 = 20 dollars in total.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1557,"row":{"number":2009,"difficulty":2,"question":"class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. In one operation, you can replace any element in nums with any integer.\n        nums is considered continuous if both of the following conditions are fulfilled:\n            All elements in nums are unique.\n            The difference between the maximum element and the minimum element in nums equals nums.length - 1.\n        For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.\n        Return the minimum number of operations to make nums continuous.\n        Example 1:\n        Input: nums = [4,2,5,3]\n        Output: 0\n        Explanation: nums is already continuous.\n        Example 2:\n        Input: nums = [1,2,3,5,6]\n        Output: 1\n        Explanation: One possible solution is to change the last element to 4.\n        The resulting array is [1,2,3,5,4], which is continuous.\n        Example 3:\n        Input: nums = [1,10,100,1000]\n        Output: 3\n        Explanation: One possible solution is to:\n        - Change the second element to 2.\n        - Change the third element to 3.\n        - Change the fourth element to 4.\n        The resulting array is [1,2,3,4], which is continuous.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1558,"row":{"number":1971,"difficulty":0,"question":"class Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        \"\"\"\n        There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\n        You want to determine if there is a valid path that exists from vertex source to vertex destination.\n        Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\n        Example 1:\n        Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\n        Output: true\n        Explanation: There are two paths from vertex 0 to vertex 2:\n        - 0 → 1 → 2\n        - 0 → 2\n        Example 2:\n        Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\n        Output: false\n        Explanation: There is no path from vertex 0 to vertex 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1559,"row":{"number":1995,"difficulty":0,"question":"class Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:\n            nums[a] + nums[b] + nums[c] == nums[d], and\n            a < b < c < d\n        Example 1:\n        Input: nums = [1,2,3,6]\n        Output: 1\n        Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6.\n        Example 2:\n        Input: nums = [3,3,6,4,5]\n        Output: 0\n        Explanation: There are no such quadruplets in [3,3,6,4,5].\n        Example 3:\n        Input: nums = [1,1,1,3,5]\n        Output: 4\n        Explanation: The 4 quadruplets that satisfy the requirement are:\n        - (0, 1, 2, 3): 1 + 1 + 1 == 3\n        - (0, 1, 3, 4): 1 + 1 + 3 == 5\n        - (0, 2, 3, 4): 1 + 1 + 3 == 5\n        - (1, 2, 3, 4): 1 + 1 + 3 == 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1560,"row":{"number":1996,"difficulty":1,"question":"class Solution:\n    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:\n        \"\"\"\n        You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.\n        A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.\n        Return the number of weak characters.\n        Example 1:\n        Input: properties = [[5,5],[6,3],[3,6]]\n        Output: 0\n        Explanation: No character has strictly greater attack and defense than the other.\n        Example 2:\n        Input: properties = [[2,2],[3,3]]\n        Output: 1\n        Explanation: The first character is weak because the second character has a strictly greater attack and defense.\n        Example 3:\n        Input: properties = [[1,5],[10,4],[4,3]]\n        Output: 1\n        Explanation: The third character is weak because the second character has a strictly greater attack and defense.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1561,"row":{"number":1997,"difficulty":1,"question":"class Solution:\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\n        \"\"\"\n        There are n rooms you need to visit, labeled from 0 to n - 1. Each day is labeled, starting from 0. You will go in and visit one room a day.\n        Initially on day 0, you visit room 0. The order you visit the rooms for the coming days is determined by the following rules and a given 0-indexed array nextVisit of length n:\n            Assuming that on a day, you visit room i,\n            if you have been in room i an odd number of times (including the current visit), on the next day you will visit a room with a lower or equal room number specified by nextVisit[i] where 0 <= nextVisit[i] <= i;\n            if you have been in room i an even number of times (including the current visit), on the next day you will visit room (i + 1) mod n.\n        Return the label of the first day where you have been in all the rooms. It can be shown that such a day exists. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: nextVisit = [0,0]\n        Output: 2\n        Explanation:\n        - On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n          On the next day you will visit room nextVisit[0] = 0\n        - On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n          On the next day you will visit room (0 + 1) mod 2 = 1\n        - On day 2, you visit room 1. This is the first day where you have been in all the rooms.\n        Example 2:\n        Input: nextVisit = [0,0,2]\n        Output: 6\n        Explanation:\n        Your room visiting order for each day is: [0,0,1,0,0,1,2,...].\n        Day 6 is the first day where you have been in all the rooms.\n        Example 3:\n        Input: nextVisit = [0,1,2,0]\n        Output: 6\n        Explanation:\n        Your room visiting order for each day is: [0,0,1,1,2,2,3,...].\n        Day 6 is the first day where you have been in all the rooms.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1562,"row":{"number":1998,"difficulty":2,"question":"class Solution:\n    def gcdSort(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums, and you can perform the following operation any number of times on nums:\n            Swap the positions of two elements nums[i] and nums[j] if gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest common divisor of nums[i] and nums[j].\n        Return true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise.\n        Example 1:\n        Input: nums = [7,21,3]\n        Output: true\n        Explanation: We can sort [7,21,3] by performing the following operations:\n        - Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3]\n        - Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21]\n        Example 2:\n        Input: nums = [5,2,6,2]\n        Output: false\n        Explanation: It is impossible to sort the array because 5 cannot be swapped with any other element.\n        Example 3:\n        Input: nums = [10,5,9,3,15]\n        Output: true\n        We can sort [10,5,9,3,15] by performing the following operations:\n        - Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10]\n        - Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10]\n        - Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1563,"row":{"number":2000,"difficulty":0,"question":"class Solution:\n    def reversePrefix(self, word: str, ch: str) -> str:\n        \"\"\"\n        Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\n            For example, if word = \"abcdefd\" and ch = \"d\", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \"dcbaefd\".\n        Return the resulting string.\n        Example 1:\n        Input: word = \"abcdefd\", ch = \"d\"\n        Output: \"dcbaefd\"\n        Explanation: The first occurrence of \"d\" is at index 3. \n        Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\".\n        Example 2:\n        Input: word = \"xyxzxe\", ch = \"z\"\n        Output: \"zxyxxe\"\n        Explanation: The first and only occurrence of \"z\" is at index 3.\n        Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\".\n        Example 3:\n        Input: word = \"abcd\", ch = \"z\"\n        Output: \"abcd\"\n        Explanation: \"z\" does not exist in word.\n        You should not do any reverse operation, the resulting string is \"abcd\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1564,"row":{"number":2001,"difficulty":1,"question":"class Solution:\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\n        \"\"\"\n        You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle.\n        Two rectangles i and j (i < j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division).\n        Return the number of pairs of interchangeable rectangles in rectangles.\n        Example 1:\n        Input: rectangles = [[4,8],[3,6],[10,20],[15,30]]\n        Output: 6\n        Explanation: The following are the interchangeable pairs of rectangles by index (0-indexed):\n        - Rectangle 0 with rectangle 1: 4/8 == 3/6.\n        - Rectangle 0 with rectangle 2: 4/8 == 10/20.\n        - Rectangle 0 with rectangle 3: 4/8 == 15/30.\n        - Rectangle 1 with rectangle 2: 3/6 == 10/20.\n        - Rectangle 1 with rectangle 3: 3/6 == 15/30.\n        - Rectangle 2 with rectangle 3: 10/20 == 15/30.\n        Example 2:\n        Input: rectangles = [[4,5],[7,8]]\n        Output: 0\n        Explanation: There are no interchangeable pairs of rectangles.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1565,"row":{"number":2002,"difficulty":1,"question":"class Solution:\n    def maxProduct(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find two disjoint palindromic subsequences of s such that the product of their lengths is maximized. The two subsequences are disjoint if they do not both pick a character at the same index.\n        Return the maximum possible product of the lengths of the two palindromic subsequences.\n        A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is palindromic if it reads the same forward and backward.\n        Example 1:\n        Input: s = \"leetcodecom\"\n        Output: 9\n        Explanation: An optimal solution is to choose \"ete\" for the 1st subsequence and \"cdc\" for the 2nd subsequence.\n        The product of their lengths is: 3 * 3 = 9.\n        Example 2:\n        Input: s = \"bb\"\n        Output: 1\n        Explanation: An optimal solution is to choose \"b\" (the first character) for the 1st subsequence and \"b\" (the second character) for the 2nd subsequence.\n        The product of their lengths is: 1 * 1 = 1.\n        Example 3:\n        Input: s = \"accbcaxxcxx\"\n        Output: 25\n        Explanation: An optimal solution is to choose \"accca\" for the 1st subsequence and \"xxcxx\" for the 2nd subsequence.\n        The product of their lengths is: 5 * 5 = 25.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1566,"row":{"number":2003,"difficulty":2,"question":"class Solution:\n    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\n        \"\"\"\n        There is a family tree rooted at 0 consisting of n nodes numbered 0 to n - 1. You are given a 0-indexed integer array parents, where parents[i] is the parent for node i. Since node 0 is the root, parents[0] == -1.\n        There are 105 genetic values, each represented by an integer in the inclusive range [1, 105]. You are given a 0-indexed integer array nums, where nums[i] is a distinct genetic value for node i.\n        Return an array ans of length n where ans[i] is the smallest genetic value that is missing from the subtree rooted at node i.\n        The subtree rooted at a node x contains node x and all of its descendant nodes.\n        Example 1:\n        Input: parents = [-1,0,0,2], nums = [1,2,3,4]\n        Output: [5,1,1,1]\n        Explanation: The answer for each subtree is calculated as follows:\n        - 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value.\n        - 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.\n        - 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value.\n        - 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.\n        Example 2:\n        Input: parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]\n        Output: [7,1,1,4,2,1]\n        Explanation: The answer for each subtree is calculated as follows:\n        - 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value.\n        - 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value.\n        - 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.\n        - 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value.\n        - 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.\n        - 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.\n        Example 3:\n        Input: parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]\n        Output: [1,1,1,1,1,1,1]\n        Explanation: The value 1 is missing from all the subtrees.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1567,"row":{"number":2022,"difficulty":0,"question":"class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\n        \"\"\"\n        You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.\n        The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\n        Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.\n        Example 1:\n        Input: original = [1,2,3,4], m = 2, n = 2\n        Output: [[1,2],[3,4]]\n        Explanation: The constructed 2D array should contain 2 rows and 2 columns.\n        The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\n        The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n        Example 2:\n        Input: original = [1,2,3], m = 1, n = 3\n        Output: [[1,2,3]]\n        Explanation: The constructed 2D array should contain 1 row and 3 columns.\n        Put all three elements in original into the first row of the constructed 2D array.\n        Example 3:\n        Input: original = [1,2], m = 1, n = 1\n        Output: []\n        Explanation: There are 2 elements in original.\n        It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1568,"row":{"number":2023,"difficulty":1,"question":"class Solution:\n    def numOfPairs(self, nums: List[str], target: str) -> int:\n        \"\"\"\n        Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.\n        Example 1:\n        Input: nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\n        Output: 4\n        Explanation: Valid pairs are:\n        - (0, 1): \"777\" + \"7\"\n        - (1, 0): \"7\" + \"777\"\n        - (2, 3): \"77\" + \"77\"\n        - (3, 2): \"77\" + \"77\"\n        Example 2:\n        Input: nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\n        Output: 2\n        Explanation: Valid pairs are:\n        - (0, 1): \"123\" + \"4\"\n        - (2, 3): \"12\" + \"34\"\n        Example 3:\n        Input: nums = [\"1\",\"1\",\"1\"], target = \"11\"\n        Output: 6\n        Explanation: Valid pairs are:\n        - (0, 1): \"1\" + \"1\"\n        - (1, 0): \"1\" + \"1\"\n        - (0, 2): \"1\" + \"1\"\n        - (2, 0): \"1\" + \"1\"\n        - (1, 2): \"1\" + \"1\"\n        - (2, 1): \"1\" + \"1\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1569,"row":{"number":2024,"difficulty":1,"question":"class Solution:\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n        \"\"\"\n        A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).\n        You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:\n            Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').\n        Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.\n        Example 1:\n        Input: answerKey = \"TTFF\", k = 2\n        Output: 4\n        Explanation: We can replace both the 'F's with 'T's to make answerKey = \"TTTT\".\n        There are four consecutive 'T's.\n        Example 2:\n        Input: answerKey = \"TFFT\", k = 1\n        Output: 3\n        Explanation: We can replace the first 'T' with an 'F' to make answerKey = \"FFFT\".\n        Alternatively, we can replace the second 'T' with an 'F' to make answerKey = \"TFFF\".\n        In both cases, there are three consecutive 'F's.\n        Example 3:\n        Input: answerKey = \"TTFTTFTT\", k = 1\n        Output: 5\n        Explanation: We can replace the first 'F' to make answerKey = \"TTTTTFTT\"\n        Alternatively, we can replace the second 'F' to make answerKey = \"TTFTTTTT\". \n        In both cases, there are five consecutive 'T's.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1570,"row":{"number":2025,"difficulty":2,"question":"class Solution:\n    def waysToPartition(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\n            1 <= pivot < n\n            nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]\n        You are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\n        Return the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.\n        Example 1:\n        Input: nums = [2,-1,2], k = 3\n        Output: 1\n        Explanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].\n        There is one way to partition the array:\n        - For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.\n        Example 2:\n        Input: nums = [0,0,0], k = 1\n        Output: 2\n        Explanation: The optimal approach is to leave the array unchanged.\n        There are two ways to partition the array:\n        - For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n        - For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.\n        Example 3:\n        Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\n        Output: 4\n        Explanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].\n        There are four ways to partition the array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1571,"row":{"number":2011,"difficulty":0,"question":"class Solution:\n    def finalValueAfterOperations(self, operations: List[str]) -> int:\n        \"\"\"\n        There is a programming language with only four operations and one variable X:\n            ++X and X++ increments the value of the variable X by 1.\n            --X and X-- decrements the value of the variable X by 1.\n        Initially, the value of X is 0.\n        Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.\n        Example 1:\n        Input: operations = [\"--X\",\"X++\",\"X++\"]\n        Output: 1\n        Explanation: The operations are performed as follows:\n        Initially, X = 0.\n        --X: X is decremented by 1, X =  0 - 1 = -1.\n        X++: X is incremented by 1, X = -1 + 1 =  0.\n        X++: X is incremented by 1, X =  0 + 1 =  1.\n        Example 2:\n        Input: operations = [\"++X\",\"++X\",\"X++\"]\n        Output: 3\n        Explanation: The operations are performed as follows:\n        Initially, X = 0.\n        ++X: X is incremented by 1, X = 0 + 1 = 1.\n        ++X: X is incremented by 1, X = 1 + 1 = 2.\n        X++: X is incremented by 1, X = 2 + 1 = 3.\n        Example 3:\n        Input: operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\n        Output: 0\n        Explanation: The operations are performed as follows:\n        Initially, X = 0.\n        X++: X is incremented by 1, X = 0 + 1 = 1.\n        ++X: X is incremented by 1, X = 1 + 1 = 2.\n        --X: X is decremented by 1, X = 2 - 1 = 1.\n        X--: X is decremented by 1, X = 1 - 1 = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1572,"row":{"number":2012,"difficulty":1,"question":"class Solution:\n    def sumOfBeauties(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. For each index i (1 <= i <= nums.length - 2) the beauty of nums[i] equals:\n            2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for all i < k <= nums.length - 1.\n            1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous condition is not satisfied.\n            0, if none of the previous conditions holds.\n        Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: 2\n        Explanation: For each index i in the range 1 <= i <= 1:\n        - The beauty of nums[1] equals 2.\n        Example 2:\n        Input: nums = [2,4,6,4]\n        Output: 1\n        Explanation: For each index i in the range 1 <= i <= 2:\n        - The beauty of nums[1] equals 1.\n        - The beauty of nums[2] equals 0.\n        Example 3:\n        Input: nums = [3,2,1]\n        Output: 0\n        Explanation: For each index i in the range 1 <= i <= 1:\n        - The beauty of nums[1] equals 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1573,"row":{"number":2013,"difficulty":1,"question":"class DetectSquares:\n    def __init__(self):\n    def add(self, point: List[int]) -> None:\n    def count(self, point: List[int]) -> int:\n        \"\"\"\n        You are given a stream of points on the X-Y plane. Design an algorithm that:\n            Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.\n            Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.\n        An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\n        Implement the DetectSquares class:\n            DetectSquares() Initializes the object with an empty data structure.\n            void add(int[] point) Adds a new point point = [x, y] to the data structure.\n            int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.\n        Example 1:\n        Input\n        [\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n        [[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n        Output\n        [null, null, null, null, 1, 0, null, 2]\n        Explanation\n        DetectSquares detectSquares = new DetectSquares();\n        detectSquares.add([3, 10]);\n        detectSquares.add([11, 2]);\n        detectSquares.add([3, 2]);\n        detectSquares.count([11, 10]); // return 1. You can choose:\n                                       //   - The first, second, and third points\n        detectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.\n        detectSquares.add([11, 2]);    // Adding duplicate points is allowed.\n        detectSquares.count([11, 10]); // return 2. You can choose:\n                                       //   - The first, second, and third points\n                                       //   - The first, third, and fourth points\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1574,"row":{"number":2014,"difficulty":2,"question":"class Solution:\n    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\n        \"\"\"\n        You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s.\n        A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n        A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times.\n            For example, \"bba\" is repeated 2 times in the string \"bababcba\", because the string \"bbabba\", constructed by concatenating \"bba\" 2 times, is a subsequence of the string \"bababcba\".\n        Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.\n        Example 1:\n        Input: s = \"letsleetcode\", k = 2\n        Output: \"let\"\n        Explanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\".\n        \"let\" is the lexicographically largest one.\n        Example 2:\n        Input: s = \"bb\", k = 2\n        Output: \"b\"\n        Explanation: The longest subsequence repeated 2 times is \"b\".\n        Example 3:\n        Input: s = \"ab\", k = 2\n        Output: \"\"\n        Explanation: There is no subsequence repeated 2 times. Empty string is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1575,"row":{"number":2016,"difficulty":0,"question":"class Solution:\n    def maximumDifference(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].\n        Return the maximum difference. If no such i and j exists, return -1.\n        Example 1:\n        Input: nums = [7,1,5,4]\n        Output: 4\n        Explanation:\n        The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.\n        Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.\n        Example 2:\n        Input: nums = [9,4,3,2]\n        Output: -1\n        Explanation:\n        There is no i and j such that i < j and nums[i] < nums[j].\n        Example 3:\n        Input: nums = [1,5,2,10]\n        Output: 9\n        Explanation:\n        The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1576,"row":{"number":2017,"difficulty":1,"question":"class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\n        Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\n        At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\n        The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.\n        Example 1:\n        Input: grid = [[2,5,4],[1,5,1]]\n        Output: 4\n        Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\n        The cells visited by the first robot are set to 0.\n        The second robot will collect 0 + 0 + 4 + 0 = 4 points.\n        Example 2:\n        Input: grid = [[3,3,1],[8,5,2]]\n        Output: 4\n        Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\n        The cells visited by the first robot are set to 0.\n        The second robot will collect 0 + 3 + 1 + 0 = 4 points.\n        Example 3:\n        Input: grid = [[1,3,1,15],[1,3,3,1]]\n        Output: 7\n        Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\n        The cells visited by the first robot are set to 0.\n        The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1577,"row":{"number":2018,"difficulty":1,"question":"class Solution:\n    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        You are given an m x n matrix board, representing the current state of a crossword puzzle. The crossword contains lowercase English letters (from solved words), ' ' to represent any empty cells, and '#' to represent any blocked cells.\n        A word can be placed horizontally (left to right or right to left) or vertically (top to bottom or bottom to top) in the board if:\n            It does not occupy a cell containing the character '#'.\n            The cell each letter is placed in must either be ' ' (empty) or match the letter already on the board.\n            There must not be any empty cells ' ' or other lowercase letters directly left or right of the word if the word was placed horizontally.\n            There must not be any empty cells ' ' or other lowercase letters directly above or below the word if the word was placed vertically.\n        Given a string word, return true if word can be placed in board, or false otherwise.\n        Example 1:\n        Input: board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\"\n        Output: true\n        Explanation: The word \"abc\" can be placed as shown above (top to bottom).\n        Example 2:\n        Input: board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\"\n        Output: false\n        Explanation: It is impossible to place the word because there will always be a space/letter above or below it.\n        Example 3:\n        Input: board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\"\n        Output: true\n        Explanation: The word \"ca\" can be placed as shown above (right to left). \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1578,"row":{"number":2019,"difficulty":2,"question":"class Solution:\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n        \"\"\"\n        You are given a string s that contains digits 0-9, addition symbols '+', and multiplication symbols '*' only, representing a valid math expression of single digit numbers (e.g., 3+5*2). This expression was given to n elementary school students. The students were instructed to get the answer of the expression by following this order of operations:\n            Compute multiplication, reading from left to right; Then,\n            Compute addition, reading from left to right.\n        You are given an integer array answers of length n, which are the submitted answers of the students in no particular order. You are asked to grade the answers, by following these rules:\n            If an answer equals the correct answer of the expression, this student will be rewarded 5 points;\n            Otherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded 2 points;\n            Otherwise, this student will be rewarded 0 points.\n        Return the sum of the points of the students.\n        Example 1:\n        Input: s = \"7+3*1*2\", answers = [20,13,42]\n        Output: 7\n        Explanation: As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,13,42]\n        A student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [20,13,42]\n        The points for the students are: [2,5,0]. The sum of the points is 2+5+0=7.\n        Example 2:\n        Input: s = \"3+5*2\", answers = [13,0,10,13,13,16,16]\n        Output: 19\n        Explanation: The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [13,0,10,13,13,16,16]\n        A student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,16,16]\n        The points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.\n        Example 3:\n        Input: s = \"6+0*1\", answers = [12,9,6,4,8,6]\n        Output: 10\n        Explanation: The correct answer of the expression is 6.\n        If a student had incorrectly done (6+0)*1, the answer would also be 6.\n        By the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.\n        The points for the students are: [0,0,5,0,0,5]. The sum of the points is 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1579,"row":{"number":2037,"difficulty":0,"question":"class Solution:\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\n        \"\"\"\n        There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.\n        You may perform the following move any number of times:\n            Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)\n        Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.\n        Note that there may be multiple seats or students in the same position at the beginning.\n        Example 1:\n        Input: seats = [3,1,5], students = [2,7,4]\n        Output: 4\n        Explanation: The students are moved as follows:\n        - The first student is moved from from position 2 to position 1 using 1 move.\n        - The second student is moved from from position 7 to position 5 using 2 moves.\n        - The third student is moved from from position 4 to position 3 using 1 move.\n        In total, 1 + 2 + 1 = 4 moves were used.\n        Example 2:\n        Input: seats = [4,1,5,9], students = [1,3,2,6]\n        Output: 7\n        Explanation: The students are moved as follows:\n        - The first student is not moved.\n        - The second student is moved from from position 3 to position 4 using 1 move.\n        - The third student is moved from from position 2 to position 5 using 3 moves.\n        - The fourth student is moved from from position 6 to position 9 using 3 moves.\n        In total, 0 + 1 + 3 + 3 = 7 moves were used.\n        Example 3:\n        Input: seats = [2,2,6,6], students = [1,3,2,6]\n        Output: 4\n        Explanation: Note that there are two seats at position 2 and two seats at position 6.\n        The students are moved as follows:\n        - The first student is moved from from position 1 to position 2 using 1 move.\n        - The second student is moved from from position 3 to position 6 using 3 moves.\n        - The third student is not moved.\n        - The fourth student is not moved.\n        In total, 1 + 3 + 0 + 0 = 4 moves were used.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1580,"row":{"number":2038,"difficulty":1,"question":"class Solution:\n    def winnerOfGame(self, colors: str) -> bool:\n        \"\"\"\n        There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\n        Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n            Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\n            Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\n            Alice and Bob cannot remove pieces from the edge of the line.\n            If a player cannot make a move on their turn, that player loses and the other player wins.\n        Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.\n        Example 1:\n        Input: colors = \"AAABABB\"\n        Output: true\n        Explanation:\n        AAABABB -> AABABB\n        Alice moves first.\n        She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n        Now it's Bob's turn.\n        Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\n        Thus, Alice wins, so return true.\n        Example 2:\n        Input: colors = \"AA\"\n        Output: false\n        Explanation:\n        Alice has her turn first.\n        There are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\n        Thus, Bob wins, so return false.\n        Example 3:\n        Input: colors = \"ABBBBBBBAAA\"\n        Output: false\n        Explanation:\n        ABBBBBBBAAA -> ABBBBBBBAA\n        Alice moves first.\n        Her only option is to remove the second to last 'A' from the right.\n        ABBBBBBBAA -> ABBBBBBAA\n        Next is Bob's turn.\n        He has many options for which 'B' piece to remove. He can pick any.\n        On Alice's second turn, she has no more pieces that she can remove.\n        Thus, Bob wins, so return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1581,"row":{"number":2040,"difficulty":2,"question":"class Solution:\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        \"\"\"\n        Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j] where 0 <= i < nums1.length and 0 <= j < nums2.length.\n        Example 1:\n        Input: nums1 = [2,5], nums2 = [3,4], k = 2\n        Output: 8\n        Explanation: The 2 smallest products are:\n        - nums1[0] * nums2[0] = 2 * 3 = 6\n        - nums1[0] * nums2[1] = 2 * 4 = 8\n        The 2nd smallest product is 8.\n        Example 2:\n        Input: nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6\n        Output: 0\n        Explanation: The 6 smallest products are:\n        - nums1[0] * nums2[1] = (-4) * 4 = -16\n        - nums1[0] * nums2[0] = (-4) * 2 = -8\n        - nums1[1] * nums2[1] = (-2) * 4 = -8\n        - nums1[1] * nums2[0] = (-2) * 2 = -4\n        - nums1[2] * nums2[0] = 0 * 2 = 0\n        - nums1[2] * nums2[1] = 0 * 4 = 0\n        The 6th smallest product is 0.\n        Example 3:\n        Input: nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3\n        Output: -6\n        Explanation: The 3 smallest products are:\n        - nums1[0] * nums2[4] = (-2) * 5 = -10\n        - nums1[0] * nums2[3] = (-2) * 4 = -8\n        - nums1[4] * nums2[0] = 2 * (-3) = -6\n        The 3rd smallest product is -6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1582,"row":{"number":2039,"difficulty":1,"question":"class Solution:\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\n        \"\"\"\n        There is a network of n servers, labeled from 0 to n - 1. You are given a 2D integer array edges, where edges[i] = [ui, vi] indicates there is a message channel between servers ui and vi, and they can pass any number of messages to each other directly in one second. You are also given a 0-indexed integer array patience of length n.\n        All servers are connected, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.\n        The server labeled 0 is the master server. The rest are data servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers optimally, so every message takes the least amount of time to arrive at the master server. The master server will process all newly arrived messages instantly and send a reply to the originating server via the reversed path the message had gone through.\n        At the beginning of second 0, each data server sends its message to be processed. Starting from second 1, at the beginning of every second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:\n            If it has not, it will resend the message periodically. The data server i will resend the message every patience[i] second(s), i.e., the data server i will resend the message if patience[i] second(s) have elapsed since the last time the message was sent from this server.\n            Otherwise, no more resending will occur from this server.\n        The network becomes idle when there are no messages passing between servers or arriving at servers.\n        Return the earliest second starting from which the network becomes idle.\n        Example 1:\n        Input: edges = [[0,1],[1,2]], patience = [0,2,1]\n        Output: 8\n        Explanation:\n        At (the beginning of) second 0,\n        - Data server 1 sends its message (denoted 1A) to the master server.\n        - Data server 2 sends its message (denoted 2A) to the master server.\n        At second 1,\n        - Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n        - Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.\n        - Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).\n        At second 2,\n        - The reply 1A arrives at server 1. No more resending will occur from server 1.\n        - Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n        - Server 2 resends the message (denoted 2C).\n        ...\n        At second 4,\n        - The reply 2A arrives at server 2. No more resending will occur from server 2.\n        ...\n        At second 7, reply 2D arrives at server 2.\n        Starting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.\n        This is the time when the network becomes idle.\n        Example 2:\n        Input: edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]\n        Output: 3\n        Explanation: Data servers 1 and 2 receive a reply back at the beginning of second 2.\n        From the beginning of the second 3, the network becomes idle.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1583,"row":{"number":2027,"difficulty":0,"question":"class Solution:\n    def minimumMoves(self, s: str) -> int:\n        \"\"\"\n        You are given a string s consisting of n characters which are either 'X' or 'O'.\n        A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.\n        Return the minimum number of moves required so that all the characters of s are converted to 'O'.\n        Example 1:\n        Input: s = \"XXX\"\n        Output: 1\n        Explanation: XXX -> OOO\n        We select all the 3 characters and convert them in one move.\n        Example 2:\n        Input: s = \"XXOX\"\n        Output: 2\n        Explanation: XXOX -> OOOX -> OOOO\n        We select the first 3 characters in the first move, and convert them to 'O'.\n        Then we select the last 3 characters and convert them so that the final string contains all 'O's.\n        Example 3:\n        Input: s = \"OOOO\"\n        Output: 0\n        Explanation: There are no 'X's in s to convert.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1584,"row":{"number":2028,"difficulty":1,"question":"class Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        \"\"\"\n        You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls.\n        You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.\n        Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array.\n        The average value of a set of k numbers is the sum of the numbers divided by k.\n        Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.\n        Example 1:\n        Input: rolls = [3,2,4,3], mean = 4, n = 2\n        Output: [6,6]\n        Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.\n        Example 2:\n        Input: rolls = [1,5,6], mean = 3, n = 4\n        Output: [2,3,2,2]\n        Explanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.\n        Example 3:\n        Input: rolls = [1,2,3,4], mean = 6, n = 4\n        Output: []\n        Explanation: It is impossible for the mean to be 6 no matter what the 4 missing rolls are.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1585,"row":{"number":2029,"difficulty":1,"question":"class Solution:\n    def stoneGameIX(self, stones: List[int]) -> bool:\n        \"\"\"\n        Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array stones, where stones[i] is the value of the ith stone.\n        Alice and Bob take turns, with Alice starting first. On each turn, the player may remove any stone from stones. The player who removes a stone loses if the sum of the values of all removed stones is divisible by 3. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\n        Assuming both players play optimally, return true if Alice wins and false if Bob wins.\n        Example 1:\n        Input: stones = [2,1]\n        Output: true\n        Explanation: The game will be played as follows:\n        - Turn 1: Alice can remove either stone.\n        - Turn 2: Bob removes the remaining stone. \n        The sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\n        Example 2:\n        Input: stones = [2]\n        Output: false\n        Explanation: Alice will remove the only stone, and the sum of the values on the removed stones is 2. \n        Since all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\n        Example 3:\n        Input: stones = [5,1,2,4,3]\n        Output: false\n        Explanation: Bob will always win. One possible way for Bob to win is shown below:\n        - Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n        - Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n        - Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n        - Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n        - Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\n        Alice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1586,"row":{"number":2030,"difficulty":2,"question":"class Solution:\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n        \"\"\"\n        You are given a string s, an integer k, a letter letter, and an integer repetition.\n        Return the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. The test cases are generated so that the letter appears in s at least repetition times.\n        A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n        A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\n        Example 1:\n        Input: s = \"leet\", k = 3, letter = \"e\", repetition = 1\n        Output: \"eet\"\n        Explanation: There are four subsequences of length 3 that have the letter 'e' appear at least 1 time:\n        - \"lee\" (from \"leet\")\n        - \"let\" (from \"leet\")\n        - \"let\" (from \"leet\")\n        - \"eet\" (from \"leet\")\n        The lexicographically smallest subsequence among them is \"eet\".\n        Example 2:\n        Input: s = \"leetcode\", k = 4, letter = \"e\", repetition = 2\n        Output: \"ecde\"\n        Explanation: \"ecde\" is the lexicographically smallest subsequence of length 4 that has the letter \"e\" appear at least 2 times.\n        Example 3:\n        Input: s = \"bb\", k = 2, letter = \"b\", repetition = 2\n        Output: \"bb\"\n        Explanation: \"bb\" is the only subsequence of length 2 that has the letter \"b\" appear at least 2 times.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1587,"row":{"number":2032,"difficulty":0,"question":"class Solution:\n    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        \"\"\"\n        Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order.\n        Example 1:\n        Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]\n        Output: [3,2]\n        Explanation: The values that are present in at least two arrays are:\n        - 3, in all three arrays.\n        - 2, in nums1 and nums2.\n        Example 2:\n        Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]\n        Output: [2,3,1]\n        Explanation: The values that are present in at least two arrays are:\n        - 2, in nums2 and nums3.\n        - 3, in nums1 and nums2.\n        - 1, in nums1 and nums3.\n        Example 3:\n        Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]\n        Output: []\n        Explanation: No value is present in at least two arrays.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1588,"row":{"number":2033,"difficulty":1,"question":"class Solution:\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\n        \"\"\"\n        You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.\n        A uni-value grid is a grid where all the elements of it are equal.\n        Return the minimum number of operations to make the grid uni-value. If it is not possible, return -1.\n        Example 1:\n        Input: grid = [[2,4],[6,8]], x = 2\n        Output: 4\n        Explanation: We can make every element equal to 4 by doing the following: \n        - Add x to 2 once.\n        - Subtract x from 6 once.\n        - Subtract x from 8 twice.\n        A total of 4 operations were used.\n        Example 2:\n        Input: grid = [[1,5],[2,3]], x = 1\n        Output: 5\n        Explanation: We can make every element equal to 3.\n        Example 3:\n        Input: grid = [[1,2],[3,4]], x = 2\n        Output: -1\n        Explanation: It is impossible to make every element equal.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1589,"row":{"number":2034,"difficulty":1,"question":"class StockPrice:\n    def __init__(self):\n    def update(self, timestamp: int, price: int) -> None:\n    def current(self) -> int:\n    def maximum(self) -> int:\n    def minimum(self) -> int:\n        \"\"\"\n        You are given a stream of records about a particular stock. Each record contains a timestamp and the corresponding price of the stock at that timestamp.\n        Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream correcting the price of the previous wrong record.\n        Design an algorithm that:\n            Updates the price of the stock at a particular timestamp, correcting the price from any previous records at the timestamp.\n            Finds the latest price of the stock based on the current records. The latest price is the price at the latest timestamp recorded.\n            Finds the maximum price the stock has been based on the current records.\n            Finds the minimum price the stock has been based on the current records.\n        Implement the StockPrice class:\n            StockPrice() Initializes the object with no price records.\n            void update(int timestamp, int price) Updates the price of the stock at the given timestamp.\n            int current() Returns the latest price of the stock.\n            int maximum() Returns the maximum price of the stock.\n            int minimum() Returns the minimum price of the stock.\n        Example 1:\n        Input\n        [\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n        [[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n        Output\n        [null, null, null, 5, 10, null, 5, null, 2]\n        Explanation\n        StockPrice stockPrice = new StockPrice();\n        stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].\n        stockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].\n        stockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.\n        stockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.\n        stockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.\n                                  // Timestamps are [1,2] with corresponding prices [3,5].\n        stockPrice.maximum();     // return 5, the maximum price is 5 after the correction.\n        stockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].\n        stockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1590,"row":{"number":2035,"difficulty":2,"question":"class Solution:\n    def minimumDifference(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums of 2 * n integers. You need to partition nums into two arrays of length n to minimize the absolute difference of the sums of the arrays. To partition nums, put each element of nums into one of the two arrays.\n        Return the minimum possible absolute difference.\n        Example 1:\n        Input: nums = [3,9,7,3]\n        Output: 2\n        Explanation: One optimal partition is: [3,9] and [7,3].\n        The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.\n        Example 2:\n        Input: nums = [-36,36]\n        Output: 72\n        Explanation: One optimal partition is: [-36] and [36].\n        The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.\n        Example 3:\n        Input: nums = [2,-1,0,4,-2,-9]\n        Output: 0\n        Explanation: One optimal partition is: [2,4,-9] and [-1,0,-2].\n        The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1591,"row":{"number":2053,"difficulty":0,"question":"class Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        \"\"\"\n        A distinct string is a string that is present only once in an array.\n        Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string \"\".\n        Note that the strings are considered in the order in which they appear in the array.\n        Example 1:\n        Input: arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2\n        Output: \"a\"\n        Explanation:\n        The only distinct strings in arr are \"d\" and \"a\".\n        \"d\" appears 1st, so it is the 1st distinct string.\n        \"a\" appears 2nd, so it is the 2nd distinct string.\n        Since k == 2, \"a\" is returned. \n        Example 2:\n        Input: arr = [\"aaa\",\"aa\",\"a\"], k = 1\n        Output: \"aaa\"\n        Explanation:\n        All strings in arr are distinct, so the 1st string \"aaa\" is returned.\n        Example 3:\n        Input: arr = [\"a\",\"b\",\"a\"], k = 3\n        Output: \"\"\n        Explanation:\n        The only distinct string is \"b\". Since there are fewer than 3 distinct strings, we return an empty string \"\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1592,"row":{"number":2054,"difficulty":1,"question":"class Solution:\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.\n        Return this maximum sum.\n        Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1.\n        Example 1:\n        Input: events = [[1,3,2],[4,5,2],[2,4,3]]\n        Output: 4\n        Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n        Example 2:\n        Input: events = [[1,3,2],[4,5,2],[1,5,5]]\n        Output: 5\n        Explanation: Choose event 2 for a sum of 5.\n        Example 3:\n        Input: events = [[1,5,3],[1,5,1],[6,6,5]]\n        Output: 8\n        Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1593,"row":{"number":2055,"difficulty":1,"question":"class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.\n        You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.\n            For example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.\n        Return an integer array answer where answer[i] is the answer to the ith query.\n        Example 1:\n        Input: s = \"**|**|***|\", queries = [[2,5],[5,9]]\n        Output: [2,3]\n        Explanation:\n        - queries[0] has two plates between candles.\n        - queries[1] has three plates between candles.\n        Example 2:\n        Input: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\n        Output: [9,0,0,0,0]\n        Explanation:\n        - queries[0] has nine plates between candles.\n        - The other queries have zero plates between candles.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1594,"row":{"number":2056,"difficulty":2,"question":"class Solution:\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\n        \"\"\"\n        There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard.\n        When making a move for a piece, you choose a destination square that the piece will travel toward and stop on.\n            A rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1).\n            A queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\n            A bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\n        You must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square.\n        Return the number of valid move combinations​​​​​.\n        Notes:\n            No two pieces will start in the same square.\n            You may choose the square a piece is already on as its destination.\n            If two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.\n        Example 1:\n        Input: pieces = [\"rook\"], positions = [[1,1]]\n        Output: 15\n        Explanation: The image above shows the possible squares the piece can move to.\n        Example 2:\n        Input: pieces = [\"queen\"], positions = [[1,1]]\n        Output: 22\n        Explanation: The image above shows the possible squares the piece can move to.\n        Example 3:\n        Input: pieces = [\"bishop\"], positions = [[4,3]]\n        Output: 12\n        Explanation: The image above shows the possible squares the piece can move to.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1595,"row":{"number":2042,"difficulty":0,"question":"class Solution:\n    def areNumbersAscending(self, s: str) -> bool:\n        \"\"\"\n        A sentence is a list of tokens separated by a single space with no leading or trailing spaces. Every token is either a positive number consisting of digits 0-9 with no leading zeros, or a word consisting of lowercase English letters.\n            For example, \"a puppy has 2 eyes 4 legs\" is a sentence with seven tokens: \"2\" and \"4\" are numbers and the other tokens such as \"puppy\" are words.\n        Given a string s representing a sentence, you need to check if all the numbers in s are strictly increasing from left to right (i.e., other than the last number, each number is strictly smaller than the number on its right in s).\n        Return true if so, or false otherwise.\n        Example 1:\n        Input: s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        Output: true\n        Explanation: The numbers in s are: 1, 3, 4, 6, 12.\n        They are strictly increasing from left to right: 1 < 3 < 4 < 6 < 12.\n        Example 2:\n        Input: s = \"hello world 5 x 5\"\n        Output: false\n        Explanation: The numbers in s are: 5, 5. They are not strictly increasing.\n        Example 3:\n        Input: s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"\n        Output: false\n        Explanation: The numbers in s are: 7, 51, 50, 60. They are not strictly increasing.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1596,"row":{"number":2043,"difficulty":1,"question":"class Bank:\n    def __init__(self, balance: List[int]):\n    def transfer(self, account1: int, account2: int, money: int) -> bool:\n    def deposit(self, account: int, money: int) -> bool:\n    def withdraw(self, account: int, money: int) -> bool:\n        \"\"\"\n        You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i].\n        Execute all the valid transactions. A transaction is valid if:\n            The given account number(s) are between 1 and n, and\n            The amount of money withdrawn or transferred from is less than or equal to the balance of the account.\n        Implement the Bank class:\n            Bank(long[] balance) Initializes the object with the 0-indexed integer array balance.\n            boolean transfer(int account1, int account2, long money) Transfers money dollars from the account numbered account1 to the account numbered account2. Return true if the transaction was successful, false otherwise.\n            boolean deposit(int account, long money) Deposit money dollars into the account numbered account. Return true if the transaction was successful, false otherwise.\n            boolean withdraw(int account, long money) Withdraw money dollars from the account numbered account. Return true if the transaction was successful, false otherwise.\n        Example 1:\n        Input\n        [\"Bank\", \"withdraw\", \"transfer\", \"deposit\", \"transfer\", \"withdraw\"]\n        [[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]\n        Output\n        [null, true, true, true, false, false]\n        Explanation\n        Bank bank = new Bank([10, 100, 20, 50, 30]);\n        bank.withdraw(3, 10);    // return true, account 3 has a balance of $20, so it is valid to withdraw $10.\n                                 // Account 3 has $20 - $10 = $10.\n        bank.transfer(5, 1, 20); // return true, account 5 has a balance of $30, so it is valid to transfer $20.\n                                 // Account 5 has $30 - $20 = $10, and account 1 has $10 + $20 = $30.\n        bank.deposit(5, 20);     // return true, it is valid to deposit $20 to account 5.\n                                 // Account 5 has $10 + $20 = $30.\n        bank.transfer(3, 4, 15); // return false, the current balance of account 3 is $10,\n                                 // so it is invalid to transfer $15 from it.\n        bank.withdraw(10, 50);   // return false, it is invalid because account 10 does not exist.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1597,"row":{"number":2044,"difficulty":1,"question":"class Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\n        An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\n        The bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).\n        Example 1:\n        Input: nums = [3,1]\n        Output: 2\n        Explanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n        - [3]\n        - [3,1]\n        Example 2:\n        Input: nums = [2,2,2]\n        Output: 7\n        Explanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.\n        Example 3:\n        Input: nums = [3,2,1,5]\n        Output: 6\n        Explanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n        - [3,5]\n        - [3,1,5]\n        - [3,2,5]\n        - [3,2,1,5]\n        - [2,5]\n        - [2,1,5]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1598,"row":{"number":2045,"difficulty":2,"question":"class Solution:\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n        \"\"\"\n        A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes.\n        Each vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.\n        The second minimum value is defined as the smallest value strictly larger than the minimum value.\n            For example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4.\n        Given n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n.\n        Notes:\n            You can go through any vertex any number of times, including 1 and n.\n            You can assume that when the journey starts, all signals have just turned green.\n        Example 1:\n        Input: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\n        Output: 13\n        Explanation:\n        The figure on the left shows the given graph.\n        The blue path in the figure on the right is the minimum time path.\n        The time taken is:\n        - Start at 1, time elapsed=0\n        - 1 -> 4: 3 minutes, time elapsed=3\n        - 4 -> 5: 3 minutes, time elapsed=6\n        Hence the minimum time needed is 6 minutes.\n        The red path shows the path to get the second minimum time.\n        - Start at 1, time elapsed=0\n        - 1 -> 3: 3 minutes, time elapsed=3\n        - 3 -> 4: 3 minutes, time elapsed=6\n        - Wait at 4 for 4 minutes, time elapsed=10\n        - 4 -> 5: 3 minutes, time elapsed=13\n        Hence the second minimum time is 13 minutes.      \n        Example 2:\n        Input: n = 2, edges = [[1,2]], time = 3, change = 2\n        Output: 11\n        Explanation:\n        The minimum time path is 1 -> 2 with time = 3 minutes.\n        The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1599,"row":{"number":2047,"difficulty":0,"question":"class Solution:\n    def countValidWords(self, sentence: str) -> int:\n        \"\"\"\n        A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. Each sentence can be broken down into one or more tokens separated by one or more spaces ' '.\n        A token is a valid word if all three of the following are true:\n            It only contains lowercase letters, hyphens, and/or punctuation (no digits).\n            There is at most one hyphen '-'. If present, it must be surrounded by lowercase characters (\"a-b\" is valid, but \"-ab\" and \"ab-\" are not valid).\n            There is at most one punctuation mark. If present, it must be at the end of the token (\"ab,\", \"cd!\", and \".\" are valid, but \"a!b\" and \"c.,\" are not valid).\n        Examples of valid words include \"a-b.\", \"afad\", \"ba-c\", \"a!\", and \"!\".\n        Given a string sentence, return the number of valid words in sentence.\n        Example 1:\n        Input: sentence = \"cat and  dog\"\n        Output: 3\n        Explanation: The valid words in the sentence are \"cat\", \"and\", and \"dog\".\n        Example 2:\n        Input: sentence = \"!this  1-s b8d!\"\n        Output: 0\n        Explanation: There are no valid words in the sentence.\n        \"!this\" is invalid because it starts with a punctuation mark.\n        \"1-s\" and \"b8d\" are invalid because they contain digits.\n        Example 3:\n        Input: sentence = \"alice and  bob are playing stone-game10\"\n        Output: 5\n        Explanation: The valid words in the sentence are \"alice\", \"and\", \"bob\", \"are\", and \"playing\".\n        \"stone-game10\" is invalid because it contains digits.\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}