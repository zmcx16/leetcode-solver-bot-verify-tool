{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1900,"row":{"number":2462,"difficulty":1,"question":"class Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.\n        You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\n            You will run k sessions and hire exactly one worker in each session.\n            In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.\n                For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].\n                In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.\n            If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n            A worker can only be chosen once.\n        Return the total cost to hire exactly k workers.\n        Example 1:\n        Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n        Output: 11\n        Explanation: We hire 3 workers in total. The total cost is initially 0.\n        - In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.\n        - In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.\n        - In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.\n        The total hiring cost is 11.\n        Example 2:\n        Input: costs = [1,2,4,1], k = 3, candidates = 3\n        Output: 4\n        Explanation: We hire 3 workers in total. The total cost is initially 0.\n        - In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.\n        - In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.\n        - In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.\n        The total hiring cost is 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1901,"row":{"number":2463,"difficulty":2,"question":"class Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        \"\"\"\n        There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\n        The positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.\n        All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\n        At any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.\n        Return the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.\n        Note that\n            All robots move at the same speed.\n            If two robots move in the same direction, they will never collide.\n            If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\n            If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\n            If the robot moved from a position x to a position y, the distance it moved is |y - x|.\n        Example 1:\n        Input: robot = [0,4,6], factory = [[2,2],[6,2]]\n        Output: 4\n        Explanation: As shown in the figure:\n        - The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n        - The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n        - The third robot at position 6 will be repaired at the second factory. It does not need to move.\n        The limit of the first factory is 2, and it fixed 2 robots.\n        The limit of the second factory is 2, and it fixed 1 robot.\n        The total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n        Example 2:\n        Input: robot = [1,-1], factory = [[-2,1],[2,1]]\n        Output: 2\n        Explanation: As shown in the figure:\n        - The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n        - The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\n        The limit of the first factory is 1, and it fixed 1 robot.\n        The limit of the second factory is 1, and it fixed 1 robot.\n        The total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1902,"row":{"number":2469,"difficulty":0,"question":"class Solution:\n    def convertTemperature(self, celsius: float) -> List[float]:\n        \"\"\"\n        You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\n        You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\n        Return the array ans. Answers within 10-5 of the actual answer will be accepted.\n        Note that:\n            Kelvin = Celsius + 273.15\n            Fahrenheit = Celsius * 1.80 + 32.00\n        Example 1:\n        Input: celsius = 36.50\n        Output: [309.65000,97.70000]\n        Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.\n        Example 2:\n        Input: celsius = 122.11\n        Output: [395.26000,251.79800]\n        Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1903,"row":{"number":2470,"difficulty":1,"question":"class Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray's elements is k.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.\n        Example 1:\n        Input: nums = [3,6,2,7,1], k = 6\n        Output: 4\n        Explanation: The subarrays of nums where 6 is the least common multiple of all the subarray's elements are:\n        - [3,6,2,7,1]\n        - [3,6,2,7,1]\n        - [3,6,2,7,1]\n        - [3,6,2,7,1]\n        Example 2:\n        Input: nums = [3], k = 2\n        Output: 0\n        Explanation: There are no subarrays of nums where 2 is the least common multiple of all the subarray's elements.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1904,"row":{"number":2471,"difficulty":1,"question":"class Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        You are given the root of a binary tree with unique values.\n        In one operation, you can choose any two nodes at the same level and swap their values.\n        Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.\n        The level of a node is the number of edges along the path between it and the root node.\n        Example 1:\n        Input: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\n        Output: 3\n        Explanation:\n        - Swap 4 and 3. The 2nd level becomes [3,4].\n        - Swap 7 and 5. The 3rd level becomes [5,6,8,7].\n        - Swap 8 and 7. The 3rd level becomes [5,6,7,8].\n        We used 3 operations so return 3.\n        It can be proven that 3 is the minimum number of operations needed.\n        Example 2:\n        Input: root = [1,3,2,7,6,5,4]\n        Output: 3\n        Explanation:\n        - Swap 3 and 2. The 2nd level becomes [2,3].\n        - Swap 7 and 4. The 3rd level becomes [4,6,5,7].\n        - Swap 6 and 5. The 3rd level becomes [4,5,6,7].\n        We used 3 operations so return 3.\n        It can be proven that 3 is the minimum number of operations needed.\n        Example 3:\n        Input: root = [1,2,3,4,5,6]\n        Output: 0\n        Explanation: Each level is already sorted in increasing order so return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1905,"row":{"number":2472,"difficulty":2,"question":"class Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        \"\"\"\n        You are given a string s and a positive integer k.\n        Select a set of non-overlapping substrings from the string s that satisfy the following conditions:\n            The length of each substring is at least k.\n            Each substring is a palindrome.\n        Return the maximum number of substrings in an optimal selection.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"abaccdbbd\", k = 3\n        Output: 2\n        Explanation: We can select the substrings underlined in s = \"abaccdbbd\". Both \"aba\" and \"dbbd\" are palindromes and have a length of at least k = 3.\n        It can be shown that we cannot find a selection with more than two valid substrings.\n        Example 2:\n        Input: s = \"adbcda\", k = 2\n        Output: 0\n        Explanation: There is no palindrome substring of length at least 2 in the string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1906,"row":{"number":2465,"difficulty":0,"question":"class Solution:\n    def distinctAverages(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums of even length.\n        As long as nums is not empty, you must repetitively:\n            Find the minimum number in nums and remove it.\n            Find the maximum number in nums and remove it.\n            Calculate the average of the two removed numbers.\n        The average of two numbers a and b is (a + b) / 2.\n            For example, the average of 2 and 3 is (2 + 3) / 2 = 2.5.\n        Return the number of distinct averages calculated using the above process.\n        Note that when there is a tie for a minimum or maximum number, any can be removed.\n        Example 1:\n        Input: nums = [4,1,4,0,3,5]\n        Output: 2\n        Explanation:\n        1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].\n        2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].\n        3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.\n        Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.\n        Example 2:\n        Input: nums = [1,100]\n        Output: 1\n        Explanation:\n        There is only one average to be calculated after removing 1 and 100, so we return 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1907,"row":{"number":2466,"difficulty":1,"question":"class Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        \"\"\"\n        Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\n            Append the character '0' zero times.\n            Append the character '1' one times.\n        This can be performed any number of times.\n        A good string is a string constructed by the above process having a length between low and high (inclusive).\n        Return the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.\n        Example 1:\n        Input: low = 3, high = 3, zero = 1, one = 1\n        Output: 8\n        Explanation: \n        One possible valid good string is \"011\". \n        It can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \n        All binary strings from \"000\" to \"111\" are good strings in this example.\n        Example 2:\n        Input: low = 2, high = 3, zero = 1, one = 2\n        Output: 5\n        Explanation: The good strings are \"00\", \"11\", \"000\", \"110\", and \"011\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1908,"row":{"number":2468,"difficulty":2,"question":"class Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        \"\"\"\n        You are given a string, message, and a positive integer, limit.\n        You must split message into one or more parts based on limit. Each resulting part should have the suffix \"<a/b>\", where \"b\" is to be replaced with the total number of parts and \"a\" is to be replaced with the index of the part, starting from 1 and going up to b. Additionally, the length of each resulting part (including its suffix) should be equal to limit, except for the last part whose length can be at most limit.\n        The resulting parts should be formed such that when their suffixes are removed and they are all concatenated in order, they should be equal to message. Also, the result should contain as few parts as possible.\n        Return the parts message would be split into as an array of strings. If it is impossible to split message as required, return an empty array.\n        Example 1:\n        Input: message = \"this is really a very awesome message\", limit = 9\n        Output: [\"thi<1/14>\",\"s i<2/14>\",\"s r<3/14>\",\"eal<4/14>\",\"ly <5/14>\",\"a v<6/14>\",\"ery<7/14>\",\" aw<8/14>\",\"eso<9/14>\",\"me<10/14>\",\" m<11/14>\",\"es<12/14>\",\"sa<13/14>\",\"ge<14/14>\"]\n        Explanation:\n        The first 9 parts take 3 characters each from the beginning of message.\n        The next 5 parts take 2 characters each to finish splitting message. \n        In this example, each part, including the last, has length 9. \n        It can be shown it is not possible to split message into less than 14 parts.\n        Example 2:\n        Input: message = \"short message\", limit = 15\n        Output: [\"short mess<1/2>\",\"age<2/2>\"]\n        Explanation:\n        Under the given constraints, the string can be split into two parts: \n        - The first part comprises of the first 10 characters, and has a length 15.\n        - The next part comprises of the last 3 characters, and has a length 8.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1909,"row":{"number":2467,"difficulty":1,"question":"class Solution:\n    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n        \"\"\"\n        There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\n        At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:\n            the price needed to open the gate at node i, if amount[i] is negative, or,\n            the cash reward obtained on opening the gate at node i, otherwise.\n        The game goes on as follows:\n            Initially, Alice is at node 0 and Bob is at node bob.\n            At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.\n            For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:\n                If the gate is already open, no price will be required, nor will there be any cash reward.\n                If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each.\n            If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other.\n        Return the maximum net income Alice can have if she travels towards the optimal leaf node.\n        Example 1:\n        Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]\n        Output: 6\n        Explanation: \n        The above diagram represents the given tree. The game goes as follows:\n        - Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\n          Alice's net income is now -2.\n        - Both Alice and Bob move to node 1. \n          Since they reach here simultaneously, they open the gate together and share the reward.\n          Alice's net income becomes -2 + (4 / 2) = 0.\n        - Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.\n          Bob moves on to node 0, and stops moving.\n        - Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\n        Now, neither Alice nor Bob can make any further moves, and the game ends.\n        It is not possible for Alice to get a higher net income.\n        Example 2:\n        Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]\n        Output: -7280\n        Explanation: \n        Alice follows the path 0->1 whereas Bob follows the path 1->0.\n        Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1910,"row":{"number":2475,"difficulty":0,"question":"class Solution:\n    def unequalTriplets(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:\n            0 <= i < j < k < nums.length\n            nums[i], nums[j], and nums[k] are pairwise distinct.\n                In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].\n        Return the number of triplets that meet the conditions.\n        Example 1:\n        Input: nums = [4,4,2,4,3]\n        Output: 3\n        Explanation: The following triplets meet the conditions:\n        - (0, 2, 4) because 4 != 2 != 3\n        - (1, 2, 4) because 4 != 2 != 3\n        - (2, 3, 4) because 2 != 4 != 3\n        Since there are 3 triplets, we return 3.\n        Note that (2, 0, 4) is not a valid triplet because 2 > 0.\n        Example 2:\n        Input: nums = [1,1,1,1,1]\n        Output: 0\n        Explanation: No triplets meet the conditions so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1911,"row":{"number":2476,"difficulty":1,"question":"class Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\n        Find a 2D array answer of size n where answer[i] = [mini, maxi]:\n            mini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\n            maxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n        Return the array answer.\n        Example 1:\n        Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\n        Output: [[2,2],[4,6],[15,-1]]\n        Explanation: We answer the queries in the following way:\n        - The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].\n        - The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].\n        - The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].\n        Example 2:\n        Input: root = [4,null,9], queries = [3]\n        Output: [[-1,4]]\n        Explanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1912,"row":{"number":2477,"difficulty":1,"question":"class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        \"\"\"\n        There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\n        There is a meeting for the representatives of each city. The meeting is in the capital city.\n        There is a car in each city. You are given an integer seats that indicates the number of seats in each car.\n        A representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\n        Return the minimum number of liters of fuel to reach the capital city.\n        Example 1:\n        Input: roads = [[0,1],[0,2],[0,3]], seats = 5\n        Output: 3\n        Explanation: \n        - Representative1 goes directly to the capital with 1 liter of fuel.\n        - Representative2 goes directly to the capital with 1 liter of fuel.\n        - Representative3 goes directly to the capital with 1 liter of fuel.\n        It costs 3 liters of fuel at minimum. \n        It can be proven that 3 is the minimum number of liters of fuel needed.\n        Example 2:\n        Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\n        Output: 7\n        Explanation: \n        - Representative2 goes directly to city 3 with 1 liter of fuel.\n        - Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n        - Representative2 and representative3 go together to the capital with 1 liter of fuel.\n        - Representative1 goes directly to the capital with 1 liter of fuel.\n        - Representative5 goes directly to the capital with 1 liter of fuel.\n        - Representative6 goes directly to city 4 with 1 liter of fuel.\n        - Representative4 and representative6 go together to the capital with 1 liter of fuel.\n        It costs 7 liters of fuel at minimum. \n        It can be proven that 7 is the minimum number of liters of fuel needed.\n        Example 3:\n        Input: roads = [], seats = 1\n        Output: 0\n        Explanation: No representatives need to travel to the capital city.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1913,"row":{"number":2478,"difficulty":2,"question":"class Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        \"\"\"\n        You are given a string s that consists of the digits '1' to '9' and two integers k and minLength.\n        A partition of s is called beautiful if:\n            s is partitioned into k non-intersecting substrings.\n            Each substring has a length of at least minLength.\n            Each substring starts with a prime digit and ends with a non-prime digit. Prime digits are '2', '3', '5', and '7', and the rest of the digits are non-prime.\n        Return the number of beautiful partitions of s. Since the answer may be very large, return it modulo 109 + 7.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"23542185131\", k = 3, minLength = 2\n        Output: 3\n        Explanation: There exists three ways to create a beautiful partition:\n        \"2354 | 218 | 5131\"\n        \"2354 | 21851 | 31\"\n        \"2354218 | 51 | 31\"\n        Example 2:\n        Input: s = \"23542185131\", k = 3, minLength = 3\n        Output: 1\n        Explanation: There exists one way to create a beautiful partition: \"2354 | 218 | 5131\".\n        Example 3:\n        Input: s = \"3312958\", k = 3, minLength = 1\n        Output: 1\n        Explanation: There exists one way to create a beautiful partition: \"331 | 29 | 58\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1914,"row":{"number":2485,"difficulty":0,"question":"class Solution:\n    def pivotInteger(self, n: int) -> int:\n        \"\"\"\n        Given a positive integer n, find the pivot integer x such that:\n            The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.\n        Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.\n        Example 1:\n        Input: n = 8\n        Output: 6\n        Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        Explanation: 1 is the pivot integer since: 1 = 1.\n        Example 3:\n        Input: n = 4\n        Output: -1\n        Explanation: It can be proved that no such integer exist.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1915,"row":{"number":2486,"difficulty":1,"question":"class Solution:\n    def appendCharacters(self, s: str, t: str) -> int:\n        \"\"\"\n        You are given two strings s and t consisting of only lowercase English letters.\n        Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.\n        A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n        Example 1:\n        Input: s = \"coaching\", t = \"coding\"\n        Output: 4\n        Explanation: Append the characters \"ding\" to the end of s so that s = \"coachingding\".\n        Now, t is a subsequence of s (\"coachingding\").\n        It can be shown that appending any 3 characters to the end of s will never make t a subsequence.\n        Example 2:\n        Input: s = \"abcde\", t = \"a\"\n        Output: 0\n        Explanation: t is already a subsequence of s (\"abcde\").\n        Example 3:\n        Input: s = \"z\", t = \"abcde\"\n        Output: 5\n        Explanation: Append the characters \"abcde\" to the end of s so that s = \"zabcde\".\n        Now, t is a subsequence of s (\"zabcde\").\n        It can be shown that appending any 4 characters to the end of s will never make t a subsequence.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1916,"row":{"number":2487,"difficulty":1,"question":"class Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the head of a linked list.\n        Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n        Return the head of the modified linked list.\n        Example 1:\n        Input: head = [5,2,13,3,8]\n        Output: [13,8]\n        Explanation: The nodes that should be removed are 5, 2 and 3.\n        - Node 13 is to the right of node 5.\n        - Node 13 is to the right of node 2.\n        - Node 8 is to the right of node 3.\n        Example 2:\n        Input: head = [1,1,1,1]\n        Output: [1,1,1,1]\n        Explanation: Every node has value 1, so no nodes are removed.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1917,"row":{"number":2488,"difficulty":2,"question":"class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.\n        Return the number of non-empty subarrays in nums that have a median equal to k.\n        Note:\n            The median of an array is the middle element after sorting the array in ascending order. If the array is of even length, the median is the left middle element.\n                For example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1] is 4.\n            A subarray is a contiguous part of an array.\n        Example 1:\n        Input: nums = [3,2,1,4,5], k = 4\n        Output: 3\n        Explanation: The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5].\n        Example 2:\n        Input: nums = [2,3,1], k = 3\n        Output: 1\n        Explanation: [3] is the only subarray that has a median equal to 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1918,"row":{"number":2481,"difficulty":0,"question":"class Solution:\n    def numberOfCuts(self, n: int) -> int:\n        \"\"\"\n        A valid cut in a circle can be:\n            A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or\n            A cut that is represented by a straight line that touches one point on the edge of the circle and its center.\n        Some valid and invalid cuts are shown in the figures below.\n        Given the integer n, return the minimum number of cuts needed to divide a circle into n equal slices.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: \n        The above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation:\n        At least 3 cuts are needed to divide the circle into 3 equal slices. \n        It can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.\n        Also note that the first cut will not divide the circle into distinct parts.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1919,"row":{"number":2483,"difficulty":1,"question":"class Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        \"\"\"\n        You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':\n            if the ith character is 'Y', it means that customers come at the ith hour\n            whereas 'N' indicates that no customers come at the ith hour.\n        If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:\n            For every hour when the shop is open and no customers come, the penalty increases by 1.\n            For every hour when the shop is closed and customers come, the penalty increases by 1.\n        Return the earliest hour at which the shop must be closed to incur a minimum penalty.\n        Note that if a shop closes at the jth hour, it means the shop is closed at the hour j.\n        Example 1:\n        Input: customers = \"YYNY\"\n        Output: 2\n        Explanation: \n        - Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.\n        - Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.\n        - Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.\n        - Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\n        - Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.\n        Closing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.\n        Example 2:\n        Input: customers = \"NNNNN\"\n        Output: 0\n        Explanation: It is best to close the shop at the 0th hour as no customers arrive.\n        Example 3:\n        Input: customers = \"YYYY\"\n        Output: 4\n        Explanation: It is best to close the shop at the 4th hour as customers arrive at each hour.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1920,"row":{"number":2484,"difficulty":2,"question":"class Solution:\n    def countPalindromes(self, s: str) -> int:\n        \"\"\"\n        Given a string of digits s, return the number of palindromic subsequences of s having length 5. Since the answer may be very large, return it modulo 109 + 7.\n        Note:\n            A string is palindromic if it reads the same forward and backward.\n            A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n        Example 1:\n        Input: s = \"103301\"\n        Output: 2\n        Explanation: \n        There are 6 possible subsequences of length 5: \"10330\",\"10331\",\"10301\",\"10301\",\"13301\",\"03301\". \n        Two of them (both equal to \"10301\") are palindromic.\n        Example 2:\n        Input: s = \"0000000\"\n        Output: 21\n        Explanation: All 21 subsequences are \"00000\", which is palindromic.\n        Example 3:\n        Input: s = \"9999900000\"\n        Output: 2\n        Explanation: The only two palindromic subsequences are \"99999\" and \"00000\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1921,"row":{"number":2490,"difficulty":0,"question":"class Solution:\n    def isCircularSentence(self, sentence: str) -> bool:\n        \"\"\"\n        A sentence is a list of words that are separated by a single space with no leading or trailing spaces.\n            For example, \"Hello World\", \"HELLO\", \"hello world hello world\" are all sentences.\n        Words consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.\n        A sentence is circular if:\n            The last character of a word is equal to the first character of the next word.\n            The last character of the last word is equal to the first character of the first word.\n        For example, \"leetcode exercises sound delightful\", \"eetcode\", \"leetcode eats soul\" are all circular sentences. However, \"Leetcode is cool\", \"happy Leetcode\", \"Leetcode\" and \"I like Leetcode\" are not circular sentences.\n        Given a string sentence, return true if it is circular. Otherwise, return false.\n        Example 1:\n        Input: sentence = \"leetcode exercises sound delightful\"\n        Output: true\n        Explanation: The words in sentence are [\"leetcode\", \"exercises\", \"sound\", \"delightful\"].\n        - leetcode's last character is equal to exercises's first character.\n        - exercises's last character is equal to sound's first character.\n        - sound's last character is equal to delightful's first character.\n        - delightful's last character is equal to leetcode's first character.\n        The sentence is circular.\n        Example 2:\n        Input: sentence = \"eetcode\"\n        Output: true\n        Explanation: The words in sentence are [\"eetcode\"].\n        - eetcode's last character is equal to eetcode's first character.\n        The sentence is circular.\n        Example 3:\n        Input: sentence = \"Leetcode is cool\"\n        Output: false\n        Explanation: The words in sentence are [\"Leetcode\", \"is\", \"cool\"].\n        - Leetcode's last character is not equal to is's first character.\n        The sentence is not circular.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1922,"row":{"number":2491,"difficulty":1,"question":"class Solution:\n    def dividePlayers(self, skill: List[int]) -> int:\n        \"\"\"\n        You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\n        The chemistry of a team is equal to the product of the skills of the players on that team.\n        Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.\n        Example 1:\n        Input: skill = [3,2,5,1,3,4]\n        Output: 22\n        Explanation: \n        Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\n        The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.\n        Example 2:\n        Input: skill = [3,4]\n        Output: 12\n        Explanation: \n        The two players form a team with a total skill of 7.\n        The chemistry of the team is 3 * 4 = 12.\n        Example 3:\n        Input: skill = [1,1,2,3]\n        Output: -1\n        Explanation: \n        There is no way to divide the players into teams such that the total skill of each team is equal.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1923,"row":{"number":2492,"difficulty":1,"question":"class Solution:\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\n        \"\"\"\n        You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.\n        The score of a path between two cities is defined as the minimum distance of a road in this path.\n        Return the minimum possible score of a path between cities 1 and n.\n        Note:\n            A path is a sequence of roads between two cities.\n            It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n            The test cases are generated such that there is at least one path between 1 and n.\n        Example 1:\n        Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\n        Output: 5\n        Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\n        It can be shown that no other path has less score.\n        Example 2:\n        Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\n        Output: 2\n        Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1924,"row":{"number":2493,"difficulty":2,"question":"class Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        \"\"\"\n        You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.\n        You are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.\n        Divide the nodes of the graph into m groups (1-indexed) such that:\n            Each node in the graph belongs to exactly one group.\n            For every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.\n        Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.\n        Example 1:\n        Input: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\n        Output: 4\n        Explanation: As shown in the image we:\n        - Add node 5 to the first group.\n        - Add node 1 to the second group.\n        - Add nodes 2 and 4 to the third group.\n        - Add nodes 3 and 6 to the fourth group.\n        We can see that every edge is satisfied.\n        It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n        Example 2:\n        Input: n = 3, edges = [[1,2],[2,3],[3,1]]\n        Output: -1\n        Explanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\n        It can be shown that no grouping is possible.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1925,"row":{"number":2500,"difficulty":0,"question":"class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n matrix grid consisting of positive integers.\n        Perform the following operation until grid becomes empty:\n            Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\n            Add the maximum of deleted elements to the answer.\n        Note that the number of columns decreases by one after each operation.\n        Return the answer after performing the operations described above.\n        Example 1:\n        Input: grid = [[1,2,4],[3,3,1]]\n        Output: 8\n        Explanation: The diagram above shows the removed values in each step.\n        - In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n        - In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n        - In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\n        The final answer = 4 + 3 + 1 = 8.\n        Example 2:\n        Input: grid = [[10]]\n        Output: 10\n        Explanation: The diagram above shows the removed values in each step.\n        - In the first operation, we remove 10 from the first row. We add 10 to the answer.\n        The final answer = 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1926,"row":{"number":2501,"difficulty":1,"question":"class Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. A subsequence of nums is called a square streak if:\n            The length of the subsequence is at least 2, and\n            after sorting the subsequence, each element (except the first element) is the square of the previous number.\n        Return the length of the longest square streak in nums, or return -1 if there is no square streak.\n        A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: nums = [4,3,6,16,8,2]\n        Output: 3\n        Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].\n        - 4 = 2 * 2.\n        - 16 = 4 * 4.\n        Therefore, [4,16,2] is a square streak.\n        It can be shown that every subsequence of length 4 is not a square streak.\n        Example 2:\n        Input: nums = [2,3,5,6,7]\n        Output: -1\n        Explanation: There is no square streak in nums so return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1927,"row":{"number":2502,"difficulty":1,"question":"class Allocator:\n    def __init__(self, n: int):\n    def allocate(self, size: int, mID: int) -> int:\n    def free(self, mID: int) -> int:\n        \"\"\"\n        You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.\n        You have a memory allocator with the following functionalities:\n            Allocate a block of size consecutive free memory units and assign it the id mID.\n            Free all memory units with the given id mID.\n        Note that:\n            Multiple blocks can be allocated to the same mID.\n            You should free all the memory units with mID, even if they were allocated in different blocks.\n        Implement the Allocator class:\n            Allocator(int n) Initializes an Allocator object with a memory array of size n.\n            int allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1.\n            int free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.\n        Example 1:\n        Input\n        [\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]\n        [[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]\n        Output\n        [null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\n        Explanation\n        Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.\n        loc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.\n        loc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.\n        loc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.\n        loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.\n        loc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.\n        loc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.\n        loc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.\n        loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.\n        loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.\n        loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1928,"row":{"number":2503,"difficulty":2,"question":"class Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        \"\"\"\n        You are given an m x n integer matrix grid and an array queries of size k.\n        Find an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n            If queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\n            Otherwise, you do not get any points, and you end this process.\n        After the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\n        Return the resulting array answer.\n        Example 1:\n        Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\n        Output: [5,8,1]\n        Explanation: The diagrams above show which cells we visit to get points for each query.\n        Example 2:\n        Input: grid = [[5,2,1],[1,1,2]], queries = [3]\n        Output: [0]\n        Explanation: We can not get any points because the value of the top left cell is already greater than or equal to 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1929,"row":{"number":2496,"difficulty":0,"question":"class Solution:\n    def maximumValue(self, strs: List[str]) -> int:\n        \"\"\"\n        The value of an alphanumeric string can be defined as:\n            The numeric representation of the string in base 10, if it comprises of digits only.\n            The length of the string, otherwise.\n        Given an array strs of alphanumeric strings, return the maximum value of any string in strs.\n        Example 1:\n        Input: strs = [\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]\n        Output: 5\n        Explanation: \n        - \"alic3\" consists of both letters and digits, so its value is its length, i.e. 5.\n        - \"bob\" consists only of letters, so its value is also its length, i.e. 3.\n        - \"3\" consists only of digits, so its value is its numeric equivalent, i.e. 3.\n        - \"4\" also consists only of digits, so its value is 4.\n        - \"00000\" consists only of digits, so its value is 0.\n        Hence, the maximum value is 5, of \"alic3\".\n        Example 2:\n        Input: strs = [\"1\",\"01\",\"001\",\"0001\"]\n        Output: 1\n        Explanation: \n        Each string in the array has value 1. Hence, we return 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1930,"row":{"number":2497,"difficulty":1,"question":"class Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        \"\"\"\n        There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.\n        You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\n        A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\n        The image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.\n        The star sum is the sum of the values of all the nodes present in the star graph.\n        Given an integer k, return the maximum star sum of a star graph containing at most k edges.\n        Example 1:\n        Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\n        Output: 16\n        Explanation: The above diagram represents the input graph.\n        The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\n        It can be shown it is not possible to get a star graph with a sum greater than 16.\n        Example 2:\n        Input: vals = [-5], edges = [], k = 0\n        Output: -5\n        Explanation: There is only one possible star graph, which is node 0 itself.\n        Hence, we return -5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1931,"row":{"number":2498,"difficulty":1,"question":"class Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river.\n        A frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once.\n        The length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.\n            More formally, if the frog is at stones[i] and is jumping to stones[j], the length of the jump is |stones[i] - stones[j]|.\n        The cost of a path is the maximum length of a jump among all jumps in the path.\n        Return the minimum cost of a path for the frog.\n        Example 1:\n        Input: stones = [0,2,5,6,7]\n        Output: 5\n        Explanation: The above figure represents one of the optimal paths the frog can take.\n        The cost of this path is 5, which is the maximum length of a jump.\n        Since it is not possible to achieve a cost of less than 5, we return it.\n        Example 2:\n        Input: stones = [0,3,9]\n        Output: 9\n        Explanation: \n        The frog can jump directly to the last stone and come back to the first stone. \n        In this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.\n        It can be shown that this is the minimum achievable cost.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1932,"row":{"number":2499,"difficulty":2,"question":"class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\n        In one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\n        Find the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\n        Return the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.\n        Example 1:\n        Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\n        Output: 10\n        Explanation: \n        One of the ways we can perform the operations is:\n        - Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n        - Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n        - Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\n        We can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\n        Note that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.\n        Example 2:\n        Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\n        Output: 10\n        Explanation: \n        One of the ways we can perform the operations is:\n        - Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n        - Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\n        The total cost needed here is 10, which is the minimum possible.\n        Example 3:\n        Input: nums1 = [1,2,2], nums2 = [1,2,2]\n        Output: -1\n        Explanation: \n        It can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\n        Hence, we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1933,"row":{"number":2506,"difficulty":0,"question":"class Solution:\n    def similarPairs(self, words: List[str]) -> int:\n        \"\"\"\n        You are given a 0-indexed string array words.\n        Two strings are similar if they consist of the same characters.\n            For example, \"abca\" and \"cba\" are similar since both consist of characters 'a', 'b', and 'c'.\n            However, \"abacba\" and \"bcfd\" are not similar since they do not consist of the same characters.\n        Return the number of pairs (i, j) such that 0 <= i < j <= word.length - 1 and the two strings words[i] and words[j] are similar.\n        Example 1:\n        Input: words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]\n        Output: 2\n        Explanation: There are 2 pairs that satisfy the conditions:\n        - i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n        - i = 3 and j = 4 : both words[3] and words[4] only consist of characters 'a', 'b', and 'c'. \n        Example 2:\n        Input: words = [\"aabb\",\"ab\",\"ba\"]\n        Output: 3\n        Explanation: There are 3 pairs that satisfy the conditions:\n        - i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n        - i = 0 and j = 2 : both words[0] and words[2] only consist of characters 'a' and 'b'.\n        - i = 1 and j = 2 : both words[1] and words[2] only consist of characters 'a' and 'b'.\n        Example 3:\n        Input: words = [\"nba\",\"cba\",\"dba\"]\n        Output: 0\n        Explanation: Since there does not exist any pair that satisfies the conditions, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1934,"row":{"number":2507,"difficulty":1,"question":"class Solution:\n    def smallestValue(self, n: int) -> int:\n        \"\"\"\n        You are given a positive integer n.\n        Continuously replace n with the sum of its prime factors.\n            Note that if a prime factor divides n multiple times, it should be included in the sum as many times as it divides n.\n        Return the smallest value n will take on.\n        Example 1:\n        Input: n = 15\n        Output: 5\n        Explanation: Initially, n = 15.\n        15 = 3 * 5, so replace n with 3 + 5 = 8.\n        8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.\n        6 = 2 * 3, so replace n with 2 + 3 = 5.\n        5 is the smallest value n will take on.\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: Initially, n = 3.\n        3 is the smallest value n will take on.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1935,"row":{"number":2508,"difficulty":2,"question":"class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        \"\"\"\n        There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\n        You can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\n        Return true if it is possible to make the degree of each node in the graph even, otherwise return false.\n        The degree of a node is the number of edges connected to it.\n        Example 1:\n        Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\n        Output: true\n        Explanation: The above diagram shows a valid way of adding an edge.\n        Every node in the resulting graph is connected to an even number of edges.\n        Example 2:\n        Input: n = 4, edges = [[1,2],[3,4]]\n        Output: true\n        Explanation: The above diagram shows a valid way of adding two edges.\n        Example 3:\n        Input: n = 4, edges = [[1,2],[1,3],[1,4]]\n        Output: false\n        Explanation: It is not possible to obtain a valid graph with adding at most 2 edges.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1936,"row":{"number":2509,"difficulty":2,"question":"class Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an integer n. There is a complete binary tree with 2n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2n - 1 - 1] has two children where:\n            The left node has the value 2 * val, and\n            The right node has the value 2 * val + 1.\n        You are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem:\n            Add an edge between the nodes with values ai and bi.\n            Find the length of the cycle in the graph.\n            Remove the added edge between nodes with values ai and bi.\n        Note that:\n            A cycle is a path that starts and ends at the same node, and each edge in the path is visited only once.\n            The length of a cycle is the number of edges visited in the cycle.\n            There could be multiple edges between two nodes in the tree after adding the edge of the query.\n        Return an array answer of length m where answer[i] is the answer to the ith query.\n        Example 1:\n        Input: n = 3, queries = [[5,3],[4,7],[2,3]]\n        Output: [4,5,3]\n        Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n        - After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query.\n        - After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query.\n        - After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge.\n        Example 2:\n        Input: n = 2, queries = [[1,2]]\n        Output: [2]\n        Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n        - After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1937,"row":{"number":2515,"difficulty":0,"question":"class Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\n        \"\"\"\n        You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n            Formally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n        Starting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\n        Return the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.\n        Example 1:\n        Input: words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\n        Output: 1\n        Explanation: We start from index 1 and can reach \"hello\" by\n        - moving 3 units to the right to reach index 4.\n        - moving 2 units to the left to reach index 4.\n        - moving 4 units to the right to reach index 0.\n        - moving 1 unit to the left to reach index 0.\n        The shortest distance to reach \"hello\" is 1.\n        Example 2:\n        Input: words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\n        Output: 1\n        Explanation: We start from index 0 and can reach \"leetcode\" by\n        - moving 2 units to the right to reach index 3.\n        - moving 1 unit to the left to reach index 3.\n        The shortest distance to reach \"leetcode\" is 1.\n        Example 3:\n        Input: words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\n        Output: -1\n        Explanation: Since \"ate\" does not exist in words, we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1938,"row":{"number":2516,"difficulty":1,"question":"class Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        \"\"\"\n        You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.\n        Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.\n        Example 1:\n        Input: s = \"aabaaaacaabc\", k = 2\n        Output: 8\n        Explanation: \n        Take three characters from the left of s. You now have two 'a' characters, and one 'b' character.\n        Take five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.\n        A total of 3 + 5 = 8 minutes is needed.\n        It can be proven that 8 is the minimum number of minutes needed.\n        Example 2:\n        Input: s = \"a\", k = 1\n        Output: -1\n        Explanation: It is not possible to take one 'b' or 'c' so return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1939,"row":{"number":2517,"difficulty":1,"question":"class Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        \"\"\"\n        You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.\n        The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.\n        Return the maximum tastiness of a candy basket.\n        Example 1:\n        Input: price = [13,5,1,8,21,2], k = 3\n        Output: 8\n        Explanation: Choose the candies with the prices [13,5,21].\n        The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\n        It can be proven that 8 is the maximum tastiness that can be achieved.\n        Example 2:\n        Input: price = [1,3,1], k = 2\n        Output: 2\n        Explanation: Choose the candies with the prices [1,3].\n        The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\n        It can be proven that 2 is the maximum tastiness that can be achieved.\n        Example 3:\n        Input: price = [7,7,7,7], k = 2\n        Output: 0\n        Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1940,"row":{"number":2518,"difficulty":2,"question":"class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an array nums consisting of positive integers and an integer k.\n        Partition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.\n        Return the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7.\n        Two partitions are considered distinct if some element nums[i] is in different groups in the two partitions.\n        Example 1:\n        Input: nums = [1,2,3,4], k = 4\n        Output: 6\n        Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).\n        Example 2:\n        Input: nums = [3,3,3], k = 4\n        Output: 0\n        Explanation: There are no great partitions for this array.\n        Example 3:\n        Input: nums = [6,6], k = 2\n        Output: 2\n        Explanation: We can either put nums[0] in the first partition or in the second partition.\n        The great partitions will be ([6], [6]) and ([6], [6]).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1941,"row":{"number":2511,"difficulty":0,"question":"class Solution:\n    def captureForts(self, forts: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:\n            -1 represents there is no fort at the ith position.\n            0 indicates there is an enemy fort at the ith position.\n            1 indicates the fort at the ith the position is under your command.\n        Now you have decided to move your army from one of your forts at position i to an empty position j such that:\n            0 <= i, j <= n - 1\n            The army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0.\n        While moving the army, all the enemy forts that come in the way are captured.\n        Return the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.\n        Example 1:\n        Input: forts = [1,0,0,-1,0,0,0,0,1]\n        Output: 4\n        Explanation:\n        - Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n        - Moving the army from position 8 to position 3 captures 4 enemy forts.\n        Since 4 is the maximum number of enemy forts that can be captured, we return 4.\n        Example 2:\n        Input: forts = [0,0,1,-1]\n        Output: 0\n        Explanation: Since no enemy fort can be captured, 0 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1942,"row":{"number":2512,"difficulty":1,"question":"class Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        \"\"\"\n        You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.\n        Initially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1.\n        You are given n feedback reports, represented by a 0-indexed string array report and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique.\n        Given an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.\n        Example 1:\n        Input: positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is studious\",\"the student is smart\"], student_id = [1,2], k = 2\n        Output: [1,2]\n        Explanation: \n        Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher.\n        Example 2:\n        Input: positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is not studious\",\"the student is smart\"], student_id = [1,2], k = 2\n        Output: [2,1]\n        Explanation: \n        - The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points. \n        - The student with ID 2 has 1 positive feedback, so he has 3 points. \n        Since student 2 has more points, [2,1] is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1943,"row":{"number":2541,"difficulty":1,"question":"class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        \"\"\"\n        You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1:\n            Choose two indexes i and j and increment nums1[i] by k and decrement nums1[j] by k. In other words, nums1[i] = nums1[i] + k and nums1[j] = nums1[j] - k.\n        nums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i].\n        Return the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.\n        Example 1:\n        Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\n        Output: 2\n        Explanation: In 2 operations, we can transform nums1 to nums2.\n        1st operation: i = 2, j = 0. After applying the operation, nums1 = [1,3,4,4].\n        2nd operation: i = 2, j = 3. After applying the operation, nums1 = [1,3,7,1].\n        One can prove that it is impossible to make arrays equal in fewer operations.\n        Example 2:\n        Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1\n        Output: -1\n        Explanation: It can be proved that it is impossible to make the two arrays equal.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1944,"row":{"number":2514,"difficulty":2,"question":"class Solution:\n    def countAnagrams(self, s: str) -> int:\n        \"\"\"\n        You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\n        A string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n            For example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\n        Return the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: s = \"too hot\"\n        Output: 18\n        Explanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".\n        Example 2:\n        Input: s = \"aa\"\n        Output: 1\n        Explanation: There is only one anagram possible for the given string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1945,"row":{"number":2482,"difficulty":1,"question":"class Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given a 0-indexed m x n binary matrix grid.\n        A 0-indexed m x n difference matrix diff is created with the following procedure:\n            Let the number of ones in the ith row be onesRowi.\n            Let the number of ones in the jth column be onesColj.\n            Let the number of zeros in the ith row be zerosRowi.\n            Let the number of zeros in the jth column be zerosColj.\n            diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\n        Return the difference matrix diff.\n        Example 1:\n        Input: grid = [[0,1,1],[1,0,1],[0,0,1]]\n        Output: [[0,0,4],[0,0,4],[-2,-2,2]]\n        Explanation:\n        - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n        - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n        - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n        - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n        - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n        - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n        - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2\n        - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2\n        - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2\n        Example 2:\n        Input: grid = [[1,1,1],[1,1,1]]\n        Output: [[5,5,5],[5,5,5]]\n        Explanation:\n        - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n        - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n        - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n        - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n        - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n        - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1946,"row":{"number":2520,"difficulty":0,"question":"class Solution:\n    def countDigits(self, num: int) -> int:\n        \"\"\"\n        Given an integer num, return the number of digits in num that divide num.\n        An integer val divides nums if nums % val == 0.\n        Example 1:\n        Input: num = 7\n        Output: 1\n        Explanation: 7 divides itself, hence the answer is 1.\n        Example 2:\n        Input: num = 121\n        Output: 2\n        Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2.\n        Example 3:\n        Input: num = 1248\n        Output: 4\n        Explanation: 1248 is divisible by all of its digits, hence the answer is 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1947,"row":{"number":2521,"difficulty":1,"question":"class Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.\n        Note that:\n            A number greater than 1 is called prime if it is divisible by only 1 and itself.\n            An integer val1 is a factor of another integer val2 if val2 / val1 is an integer.\n        Example 1:\n        Input: nums = [2,4,3,7,10,6]\n        Output: 4\n        Explanation:\n        The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7.\n        There are 4 distinct prime factors so we return 4.\n        Example 2:\n        Input: nums = [2,4,8,16]\n        Output: 1\n        Explanation:\n        The product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210.\n        There is 1 distinct prime factor so we return 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1948,"row":{"number":2523,"difficulty":1,"question":"class Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        \"\"\"\n        Given two positive integers left and right, find the two integers num1 and num2 such that:\n            left <= nums1 < nums2 <= right .\n            nums1 and nums2 are both prime numbers.\n            nums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.\n        Return the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.\n        A number greater than 1 is called prime if it is only divisible by 1 and itself.\n        Example 1:\n        Input: left = 10, right = 19\n        Output: [11,13]\n        Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.\n        The closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].\n        Since 11 is smaller than 17, we return the first pair.\n        Example 2:\n        Input: left = 4, right = 6\n        Output: [-1,-1]\n        Explanation: There exists only one prime number in the given range, so the conditions cannot be satisfied.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1949,"row":{"number":2529,"difficulty":0,"question":"class Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.\n            In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.\n        Note that 0 is neither positive nor negative.\n        Example 1:\n        Input: nums = [-2,-1,-1,1,2,3]\n        Output: 3\n        Explanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3.\n        Example 2:\n        Input: nums = [-3,-2,-1,0,0,1,2]\n        Output: 3\n        Explanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3.\n        Example 3:\n        Input: nums = [5,20,66,1314]\n        Output: 4\n        Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1950,"row":{"number":2531,"difficulty":1,"question":"class Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        \"\"\"\n        You are given two 0-indexed strings word1 and word2.\n        A move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j].\n        Return true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.\n        Example 1:\n        Input: word1 = \"ac\", word2 = \"b\"\n        Output: false\n        Explanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string.\n        Example 2:\n        Input: word1 = \"abcc\", word2 = \"aab\"\n        Output: true\n        Explanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = \"abac\" and word2 = \"cab\", which both have 3 distinct characters.\n        Example 3:\n        Input: word1 = \"abcde\", word2 = \"fghij\"\n        Output: true\n        Explanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1951,"row":{"number":2530,"difficulty":1,"question":"class Solution:\n    def maxKelements(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.\n        In one operation:\n            choose an index i such that 0 <= i < nums.length,\n            increase your score by nums[i], and\n            replace nums[i] with ceil(nums[i] / 3).\n        Return the maximum possible score you can attain after applying exactly k operations.\n        The ceiling function ceil(val) is the least integer greater than or equal to val.\n        Example 1:\n        Input: nums = [10,10,10,10,10], k = 5\n        Output: 50\n        Explanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.\n        Example 2:\n        Input: nums = [1,10,3,3,3], k = 3\n        Output: 17\n        Explanation: You can do the following operations:\n        Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.\n        Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.\n        Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.\n        The final score is 10 + 4 + 3 = 17.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1952,"row":{"number":2528,"difficulty":2,"question":"class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\n        Each power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n            Note that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n        The power of a city is the total number of power stations it is being provided power from.\n        The government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\n        Given the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\n        Note that you can build the k power stations in multiple cities.\n        Example 1:\n        Input: stations = [1,2,4,5,0], r = 1, k = 2\n        Output: 5\n        Explanation: \n        One of the optimal ways is to install both the power stations at city 1. \n        So stations will become [1,4,4,5,0].\n        - City 0 is provided by 1 + 4 = 5 power stations.\n        - City 1 is provided by 1 + 4 + 4 = 9 power stations.\n        - City 2 is provided by 4 + 4 + 5 = 13 power stations.\n        - City 3 is provided by 5 + 4 = 9 power stations.\n        - City 4 is provided by 5 + 0 = 5 power stations.\n        So the minimum power of a city is 5.\n        Since it is not possible to obtain a larger power, we return 5.\n        Example 2:\n        Input: stations = [4,4,4,4], r = 0, k = 3\n        Output: 4\n        Explanation: \n        It can be proved that we cannot make the minimum power of a city greater than 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1953,"row":{"number":2525,"difficulty":0,"question":"class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\n        \"\"\"\n        Given four integers length, width, height, and mass, representing the dimensions and mass of a box, respectively, return a string representing the category of the box.\n            The box is \"Bulky\" if:\n                Any of the dimensions of the box is greater or equal to 104.\n                Or, the volume of the box is greater or equal to 109.\n            If the mass of the box is greater or equal to 100, it is \"Heavy\".\n            If the box is both \"Bulky\" and \"Heavy\", then its category is \"Both\".\n            If the box is neither \"Bulky\" nor \"Heavy\", then its category is \"Neither\".\n            If the box is \"Bulky\" but not \"Heavy\", then its category is \"Bulky\".\n            If the box is \"Heavy\" but not \"Bulky\", then its category is \"Heavy\".\n        Note that the volume of the box is the product of its length, width and height.\n        Example 1:\n        Input: length = 1000, width = 35, height = 700, mass = 300\n        Output: \"Heavy\"\n        Explanation: \n        None of the dimensions of the box is greater or equal to 104. \n        Its volume = 24500000 <= 109. So it cannot be categorized as \"Bulky\".\n        However mass >= 100, so the box is \"Heavy\".\n        Since the box is not \"Bulky\" but \"Heavy\", we return \"Heavy\".\n        Example 2:\n        Input: length = 200, width = 50, height = 800, mass = 50\n        Output: \"Neither\"\n        Explanation: \n        None of the dimensions of the box is greater or equal to 104.\n        Its volume = 8 * 106 <= 109. So it cannot be categorized as \"Bulky\".\n        Its mass is also less than 100, so it cannot be categorized as \"Heavy\" either. \n        Since its neither of the two above categories, we return \"Neither\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1954,"row":{"number":2526,"difficulty":1,"question":"class DataStream:\n    def __init__(self, value: int, k: int):\n    def consec(self, num: int) -> bool:\n        \"\"\"\n        For a stream of integers, implement a data structure that checks if the last k integers parsed in the stream are equal to value.\n        Implement the DataStream class:\n            DataStream(int value, int k) Initializes the object with an empty integer stream and the two integers value and k.\n            boolean consec(int num) Adds num to the stream of integers. Returns true if the last k integers are equal to value, and false otherwise. If there are less than k integers, the condition does not hold true, so returns false.\n        Example 1:\n        Input\n        [\"DataStream\", \"consec\", \"consec\", \"consec\", \"consec\"]\n        [[4, 3], [4], [4], [4], [3]]\n        Output\n        [null, false, false, true, false]\n        Explanation\n        DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3 \n        dataStream.consec(4); // Only 1 integer is parsed, so returns False. \n        dataStream.consec(4); // Only 2 integers are parsed.\n                              // Since 2 is less than k, returns False. \n        dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True. \n        dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].\n                              // Since 3 is not equal to value, it returns False.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1955,"row":{"number":2527,"difficulty":1,"question":"class Solution:\n    def xorBeauty(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums.\n        The effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).\n        The xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.\n        Return the xor-beauty of nums.\n        Note that:\n            val1 | val2 is bitwise OR of val1 and val2.\n            val1 & val2 is bitwise AND of val1 and val2.\n        Example 1:\n        Input: nums = [1,4]\n        Output: 5\n        Explanation: \n        The triplets and their corresponding effective values are listed below:\n        - (0,0,0) with effective value ((1 | 1) & 1) = 1\n        - (0,0,1) with effective value ((1 | 1) & 4) = 0\n        - (0,1,0) with effective value ((1 | 4) & 1) = 1\n        - (0,1,1) with effective value ((1 | 4) & 4) = 4\n        - (1,0,0) with effective value ((4 | 1) & 1) = 1\n        - (1,0,1) with effective value ((4 | 1) & 4) = 4\n        - (1,1,0) with effective value ((4 | 4) & 1) = 0\n        - (1,1,1) with effective value ((4 | 4) & 4) = 4 \n        Xor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.\n        Example 2:\n        Input: nums = [15,45,20,2,34,35,5,44,32,30]\n        Output: 34\n        Explanation: The xor-beauty of the given array is 34.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1956,"row":{"number":2535,"difficulty":0,"question":"class Solution:\n    def differenceOfSum(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a positive integer array nums.\n            The element sum is the sum of all the elements in nums.\n            The digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.\n        Return the absolute difference between the element sum and digit sum of nums.\n        Note that the absolute difference between two integers x and y is defined as |x - y|.\n        Example 1:\n        Input: nums = [1,15,6,3]\n        Output: 9\n        Explanation: \n        The element sum of nums is 1 + 15 + 6 + 3 = 25.\n        The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.\n        The absolute difference between the element sum and digit sum is |25 - 16| = 9.\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: 0\n        Explanation:\n        The element sum of nums is 1 + 2 + 3 + 4 = 10.\n        The digit sum of nums is 1 + 2 + 3 + 4 = 10.\n        The absolute difference between the element sum and digit sum is |10 - 10| = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1957,"row":{"number":2536,"difficulty":1,"question":"class Solution:\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer matrix mat filled with zeroes.\n        You are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:\n            Add 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat[x][y] for all row1i <= x <= row2i and col1i <= y <= col2i.\n        Return the matrix mat after performing every query.\n        Example 1:\n        Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]\n        Output: [[1,1,0],[1,2,1],[0,1,1]]\n        Explanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.\n        - In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).\n        - In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).\n        Example 2:\n        Input: n = 2, queries = [[0,0,1,1]]\n        Output: [[1,1],[1,1]]\n        Explanation: The diagram above shows the initial matrix and the matrix after the first query.\n        - In the first query we add 1 to every element in the matrix.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1958,"row":{"number":2537,"difficulty":1,"question":"class Solution:\n    def countGood(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the number of good subarrays of nums.\n        A subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,1,1,1,1], k = 10\n        Output: 1\n        Explanation: The only good subarray is the array nums itself.\n        Example 2:\n        Input: nums = [3,1,4,3,2,2,4], k = 2\n        Output: 4\n        Explanation: There are 4 different good subarrays:\n        - [3,1,4,3,2,2] that has 2 pairs.\n        - [3,1,4,3,2,2,4] that has 3 pairs.\n        - [1,4,3,2,2,4] that has 2 pairs.\n        - [4,3,2,2,4] that has 2 pairs.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1959,"row":{"number":2538,"difficulty":2,"question":"class Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        \"\"\"\n        There exists an undirected and initially unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\n        Each node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\n        The price sum of a given path is the sum of the prices of all nodes lying on that path.\n        The tree can be rooted at any node root of your choice. The incurred cost after choosing root is the difference between the maximum and minimum price sum amongst all paths starting at root.\n        Return the maximum possible cost amongst all possible root choices.\n        Example 1:\n        Input: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\n        Output: 24\n        Explanation: The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n        - The first path contains nodes [2,1,3,4]: the prices are [7,8,6,10], and the sum of the prices is 31.\n        - The second path contains the node [2] with the price [7].\n        The difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.\n        Example 2:\n        Input: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]\n        Output: 2\n        Explanation: The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n        - The first path contains nodes [0,1,2]: the prices are [1,1,1], and the sum of the prices is 3.\n        - The second path contains node [0] with a price [1].\n        The difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1960,"row":{"number":2513,"difficulty":1,"question":"class Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        \"\"\"\n        We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:\n            arr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1.\n            arr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2.\n            No integer is present in both arr1 and arr2.\n        Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.\n        Example 1:\n        Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3\n        Output: 4\n        Explanation: \n        We can distribute the first 4 natural numbers into arr1 and arr2.\n        arr1 = [1] and arr2 = [2,3,4].\n        We can see that both arrays satisfy all the conditions.\n        Since the maximum value is 4, we return it.\n        Example 2:\n        Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1\n        Output: 3\n        Explanation: \n        Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.\n        Since the maximum value is 3, we return it.\n        Example 3:\n        Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2\n        Output: 15\n        Explanation: \n        Here, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6].\n        It can be shown that it is not possible to obtain a lower maximum satisfying all conditions. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1961,"row":{"number":2544,"difficulty":0,"question":"class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        \"\"\"\n        You are given a positive integer n. Each digit of n has a sign according to the following rules:\n            The most significant digit is assigned a positive sign.\n            Each other digit has an opposite sign to its adjacent digits.\n        Return the sum of all digits with their corresponding sign.\n        Example 1:\n        Input: n = 521\n        Output: 4\n        Explanation: (+5) + (-2) + (+1) = 4.\n        Example 2:\n        Input: n = 111\n        Output: 1\n        Explanation: (+1) + (-1) + (+1) = 1.\n        Example 3:\n        Input: n = 886996\n        Output: 0\n        Explanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1962,"row":{"number":2545,"difficulty":1,"question":"class Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        \"\"\"\n        There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only.\n        You are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest.\n        Return the matrix after sorting it.\n        Example 1:\n        Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2\n        Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]\n        Explanation: In the above diagram, S denotes the student, while E denotes the exam.\n        - The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.\n        - The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.\n        - The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.\n        Example 2:\n        Input: score = [[3,4],[5,6]], k = 0\n        Output: [[5,6],[3,4]]\n        Explanation: In the above diagram, S denotes the student, while E denotes the exam.\n        - The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.\n        - The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1963,"row":{"number":2546,"difficulty":1,"question":"class Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        \"\"\"\n        You are given two 0-indexed binary strings s and target of the same length n. You can do the following operation on s any number of times:\n            Choose two different indices i and j where 0 <= i, j < n.\n            Simultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR s[j]).\n        For example, if s = \"0110\", you can choose i = 0 and j = 2, then simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = \"1110\".\n        Return true if you can make the string s equal to target, or false otherwise.\n        Example 1:\n        Input: s = \"1010\", target = \"0110\"\n        Output: true\n        Explanation: We can do the following operations:\n        - Choose i = 2 and j = 0. We have now s = \"0010\".\n        - Choose i = 2 and j = 1. We have now s = \"0110\".\n        Since we can make s equal to target, we return true.\n        Example 2:\n        Input: s = \"11\", target = \"00\"\n        Output: false\n        Explanation: It is not possible to make s equal to target with any number of operations.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1964,"row":{"number":2547,"difficulty":2,"question":"class Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer k.\n        Split the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\n        Let trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n            For example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n        The importance value of a subarray is k + trimmed(subarray).length.\n            For example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n        Return the minimum possible cost of a split of nums.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,2,1,2,1,3,3], k = 2\n        Output: 8\n        Explanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\n        The importance value of [1,2] is 2 + (0) = 2.\n        The importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\n        The cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.\n        Example 2:\n        Input: nums = [1,2,1,2,1], k = 2\n        Output: 6\n        Explanation: We split nums to have two subarrays: [1,2], [1,2,1].\n        The importance value of [1,2] is 2 + (0) = 2.\n        The importance value of [1,2,1] is 2 + (2) = 4.\n        The cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.\n        Example 3:\n        Input: nums = [1,2,1,2,1], k = 5\n        Output: 10\n        Explanation: We split nums to have one subarray: [1,2,1,2,1].\n        The importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\n        The cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1965,"row":{"number":2540,"difficulty":0,"question":"class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.\n        Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.\n        Example 1:\n        Input: nums1 = [1,2,3], nums2 = [2,4]\n        Output: 2\n        Explanation: The smallest element common to both arrays is 2, so we return 2.\n        Example 2:\n        Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]\n        Output: 2\n        Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1966,"row":{"number":2543,"difficulty":2,"question":"class Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        \"\"\"\n        There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\n        In one step, you can move from point (x, y) to any one of the following points:\n            (x, y - x)\n            (x - y, y)\n            (2 * x, y)\n            (x, 2 * y)\n        Given two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.\n        Example 1:\n        Input: targetX = 6, targetY = 9\n        Output: false\n        Explanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.\n        Example 2:\n        Input: targetX = 4, targetY = 7\n        Output: true\n        Explanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1967,"row":{"number":2542,"difficulty":1,"question":"class Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        \"\"\"\n        You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\n        For chosen indices i0, i1, ..., ik - 1, your score is defined as:\n            The sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\n            It can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\n        Return the maximum possible score.\n        A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\n        Example 1:\n        Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\n        Output: 12\n        Explanation: \n        The four possible subsequence scores are:\n        - We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.\n        - We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. \n        - We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. \n        - We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.\n        Therefore, we return the max score, which is 12.\n        Example 2:\n        Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\n        Output: 30\n        Explanation: \n        Choosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1968,"row":{"number":2553,"difficulty":0,"question":"class Solution:\n    def separateDigits(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.\n        To separate the digits of an integer is to get all the digits it has in the same order.\n            For example, for the integer 10921, the separation of its digits is [1,0,9,2,1].\n        Example 1:\n        Input: nums = [13,25,83,77]\n        Output: [1,3,2,5,8,3,7,7]\n        Explanation: \n        - The separation of 13 is [1,3].\n        - The separation of 25 is [2,5].\n        - The separation of 83 is [8,3].\n        - The separation of 77 is [7,7].\n        answer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.\n        Example 2:\n        Input: nums = [7,1,3,9]\n        Output: [7,1,3,9]\n        Explanation: The separation of each integer in nums is itself.\n        answer = [7,1,3,9].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1969,"row":{"number":2554,"difficulty":1,"question":"class Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        \"\"\"\n        You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:\n            The chosen integers have to be in the range [1, n].\n            Each integer can be chosen at most once.\n            The chosen integers should not be in the array banned.\n            The sum of the chosen integers should not exceed maxSum.\n        Return the maximum number of integers you can choose following the mentioned rules.\n        Example 1:\n        Input: banned = [1,6,5], n = 5, maxSum = 6\n        Output: 2\n        Explanation: You can choose the integers 2 and 4.\n        2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.\n        Example 2:\n        Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\n        Output: 0\n        Explanation: You cannot choose any integer while following the mentioned conditions.\n        Example 3:\n        Input: banned = [11], n = 7, maxSum = 50\n        Output: 7\n        Explanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.\n        They are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1970,"row":{"number":2556,"difficulty":1,"question":"class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        \"\"\"\n        You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1. The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\n        You can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\n        Return true if it is possible to make the matrix disconnect or false otherwise.\n        Note that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n        Example 1:\n        Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\n        Output: true\n        Explanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n        Example 2:\n        Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: false\n        Explanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1971,"row":{"number":2532,"difficulty":2,"question":"class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        \"\"\"\n        There are k workers who want to move n boxes from an old warehouse to a new one. You are given the two integers n and k, and a 2D integer array time of size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].\n        The warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all k workers are waiting on the left side of the bridge. To move the boxes, the ith worker (0-indexed) can :\n            Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in leftToRighti minutes.\n            Pick a box from the old warehouse and return to the bridge in pickOldi minutes. Different workers can pick up their boxes simultaneously.\n            Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in rightToLefti minutes.\n            Put the box in the new warehouse and return to the bridge in putNewi minutes. Different workers can put their boxes simultaneously.\n        A worker i is less efficient than a worker j if either condition is met:\n            leftToRighti + rightToLefti > leftToRightj + rightToLeftj\n            leftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j\n        The following rules regulate the movement of the workers through the bridge :\n            If a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\n            If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\n            If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\n        Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\n        Example 1:\n        Input: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\n        Output: 6\n        Explanation: \n        From 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\n        From 1 to 2: worker 2 picks up a box from the old warehouse.\n        From 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\n        From 6 to 7: worker 2 puts a box at the new warehouse.\n        The whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n        Example 2:\n        Input: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\n        Output: 50\n        Explanation: \n        From 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.\n        From 10 to 20: worker 1 picks up a box from the old warehouse.\n        From 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\n        From 11 to 20: worker 0 picks up a box from the old warehouse.\n        From 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\n        From 30 to 40: worker 1 puts a box at the new warehouse.\n        From 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\n        From 31 to 39: worker 0 puts a box at the new warehouse.\n        From 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\n        From 40 to 49: worker 0 picks up a box from the old warehouse.\n        From 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\n        From 50 to 58: worker 0 puts a box at the new warehouse.\n        The whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1972,"row":{"number":2582,"difficulty":0,"question":"class Solution:\n    def passThePillow(self, n: int, time: int) -> int:\n        \"\"\"\n        There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\n            For example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.\n        Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.\n        Example 1:\n        Input: n = 4, time = 5\n        Output: 2\n        Explanation: People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.\n        Afer five seconds, the pillow is given to the 2nd person.\n        Example 2:\n        Input: n = 3, time = 2\n        Output: 3\n        Explanation: People pass the pillow in the following way: 1 -> 2 -> 3.\n        Afer two seconds, the pillow is given to the 3rd person.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1973,"row":{"number":2583,"difficulty":1,"question":"class Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        \"\"\"\n        You are given the root of a binary tree and a positive integer k.\n        The level sum in the tree is the sum of the values of the nodes that are on the same level.\n        Return the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\n        Note that two nodes are on the same level if they have the same distance from the root.\n        Example 1:\n        Input: root = [5,8,9,2,1,3,7,4,6], k = 2\n        Output: 13\n        Explanation: The level sums are the following:\n        - Level 1: 5.\n        - Level 2: 8 + 9 = 17.\n        - Level 3: 2 + 1 + 3 + 7 = 13.\n        - Level 4: 4 + 6 = 10.\n        The 2nd largest level sum is 13.\n        Example 2:\n        Input: root = [1,2,null,3], k = 1\n        Output: 3\n        Explanation: The largest level sum is 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1974,"row":{"number":2584,"difficulty":2,"question":"class Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums of length n.\n        A split at an index i where 0 <= i <= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.\n            For example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1.\n        Return the smallest index i at which the array can be split validly or -1 if there is no such split.\n        Two values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.\n        Example 1:\n        Input: nums = [4,7,8,15,3,5]\n        Output: 2\n        Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\n        The only valid split is at index 2.\n        Example 2:\n        Input: nums = [4,7,15,8,3,5]\n        Output: -1\n        Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\n        There is no valid split.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1975,"row":{"number":2585,"difficulty":2,"question":"class Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        \"\"\"\n        There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points.\n        Return the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7.\n        Note that questions of the same type are indistinguishable.\n            For example, if there are 3 questions of the same type, then solving the 1st and 2nd questions is the same as solving the 1st and 3rd questions, or the 2nd and 3rd questions.\n        Example 1:\n        Input: target = 6, types = [[6,1],[3,2],[2,3]]\n        Output: 7\n        Explanation: You can earn 6 points in one of the seven ways:\n        - Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6\n        - Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6\n        - Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6\n        - Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6\n        - Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6\n        - Solve 3 questions of the 1st type: 2 + 2 + 2 = 6\n        - Solve 2 questions of the 2nd type: 3 + 3 = 6\n        Example 2:\n        Input: target = 5, types = [[50,1],[50,2],[50,5]]\n        Output: 4\n        Explanation: You can earn 5 points in one of the four ways:\n        - Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5\n        - Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5\n        - Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5\n        - Solve 1 question of the 2nd type: 5\n        Example 3:\n        Input: target = 18, types = [[6,1],[3,2],[2,3]]\n        Output: 1\n        Explanation: You can only earn 18 points by answering all questions.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1976,"row":{"number":2579,"difficulty":1,"question":"class Solution:\n    def coloredCells(self, n: int) -> int:\n        \"\"\"\n        There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes:\n            At the first minute, color any arbitrary unit cell blue.\n            Every minute thereafter, color blue every uncolored cell that touches a blue cell.\n        Below is a pictorial representation of the state of the grid after minutes 1, 2, and 3.\n        Return the number of colored cells at the end of n minutes.\n        Example 1:\n        Input: n = 1\n        Output: 1\n        Explanation: After 1 minute, there is only 1 blue cell, so we return 1.\n        Example 2:\n        Input: n = 2\n        Output: 5\n        Explanation: After 2 minutes, there are 4 colored cells on the boundary and 1 in the center, so we return 5. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1977,"row":{"number":2578,"difficulty":0,"question":"class Solution:\n    def splitNum(self, num: int) -> int:\n        \"\"\"\n        Given a positive integer num, split it into two non-negative integers num1 and num2 such that:\n            The concatenation of num1 and num2 is a permutation of num.\n                In other words, the sum of the number of occurrences of each digit in num1 and num2 is equal to the number of occurrences of that digit in num.\n            num1 and num2 can contain leading zeros.\n        Return the minimum possible sum of num1 and num2.\n        Notes:\n            It is guaranteed that num does not contain any leading zeros.\n            The order of occurrence of the digits in num1 and num2 may differ from the order of occurrence of num.\n        Example 1:\n        Input: num = 4325\n        Output: 59\n        Explanation: We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.\n        Example 2:\n        Input: num = 687\n        Output: 75\n        Explanation: We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1978,"row":{"number":2580,"difficulty":1,"question":"class Solution:\n    def countWays(self, ranges: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D integer array ranges where ranges[i] = [starti, endi] denotes that all integers between starti and endi (both inclusive) are contained in the ith range.\n        You are to split ranges into two (possibly empty) groups such that:\n            Each range belongs to exactly one group.\n            Any two overlapping ranges must belong to the same group.\n        Two ranges are said to be overlapping if there exists at least one integer that is present in both ranges.\n            For example, [1, 3] and [2, 5] are overlapping because 2 and 3 occur in both ranges.\n        Return the total number of ways to split ranges into two groups. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: ranges = [[6,10],[5,15]]\n        Output: 2\n        Explanation: \n        The two ranges are overlapping, so they must be in the same group.\n        Thus, there are two possible ways:\n        - Put both the ranges together in group 1.\n        - Put both the ranges together in group 2.\n        Example 2:\n        Input: ranges = [[1,3],[10,20],[2,5],[4,8]]\n        Output: 4\n        Explanation: \n        Ranges [1,3], and [2,5] are overlapping. So, they must be in the same group.\n        Again, ranges [2,5] and [4,8] are also overlapping. So, they must also be in the same group. \n        Thus, there are four possible ways to group them:\n        - All the ranges in group 1.\n        - All the ranges in group 2.\n        - Ranges [1,3], [2,5], and [4,8] in group 1 and [10,20] in group 2.\n        - Ranges [1,3], [2,5], and [4,8] in group 2 and [10,20] in group 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1979,"row":{"number":2581,"difficulty":2,"question":"class Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        \"\"\"\n        Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\n        Alice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n            Chooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\n            He tells Alice that u is the parent of v in the tree.\n        Bob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\n        Alice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\n        Given the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.\n        Example 1:\n        Input: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\n        Output: 3\n        Explanation: \n        Root = 0, correct guesses = [1,3], [0,1], [2,4]\n        Root = 1, correct guesses = [1,3], [1,0], [2,4]\n        Root = 2, correct guesses = [1,3], [1,0], [2,4]\n        Root = 3, correct guesses = [1,0], [2,4]\n        Root = 4, correct guesses = [1,3], [1,0]\n        Considering 0, 1, or 2 as root node leads to 3 correct guesses.\n        Example 2:\n        Input: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\n        Output: 5\n        Explanation: \n        Root = 0, correct guesses = [3,4]\n        Root = 1, correct guesses = [1,0], [3,4]\n        Root = 2, correct guesses = [1,0], [2,1], [3,4]\n        Root = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\n        Root = 4, correct guesses = [1,0], [2,1], [3,2]\n        Considering any node as root will give at least 1 correct guess. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1980,"row":{"number":2586,"difficulty":0,"question":"class Solution:\n    def vowelStrings(self, words: List[str], left: int, right: int) -> int:\n        \"\"\"\n        You are given a 0-indexed array of string words and two integers left and right.\n        A string is called a vowel string if it starts with a vowel character and ends with a vowel character where vowel characters are 'a', 'e', 'i', 'o', and 'u'.\n        Return the number of vowel strings words[i] where i belongs to the inclusive range [left, right].\n        Example 1:\n        Input: words = [\"are\",\"amy\",\"u\"], left = 0, right = 2\n        Output: 2\n        Explanation: \n        - \"are\" is a vowel string because it starts with 'a' and ends with 'e'.\n        - \"amy\" is not a vowel string because it does not end with a vowel.\n        - \"u\" is a vowel string because it starts with 'u' and ends with 'u'.\n        The number of vowel strings in the mentioned range is 2.\n        Example 2:\n        Input: words = [\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"], left = 1, right = 4\n        Output: 3\n        Explanation: \n        - \"aeo\" is a vowel string because it starts with 'a' and ends with 'o'.\n        - \"mu\" is not a vowel string because it does not start with a vowel.\n        - \"ooo\" is a vowel string because it starts with 'o' and ends with 'o'.\n        - \"artro\" is a vowel string because it starts with 'a' and ends with 'o'.\n        The number of vowel strings in the mentioned range is 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1981,"row":{"number":2587,"difficulty":1,"question":"class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. You can rearrange the elements of nums to any order (including the given order).\n        Let prefix be the array containing the prefix sums of nums after rearranging it. In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it. The score of nums is the number of positive integers in the array prefix.\n        Return the maximum score you can achieve.\n        Example 1:\n        Input: nums = [2,-1,0,1,-3,3,-3]\n        Output: 6\n        Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].\n        prefix = [2,5,6,5,2,2,-1], so the score is 6.\n        It can be shown that 6 is the maximum score we can obtain.\n        Example 2:\n        Input: nums = [-2,-3,0]\n        Output: 0\n        Explanation: Any rearrangement of the array will result in a score of 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1982,"row":{"number":2588,"difficulty":1,"question":"class Solution:\n    def beautifulSubarrays(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. In one operation, you can:\n            Choose two different indices i and j such that 0 <= i, j < nums.length.\n            Choose a non-negative integer k such that the kth bit (0-indexed) in the binary representation of nums[i] and nums[j] is 1.\n            Subtract 2k from nums[i] and nums[j].\n        A subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times.\n        Return the number of beautiful subarrays in the array nums.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [4,3,1,2,4]\n        Output: 2\n        Explanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and [4,3,1,2,4].\n        - We can make all elements in the subarray [3,1,2] equal to 0 in the following way:\n          - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers. The subarray becomes [1, 1, 0].\n          - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 0, 0].\n        - We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:\n          - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both numbers. The subarray becomes [0, 3, 1, 2, 0].\n          - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 2, 0, 2, 0].\n          - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both numbers. The subarray becomes [0, 0, 0, 0, 0].\n        Example 2:\n        Input: nums = [1,10,4]\n        Output: 0\n        Explanation: There are no beautiful subarrays in nums.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1983,"row":{"number":2589,"difficulty":2,"question":"class Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        \"\"\"\n        There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array tasks where tasks[i] = [starti, endi, durationi] indicates that the ith task should run for a total of durationi seconds (not necessarily continuous) within the inclusive time range [starti, endi].\n        You may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\n        Return the minimum time during which the computer should be turned on to complete all tasks.\n        Example 1:\n        Input: tasks = [[2,3,1],[4,5,1],[1,5,2]]\n        Output: 2\n        Explanation: \n        - The first task can be run in the inclusive time range [2, 2].\n        - The second task can be run in the inclusive time range [5, 5].\n        - The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].\n        The computer will be on for a total of 2 seconds.\n        Example 2:\n        Input: tasks = [[1,3,2],[2,5,3],[5,6,2]]\n        Output: 4\n        Explanation: \n        - The first task can be run in the inclusive time range [2, 3].\n        - The second task can be run in the inclusive time ranges [2, 3] and [5, 5].\n        - The third task can be run in the two inclusive time range [5, 6].\n        The computer will be on for a total of 4 seconds.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1984,"row":{"number":2595,"difficulty":0,"question":"class Solution:\n    def evenOddBit(self, n: int) -> List[int]:\n        \"\"\"\n        You are given a positive integer n.\n        Let even denote the number of even indices in the binary representation of n (0-indexed) with value 1.\n        Let odd denote the number of odd indices in the binary representation of n (0-indexed) with value 1.\n        Return an integer array answer where answer = [even, odd].\n        Example 1:\n        Input: n = 17\n        Output: [2,0]\n        Explanation: The binary representation of 17 is 10001. \n        It contains 1 on the 0th and 4th indices. \n        There are 2 even and 0 odd indices.\n        Example 2:\n        Input: n = 2\n        Output: [0,1]\n        Explanation: The binary representation of 2 is 10.\n        It contains 1 on the 1st index. \n        There are 0 even and 1 odd indices.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1985,"row":{"number":2598,"difficulty":1,"question":"class Solution:\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums and an integer value.\n        In one operation, you can add or subtract value from any element of nums.\n            For example, if nums = [1,2,3] and value = 2, you can choose to subtract value from nums[0] to make nums = [-1,2,3].\n        The MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.\n            For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.\n        Return the maximum MEX of nums after applying the mentioned operation any number of times.\n        Example 1:\n        Input: nums = [1,-10,7,13,6,8], value = 5\n        Output: 4\n        Explanation: One can achieve this result by applying the following operations:\n        - Add value to nums[1] twice to make nums = [1,0,7,13,6,8]\n        - Subtract value from nums[2] once to make nums = [1,0,2,13,6,8]\n        - Subtract value from nums[3] twice to make nums = [1,0,2,3,6,8]\n        The MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve.\n        Example 2:\n        Input: nums = [1,-10,7,13,6,8], value = 7\n        Output: 2\n        Explanation: One can achieve this result by applying the following operation:\n        - subtract value from nums[2] once to make nums = [1,-10,0,13,6,8]\n        The MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1986,"row":{"number":2596,"difficulty":1,"question":"class Solution:\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\n        \"\"\"\n        There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\n        You are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\n        Return true if grid represents a valid configuration of the knight's movements or false otherwise.\n        Note that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n        Example 1:\n        Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\n        Output: true\n        Explanation: The above diagram represents the grid. It can be shown that it is a valid configuration.\n        Example 2:\n        Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\n        Output: false\n        Explanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1987,"row":{"number":2591,"difficulty":0,"question":"class Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        \"\"\"\n        You are given an integer money denoting the amount of money (in dollars) that you have and another integer children denoting the number of children that you must distribute the money to.\n        You have to distribute the money according to the following rules:\n            All money must be distributed.\n            Everyone must receive at least 1 dollar.\n            Nobody receives 4 dollars.\n        Return the maximum number of children who may receive exactly 8 dollars if you distribute the money according to the aforementioned rules. If there is no way to distribute the money, return -1.\n        Example 1:\n        Input: money = 20, children = 3\n        Output: 1\n        Explanation: \n        The maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is:\n        - 8 dollars to the first child.\n        - 9 dollars to the second child. \n        - 3 dollars to the third child.\n        It can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1.\n        Example 2:\n        Input: money = 16, children = 2\n        Output: 2\n        Explanation: Each child can be given 8 dollars.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1988,"row":{"number":2592,"difficulty":1,"question":"class Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. You are allowed to permute nums into a new array perm of your choosing.\n        We define the greatness of nums be the number of indices 0 <= i < nums.length for which perm[i] > nums[i].\n        Return the maximum possible greatness you can achieve after permuting nums.\n        Example 1:\n        Input: nums = [1,3,5,2,1,3,1]\n        Output: 4\n        Explanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].\n        At indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we return 4.\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: 3\n        Explanation: We can prove the optimal perm is [2,3,4,1].\n        At indices = 0, 1, and 2, perm[i] > nums[i]. Hence, we return 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1989,"row":{"number":2594,"difficulty":1,"question":"class Solution:\n    def repairCars(self, ranks: List[int], cars: int) -> int:\n        \"\"\"\n        You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.\n        You are also given an integer cars representing the total number of cars waiting in the garage to be repaired.\n        Return the minimum time taken to repair all the cars.\n        Note: All the mechanics can repair the cars simultaneously.\n        Example 1:\n        Input: ranks = [4,2,3,1], cars = 10\n        Output: 16\n        Explanation: \n        - The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.\n        - The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.\n        - The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.\n        - The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\n        It can be proved that the cars cannot be repaired in less than 16 minutes.\n        Example 2:\n        Input: ranks = [5,1,8], cars = 6\n        Output: 16\n        Explanation: \n        - The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.\n        - The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\n        - The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.\n        It can be proved that the cars cannot be repaired in less than 16 minutes.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1990,"row":{"number":2555,"difficulty":1,"question":"class Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        \"\"\"\n        There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k.\n        You are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n            For example if k = 2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or 2 <= prizePositions[i] <= 4.\n        Return the maximum number of prizes you can win if you choose the two segments optimally.\n        Example 1:\n        Input: prizePositions = [1,1,2,2,3,3,5], k = 2\n        Output: 7\n        Explanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].\n        Example 2:\n        Input: prizePositions = [1,2,3,4], k = 0\n        Output: 2\n        Explanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1991,"row":{"number":2549,"difficulty":0,"question":"class Solution:\n    def distinctIntegers(self, n: int) -> int:\n        \"\"\"\n        You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:\n            For each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.\n            Then, place those numbers on the board.\n        Return the number of distinct integers present on the board after 109 days have elapsed.\n        Note:\n            Once a number is placed on the board, it will remain on it until the end.\n            % stands for the modulo operation. For example, 14 % 3 is 2.\n        Example 1:\n        Input: n = 5\n        Output: 4\n        Explanation: Initially, 5 is present on the board. \n        The next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. \n        After that day, 3 will be added to the board because 4 % 3 == 1. \n        At the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. \n        Example 2:\n        Input: n = 3\n        Output: 2\n        Explanation: \n        Since 3 % 2 == 1, 2 will be added to the board. \n        After a billion days, the only two distinct numbers on the board are 2 and 3. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1992,"row":{"number":2550,"difficulty":1,"question":"class Solution:\n    def monkeyMove(self, n: int) -> int:\n        \"\"\"\n        There is a regular convex polygon with n vertices. The vertices are labeled from 0 to n - 1 in a clockwise direction, and each vertex has exactly one monkey. The following figure shows a convex polygon of 6 vertices.\n        Each monkey moves simultaneously to a neighboring vertex. A neighboring vertex for a vertex i can be:\n            the vertex (i + 1) % n in the clockwise direction, or\n            the vertex (i - 1 + n) % n in the counter-clockwise direction.\n        A collision happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge.\n        Return the number of ways the monkeys can move so that at least one collision  happens. Since the answer may be very large, return it modulo 109 + 7.\n        Note that each monkey can only move once.\n        Example 1:\n        Input: n = 3\n        Output: 6\n        Explanation: There are 8 total possible movements.\n        Two ways such that they collide at some point are:\n        - Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.\n        - Monkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.\n        It can be shown 6 total movements result in a collision.\n        Example 2:\n        Input: n = 4\n        Output: 14\n        Explanation: It can be shown that there are 14 ways for the monkeys to collide.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1993,"row":{"number":2551,"difficulty":2,"question":"class Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        \"\"\"\n        You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.\n        Divide the marbles into the k bags according to the following rules:\n            No bag is empty.\n            If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.\n            If a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].\n        The score after distributing the marbles is the sum of the costs of all the k bags.\n        Return the difference between the maximum and minimum scores among marble distributions.\n        Example 1:\n        Input: weights = [1,3,5,1], k = 2\n        Output: 4\n        Explanation: \n        The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. \n        The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. \n        Thus, we return their difference 10 - 6 = 4.\n        Example 2:\n        Input: weights = [1, 3], k = 2\n        Output: 0\n        Explanation: The only distribution possible is [1],[3]. \n        Since both the maximal and minimal score are the same, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1994,"row":{"number":2552,"difficulty":2,"question":"class Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.\n        A quadruplet (i, j, k, l) is increasing if:\n            0 <= i < j < k < l < n, and\n            nums[i] < nums[k] < nums[j] < nums[l].\n        Example 1:\n        Input: nums = [1,3,2,4,5]\n        Output: 2\n        Explanation: \n        - When i = 0, j = 1, k = 2, and l = 3, nums[i] < nums[k] < nums[j] < nums[l].\n        - When i = 0, j = 1, k = 2, and l = 4, nums[i] < nums[k] < nums[j] < nums[l]. \n        There are no other quadruplets, so we return 2.\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: 0\n        Explanation: There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums[j] < nums[k], we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1995,"row":{"number":2561,"difficulty":2,"question":"class Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        \"\"\"\n        You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:\n            Chose two indices i and j, and swap the ith fruit of basket1 with the jth fruit of basket2.\n            The cost of the swap is min(basket1[i],basket2[j]).\n        Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.\n        Return the minimum cost to make both the baskets equal or -1 if impossible.\n        Example 1:\n        Input: basket1 = [4,2,2,2], basket2 = [1,4,1,2]\n        Output: 1\n        Explanation: Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal.\n        Example 2:\n        Input: basket1 = [2,3,4,1], basket2 = [3,2,5,1]\n        Output: -1\n        Explanation: It can be shown that it is impossible to make both the baskets equal.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1996,"row":{"number":2560,"difficulty":1,"question":"class Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes.\n        The capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\n        You are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars.\n        You are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses.\n        Return the minimum capability of the robber out of all the possible ways to steal at least k houses.\n        Example 1:\n        Input: nums = [2,3,5,9], k = 2\n        Output: 5\n        Explanation: \n        There are three ways to rob at least 2 houses:\n        - Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.\n        - Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.\n        - Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.\n        Therefore, we return min(5, 9, 9) = 5.\n        Example 2:\n        Input: nums = [2,7,9,3,1], k = 2\n        Output: 2\n        Explanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1997,"row":{"number":2559,"difficulty":1,"question":"class Solution:\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array of strings words and a 2D array of integers queries.\n        Each query queries[i] = [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.\n        Return an array ans of size queries.length, where ans[i] is the answer to the ith query.\n        Note that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.\n        Example 1:\n        Input: words = [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"], queries = [[0,2],[1,4],[1,1]]\n        Output: [2,3,0]\n        Explanation: The strings starting and ending with a vowel are \"aba\", \"ece\", \"aa\" and \"e\".\n        The answer to the query [0,2] is 2 (strings \"aba\" and \"ece\").\n        to query [1,4] is 3 (strings \"ece\", \"aa\", \"e\").\n        to query [1,1] is 0.\n        We return [2,3,0].\n        Example 2:\n        Input: words = [\"a\",\"e\",\"i\"], queries = [[0,2],[0,1],[2,2]]\n        Output: [3,2,1]\n        Explanation: Every string satisfies the conditions, so we return [3,2,1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1998,"row":{"number":2558,"difficulty":0,"question":"class Solution:\n    def pickGifts(self, gifts: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:\n            Choose the pile with the maximum number of gifts.\n            If there is more than one pile with the maximum number of gifts, choose any.\n            Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.\n        Return the number of gifts remaining after k seconds.\n        Example 1:\n        Input: gifts = [25,64,9,4,100], k = 4\n        Output: 29\n        Explanation: \n        The gifts are taken in the following way:\n        - In the first second, the last pile is chosen and 10 gifts are left behind.\n        - Then the second pile is chosen and 8 gifts are left behind.\n        - After that the first pile is chosen and 5 gifts are left behind.\n        - Finally, the last pile is chosen again and 3 gifts are left behind.\n        The final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.\n        Example 2:\n        Input: gifts = [1,1,1,1], k = 4\n        Output: 4\n        Explanation: \n        In this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. \n        That is, you can't take any pile with you. \n        So, the total gifts remaining are 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1999,"row":{"number":2593,"difficulty":1,"question":"class Solution:\n    def findScore(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums consisting of positive integers.\n        Starting with score = 0, apply the following algorithm:\n            Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.\n            Add the value of the chosen integer to score.\n            Mark the chosen element and its two adjacent elements if they exist.\n            Repeat until all the array elements are marked.\n        Return the score you get after applying the above algorithm.\n        Example 1:\n        Input: nums = [2,1,3,4,5,2]\n        Output: 7\n        Explanation: We mark the elements as follows:\n        - 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].\n        - 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].\n        - 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].\n        Our score is 1 + 2 + 4 = 7.\n        Example 2:\n        Input: nums = [2,3,5,1,3,2]\n        Output: 5\n        Explanation: We mark the elements as follows:\n        - 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].\n        - 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].\n        - 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].\n        Our score is 1 + 2 + 2 = 5.\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}