{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1200,"row":{"number":1509,"difficulty":1,"question":"class Solution:\n    def minDifference(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums.\n        In one move, you can choose one element of nums and change it to any value.\n        Return the minimum difference between the largest and smallest value of nums after performing at most three moves.\n        Example 1:\n        Input: nums = [5,3,2,4]\n        Output: 0\n        Explanation: We can make at most 3 moves.\n        In the first move, change 2 to 3. nums becomes [5,3,3,4].\n        In the second move, change 4 to 3. nums becomes [5,3,3,3].\n        In the third move, change 5 to 3. nums becomes [3,3,3,3].\n        After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.\n        Example 2:\n        Input: nums = [1,5,0,10,14]\n        Output: 1\n        Explanation: We can make at most 3 moves.\n        In the first move, change 5 to 0. nums becomes [1,0,0,10,14].\n        In the second move, change 10 to 0. nums becomes [1,0,0,0,14].\n        In the third move, change 14 to 1. nums becomes [1,0,0,0,1].\n        After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 0.\n        It can be shown that there is no way to make the difference 0 in 3 moves.\n        Example 3:\n        Input: nums = [3,100,20]\n        Output: 0\n        Explanation: We can make at most 3 moves.\n        In the first move, change 100 to 7. nums becomes [4,7,20].\n        In the second move, change 20 to 7. nums becomes [4,7,7].\n        In the third move, change 4 to 3. nums becomes [7,7,7].\n        After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1201,"row":{"number":1510,"difficulty":2,"question":"class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        \"\"\"\n        Alice and Bob take turns playing a game, with Alice starting first.\n        Initially, there are n stones in a pile. On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.\n        Also, if a player cannot make a move, he/she loses the game.\n        Given a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally.\n        Example 1:\n        Input: n = 1\n        Output: true\n        Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n        Example 2:\n        Input: n = 2\n        Output: false\n        Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n        Example 3:\n        Input: n = 4\n        Output: true\n        Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1202,"row":{"number":1496,"difficulty":0,"question":"class Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        \"\"\"\n        Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.\n        Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.\n        Example 1:\n        Input: path = \"NES\"\n        Output: false \n        Explanation: Notice that the path doesn't cross any point more than once.\n        Example 2:\n        Input: path = \"NESWW\"\n        Output: true\n        Explanation: Notice that the path visits the origin twice.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1203,"row":{"number":1497,"difficulty":1,"question":"class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \"\"\"\n        Given an array of integers arr of even length n and an integer k.\n        We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.\n        Return true If you can find a way to do that or false otherwise.\n        Example 1:\n        Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n        Output: true\n        Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).\n        Example 2:\n        Input: arr = [1,2,3,4,5,6], k = 7\n        Output: true\n        Explanation: Pairs are (1,6),(2,5) and(3,4).\n        Example 3:\n        Input: arr = [1,2,3,4,5,6], k = 10\n        Output: false\n        Explanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1204,"row":{"number":1498,"difficulty":1,"question":"class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        You are given an array of integers nums and an integer target.\n        Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: nums = [3,5,6,7], target = 9\n        Output: 4\n        Explanation: There are 4 subsequences that satisfy the condition.\n        [3] -> Min value + max value <= target (3 + 3 <= 9)\n        [3,5] -> (3 + 5 <= 9)\n        [3,5,6] -> (3 + 6 <= 9)\n        [3,6] -> (3 + 6 <= 9)\n        Example 2:\n        Input: nums = [3,3,6,8], target = 10\n        Output: 6\n        Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).\n        [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]\n        Example 3:\n        Input: nums = [2,3,3,4,6,7], target = 12\n        Output: 61\n        Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).\n        Number of valid subsequences (63 - 2 = 61).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1205,"row":{"number":1499,"difficulty":2,"question":"class Solution:\n    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:\n        \"\"\"\n        You are given an array points containing the coordinates of points on a 2D plane, sorted by the x-values, where points[i] = [xi, yi] such that xi < xj for all 1 <= i < j <= points.length. You are also given an integer k.\n        Return the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| <= k and 1 <= i < j <= points.length.\n        It is guaranteed that there exists at least one pair of points that satisfy the constraint |xi - xj| <= k.\n        Example 1:\n        Input: points = [[1,3],[2,0],[5,10],[6,-10]], k = 1\n        Output: 4\n        Explanation: The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\n        No other pairs satisfy the condition, so we return the max of 4 and 1.\n        Example 2:\n        Input: points = [[0,0],[3,0],[9,2]], k = 3\n        Output: 3\n        Explanation: Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1206,"row":{"number":1502,"difficulty":0,"question":"class Solution:\n    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:\n        \"\"\"\n        A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\n        Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.\n        Example 1:\n        Input: arr = [3,5,1]\n        Output: true\n        Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.\n        Example 2:\n        Input: arr = [1,2,4]\n        Output: false\n        Explanation: There is no way to reorder the elements to obtain an arithmetic progression.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1207,"row":{"number":1503,"difficulty":1,"question":"class Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        \"\"\"\n        We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.\n        When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\n        When an ant reaches one end of the plank at a time t, it falls out of the plank immediately.\n        Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.\n        Example 1:\n        Input: n = 4, left = [4,3], right = [0,1]\n        Output: 4\n        Explanation: In the image above:\n        -The ant at index 0 is named A and going to the right.\n        -The ant at index 1 is named B and going to the right.\n        -The ant at index 3 is named C and going to the left.\n        -The ant at index 4 is named D and going to the left.\n        The last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n        Example 2:\n        Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]\n        Output: 7\n        Explanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n        Example 3:\n        Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []\n        Output: 7\n        Explanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1208,"row":{"number":1504,"difficulty":1,"question":"class Solution:\n    def numSubmat(self, mat: List[List[int]]) -> int:\n        \"\"\"\n        Given an m x n binary matrix mat, return the number of submatrices that have all ones.\n        Example 1:\n        Input: mat = [[1,0,1],[1,1,0],[1,1,0]]\n        Output: 13\n        Explanation: \n        There are 6 rectangles of side 1x1.\n        There are 2 rectangles of side 1x2.\n        There are 3 rectangles of side 2x1.\n        There is 1 rectangle of side 2x2. \n        There is 1 rectangle of side 3x1.\n        Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.\n        Example 2:\n        Input: mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]\n        Output: 24\n        Explanation: \n        There are 8 rectangles of side 1x1.\n        There are 5 rectangles of side 1x2.\n        There are 2 rectangles of side 1x3. \n        There are 4 rectangles of side 2x1.\n        There are 2 rectangles of side 2x2. \n        There are 2 rectangles of side 3x1. \n        There is 1 rectangle of side 3x2. \n        Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1209,"row":{"number":1505,"difficulty":2,"question":"class Solution:\n    def minInteger(self, num: str, k: int) -> str:\n        \"\"\"\n        You are given a string num representing the digits of a very large integer and an integer k. You are allowed to swap any two adjacent digits of the integer at most k times.\n        Return the minimum integer you can obtain also as a string.\n        Example 1:\n        Input: num = \"4321\", k = 4\n        Output: \"1342\"\n        Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n        Example 2:\n        Input: num = \"100\", k = 1\n        Output: \"010\"\n        Explanation: It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n        Example 3:\n        Input: num = \"36789\", k = 1000\n        Output: \"36789\"\n        Explanation: We can keep the number without any swaps.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1210,"row":{"number":1523,"difficulty":0,"question":"class Solution:\n    def countOdds(self, low: int, high: int) -> int:\n        \"\"\"\n        Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).\r\n        Example 1:\r\n        Input: low = 3, high = 7\r\n        Output: 3\r\n        Explanation: The odd numbers between 3 and 7 are [3,5,7].\r\n        Example 2:\r\n        Input: low = 8, high = 10\r\n        Output: 1\r\n        Explanation: The odd numbers between 8 and 10 are [9].\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1211,"row":{"number":1524,"difficulty":1,"question":"class Solution:\n    def numOfSubarrays(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array of integers arr, return the number of subarrays with an odd sum.\n        Since the answer can be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: arr = [1,3,5]\n        Output: 4\n        Explanation: All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]\n        All sub-arrays sum are [1,4,9,3,8,5].\n        Odd sums are [1,9,3,5] so the answer is 4.\n        Example 2:\n        Input: arr = [2,4,6]\n        Output: 0\n        Explanation: All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]\n        All sub-arrays sum are [2,6,12,4,10,6].\n        All sub-arrays have even sum and the answer is 0.\n        Example 3:\n        Input: arr = [1,2,3,4,5,6,7]\n        Output: 16\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1212,"row":{"number":1525,"difficulty":1,"question":"class Solution:\n    def numSplits(self, s: str) -> int:\n        \"\"\"\n        You are given a string s.\n        A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s (i.e., sleft + sright = s) and the number of distinct letters in sleft and sright is the same.\n        Return the number of good splits you can make in s.\n        Example 1:\n        Input: s = \"aacaba\"\n        Output: 2\n        Explanation: There are 5 ways to split \"aacaba\" and 2 of them are good. \n        (\"a\", \"acaba\") Left string and right string contains 1 and 3 different letters respectively.\n        (\"aa\", \"caba\") Left string and right string contains 1 and 3 different letters respectively.\n        (\"aac\", \"aba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n        (\"aaca\", \"ba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n        (\"aacab\", \"a\") Left string and right string contains 3 and 1 different letters respectively.\n        Example 2:\n        Input: s = \"abcd\"\n        Output: 1\n        Explanation: Split the string as follows (\"ab\", \"cd\").\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1213,"row":{"number":1526,"difficulty":2,"question":"class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \"\"\"\n        You are given an integer array target. You have an integer array initial of the same size as target with all elements initially zeros.\n        In one operation you can choose any subarray from initial and increment each value by one.\n        Return the minimum number of operations to form a target array from initial.\n        The test cases are generated so that the answer fits in a 32-bit integer.\n        Example 1:\n        Input: target = [1,2,3,2,1]\n        Output: 3\n        Explanation: We need at least 3 operations to form the target array from the initial array.\n        [0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).\n        [1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).\n        [1,2,2,2,1] increment 1 at index 2.\n        [1,2,3,2,1] target array is formed.\n        Example 2:\n        Input: target = [3,1,1,2]\n        Output: 4\n        Explanation: [0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2]\n        Example 3:\n        Input: target = [3,1,5,4,2]\n        Output: 7\n        Explanation: [0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1214,"row":{"number":1512,"difficulty":0,"question":"class Solution:\n    def numIdenticalPairs(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array of integers nums, return the number of good pairs.\n        A pair (i, j) is called good if nums[i] == nums[j] and i < j.\n        Example 1:\n        Input: nums = [1,2,3,1,1,3]\n        Output: 4\n        Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n        Example 2:\n        Input: nums = [1,1,1,1]\n        Output: 6\n        Explanation: Each pair in the array are good.\n        Example 3:\n        Input: nums = [1,2,3]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1215,"row":{"number":1513,"difficulty":1,"question":"class Solution:\n    def numSub(self, s: str) -> int:\n        \"\"\"\n        Given a binary string s, return the number of substrings with all characters 1's. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: s = \"0110111\"\n        Output: 9\n        Explanation: There are 9 substring in total with only 1's characters.\n        \"1\" -> 5 times.\n        \"11\" -> 3 times.\n        \"111\" -> 1 time.\n        Example 2:\n        Input: s = \"101\"\n        Output: 2\n        Explanation: Substring \"1\" is shown 2 times in s.\n        Example 3:\n        Input: s = \"111111\"\n        Output: 21\n        Explanation: Each substring contains only 1's characters.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1216,"row":{"number":1531,"difficulty":2,"question":"class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        \"\"\"\n        Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"aabccc\" we replace \"aa\" by \"a2\" and replace \"ccc\" by \"c3\". Thus the compressed string becomes \"a2bc3\".\n        Notice that in this problem, we are not adding '1' after single characters.\n        Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.\n        Find the minimum length of the run-length encoded version of s after deleting at most k characters.\n        Example 1:\n        Input: s = \"aaabcccd\", k = 2\n        Output: 4\n        Explanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.\n        Example 2:\n        Input: s = \"aabbaa\", k = 2\n        Output: 2\n        Explanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.\n        Example 3:\n        Input: s = \"aaaaaaaaaaa\", k = 0\n        Output: 3\n        Explanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1217,"row":{"number":1515,"difficulty":2,"question":"class Solution:\n    def getMinDistSum(self, positions: List[List[int]]) -> float:\n        \"\"\"\n        A delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new center in a position such that the sum of the euclidean distances to all customers is minimum.\n        Given an array positions where positions[i] = [xi, yi] is the position of the ith customer on the map, return the minimum sum of the euclidean distances to all customers.\n        In other words, you need to choose the position of the service center [xcentre, ycentre] such that the following formula is minimized:\n        Answers within 10-5 of the actual value will be accepted.\n        Example 1:\n        Input: positions = [[0,1],[1,0],[1,2],[2,1]]\n        Output: 4.00000\n        Explanation: As shown, you can see that choosing [xcentre, ycentre] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve.\n        Example 2:\n        Input: positions = [[1,1],[3,3]]\n        Output: 2.82843\n        Explanation: The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1218,"row":{"number":1518,"difficulty":0,"question":"class Solution:\n    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:\n        \"\"\"\n        There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.\n        The operation of drinking a full water bottle turns it into an empty bottle.\n        Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.\n        Example 1:\n        Input: numBottles = 9, numExchange = 3\n        Output: 13\n        Explanation: You can exchange 3 empty bottles to get 1 full water bottle.\n        Number of water bottles you can drink: 9 + 3 + 1 = 13.\n        Example 2:\n        Input: numBottles = 15, numExchange = 4\n        Output: 19\n        Explanation: You can exchange 4 empty bottles to get 1 full water bottle. \n        Number of water bottles you can drink: 15 + 3 + 1 = 19.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1219,"row":{"number":1519,"difficulty":1,"question":"class Solution:\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\n        \"\"\"\n        You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]).\n        The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\n        Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i.\n        A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\n        Example 1:\n        Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\"\n        Output: [2,1,1,1,1,1,1]\n        Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.\n        Node 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).\n        Example 2:\n        Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\"\n        Output: [4,2,1,1]\n        Explanation: The sub-tree of node 2 contains only node 2, so the answer is 1.\n        The sub-tree of node 3 contains only node 3, so the answer is 1.\n        The sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.\n        The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.\n        Example 3:\n        Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\"\n        Output: [3,2,1,1,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1220,"row":{"number":1520,"difficulty":2,"question":"class Solution:\n    def maxNumOfSubstrings(self, s: str) -> List[str]:\n        \"\"\"\n        Given a string s of lowercase letters, you need to find the maximum number of non-empty substrings of s that meet the following conditions:\n            The substrings do not overlap, that is for any two substrings s[i..j] and s[x..y], either j < x or i > y is true.\n            A substring that contains a certain character c must also contain all occurrences of c.\n        Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. It can be shown that there exists a unique solution of minimum total length.\n        Notice that you can return the substrings in any order.\n        Example 1:\n        Input: s = \"adefaddaccc\"\n        Output: [\"e\",\"f\",\"ccc\"]\n        Explanation: The following are all the possible substrings that meet the conditions:\n        [\n          \"adefaddaccc\"\n          \"adefadda\",\n          \"ef\",\n          \"e\",\n          \"f\",\n          \"ccc\",\n        ]\n        If we choose the first string, we cannot choose anything else and we'd get only 1. If we choose \"adefadda\", we are left with \"ccc\" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose \"ef\" since it can be split into two. Therefore, the optimal way is to choose [\"e\",\"f\",\"ccc\"] which gives us 3 substrings. No other solution of the same number of substrings exist.\n        Example 2:\n        Input: s = \"abbaccd\"\n        Output: [\"d\",\"bb\",\"cc\"]\n        Explanation: Notice that while the set of substrings [\"d\",\"abba\",\"cc\"] also has length 3, it's considered incorrect since it has larger total length.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1221,"row":{"number":1521,"difficulty":2,"question":"class Solution:\n    def closestToTarget(self, arr: List[int], target: int) -> int:\n        \"\"\"\n        Winston was given the above mysterious function func. He has an integer array arr and an integer target and he wants to find the values l and r that make the value |func(arr, l, r) - target| minimum possible.\n        Return the minimum possible value of |func(arr, l, r) - target|.\n        Notice that func should be called with the values l and r where 0 <= l, r < arr.length.\n        Example 1:\n        Input: arr = [9,12,3,7,15], target = 5\n        Output: 2\n        Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.\n        Example 2:\n        Input: arr = [1000000,1000000,1000000], target = 1\n        Output: 999999\n        Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999.\n        Example 3:\n        Input: arr = [1,2,4,8,16], target = 0\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1222,"row":{"number":1539,"difficulty":0,"question":"class Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        \"\"\"\n        Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\n        Return the kth positive integer that is missing from this array.\n        Example 1:\n        Input: arr = [2,3,4,7,11], k = 5\n        Output: 9\n        Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.\n        Example 2:\n        Input: arr = [1,2,3,4], k = 2\n        Output: 6\n        Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1223,"row":{"number":1540,"difficulty":1,"question":"class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \"\"\"\n        Given two strings s and t, your goal is to convert s into t in k moves or less.\n        During the ith (1 <= i <= k) move you can:\n            Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.\n            Do nothing.\n        Shifting a character means replacing it by the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Shifting a character by i means applying the shift operations i times.\n        Remember that any index j can be picked at most once.\n        Return true if it's possible to convert s into t in no more than k moves, otherwise return false.\n        Example 1:\n        Input: s = \"input\", t = \"ouput\", k = 9\n        Output: true\n        Explanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.\n        Example 2:\n        Input: s = \"abc\", t = \"bcd\", k = 10\n        Output: false\n        Explanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\n        Example 3:\n        Input: s = \"aab\", t = \"bbb\", k = 27\n        Output: true\n        Explanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1224,"row":{"number":1541,"difficulty":1,"question":"class Solution:\n    def minInsertions(self, s: str) -> int:\n        \"\"\"\n        Given a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if:\n            Any left parenthesis '(' must have a corresponding two consecutive right parenthesis '))'.\n            Left parenthesis '(' must go before the corresponding two consecutive right parenthesis '))'.\n        In other words, we treat '(' as an opening parenthesis and '))' as a closing parenthesis.\n            For example, \"())\", \"())(())))\" and \"(())())))\" are balanced, \")()\", \"()))\" and \"(()))\" are not balanced.\n        You can insert the characters '(' and ')' at any position of the string to balance it if needed.\n        Return the minimum number of insertions needed to make s balanced.\n        Example 1:\n        Input: s = \"(()))\"\n        Output: 1\n        Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to add one more ')' at the end of the string to be \"(())))\" which is balanced.\n        Example 2:\n        Input: s = \"())\"\n        Output: 0\n        Explanation: The string is already balanced.\n        Example 3:\n        Input: s = \"))())(\"\n        Output: 3\n        Explanation: Add '(' to match the first '))', Add '))' to match the last '('.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1225,"row":{"number":1546,"difficulty":1,"question":"class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n        Example 1:\n        Input: nums = [1,1,1,1,1], target = 2\n        Output: 2\n        Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n        Example 2:\n        Input: nums = [-1,3,5,1,4,2,-9], target = 6\n        Output: 2\n        Explanation: There are 3 subarrays with sum equal to 6.\n        ([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1226,"row":{"number":1528,"difficulty":0,"question":"class Solution:\r\n    def restoreString(self, s: str, indices: List[int]) -> str:\n        \"\"\"\n        You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n        Return the shuffled string.\n        Example 1:\n        Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\n        Output: \"leetcode\"\n        Explanation: As shown, \"codeleet\" becomes \"leetcode\" after shuffling.\n        Example 2:\n        Input: s = \"abc\", indices = [0,1,2]\n        Output: \"abc\"\n        Explanation: After shuffling, each character remains in its position.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1227,"row":{"number":1529,"difficulty":1,"question":"class Solution:\n    def minFlips(self, target: str) -> int:\n        \"\"\"\n        You are given a 0-indexed binary string target of length n. You have another binary string s of length n that is initially set to all zeros. You want to make s equal to target.\n        In one operation, you can pick an index i where 0 <= i < n and flip all bits in the inclusive range [i, n - 1]. Flip means changing '0' to '1' and '1' to '0'.\n        Return the minimum number of operations needed to make s equal to target.\n        Example 1:\n        Input: target = \"10111\"\n        Output: 3\n        Explanation: Initially, s = \"00000\".\n        Choose index i = 2: \"00000\" -> \"00111\"\n        Choose index i = 0: \"00111\" -> \"11000\"\n        Choose index i = 1: \"11000\" -> \"10111\"\n        We need at least 3 flip operations to form target.\n        Example 2:\n        Input: target = \"101\"\n        Output: 3\n        Explanation: Initially, s = \"000\".\n        Choose index i = 0: \"000\" -> \"111\"\n        Choose index i = 1: \"111\" -> \"100\"\n        Choose index i = 2: \"100\" -> \"101\"\n        We need at least 3 flip operations to form target.\n        Example 3:\n        Input: target = \"00000\"\n        Output: 0\n        Explanation: We do not need any operations since the initial s already equals target.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1228,"row":{"number":1530,"difficulty":1,"question":"class Solution:\n    def countPairs(self, root: TreeNode, distance: int) -> int:\n        \"\"\"\n        You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path between them is less than or equal to distance.\n        Return the number of good leaf node pairs in the tree.\n        Example 1:\n        Input: root = [1,2,3,null,4], distance = 3\n        Output: 1\n        Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.\n        Example 2:\n        Input: root = [1,2,3,4,5,6,7], distance = 3\n        Output: 2\n        Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.\n        Example 3:\n        Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n        Output: 1\n        Explanation: The only good pair is [2,5].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1229,"row":{"number":1534,"difficulty":0,"question":"class Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        \"\"\"\n        Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.\r\n        A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:\r\n            0 <= i < j < k < arr.length\r\n            |arr[i] - arr[j]| <= a\r\n            |arr[j] - arr[k]| <= b\r\n            |arr[i] - arr[k]| <= c\r\n        Where |x| denotes the absolute value of x.\r\n        Return the number of good triplets.\r\n        Example 1:\r\n        Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\r\n        Output: 4\r\n        Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].\r\n        Example 2:\r\n        Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1\r\n        Output: 0\r\n        Explanation: No triplet satisfies all conditions.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1230,"row":{"number":1535,"difficulty":1,"question":"class Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array arr of distinct integers and an integer k.\n        A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.\n        Return the integer which will win the game.\n        It is guaranteed that there will be a winner of the game.\n        Example 1:\n        Input: arr = [2,1,3,5,4,6,7], k = 2\n        Output: 5\n        Explanation: Let's see the rounds of the game:\n        Round |       arr       | winner | win_count\n          1   | [2,1,3,5,4,6,7] | 2      | 1\n          2   | [2,3,5,4,6,7,1] | 3      | 1\n          3   | [3,5,4,6,7,1,2] | 5      | 1\n          4   | [5,4,6,7,1,2,3] | 5      | 2\n        So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.\n        Example 2:\n        Input: arr = [3,2,1], k = 10\n        Output: 3\n        Explanation: 3 will win the first 10 rounds consecutively.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1231,"row":{"number":1536,"difficulty":1,"question":"class Solution:\n    def minSwaps(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.\n        A grid is said to be valid if all the cells above the main diagonal are zeros.\n        Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.\n        The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).\n        Example 1:\n        Input: grid = [[0,0,1],[1,1,0],[1,0,0]]\n        Output: 3\n        Example 2:\n        Input: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n        Output: -1\n        Explanation: All rows are similar, swaps have no effect on the grid.\n        Example 3:\n        Input: grid = [[1,0,0],[1,1,0],[1,1,1]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1232,"row":{"number":1537,"difficulty":2,"question":"class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two sorted arrays of distinct integers nums1 and nums2.\n        A valid path is defined as follows:\n            Choose array nums1 or nums2 to traverse (from index-0).\n            Traverse the current array from left to right.\n            If you are reading any value that is present in nums1 and nums2 you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n        The score is defined as the sum of uniques values in a valid path.\n        Return the maximum score you can obtain of all possible valid paths. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\n        Output: 30\n        Explanation: Valid paths:\n        [2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)\n        [4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)\n        The maximum is obtained with the path in green [2,4,6,8,10].\n        Example 2:\n        Input: nums1 = [1,3,5,7,9], nums2 = [3,5,100]\n        Output: 109\n        Explanation: Maximum sum is obtained with the path [1,3,5,100].\n        Example 3:\n        Input: nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]\n        Output: 40\n        Explanation: There are no common elements between nums1 and nums2.\n        Maximum sum is obtained with the path [6,7,8,9,10].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1233,"row":{"number":1556,"difficulty":0,"question":"class Solution:\n    def thousandSeparator(self, n: int) -> str:\n        \"\"\"\n        Given an integer n, add a dot (\".\") as the thousands separator and return it in string format.\n        Example 1:\n        Input: n = 987\n        Output: \"987\"\n        Example 2:\n        Input: n = 1234\n        Output: \"1.234\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1234,"row":{"number":1557,"difficulty":1,"question":"class Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi.\r\n        Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists.\r\n        Notice that you can return the vertices in any order.\r\n        Example 1:\r\n        Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\r\n        Output: [0,3]\r\n        Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].\r\n        Example 2:\r\n        Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\r\n        Output: [0,2,3]\r\n        Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1235,"row":{"number":1558,"difficulty":1,"question":"class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. You have an integer array arr of the same length with all values set to 0 initially. You also have the following modify function:\n        You want to use the modify function to covert arr to nums using the minimum number of calls.\n        Return the minimum number of function calls to make nums from arr.\n        The test cases are generated so that the answer fits in a 32-bit signed integer.\n        Example 1:\n        Input: nums = [1,5]\n        Output: 5\n        Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).\n        Double all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).\n        Increment by 1 (both elements)  [0, 4] -> [1, 4] -> [1, 5] (2 operations).\n        Total of operations: 1 + 2 + 2 = 5.\n        Example 2:\n        Input: nums = [2,2]\n        Output: 3\n        Explanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations).\n        Double all the elements: [1, 1] -> [2, 2] (1 operation).\n        Total of operations: 2 + 1 = 3.\n        Example 3:\n        Input: nums = [4,2,5]\n        Output: 6\n        Explanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5](nums).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1236,"row":{"number":1559,"difficulty":1,"question":"class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        \"\"\"\n        Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\n        A cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\n        Also, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\n        Return true if any cycle of the same value exists in grid, otherwise, return false.\n        Example 1:\n        Input: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\n        Output: true\n        Explanation: There are two valid cycles shown in different colors in the image below:\n        Example 2:\n        Input: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\n        Output: true\n        Explanation: There is only one valid cycle highlighted in the image below:\n        Example 3:\n        Input: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1237,"row":{"number":1544,"difficulty":0,"question":"class Solution:\n    def makeGood(self, s: str) -> str:\n        \"\"\"\n        Given a string s of lower and upper case English letters.\n        A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:\n            0 <= i <= s.length - 2\n            s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.\n        To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.\n        Return the string after making it good. The answer is guaranteed to be unique under the given constraints.\n        Notice that an empty string is also good.\n        Example 1:\n        Input: s = \"leEeetcode\"\n        Output: \"leetcode\"\n        Explanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\".\n        Example 2:\n        Input: s = \"abBAcC\"\n        Output: \"\"\n        Explanation: We have many possible scenarios, and all lead to the same answer. For example:\n        \"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n        \"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\n        Example 3:\n        Input: s = \"s\"\n        Output: \"s\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1238,"row":{"number":1545,"difficulty":1,"question":"class Solution:\n    def findKthBit(self, n: int, k: int) -> str:\n        \"\"\"\n        Given two positive integers n and k, the binary string Sn is formed as follows:\n            S1 = \"0\"\n            Si = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n        Where + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\n        For example, the first four strings in the above sequence are:\n            S1 = \"0\"\n            S2 = \"011\"\n            S3 = \"0111001\"\n            S4 = \"011100110110001\"\n        Return the kth bit in Sn. It is guaranteed that k is valid for the given n.\n        Example 1:\n        Input: n = 3, k = 1\n        Output: \"0\"\n        Explanation: S3 is \"0111001\".\n        The 1st bit is \"0\".\n        Example 2:\n        Input: n = 4, k = 11\n        Output: \"1\"\n        Explanation: S4 is \"011100110110001\".\n        The 11th bit is \"1\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1239,"row":{"number":1542,"difficulty":2,"question":"class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \"\"\"\n        You are given a string s. An awesome substring is a non-empty substring of s such that we can make any number of swaps in order to make it a palindrome.\n        Return the length of the maximum length awesome substring of s.\n        Example 1:\n        Input: s = \"3242415\"\n        Output: 5\n        Explanation: \"24241\" is the longest awesome substring, we can form the palindrome \"24142\" with some swaps.\n        Example 2:\n        Input: s = \"12345678\"\n        Output: 1\n        Example 3:\n        Input: s = \"213123\"\n        Output: 6\n        Explanation: \"213123\" is the longest awesome substring, we can form the palindrome \"231132\" with some swaps.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1240,"row":{"number":1547,"difficulty":2,"question":"class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \"\"\"\n        Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:\n        Given an integer array cuts where cuts[i] denotes a position you should perform a cut at.\n        You should perform the cuts in order, you can change the order of the cuts as you wish.\n        The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n        Return the minimum total cost of the cuts.\n        Example 1:\n        Input: n = 7, cuts = [1,3,4,5]\n        Output: 16\n        Explanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:\n        The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\n        Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n        Example 2:\n        Input: n = 9, cuts = [5,6,1,4,2]\n        Output: 22\n        Explanation: If you try the given cuts ordering the cost will be 25.\n        There are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1241,"row":{"number":1551,"difficulty":1,"question":"class Solution:\n    def minOperations(self, n: int) -> int:\n        \"\"\"\n        You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n).\n        In one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\n        Given an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.\n        Example 1:\n        Input: n = 3\n        Output: 2\n        Explanation: arr = [1, 3, 5]\n        First operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\n        In the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\n        Example 2:\n        Input: n = 6\n        Output: 9\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1242,"row":{"number":1552,"difficulty":1,"question":"class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \"\"\"\n        In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\n        Rick stated that magnetic force between two different balls at positions x and y is |x - y|.\n        Given the integer array position and the integer m. Return the required force.\n        Example 1:\n        Input: position = [1,2,3,4,7], m = 3\n        Output: 3\n        Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n        Example 2:\n        Input: position = [5,4,3,2,1,1000000000], m = 2\n        Output: 999999999\n        Explanation: We can use baskets 1 and 1000000000.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1243,"row":{"number":1553,"difficulty":2,"question":"class Solution:\n    def minDays(self, n: int) -> int:\n        \"\"\"\n        There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:\n            Eat one orange.\n            If the number of remaining oranges n is divisible by 2 then you can eat n / 2 oranges.\n            If the number of remaining oranges n is divisible by 3 then you can eat 2 * (n / 3) oranges.\n        You can only choose one of the actions per day.\n        Given the integer n, return the minimum number of days to eat n oranges.\n        Example 1:\n        Input: n = 10\n        Output: 4\n        Explanation: You have 10 oranges.\n        Day 1: Eat 1 orange,  10 - 1 = 9.  \n        Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\n        Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. \n        Day 4: Eat the last orange  1 - 1  = 0.\n        You need at least 4 days to eat the 10 oranges.\n        Example 2:\n        Input: n = 6\n        Output: 3\n        Explanation: You have 6 oranges.\n        Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\n        Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\n        Day 3: Eat the last orange  1 - 1  = 0.\n        You need at least 3 days to eat the 6 oranges.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1244,"row":{"number":1572,"difficulty":0,"question":"class Solution:\n    def diagonalSum(self, mat: List[List[int]]) -> int:\n        \"\"\"\n        Given a square matrix mat, return the sum of the matrix diagonals.\n        Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.\n        Example 1:\n        Input: mat = [[1,2,3],\n                      [4,5,6],\n                      [7,8,9]]\n        Output: 25\n        Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25\n        Notice that element mat[1][1] = 5 is counted only once.\n        Example 2:\n        Input: mat = [[1,1,1,1],\n                      [1,1,1,1],\n                      [1,1,1,1],\n                      [1,1,1,1]]\n        Output: 8\n        Example 3:\n        Input: mat = [[5]]\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1245,"row":{"number":1573,"difficulty":1,"question":"class Solution:\n    def numWays(self, s: str) -> int:\n        \"\"\"\n        Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.\n        Return the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: s = \"10101\"\n        Output: 4\n        Explanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n        \"1|010|1\"\n        \"1|01|01\"\n        \"10|10|1\"\n        \"10|1|01\"\n        Example 2:\n        Input: s = \"1001\"\n        Output: 0\n        Example 3:\n        Input: s = \"0000\"\n        Output: 3\n        Explanation: There are three ways to split s in 3 parts.\n        \"0|0|00\"\n        \"0|00|0\"\n        \"00|0|0\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1246,"row":{"number":1574,"difficulty":1,"question":"class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\n        Return the length of the shortest subarray to remove.\n        A subarray is a contiguous subsequence of the array.\n        Example 1:\n        Input: arr = [1,2,3,10,4,2,3,5]\n        Output: 3\n        Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\n        Another correct solution is to remove the subarray [3,10,4].\n        Example 2:\n        Input: arr = [5,4,3,2,1]\n        Output: 4\n        Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].\n        Example 3:\n        Input: arr = [1,2,3]\n        Output: 0\n        Explanation: The array is already non-decreasing. We do not need to remove any elements.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1247,"row":{"number":1575,"difficulty":2,"question":"class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \"\"\"\n        You are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.\n        At each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.\n        Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).\n        Return the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n        Output: 4\n        Explanation: The following are all possible routes, each uses 5 units of fuel:\n        1 -> 3\n        1 -> 2 -> 3\n        1 -> 4 -> 3\n        1 -> 4 -> 2 -> 3\n        Example 2:\n        Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6\n        Output: 5\n        Explanation: The following are all possible routes:\n        1 -> 0, used fuel = 1\n        1 -> 2 -> 0, used fuel = 5\n        1 -> 2 -> 1 -> 0, used fuel = 5\n        1 -> 0 -> 1 -> 0, used fuel = 3\n        1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n        Example 3:\n        Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3\n        Output: 0\n        Explanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1248,"row":{"number":1560,"difficulty":0,"question":"class Solution:\n    def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. For example, round 1 starts at sector rounds[0] and ends at sector rounds[1]\n        Return an array of the most visited sectors sorted in ascending order.\n        Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).\n        Example 1:\n        Input: n = 4, rounds = [1,3,1,2]\n        Output: [1,2]\n        Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:\n        1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\n        We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.\n        Example 2:\n        Input: n = 2, rounds = [2,1,2,1,2,1,2,1,2]\n        Output: [2]\n        Example 3:\n        Input: n = 7, rounds = [1,3,5,7]\n        Output: [1,2,3,4,5,6,7]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1249,"row":{"number":1561,"difficulty":1,"question":"class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \"\"\"\n        There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:\n            In each step, you will choose any 3 piles of coins (not necessarily consecutive).\n            Of your choice, Alice will pick the pile with the maximum number of coins.\n            You will pick the next pile with the maximum number of coins.\n            Your friend Bob will pick the last pile.\n            Repeat until there are no more piles of coins.\n        Given an array of integers piles where piles[i] is the number of coins in the ith pile.\n        Return the maximum number of coins that you can have.\n        Example 1:\n        Input: piles = [2,4,1,2,7,8]\n        Output: 9\n        Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.\n        Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.\n        The maximum number of coins which you can have are: 7 + 2 = 9.\n        On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.\n        Example 2:\n        Input: piles = [2,4,5]\n        Output: 4\n        Example 3:\n        Input: piles = [9,8,7,6,5,1,2,3,4]\n        Output: 18\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1250,"row":{"number":1562,"difficulty":1,"question":"class Solution:\n    def findLatestStep(self, arr: List[int], m: int) -> int:\n        \"\"\"\n        Given an array arr that represents a permutation of numbers from 1 to n.\n        You have a binary string of size n that initially has all its bits set to zero. At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1.\n        You are also given an integer m. Find the latest step at which there exists a group of ones of length m. A group of ones is a contiguous substring of 1's such that it cannot be extended in either direction.\n        Return the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.\n        Example 1:\n        Input: arr = [3,5,1,2,4], m = 1\n        Output: 4\n        Explanation: \n        Step 1: \"00100\", groups: [\"1\"]\n        Step 2: \"00101\", groups: [\"1\", \"1\"]\n        Step 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\n        Step 4: \"11101\", groups: [\"111\", \"1\"]\n        Step 5: \"11111\", groups: [\"11111\"]\n        The latest step at which there exists a group of size 1 is step 4.\n        Example 2:\n        Input: arr = [3,1,5,4,2], m = 2\n        Output: -1\n        Explanation: \n        Step 1: \"00100\", groups: [\"1\"]\n        Step 2: \"10100\", groups: [\"1\", \"1\"]\n        Step 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\n        Step 4: \"10111\", groups: [\"1\", \"111\"]\n        Step 5: \"11111\", groups: [\"11111\"]\n        No group of size 2 exists during any step.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1251,"row":{"number":1563,"difficulty":2,"question":"class Solution:\n    def stoneGameV(self, stoneValue: List[int]) -> int:\n        \"\"\"\n        There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\n        In each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n        The game ends when there is only one stone remaining. Alice's is initially zero.\n        Return the maximum score that Alice can obtain.\n        Example 1:\n        Input: stoneValue = [6,2,3,4,5,5]\n        Output: 18\n        Explanation: In the first round, Alice divides the row to [6,2,3], [4,5,5]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\n        In the second round Alice divides the row to [6], [2,3]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\n        The last round Alice has only one choice to divide the row which is [2], [3]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n        Example 2:\n        Input: stoneValue = [7,7,7,7,7,7,7]\n        Output: 28\n        Example 3:\n        Input: stoneValue = [4]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1252,"row":{"number":1566,"difficulty":0,"question":"class Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        \"\"\"\n        Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n        A pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n        Return true if there exists a pattern of length m that is repeated k or more times, otherwise return false.\n        Example 1:\n        Input: arr = [1,2,4,4,4,4], m = 1, k = 3\n        Output: true\n        Explanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.\n        Example 2:\n        Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\n        Output: true\n        Explanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\n        Example 3:\n        Input: arr = [1,2,1,2,1,3], m = 2, k = 3\n        Output: false\n        Explanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1253,"row":{"number":1567,"difficulty":1,"question":"class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.\n        A subarray of an array is a consecutive sequence of zero or more values taken out of that array.\n        Return the maximum length of a subarray with positive product.\n        Example 1:\n        Input: nums = [1,-2,-3,4]\n        Output: 4\n        Explanation: The array nums already has a positive product of 24.\n        Example 2:\n        Input: nums = [0,1,-2,-3,-4]\n        Output: 3\n        Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.\n        Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\n        Example 3:\n        Input: nums = [-1,-2,-3,0,1]\n        Output: 2\n        Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1254,"row":{"number":1568,"difficulty":2,"question":"class Solution:\n    def minDays(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.\n        The grid is said to be connected if we have exactly one island, otherwise is said disconnected.\n        In one day, we are allowed to change any single land cell (1) into a water cell (0).\n        Return the minimum number of days to disconnect the grid.\n        Example 1:\n        Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\n        Output: 2\n        Explanation: We need at least 2 days to get a disconnected grid.\n        Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.\n        Example 2:\n        Input: grid = [[1,1]]\n        Output: 2\n        Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1255,"row":{"number":1569,"difficulty":2,"question":"class Solution:\n    def numOfWays(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.\n            For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.\n        Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.\n        Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: nums = [2,1,3]\n        Output: 1\n        Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n        Example 2:\n        Input: nums = [3,4,5,1,2]\n        Output: 5\n        Explanation: The following 5 arrays will yield the same BST: \n        [3,1,2,4,5]\n        [3,1,4,2,5]\n        [3,1,4,5,2]\n        [3,4,1,2,5]\n        [3,4,1,5,2]\n        Example 3:\n        Input: nums = [1,2,3]\n        Output: 0\n        Explanation: There are no other orderings of nums that will yield the same BST.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1256,"row":{"number":1588,"difficulty":0,"question":"class Solution:\n    def sumOddLengthSubarrays(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr.\n        A subarray is a contiguous subsequence of the array.\n        Example 1:\n        Input: arr = [1,4,2,5,3]\n        Output: 58\n        Explanation: The odd-length subarrays of arr and their sums are:\n        [1] = 1\n        [4] = 4\n        [2] = 2\n        [5] = 5\n        [3] = 3\n        [1,4,2] = 7\n        [4,2,5] = 11\n        [2,5,3] = 10\n        [1,4,2,5,3] = 15\n        If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n        Example 2:\n        Input: arr = [1,2]\n        Output: 3\n        Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.\n        Example 3:\n        Input: arr = [10,11,12]\n        Output: 66\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1257,"row":{"number":1590,"difficulty":1,"question":"class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \"\"\"\n        Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.\n        Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.\n        A subarray is defined as a contiguous block of elements in the array.\n        Example 1:\n        Input: nums = [3,1,4,2], p = 6\n        Output: 1\n        Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.\n        Example 2:\n        Input: nums = [6,3,5,2], p = 9\n        Output: 2\n        Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.\n        Example 3:\n        Input: nums = [1,2,3], p = 3\n        Output: 0\n        Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1258,"row":{"number":1589,"difficulty":1,"question":"class Solution:\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\n        \"\"\"\n        We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both starti and endi are 0-indexed.\n        Return the maximum total sum of all requests among all permutations of nums.\n        Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\n        Output: 19\n        Explanation: One permutation of nums is [2,1,3,4,5] with the following result: \n        requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\n        requests[1] -> nums[0] + nums[1] = 2 + 1 = 3\n        Total sum: 8 + 3 = 11.\n        A permutation with a higher total sum is [3,5,4,2,1] with the following result:\n        requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\n        requests[1] -> nums[0] + nums[1] = 3 + 5  = 8\n        Total sum: 11 + 8 = 19, which is the best that you can do.\n        Example 2:\n        Input: nums = [1,2,3,4,5,6], requests = [[0,1]]\n        Output: 11\n        Explanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].\n        Example 3:\n        Input: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\n        Output: 47\n        Explanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1259,"row":{"number":1591,"difficulty":2,"question":"class Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        \"\"\"\n        There is a strange printer with the following two special requirements:\n            On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n            Once the printer has used a color for the above operation, the same color cannot be used again.\n        You are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid.\n        Return true if it is possible to print the matrix targetGrid, otherwise, return false.\n        Example 1:\n        Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n        Output: true\n        Example 2:\n        Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n        Output: true\n        Example 3:\n        Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n        Output: false\n        Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1260,"row":{"number":1576,"difficulty":0,"question":"class Solution:\n    def modifyString(self, s: str) -> str:\n        \"\"\"\n        Given a string s containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters such that the final string does not contain any consecutive repeating characters. You cannot modify the non '?' characters.\n        It is guaranteed that there are no consecutive repeating characters in the given string except for '?'.\n        Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. It can be shown that an answer is always possible with the given constraints.\n        Example 1:\n        Input: s = \"?zs\"\n        Output: \"azs\"\n        Explanation: There are 25 solutions for this problem. From \"azs\" to \"yzs\", all are valid. Only \"z\" is an invalid modification as the string will consist of consecutive repeating characters in \"zzs\".\n        Example 2:\n        Input: s = \"ubv?w\"\n        Output: \"ubvaw\"\n        Explanation: There are 24 solutions for this problem. Only \"v\" and \"w\" are invalid modifications as the strings will consist of consecutive repeating characters in \"ubvvw\" and \"ubvww\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1261,"row":{"number":1577,"difficulty":1,"question":"class Solution:\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:\n            Type 1: Triplet (i, j, k) if nums1[i]2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length.\n            Type 2: Triplet (i, j, k) if nums2[i]2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length.\n        Example 1:\n        Input: nums1 = [7,4], nums2 = [5,2,8,9]\n        Output: 1\n        Explanation: Type 1: (1, 1, 2), nums1[1]2 = nums2[1] * nums2[2]. (42 = 2 * 8). \n        Example 2:\n        Input: nums1 = [1,1], nums2 = [1,1,1]\n        Output: 9\n        Explanation: All Triplets are valid, because 12 = 1 * 1.\n        Type 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]2 = nums2[j] * nums2[k].\n        Type 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]2 = nums1[j] * nums1[k].\n        Example 3:\n        Input: nums1 = [7,7,8,3], nums2 = [1,2,9,7]\n        Output: 2\n        Explanation: There are 2 valid triplets.\n        Type 1: (3,0,2).  nums1[3]2 = nums2[0] * nums2[2].\n        Type 2: (3,0,1).  nums2[3]2 = nums1[0] * nums1[1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1262,"row":{"number":1578,"difficulty":1,"question":"class Solution:\n    def minCost(self, colors: str, neededTime: List[int]) -> int:\n        \"\"\"\n        Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.\n        Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.\n        Return the minimum time Bob needs to make the rope colorful.\n        Example 1:\n        Input: colors = \"abaac\", neededTime = [1,2,3,4,5]\n        Output: 3\n        Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.\n        Bob can remove the blue balloon at index 2. This takes 3 seconds.\n        There are no longer two consecutive balloons of the same color. Total time = 3.\n        Example 2:\n        Input: colors = \"abc\", neededTime = [1,2,3]\n        Output: 0\n        Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.\n        Example 3:\n        Input: colors = \"aabaa\", neededTime = [1,2,3,4,1]\n        Output: 2\n        Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\n        There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1263,"row":{"number":1579,"difficulty":2,"question":"class Solution:\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n        \"\"\"\n        Alice and Bob have an undirected graph of n nodes and three types of edges:\n            Type 1: Can be traversed by Alice only.\n            Type 2: Can be traversed by Bob only.\n            Type 3: Can be traversed by both Alice and Bob.\n        Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\n        Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.\n        Example 1:\n        Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n        Output: 2\n        Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n        Example 2:\n        Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n        Output: 0\n        Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n        Example 3:\n        Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n        Output: -1\n        Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1264,"row":{"number":1582,"difficulty":0,"question":"class Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        \"\"\"\n        Given an m x n binary matrix mat, return the number of special positions in mat.\n        A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).\n        Example 1:\n        Input: mat = [[1,0,0],[0,0,1],[1,0,0]]\n        Output: 1\n        Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.\n        Example 2:\n        Input: mat = [[1,0,0],[0,1,0],[0,0,1]]\n        Output: 3\n        Explanation: (0, 0), (1, 1) and (2, 2) are special positions.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1265,"row":{"number":1583,"difficulty":1,"question":"class Solution:\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        \"\"\"\n        You are given a list of preferences for n friends, where n is always even.\n        For each person i, preferences[i] contains a list of friends sorted in the order of preference. In other words, a friend earlier in the list is more preferred than a friend later in the list. Friends in each list are denoted by integers from 0 to n-1.\n        All the friends are divided into pairs. The pairings are given in a list pairs, where pairs[i] = [xi, yi] denotes xi is paired with yi and yi is paired with xi.\n        However, this pairing may cause some of the friends to be unhappy. A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n            x prefers u over y, and\n            u prefers x over v.\n        Return the number of unhappy friends.\n        Example 1:\n        Input: n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\n        Output: 2\n        Explanation:\n        Friend 1 is unhappy because:\n        - 1 is paired with 0 but prefers 3 over 0, and\n        - 3 prefers 1 over 2.\n        Friend 3 is unhappy because:\n        - 3 is paired with 2 but prefers 1 over 2, and\n        - 1 prefers 3 over 0.\n        Friends 0 and 2 are happy.\n        Example 2:\n        Input: n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\n        Output: 0\n        Explanation: Both friends 0 and 1 are happy.\n        Example 3:\n        Input: n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1266,"row":{"number":1584,"difficulty":1,"question":"class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \"\"\"\n        You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\n        The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\n        Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\n        Example 1:\n        Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n        Output: 20\n        Explanation: \n        We can connect the points as shown above to get the minimum cost of 20.\n        Notice that there is a unique path between every pair of points.\n        Example 2:\n        Input: points = [[3,12],[-2,5],[-4,1]]\n        Output: 18\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1267,"row":{"number":1585,"difficulty":2,"question":"class Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        \"\"\"\n        Given two strings s and t, transform string s into string t using the following operation any number of times:\n            Choose a non-empty substring in s and sort it in place so the characters are in ascending order.\n                For example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n        Return true if it is possible to transform s into t. Otherwise, return false.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"84532\", t = \"34852\"\n        Output: true\n        Explanation: You can transform s into t using the following sort operations:\n        \"84532\" (from index 2 to 3) -> \"84352\"\n        \"84352\" (from index 0 to 2) -> \"34852\"\n        Example 2:\n        Input: s = \"34521\", t = \"23415\"\n        Output: true\n        Explanation: You can transform s into t using the following sort operations:\n        \"34521\" -> \"23451\"\n        \"23451\" -> \"23415\"\n        Example 3:\n        Input: s = \"12345\", t = \"12435\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1268,"row":{"number":1603,"difficulty":0,"question":"class ParkingSystem:\n    def __init__(self, big: int, medium: int, small: int):\n    def addCar(self, carType: int) -> bool:\n        \"\"\"\n        Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\n        Implement the ParkingSystem class:\n            ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.\n            bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.\n        Example 1:\n        Input\n        [\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n        [[1, 1, 0], [1], [2], [3], [1]]\n        Output\n        [null, true, true, false, false]\n        Explanation\n        ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\n        parkingSystem.addCar(1); // return true because there is 1 available slot for a big car\n        parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\n        parkingSystem.addCar(3); // return false because there is no available slot for a small car\n        parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1269,"row":{"number":1604,"difficulty":1,"question":"class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \"\"\"\n        LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. The system emits an alert if any worker uses the key-card three or more times in a one-hour period.\n        You are given a list of strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a person's name and the time when their key-card was used in a single day.\n        Access times are given in the 24-hour time format \"HH:MM\", such as \"23:51\" and \"09:49\".\n        Return a list of unique worker names who received an alert for frequent keycard use. Sort the names in ascending order alphabetically.\n        Notice that \"10:00\" - \"11:00\" is considered to be within a one-hour period, while \"22:51\" - \"23:52\" is not considered to be within a one-hour period.\n        Example 1:\n        Input: keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]\n        Output: [\"daniel\"]\n        Explanation: \"daniel\" used the keycard 3 times in a one-hour period (\"10:00\",\"10:40\", \"11:00\").\n        Example 2:\n        Input: keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]\n        Output: [\"bob\"]\n        Explanation: \"bob\" used the keycard 3 times in a one-hour period (\"21:00\",\"21:20\", \"21:30\").\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1270,"row":{"number":1606,"difficulty":2,"question":"class Solution:\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\n        \"\"\"\n        You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:\n            The ith (0-indexed) request arrives.\n            If all servers are busy, the request is dropped (not handled at all).\n            If the (i % k)th server is available, assign the request to that server.\n            Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the ith server is busy, try to assign the request to the (i+1)th server, then the (i+2)th server, and so on.\n        You are given a strictly increasing array arrival of positive integers, where arrival[i] represents the arrival time of the ith request, and another array load, where load[i] represents the load of the ith request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.\n        Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.\n        Example 1:\n        Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n        Output: [1] \n        Explanation: \n        All of the servers start out available.\n        The first 3 requests are handled by the first 3 servers in order.\n        Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\n        Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\n        Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n        Example 2:\n        Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n        Output: [0]\n        Explanation: \n        The first 3 requests are handled by first 3 servers.\n        Request 3 comes in. It is handled by server 0 since the server is available.\n        Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n        Example 3:\n        Input: k = 3, arrival = [1,2,3], load = [10,12,11]\n        Output: [0,1,2]\n        Explanation: Each server handles a single request, so they are all considered the busiest.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1271,"row":{"number":1605,"difficulty":1,"question":"class Solution:\n    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.\n        Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.\n        Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.\n        Example 1:\n        Input: rowSum = [3,8], colSum = [4,7]\n        Output: [[3,0],\n                 [1,7]]\n        Explanation: \n        0th row: 3 + 0 = 3 == rowSum[0]\n        1st row: 1 + 7 = 8 == rowSum[1]\n        0th column: 3 + 1 = 4 == colSum[0]\n        1st column: 0 + 7 = 7 == colSum[1]\n        The row and column sums match, and all matrix elements are non-negative.\n        Another possible matrix is: [[1,2],\n                                     [3,5]]\n        Example 2:\n        Input: rowSum = [5,7,10], colSum = [8,6,8]\n        Output: [[0,5,0],\n                 [6,1,0],\n                 [2,0,8]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1272,"row":{"number":1592,"difficulty":0,"question":"class Solution:\n    def reorderSpaces(self, text: str) -> str:\n        \"\"\"\n        You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word.\n        Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.\n        Return the string after rearranging the spaces.\n        Example 1:\n        Input: text = \"  this   is  a sentence \"\n        Output: \"this   is   a   sentence\"\n        Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.\n        Example 2:\n        Input: text = \" practice   makes   perfect\"\n        Output: \"practice   makes   perfect \"\n        Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1273,"row":{"number":1593,"difficulty":1,"question":"class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \"\"\"\n        Given a string s, return the maximum number of unique substrings that the given string can be split into.\n        You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"ababccc\"\n        Output: 5\n        Explanation: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times.\n        Example 2:\n        Input: s = \"aba\"\n        Output: 2\n        Explanation: One way to split maximally is ['a', 'ba'].\n        Example 3:\n        Input: s = \"aa\"\n        Output: 1\n        Explanation: It is impossible to split the string any further.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1274,"row":{"number":1594,"difficulty":1,"question":"class Solution:\n    def maxProductPath(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given a m x n matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.\n        Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (m - 1, n - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.\n        Return the maximum non-negative product modulo 109 + 7. If the maximum product is negative, return -1.\n        Notice that the modulo is performed after getting the maximum product.\n        Example 1:\n        Input: grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]\n        Output: -1\n        Explanation: It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.\n        Example 2:\n        Input: grid = [[1,-2,1],[1,-2,1],[3,-4,1]]\n        Output: 8\n        Explanation: Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8).\n        Example 3:\n        Input: grid = [[1,3],[0,-4]]\n        Output: 0\n        Explanation: Maximum non-negative product is shown (1 * 0 * -4 = 0).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1275,"row":{"number":1595,"difficulty":2,"question":"class Solution:\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\n        \"\"\"\n        You are given two groups of points where the first group has size1 points, the second group has size2 points, and size1 >= size2.\n        The cost of the connection between any two points are given in an size1 x size2 matrix where cost[i][j] is the cost of connecting point i of the first group and point j of the second group. The groups are connected if each point in both groups is connected to one or more points in the opposite group. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.\n        Return the minimum cost it takes to connect the two groups.\n        Example 1:\n        Input: cost = [[15, 96], [36, 2]]\n        Output: 17\n        Explanation: The optimal way of connecting the groups is:\n        1--A\n        2--B\n        This results in a total cost of 17.\n        Example 2:\n        Input: cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n        Output: 4\n        Explanation: The optimal way of connecting the groups is:\n        1--A\n        2--B\n        2--C\n        3--A\n        This results in a total cost of 4.\n        Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.\n        Example 3:\n        Input: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n        Output: 10\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1276,"row":{"number":1598,"difficulty":0,"question":"class Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        \"\"\"\n        The Leetcode file system keeps a log each time some user performs a change folder operation.\n        The operations are described below:\n            \"../\" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).\n            \"./\" : Remain in the same folder.\n            \"x/\" : Move to the child folder named x (This folder is guaranteed to always exist).\n        You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.\n        The file system starts in the main folder, then the operations in logs are performed.\n        Return the minimum number of operations needed to go back to the main folder after the change folder operations.\n        Example 1:\n        Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n        Output: 2\n        Explanation: Use this change folder operation \"../\" 2 times and go back to the main folder.\n        Example 2:\n        Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n        Output: 3\n        Example 3:\n        Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1277,"row":{"number":1599,"difficulty":1,"question":"class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \"\"\"\n        You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\n        You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\n        You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\n        Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.\n        Example 1:\n        Input: customers = [8,3], boardingCost = 5, runningCost = 6\n        Output: 3\n        Explanation: The numbers written on the gondolas are the number of people currently there.\n        1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n        2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n        3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\n        The highest profit was $37 after rotating the wheel 3 times.\n        Example 2:\n        Input: customers = [10,9,6], boardingCost = 6, runningCost = 4\n        Output: 7\n        Explanation:\n        1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n        2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n        3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n        4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n        5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n        6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n        7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\n        The highest profit was $122 after rotating the wheel 7 times.\n        Example 3:\n        Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n        Output: -1\n        Explanation:\n        1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n        2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n        3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n        4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n        5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\n        The profit was never positive, so return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1278,"row":{"number":1600,"difficulty":1,"question":"class ThroneInheritance:\n    def __init__(self, kingName: str):\n    def birth(self, parentName: str, childName: str) -> None:\n    def death(self, name: str) -> None:\n    def getInheritanceOrder(self) -> List[str]:\n        \"\"\"\n        A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.\n        The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let's define the recursive function Successor(x, curOrder), which given a person x and the inheritance order so far, returns who should be the next person after x in the order of inheritance.\n        Successor(x, curOrder):\n            if x has no children or all of x's children are in curOrder:\n                if x is the king return null\n                else return Successor(x's parent, curOrder)\n            else return x's oldest child who's not in curOrder\n        For example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice's son Jack.\n            In the beginning, curOrder will be [\"king\"].\n            Calling Successor(king, curOrder) will return Alice, so we append to curOrder to get [\"king\", \"Alice\"].\n            Calling Successor(Alice, curOrder) will return Jack, so we append to curOrder to get [\"king\", \"Alice\", \"Jack\"].\n            Calling Successor(Jack, curOrder) will return Bob, so we append to curOrder to get [\"king\", \"Alice\", \"Jack\", \"Bob\"].\n            Calling Successor(Bob, curOrder) will return null. Thus the order of inheritance will be [\"king\", \"Alice\", \"Jack\", \"Bob\"].\n        Using the above function, we can always obtain a unique order of inheritance.\n        Implement the ThroneInheritance class:\n            ThroneInheritance(string kingName) Initializes an object of the ThroneInheritance class. The name of the king is given as part of the constructor.\n            void birth(string parentName, string childName) Indicates that parentName gave birth to childName.\n            void death(string name) Indicates the death of name. The death of the person doesn't affect the Successor function nor the current inheritance order. You can treat it as just marking the person as dead.\n            string[] getInheritanceOrder() Returns a list representing the current order of inheritance excluding dead people.\n        Example 1:\n        Input\n        [\"ThroneInheritance\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"getInheritanceOrder\", \"death\", \"getInheritanceOrder\"]\n        [[\"king\"], [\"king\", \"andy\"], [\"king\", \"bob\"], [\"king\", \"catherine\"], [\"andy\", \"matthew\"], [\"bob\", \"alex\"], [\"bob\", \"asha\"], [null], [\"bob\"], [null]]\n        Output\n        [null, null, null, null, null, null, null, [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"], null, [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]]\n        Explanation\n        ThroneInheritance t= new ThroneInheritance(\"king\"); // order: king\n        t.birth(\"king\", \"andy\"); // order: king > andy\n        t.birth(\"king\", \"bob\"); // order: king > andy > bob\n        t.birth(\"king\", \"catherine\"); // order: king > andy > bob > catherine\n        t.birth(\"andy\", \"matthew\"); // order: king > andy > matthew > bob > catherine\n        t.birth(\"bob\", \"alex\"); // order: king > andy > matthew > bob > alex > catherine\n        t.birth(\"bob\", \"asha\"); // order: king > andy > matthew > bob > alex > asha > catherine\n        t.getInheritanceOrder(); // return [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"]\n        t.death(\"bob\"); // order: king > andy > matthew > bob > alex > asha > catherine\n        t.getInheritanceOrder(); // return [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1279,"row":{"number":1601,"difficulty":2,"question":"class Solution:\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n        \"\"\"\n        We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.\n        You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.\n        All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.\n        Return the maximum number of achievable requests.\n        Example 1:\n        Input: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n        Output: 5\n        Explantion: Let's see the requests:\n        From building 0 we have employees x and y and both want to move to building 1.\n        From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\n        From building 2 we have employee z and they want to move to building 0.\n        From building 3 we have employee c and they want to move to building 4.\n        From building 4 we don't have any requests.\n        We can achieve the requests of users x and b by swapping their places.\n        We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n        Example 2:\n        Input: n = 3, requests = [[0,0],[1,2],[2,1]]\n        Output: 3\n        Explantion: Let's see the requests:\n        From building 0 we have employee x and they want to stay in the same building 0.\n        From building 1 we have employee y and they want to move to building 2.\n        From building 2 we have employee z and they want to move to building 1.\n        We can achieve all the requests. \n        Example 3:\n        Input: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1280,"row":{"number":1621,"difficulty":1,"question":"class Solution:\n    def numberOfSets(self, n: int, k: int) -> int:\n        \"\"\"\n        Given n points on a 1-D plane, where the ith point (from 0 to n-1) is at x = i, find the number of ways we can draw exactly k non-overlapping line segments such that each segment covers two or more points. The endpoints of each segment must have integral coordinates. The k line segments do not have to cover all n points, and they are allowed to share endpoints.\n        Return the number of ways we can draw k non-overlapping line segments. Since this number can be huge, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: 5\n        Explanation: The two line segments are shown in red and blue.\n        The image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.\n        Example 2:\n        Input: n = 3, k = 1\n        Output: 3\n        Explanation: The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.\n        Example 3:\n        Input: n = 30, k = 7\n        Output: 796297179\n        Explanation: The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 109 + 7 gives us 796297179.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1281,"row":{"number":1620,"difficulty":1,"question":"class Solution:\n    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:\n        \"\"\"\n        You are given an array of network towers towers, where towers[i] = [xi, yi, qi] denotes the ith network tower with location (xi, yi) and quality factor qi. All the coordinates are integral coordinates on the X-Y plane, and the distance between the two coordinates is the Euclidean distance.\n        You are also given an integer radius where a tower is reachable if the distance is less than or equal to radius. Outside that distance, the signal becomes garbled, and the tower is not reachable.\n        The signal quality of the ith tower at a coordinate (x, y) is calculated with the formula ⌊qi / (1 + d)⌋, where d is the distance between the tower and the coordinate. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers.\n        Return the array [cx, cy] representing the integral coordinate (cx, cy) where the network quality is maximum. If there are multiple coordinates with the same network quality, return the lexicographically minimum non-negative coordinate.\n        Note:\n            A coordinate (x1, y1) is lexicographically smaller than (x2, y2) if either:\n                x1 < x2, or\n                x1 == x2 and y1 < y2.\n            ⌊val⌋ is the greatest integer less than or equal to val (the floor function).\n        Example 1:\n        Input: towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\n        Output: [2,1]\n        Explanation: At coordinate (2, 1) the total quality is 13.\n        - Quality of 7 from (2, 1) results in ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7\n        - Quality of 5 from (1, 2) results in ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2\n        - Quality of 9 from (3, 1) results in ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4\n        No other coordinate has a higher network quality.\n        Example 2:\n        Input: towers = [[23,11,21]], radius = 9\n        Output: [23,11]\n        Explanation: Since there is only one tower, the network quality is highest right at the tower's location.\n        Example 3:\n        Input: towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\n        Output: [1,2]\n        Explanation: Coordinate (1, 2) has the highest network quality.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1282,"row":{"number":1728,"difficulty":2,"question":"class Solution:\n    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:\n        \"\"\"\n        A game is played by a cat and a mouse named Cat and Mouse.\n        The environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food.\n            Players are represented by the characters 'C'(Cat),'M'(Mouse).\n            Floors are represented by the character '.' and can be walked on.\n            Walls are represented by the character '#' and cannot be walked on.\n            Food is represented by the character 'F' and can be walked on.\n            There is only one of each character 'C', 'M', and 'F' in grid.\n        Mouse and Cat play according to the following rules:\n            Mouse moves first, then they take turns to move.\n            During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid.\n            catJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n            Staying in the same position is allowed.\n            Mouse can jump over Cat.\n        The game can end in 4 ways:\n            If Cat occupies the same position as Mouse, Cat wins.\n            If Cat reaches the food first, Cat wins.\n            If Mouse reaches the food first, Mouse wins.\n            If Mouse cannot get to the food within 1000 turns, Cat wins.\n        Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.\n        Example 1:\n        Input: grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\n        Output: true\n        Explanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n        Example 2:\n        Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\n        Output: true\n        Example 3:\n        Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1283,"row":{"number":1622,"difficulty":2,"question":"class Fancy:\n    def __init__(self):\n    def append(self, val: int) -> None:\n    def addAll(self, inc: int) -> None:\n    def multAll(self, m: int) -> None:\n    def getIndex(self, idx: int) -> int:\n        \"\"\"\n        Write an API that generates fancy sequences using the append, addAll, and multAll operations.\n        Implement the Fancy class:\n            Fancy() Initializes the object with an empty sequence.\n            void append(val) Appends an integer val to the end of the sequence.\n            void addAll(inc) Increments all existing values in the sequence by an integer inc.\n            void multAll(m) Multiplies all existing values in the sequence by an integer m.\n            int getIndex(idx) Gets the current value at index idx (0-indexed) of the sequence modulo 109 + 7. If the index is greater or equal than the length of the sequence, return -1.\n        Example 1:\n        Input\n        [\"Fancy\", \"append\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"getIndex\", \"getIndex\"]\n        [[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]\n        Output\n        [null, null, null, null, null, 10, null, null, null, 26, 34, 20]\n        Explanation\n        Fancy fancy = new Fancy();\n        fancy.append(2);   // fancy sequence: [2]\n        fancy.addAll(3);   // fancy sequence: [2+3] -> [5]\n        fancy.append(7);   // fancy sequence: [5, 7]\n        fancy.multAll(2);  // fancy sequence: [5*2, 7*2] -> [10, 14]\n        fancy.getIndex(0); // return 10\n        fancy.addAll(3);   // fancy sequence: [10+3, 14+3] -> [13, 17]\n        fancy.append(10);  // fancy sequence: [13, 17, 10]\n        fancy.multAll(2);  // fancy sequence: [13*2, 17*2, 10*2] -> [26, 34, 20]\n        fancy.getIndex(0); // return 26\n        fancy.getIndex(1); // return 34\n        fancy.getIndex(2); // return 20\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1284,"row":{"number":1608,"difficulty":0,"question":"class Solution:\n    def specialArray(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\n        Notice that x does not have to be an element in nums.\n        Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.\n        Example 1:\n        Input: nums = [3,5]\n        Output: 2\n        Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.\n        Example 2:\n        Input: nums = [0,0]\n        Output: -1\n        Explanation: No numbers fit the criteria for x.\n        If x = 0, there should be 0 numbers >= x, but there are 2.\n        If x = 1, there should be 1 number >= x, but there are 0.\n        If x = 2, there should be 2 numbers >= x, but there are 0.\n        x cannot be greater since there are only 2 numbers in nums.\n        Example 3:\n        Input: nums = [0,4,3,0,4]\n        Output: 3\n        Explanation: There are 3 values that are greater than or equal to 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1285,"row":{"number":1609,"difficulty":1,"question":"class Solution:\n    def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        A binary tree is named Even-Odd if it meets the following conditions:\n            The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc.\n            For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right).\n            For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).\n        Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false.\n        Example 1:\n        Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n        Output: true\n        Explanation: The node values on each level are:\n        Level 0: [1]\n        Level 1: [10,4]\n        Level 2: [3,7,9]\n        Level 3: [12,8,6,2]\n        Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd.\n        Example 2:\n        Input: root = [5,4,2,3,3,7]\n        Output: false\n        Explanation: The node values on each level are:\n        Level 0: [5]\n        Level 1: [4,2]\n        Level 2: [3,3,7]\n        Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd.\n        Example 3:\n        Input: root = [5,9,1,3,5,7]\n        Output: false\n        Explanation: Node values in the level 1 should be even integers.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1286,"row":{"number":1611,"difficulty":2,"question":"class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, you must transform it into 0 using the following operations any number of times:\n            Change the rightmost (0th) bit in the binary representation of n.\n            Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.\n        Return the minimum number of operations to transform n into 0.\n        Example 1:\n        Input: n = 3\n        Output: 2\n        Explanation: The binary representation of 3 is \"11\".\n        \"11\" -> \"01\" with the 2nd operation since the 0th bit is 1.\n        \"01\" -> \"00\" with the 1st operation.\n        Example 2:\n        Input: n = 6\n        Output: 4\n        Explanation: The binary representation of 6 is \"110\".\n        \"110\" -> \"010\" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.\n        \"010\" -> \"011\" with the 1st operation.\n        \"011\" -> \"001\" with the 2nd operation since the 0th bit is 1.\n        \"001\" -> \"000\" with the 1st operation.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1287,"row":{"number":1610,"difficulty":2,"question":"class Solution:\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\n        \"\"\"\n        You are given an array points, an integer angle, and your location, where location = [posx, posy] and points[i] = [xi, yi] both denote integral coordinates on the X-Y plane.\n        Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, posx and posy cannot be changed. Your field of view in degrees is represented by angle, determining how wide you can see from any given view direction. Let d be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles [d - angle/2, d + angle/2].\n        Your browser does not support the video tag or this video format.\n        You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.\n        There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.\n        Return the maximum number of points you can see.\n        Example 1:\n        Input: points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\n        Output: 3\n        Explanation: The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight.\n        Example 2:\n        Input: points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\n        Output: 4\n        Explanation: All points can be made visible in your field of view, including the one at your location.\n        Example 3:\n        Input: points = [[1,0],[2,1]], angle = 13, location = [1,1]\n        Output: 1\n        Explanation: You can only see one of the two points, as shown above.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1288,"row":{"number":1614,"difficulty":0,"question":"class Solution:\n    def maxDepth(self, s: str) -> int:\n        \"\"\"\n        A string is a valid parentheses string (denoted VPS) if it meets one of the following:\n            It is an empty string \"\", or a single character not equal to \"(\" or \")\",\n            It can be written as AB (A concatenated with B), where A and B are VPS's, or\n            It can be written as (A), where A is a VPS.\n        We can similarly define the nesting depth depth(S) of any VPS S as follows:\n            depth(\"\") = 0\n            depth(C) = 0, where C is a string with a single character not equal to \"(\" or \")\".\n            depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.\n            depth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.\n        For example, \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's.\n        Given a VPS represented as string s, return the nesting depth of s.\n        Example 1:\n        Input: s = \"(1+(2*3)+((8)/4))+1\"\n        Output: 3\n        Explanation: Digit 8 is inside of 3 nested parentheses in the string.\n        Example 2:\n        Input: s = \"(1)+((2))+(((3)))\"\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1289,"row":{"number":1615,"difficulty":1,"question":"class Solution:\n    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n        \"\"\"\n        There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi.\n        The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.\n        The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.\n        Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.\n        Example 1:\n        Input: n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]\n        Output: 4\n        Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.\n        Example 2:\n        Input: n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]\n        Output: 5\n        Explanation: There are 5 roads that are connected to cities 1 or 2.\n        Example 3:\n        Input: n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]\n        Output: 5\n        Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1290,"row":{"number":1616,"difficulty":1,"question":"class Solution:\n    def checkPalindromeFormation(self, a: str, b: str) -> bool:\n        \"\"\"\n        You are given two strings a and b of the same length. Choose an index and split both strings at the same index, splitting a into two strings: aprefix and asuffix where a = aprefix + asuffix, and splitting b into two strings: bprefix and bsuffix where b = bprefix + bsuffix. Check if aprefix + bsuffix or bprefix + asuffix forms a palindrome.\n        When you split a string s into sprefix and ssuffix, either ssuffix or sprefix is allowed to be empty. For example, if s = \"abc\", then \"\" + \"abc\", \"a\" + \"bc\", \"ab\" + \"c\" , and \"abc\" + \"\" are valid splits.\n        Return true if it is possible to form a palindrome string, otherwise return false.\n        Notice that x + y denotes the concatenation of strings x and y.\n        Example 1:\n        Input: a = \"x\", b = \"y\"\n        Output: true\n        Explaination: If either a or b are palindromes the answer is true since you can split in the following way:\n        aprefix = \"\", asuffix = \"x\"\n        bprefix = \"\", bsuffix = \"y\"\n        Then, aprefix + bsuffix = \"\" + \"y\" = \"y\", which is a palindrome.\n        Example 2:\n        Input: a = \"xbdef\", b = \"xecab\"\n        Output: false\n        Example 3:\n        Input: a = \"ulacfd\", b = \"jizalu\"\n        Output: true\n        Explaination: Split them at index 3:\n        aprefix = \"ula\", asuffix = \"cfd\"\n        bprefix = \"jiz\", bsuffix = \"alu\"\n        Then, aprefix + bsuffix = \"ula\" + \"alu\" = \"ulaalu\", which is a palindrome.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1291,"row":{"number":1617,"difficulty":2,"question":"class Solution:\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.\r\n        A subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\r\n        For each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.\r\n        Return an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.\r\n        Notice that the distance between the two cities is the number of edges in the path between them.\r\n        Example 1:\r\n        Input: n = 4, edges = [[1,2],[2,3],[2,4]]\r\n        Output: [3,4,0]\r\n        Explanation:\r\n        The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\r\n        The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\r\n        No subtree has two nodes where the max distance between them is 3.\r\n        Example 2:\r\n        Input: n = 2, edges = [[1,2]]\r\n        Output: [1]\r\n        Example 3:\r\n        Input: n = 3, edges = [[1,2],[2,3]]\r\n        Output: [2,1]\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1292,"row":{"number":1636,"difficulty":0,"question":"class Solution:\n    def frequencySort(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.\n        Return the sorted array.\n        Example 1:\n        Input: nums = [1,1,2,2,2,3]\n        Output: [3,1,1,2,2,2]\n        Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.\n        Example 2:\n        Input: nums = [2,3,1,3,2]\n        Output: [1,3,3,2,2]\n        Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.\n        Example 3:\n        Input: nums = [-1,1,-6,4,5,-6,1,4,1]\n        Output: [5,-1,4,4,-6,-6,1,1,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1293,"row":{"number":1637,"difficulty":1,"question":"class Solution:\n    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:\n        \"\"\"\n        Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.\n        A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\n        Note that points on the edge of a vertical area are not considered included in the area.\n        Example 1:\n        ​\n        Input: points = [[8,7],[9,9],[7,4],[9,7]]\n        Output: 1\n        Explanation: Both the red and the blue area are optimal.\n        Example 2:\n        Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1294,"row":{"number":1638,"difficulty":1,"question":"class Solution:\n    def countSubstrings(self, s: str, t: str) -> int:\n        \"\"\"\n        Given two strings s and t, find the number of ways you can choose a non-empty substring of s and replace a single character by a different character such that the resulting substring is a substring of t. In other words, find the number of substrings in s that differ from some substring in t by exactly one character.\n        For example, the underlined substrings in \"computer\" and \"computation\" only differ by the 'e'/'a', so this is a valid way.\n        Return the number of substrings that satisfy the condition above.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"aba\", t = \"baba\"\n        Output: 6\n        Explanation: The following are the pairs of substrings from s and t that differ by exactly 1 character:\n        (\"aba\", \"baba\")\n        (\"aba\", \"baba\")\n        (\"aba\", \"baba\")\n        (\"aba\", \"baba\")\n        (\"aba\", \"baba\")\n        (\"aba\", \"baba\")\n        The underlined portions are the substrings that are chosen from s and t.\n        ​​Example 2:\n        Input: s = \"ab\", t = \"bb\"\n        Output: 3\n        Explanation: The following are the pairs of substrings from s and t that differ by 1 character:\n        (\"ab\", \"bb\")\n        (\"ab\", \"bb\")\n        (\"ab\", \"bb\")\n        ​​​​The underlined portions are the substrings that are chosen from s and t.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1295,"row":{"number":1639,"difficulty":2,"question":"class Solution:\n    def numWays(self, words: List[str], target: str) -> int:\n        \"\"\"\n        You are given a list of strings of the same length words and a string target.\n        Your task is to form target using the given words under the following rules:\n            target should be formed from left to right.\n            To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].\n            Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\n            Repeat the process until you form the string target.\n        Notice that you can use multiple characters from the same string in words provided the conditions above are met.\n        Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\n        Output: 6\n        Explanation: There are 6 ways to form target.\n        \"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n        \"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n        \"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n        \"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n        \"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n        \"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n        Example 2:\n        Input: words = [\"abba\",\"baab\"], target = \"bab\"\n        Output: 4\n        Explanation: There are 4 ways to form target.\n        \"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 2 (\"abba\")\n        \"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 3 (\"baab\")\n        \"bab\" -> index 0 (\"baab\"), index 2 (\"baab\"), index 3 (\"baab\")\n        \"bab\" -> index 1 (\"abba\"), index 2 (\"baab\"), index 3 (\"baab\")\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1296,"row":{"number":1624,"difficulty":0,"question":"class Solution:\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n        \"\"\"\n        Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"aa\"\n        Output: 0\n        Explanation: The optimal substring here is an empty substring between the two 'a's.\n        Example 2:\n        Input: s = \"abca\"\n        Output: 2\n        Explanation: The optimal substring here is \"bc\".\n        Example 3:\n        Input: s = \"cbzxy\"\n        Output: -1\n        Explanation: There are no characters that appear twice in s.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1297,"row":{"number":1625,"difficulty":1,"question":"class Solution:\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\n        \"\"\"\n        You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.\n        You can apply either of the following two operations any number of times and in any order on s:\n            Add a to all odd indices of s (0-indexed). Digits post 9 are cycled back to 0. For example, if s = \"3456\" and a = 5, s becomes \"3951\".\n            Rotate s to the right by b positions. For example, if s = \"3456\" and b = 1, s becomes \"6345\".\n        Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s.\n        A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"0158\" is lexicographically smaller than \"0190\" because the first position they differ is at the third letter, and '5' comes before '9'.\n        Example 1:\n        Input: s = \"5525\", a = 9, b = 2\n        Output: \"2050\"\n        Explanation: We can apply the following operations:\n        Start:  \"5525\"\n        Rotate: \"2555\"\n        Add:    \"2454\"\n        Add:    \"2353\"\n        Rotate: \"5323\"\n        Add:    \"5222\"\n        Add:    \"5121\"\n        Rotate: \"2151\"\n        ​​​​​​​Add:    \"2050\"​​​​​​​​​​​​\n        There is no way to obtain a string that is lexicographically smaller then \"2050\".\n        Example 2:\n        Input: s = \"74\", a = 5, b = 1\n        Output: \"24\"\n        Explanation: We can apply the following operations:\n        Start:  \"74\"\n        Rotate: \"47\"\n        ​​​​​​​Add:    \"42\"\n        ​​​​​​​Rotate: \"24\"​​​​​​​​​​​​\n        There is no way to obtain a string that is lexicographically smaller then \"24\".\n        Example 3:\n        Input: s = \"0011\", a = 4, b = 2\n        Output: \"0011\"\n        Explanation: There are no sequence of operations that will give us a lexicographically smaller string than \"0011\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1298,"row":{"number":1626,"difficulty":1,"question":"class Solution:\n    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        \"\"\"\n        You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team.\n        However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age.\n        Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.\n        Example 1:\n        Input: scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n        Output: 34\n        Explanation: You can choose all the players.\n        Example 2:\n        Input: scores = [4,5,6,5], ages = [2,1,2,1]\n        Output: 16\n        Explanation: It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n        Example 3:\n        Input: scores = [1,2,3,5], ages = [8,9,10,1]\n        Output: 6\n        Explanation: It is best to choose the first 3 players. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1299,"row":{"number":1629,"difficulty":0,"question":"class Solution:\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\n        \"\"\"\n        A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.\n        You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.\n        The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0].\n        Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.\n        Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.\n        Example 1:\n        Input: releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n        Output: \"c\"\n        Explanation: The keypresses were as follows:\n        Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).\n        Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).\n        Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).\n        Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).\n        The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.\n        'c' is lexicographically larger than 'b', so the answer is 'c'.\n        Example 2:\n        Input: releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n        Output: \"a\"\n        Explanation: The keypresses were as follows:\n        Keypress for 's' had a duration of 12.\n        Keypress for 'p' had a duration of 23 - 12 = 11.\n        Keypress for 'u' had a duration of 36 - 23 = 13.\n        Keypress for 'd' had a duration of 46 - 36 = 10.\n        Keypress for 'a' had a duration of 62 - 46 = 16.\n        The longest of these was the keypress for 'a' with duration 16.\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}