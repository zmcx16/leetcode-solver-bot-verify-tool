{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":100,"row":{"number":101,"difficulty":0,"question":"class Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n        Example 1:\n        Input: root = [1,2,2,3,4,4,3]\n        Output: true\n        Example 2:\n        Input: root = [1,2,2,null,3,null,3]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":101,"row":{"number":102,"difficulty":1,"question":"class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: [[3],[9,20],[15,7]]\n        Example 2:\n        Input: root = [1]\n        Output: [[1]]\n        Example 3:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":102,"row":{"number":103,"difficulty":1,"question":"class Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: [[3],[20,9],[15,7]]\n        Example 2:\n        Input: root = [1]\n        Output: [[1]]\n        Example 3:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":103,"row":{"number":104,"difficulty":0,"question":"class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return its maximum depth.\n        A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: 3\n        Example 2:\n        Input: root = [1,null,2]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":104,"row":{"number":105,"difficulty":1,"question":"class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        \"\"\"\n        Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n        Example 1:\n        Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n        Output: [3,9,20,null,null,15,7]\n        Example 2:\n        Input: preorder = [-1], inorder = [-1]\n        Output: [-1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":105,"row":{"number":106,"difficulty":1,"question":"class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        \"\"\"\n        Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n        Example 1:\n        Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n        Output: [3,9,20,null,null,15,7]\n        Example 2:\n        Input: inorder = [-1], postorder = [-1]\n        Output: [-1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":106,"row":{"number":107,"difficulty":1,"question":"class Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: [[15,7],[9,20],[3]]\n        Example 2:\n        Input: root = [1]\n        Output: [[1]]\n        Example 3:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":107,"row":{"number":108,"difficulty":0,"question":"class Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        \"\"\"\n        Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\n        Example 1:\n        Input: nums = [-10,-3,0,5,9]\n        Output: [0,-3,9,-10,null,5]\n        Explanation: [0,-10,5,null,-3,null,9] is also accepted:\n        Example 2:\n        Input: nums = [1,3]\n        Output: [3,1]\n        Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":108,"row":{"number":109,"difficulty":1,"question":"class Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.\n        Example 1:\n        Input: head = [-10,-3,0,5,9]\n        Output: [0,-3,9,-10,null,5]\n        Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n        Example 2:\n        Input: head = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":109,"row":{"number":110,"difficulty":0,"question":"class Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Given a binary tree, determine if it is height-balanced.\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: true\n        Example 2:\n        Input: root = [1,2,2,3,3,null,null,4,4]\n        Output: false\n        Example 3:\n        Input: root = []\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":110,"row":{"number":111,"difficulty":0,"question":"class Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given a binary tree, find its minimum depth.\n        The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n        Note: A leaf is a node with no children.\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: 2\n        Example 2:\n        Input: root = [2,null,3,null,4,null,5,null,6]\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":111,"row":{"number":112,"difficulty":0,"question":"class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        \"\"\"\n        Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\n        A leaf is a node with no children.\n        Example 1:\n        Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n        Output: true\n        Explanation: The root-to-leaf path with the target sum is shown.\n        Example 2:\n        Input: root = [1,2,3], targetSum = 5\n        Output: false\n        Explanation: There two root-to-leaf paths in the tree:\n        (1 --> 2): The sum is 3.\n        (1 --> 3): The sum is 4.\n        There is no root-to-leaf path with sum = 5.\n        Example 3:\n        Input: root = [], targetSum = 0\n        Output: false\n        Explanation: Since the tree is empty, there are no root-to-leaf paths.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":112,"row":{"number":113,"difficulty":1,"question":"class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        \"\"\"\n        Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.\n        A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.\n        Example 1:\n        Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n        Output: [[5,4,11,2],[5,8,4,5]]\n        Explanation: There are two paths whose sum equals targetSum:\n        5 + 4 + 11 + 2 = 22\n        5 + 8 + 4 + 5 = 22\n        Example 2:\n        Input: root = [1,2,3], targetSum = 5\n        Output: []\n        Example 3:\n        Input: root = [1,2], targetSum = 0\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":113,"row":{"number":114,"difficulty":1,"question":"class Solution:\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        Given the root of a binary tree, flatten the tree into a \"linked list\":\n            The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.\n            The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n        Example 1:\n        Input: root = [1,2,5,3,4,null,6]\n        Output: [1,null,2,null,3,null,4,null,5,null,6]\n        Example 2:\n        Input: root = []\n        Output: []\n        Example 3:\n        Input: root = [0]\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":114,"row":{"number":115,"difficulty":2,"question":"class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        Example 1:\n        Input: s = \"rabbbit\", t = \"rabbit\"\n        Output: 3\n        Explanation:\n        As shown below, there are 3 ways you can generate \"rabbit\" from s.\n        rabbbit\n        rabbbit\n        rabbbit\n        Example 2:\n        Input: s = \"babgbag\", t = \"bag\"\n        Output: 5\n        Explanation:\n        As shown below, there are 5 ways you can generate \"bag\" from s.\n        babgbag\n        babgbag\n        babgbag\n        babgbag\n        babgbag\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":115,"row":{"number":116,"difficulty":1,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n        You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n        struct Node {\n          int val;\n          Node *left;\n          Node *right;\n          Node *next;\n        }\n        Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n        Initially, all next pointers are set to NULL.\n        Example 1:\n        Input: root = [1,2,3,4,5,6,7]\n        Output: [1,#,2,3,#,4,5,6,7,#]\n        Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n        Example 2:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":116,"row":{"number":117,"difficulty":1,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n        Given a binary tree\n        struct Node {\n          int val;\n          Node *left;\n          Node *right;\n          Node *next;\n        }\n        Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n        Initially, all next pointers are set to NULL.\n        Example 1:\n        Input: root = [1,2,3,4,5,null,7]\n        Output: [1,#,2,3,#,4,5,7,#]\n        Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n        Example 2:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":117,"row":{"number":118,"difficulty":0,"question":"class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        \"\"\"\n        Given an integer numRows, return the first numRows of Pascal's triangle.\n        In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n        Example 1:\n        Input: numRows = 5\n        Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        Example 2:\n        Input: numRows = 1\n        Output: [[1]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":118,"row":{"number":119,"difficulty":0,"question":"class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        \"\"\"\n        Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\n        In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n        Example 1:\n        Input: rowIndex = 3\n        Output: [1,3,3,1]\n        Example 2:\n        Input: rowIndex = 0\n        Output: [1]\n        Example 3:\n        Input: rowIndex = 1\n        Output: [1,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":119,"row":{"number":120,"difficulty":1,"question":"class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        \"\"\"\n        Given a triangle array, return the minimum path sum from top to bottom.\n        For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n        Example 1:\n        Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n        Output: 11\n        Explanation: The triangle looks like:\n           2\n          3 4\n         6 5 7\n        4 1 8 3\n        The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n        Example 2:\n        Input: triangle = [[-10]]\n        Output: -10\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":120,"row":{"number":121,"difficulty":0,"question":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        \"\"\"\n        You are given an array prices where prices[i] is the price of a given stock on the ith day.\n        You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n        Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n        Example 1:\n        Input: prices = [7,1,5,3,6,4]\n        Output: 5\n        Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n        Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n        Example 2:\n        Input: prices = [7,6,4,3,1]\n        Output: 0\n        Explanation: In this case, no transactions are done and the max profit = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":121,"row":{"number":122,"difficulty":1,"question":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        \"\"\"\n        You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n        On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n        Find and return the maximum profit you can achieve.\n        Example 1:\n        Input: prices = [7,1,5,3,6,4]\n        Output: 7\n        Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n        Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n        Total profit is 4 + 3 = 7.\n        Example 2:\n        Input: prices = [1,2,3,4,5]\n        Output: 4\n        Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n        Total profit is 4.\n        Example 3:\n        Input: prices = [7,6,4,3,1]\n        Output: 0\n        Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":122,"row":{"number":123,"difficulty":2,"question":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        \"\"\"\n        You are given an array prices where prices[i] is the price of a given stock on the ith day.\n        Find the maximum profit you can achieve. You may complete at most two transactions.\n        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n        Example 1:\n        Input: prices = [3,3,5,0,0,3,1,4]\n        Output: 6\n        Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n        Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n        Example 2:\n        Input: prices = [1,2,3,4,5]\n        Output: 4\n        Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n        Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n        Example 3:\n        Input: prices = [7,6,4,3,1]\n        Output: 0\n        Explanation: In this case, no transaction is done, i.e. max profit = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":123,"row":{"number":124,"difficulty":2,"question":"class Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n        The path sum of a path is the sum of the node's values in the path.\n        Given the root of a binary tree, return the maximum path sum of any non-empty path.\n        Example 1:\n        Input: root = [1,2,3]\n        Output: 6\n        Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n        Example 2:\n        Input: root = [-10,9,20,null,null,15,7]\n        Output: 42\n        Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":124,"row":{"number":125,"difficulty":0,"question":"class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        \"\"\"\n        A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n        Given a string s, return true if it is a palindrome, or false otherwise.\n        Example 1:\n        Input: s = \"A man, a plan, a canal: Panama\"\n        Output: true\n        Explanation: \"amanaplanacanalpanama\" is a palindrome.\n        Example 2:\n        Input: s = \"race a car\"\n        Output: false\n        Explanation: \"raceacar\" is not a palindrome.\n        Example 3:\n        Input: s = \" \"\n        Output: true\n        Explanation: s is an empty string \"\" after removing non-alphanumeric characters.\n        Since an empty string reads the same forward and backward, it is a palindrome.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":125,"row":{"number":126,"difficulty":2,"question":"class Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        \"\"\"\n        A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n            Every adjacent pair of words differs by a single letter.\n            Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n            sk == endWord\n        Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n        Example 1:\n        Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n        Output: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\n        Explanation: There are 2 shortest transformation sequences:\n        \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n        \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\n        Example 2:\n        Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n        Output: []\n        Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":126,"row":{"number":127,"difficulty":2,"question":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        \"\"\"\n        A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n            Every adjacent pair of words differs by a single letter.\n            Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n            sk == endWord\n        Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n        Example 1:\n        Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n        Output: 5\n        Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n        Example 2:\n        Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n        Output: 0\n        Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":127,"row":{"number":128,"difficulty":1,"question":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n        You must write an algorithm that runs in O(n) time.\n        Example 1:\n        Input: nums = [100,4,200,1,3,2]\n        Output: 4\n        Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n        Example 2:\n        Input: nums = [0,3,7,2,5,8,4,6,0,1]\n        Output: 9\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":128,"row":{"number":129,"difficulty":1,"question":"class Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        You are given the root of a binary tree containing digits from 0 to 9 only.\n        Each root-to-leaf path in the tree represents a number.\n            For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n        Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\n        A leaf node is a node with no children.\n        Example 1:\n        Input: root = [1,2,3]\n        Output: 25\n        Explanation:\n        The root-to-leaf path 1->2 represents the number 12.\n        The root-to-leaf path 1->3 represents the number 13.\n        Therefore, sum = 12 + 13 = 25.\n        Example 2:\n        Input: root = [4,9,0,5,1]\n        Output: 1026\n        Explanation:\n        The root-to-leaf path 4->9->5 represents the number 495.\n        The root-to-leaf path 4->9->1 represents the number 491.\n        The root-to-leaf path 4->0 represents the number 40.\n        Therefore, sum = 495 + 491 + 40 = 1026.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":129,"row":{"number":130,"difficulty":1,"question":"class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\n        A region is captured by flipping all 'O's into 'X's in that surrounded region.\n        Example 1:\n        Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n        Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n        Explanation: Notice that an 'O' should not be flipped if:\n        - It is on the border, or\n        - It is adjacent to an 'O' that should not be flipped.\n        The bottom 'O' is on the border, so it is not flipped.\n        The other three 'O' form a surrounded region, so they are flipped.\n        Example 2:\n        Input: board = [[\"X\"]]\n        Output: [[\"X\"]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":130,"row":{"number":131,"difficulty":1,"question":"class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        \"\"\"\n        Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\n        Example 1:\n        Input: s = \"aab\"\n        Output: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n        Example 2:\n        Input: s = \"a\"\n        Output: [[\"a\"]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":131,"row":{"number":132,"difficulty":2,"question":"class Solution:\n    def minCut(self, s: str) -> int:\n        \"\"\"\n        Given a string s, partition s such that every substring of the partition is a palindrome.\n        Return the minimum cuts needed for a palindrome partitioning of s.\n        Example 1:\n        Input: s = \"aab\"\n        Output: 1\n        Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n        Example 2:\n        Input: s = \"a\"\n        Output: 0\n        Example 3:\n        Input: s = \"ab\"\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":132,"row":{"number":133,"difficulty":1,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n        Given a reference of a node in a connected undirected graph.\n        Return a deep copy (clone) of the graph.\n        Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n        class Node {\n            public int val;\n            public List<Node> neighbors;\n        }\n        Test case format:\n        For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\n        An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n        The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n        Example 1:\n        Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\n        Output: [[2,4],[1,3],[2,4],[1,3]]\n        Explanation: There are 4 nodes in the graph.\n        1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n        2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n        3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n        4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n        Example 2:\n        Input: adjList = [[]]\n        Output: [[]]\n        Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n        Example 3:\n        Input: adjList = []\n        Output: []\n        Explanation: This an empty graph, it does not have any nodes.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":133,"row":{"number":134,"difficulty":1,"question":"class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        \"\"\"\n        There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\n        You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\n        Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique\n        Example 1:\n        Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n        Output: 3\n        Explanation:\n        Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n        Travel to station 4. Your tank = 4 - 1 + 5 = 8\n        Travel to station 0. Your tank = 8 - 2 + 1 = 7\n        Travel to station 1. Your tank = 7 - 3 + 2 = 6\n        Travel to station 2. Your tank = 6 - 4 + 3 = 5\n        Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\n        Therefore, return 3 as the starting index.\n        Example 2:\n        Input: gas = [2,3,4], cost = [3,4,3]\n        Output: -1\n        Explanation:\n        You can't start at station 0 or 1, as there is not enough gas to travel to the next station.\n        Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n        Travel to station 0. Your tank = 4 - 3 + 2 = 3\n        Travel to station 1. Your tank = 3 - 3 + 3 = 3\n        You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\n        Therefore, you can't travel around the circuit once no matter where you start.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":134,"row":{"number":135,"difficulty":2,"question":"class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        \"\"\"\n        There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\n        You are giving candies to these children subjected to the following requirements:\n            Each child must have at least one candy.\n            Children with a higher rating get more candies than their neighbors.\n        Return the minimum number of candies you need to have to distribute the candies to the children.\n        Example 1:\n        Input: ratings = [1,0,2]\n        Output: 5\n        Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n        Example 2:\n        Input: ratings = [1,2,2]\n        Output: 4\n        Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\n        The third child gets 1 candy because it satisfies the above two conditions.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":135,"row":{"number":136,"difficulty":0,"question":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n        You must implement a solution with a linear runtime complexity and use only constant extra space.\n        Example 1:\n        Input: nums = [2,2,1]\n        Output: 1\n        Example 2:\n        Input: nums = [4,1,2,1,2]\n        Output: 4\n        Example 3:\n        Input: nums = [1]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":136,"row":{"number":137,"difficulty":1,"question":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\n        You must implement a solution with a linear runtime complexity and use only constant extra space.\n        Example 1:\n        Input: nums = [2,2,3,2]\n        Output: 3\n        Example 2:\n        Input: nums = [0,1,0,1,0,1,99]\n        Output: 99\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":137,"row":{"number":138,"difficulty":1,"question":"\n        \"\"\"\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n        A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\n        Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\n        For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\n        Return the head of the copied linked list.\n        The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\n            val: an integer representing Node.val\n            random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\n        Your code will only be given the head of the original linked list.\n        Example 1:\n        Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n        Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n        Example 2:\n        Input: head = [[1,1],[2,1]]\n        Output: [[1,1],[2,1]]\n        Example 3:\n        Input: head = [[3,null],[3,0],[3,null]]\n        Output: [[3,null],[3,0],[3,null]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":138,"row":{"number":139,"difficulty":1,"question":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        \"\"\"\n        Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\n        Note that the same word in the dictionary may be reused multiple times in the segmentation.\n        Example 1:\n        Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n        Output: true\n        Explanation: Return true because \"leetcode\" can be segmented as \"leet code\".\n        Example 2:\n        Input: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n        Output: true\n        Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\n        Note that you are allowed to reuse a dictionary word.\n        Example 3:\n        Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":139,"row":{"number":140,"difficulty":2,"question":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        \"\"\"\n        Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\n        Note that the same word in the dictionary may be reused multiple times in the segmentation.\n        Example 1:\n        Input: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\n        Output: [\"cats and dog\",\"cat sand dog\"]\n        Example 2:\n        Input: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\n        Output: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\n        Explanation: Note that you are allowed to reuse a dictionary word.\n        Example 3:\n        Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":140,"row":{"number":141,"difficulty":0,"question":"class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        \"\"\"\n        Given head, the head of a linked list, determine if the linked list has a cycle in it.\n        There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n        Return true if there is a cycle in the linked list. Otherwise, return false.\n        Example 1:\n        Input: head = [3,2,0,-4], pos = 1\n        Output: true\n        Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n        Example 2:\n        Input: head = [1,2], pos = 0\n        Output: true\n        Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n        Example 3:\n        Input: head = [1], pos = -1\n        Output: false\n        Explanation: There is no cycle in the linked list.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":141,"row":{"number":142,"difficulty":1,"question":"class Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\n        There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\n        Do not modify the linked list.\n        Example 1:\n        Input: head = [3,2,0,-4], pos = 1\n        Output: tail connects to node index 1\n        Explanation: There is a cycle in the linked list, where tail connects to the second node.\n        Example 2:\n        Input: head = [1,2], pos = 0\n        Output: tail connects to node index 0\n        Explanation: There is a cycle in the linked list, where tail connects to the first node.\n        Example 3:\n        Input: head = [1], pos = -1\n        Output: no cycle\n        Explanation: There is no cycle in the linked list.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":142,"row":{"number":143,"difficulty":1,"question":"class Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        You are given the head of a singly linked-list. The list can be represented as:\n        L0 → L1 → … → Ln - 1 → Ln\n        Reorder the list to be on the following form:\n        L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n        You may not modify the values in the list's nodes. Only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [1,4,2,3]\n        Example 2:\n        Input: head = [1,2,3,4,5]\n        Output: [1,5,2,4,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":143,"row":{"number":144,"difficulty":0,"question":"class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        \"\"\"\n        Given the root of a binary tree, return the preorder traversal of its nodes' values.\n        Example 1:\n        Input: root = [1,null,2,3]\n        Output: [1,2,3]\n        Example 2:\n        Input: root = []\n        Output: []\n        Example 3:\n        Input: root = [1]\n        Output: [1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":144,"row":{"number":145,"difficulty":0,"question":"class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        \"\"\"\n        Given the root of a binary tree, return the postorder traversal of its nodes' values.\n        Example 1:\n        Input: root = [1,null,2,3]\n        Output: [3,2,1]\n        Example 2:\n        Input: root = []\n        Output: []\n        Example 3:\n        Input: root = [1]\n        Output: [1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":145,"row":{"number":146,"difficulty":1,"question":"class LRUCache:\n    def __init__(self, capacity: int):\n    def get(self, key: int) -> int:\n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n        Implement the LRUCache class:\n            LRUCache(int capacity) Initialize the LRU cache with positive size capacity.\n            int get(int key) Return the value of the key if the key exists, otherwise return -1.\n            void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n        The functions get and put must each run in O(1) average time complexity.\n        Example 1:\n        Input\n        [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n        [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n        Output\n        [null, null, null, 1, null, -1, null, -1, 3, 4]\n        Explanation\n        LRUCache lRUCache = new LRUCache(2);\n        lRUCache.put(1, 1); // cache is {1=1}\n        lRUCache.put(2, 2); // cache is {1=1, 2=2}\n        lRUCache.get(1);    // return 1\n        lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n        lRUCache.get(2);    // returns -1 (not found)\n        lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\n        lRUCache.get(1);    // return -1 (not found)\n        lRUCache.get(3);    // return 3\n        lRUCache.get(4);    // return 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":146,"row":{"number":147,"difficulty":1,"question":"class Solution:\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.\n        The steps of the insertion sort algorithm:\n            Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.\n            At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\n            It repeats until no input elements remain.\n        The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\n        Example 1:\n        Input: head = [4,2,1,3]\n        Output: [1,2,3,4]\n        Example 2:\n        Input: head = [-1,5,3,4,0]\n        Output: [-1,0,3,4,5]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":147,"row":{"number":148,"difficulty":1,"question":"class Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, return the list after sorting it in ascending order.\n        Example 1:\n        Input: head = [4,2,1,3]\n        Output: [1,2,3,4]\n        Example 2:\n        Input: head = [-1,5,3,4,0]\n        Output: [-1,0,3,4,5]\n        Example 3:\n        Input: head = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":148,"row":{"number":149,"difficulty":2,"question":"class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        \"\"\"\n        Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n        Example 1:\n        Input: points = [[1,1],[2,2],[3,3]]\n        Output: 3\n        Example 2:\n        Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":149,"row":{"number":150,"difficulty":1,"question":"class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        \"\"\"\n        You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\n        Evaluate the expression. Return an integer that represents the value of the expression.\n        Note that:\n            The valid operators are '+', '-', '*', and '/'.\n            Each operand may be an integer or another expression.\n            The division between two integers always truncates toward zero.\n            There will not be any division by zero.\n            The input represents a valid arithmetic expression in a reverse polish notation.\n            The answer and all the intermediate calculations can be represented in a 32-bit integer.\n        Example 1:\n        Input: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n        Output: 9\n        Explanation: ((2 + 1) * 3) = 9\n        Example 2:\n        Input: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n        Output: 6\n        Explanation: (4 + (13 / 5)) = 6\n        Example 3:\n        Input: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n        Output: 22\n        Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n        = ((10 * (6 / (12 * -11))) + 17) + 5\n        = ((10 * (6 / -132)) + 17) + 5\n        = ((10 * 0) + 17) + 5\n        = (0 + 17) + 5\n        = 17 + 5\n        = 22\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":150,"row":{"number":151,"difficulty":1,"question":"class Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        Given an input string s, reverse the order of the words.\n        A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\n        Return a string of the words in reverse order concatenated by a single space.\n        Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n        Example 1:\n        Input: s = \"the sky is blue\"\n        Output: \"blue is sky the\"\n        Example 2:\n        Input: s = \"  hello world  \"\n        Output: \"world hello\"\n        Explanation: Your reversed string should not contain leading or trailing spaces.\n        Example 3:\n        Input: s = \"a good   example\"\n        Output: \"example good a\"\n        Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":151,"row":{"number":152,"difficulty":1,"question":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find a subarray that has the largest product, and return the product.\n        The test cases are generated so that the answer will fit in a 32-bit integer.\n        Example 1:\n        Input: nums = [2,3,-2,4]\n        Output: 6\n        Explanation: [2,3] has the largest product 6.\n        Example 2:\n        Input: nums = [-2,0,-1]\n        Output: 0\n        Explanation: The result cannot be 2, because [-2,-1] is not a subarray.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":152,"row":{"number":153,"difficulty":1,"question":"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        \"\"\"\n        Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n            [4,5,6,7,0,1,2] if it was rotated 4 times.\n            [0,1,2,4,5,6,7] if it was rotated 7 times.\n        Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n        Given the sorted rotated array nums of unique elements, return the minimum element of this array.\n        You must write an algorithm that runs in O(log n) time.\n        Example 1:\n        Input: nums = [3,4,5,1,2]\n        Output: 1\n        Explanation: The original array was [1,2,3,4,5] rotated 3 times.\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2]\n        Output: 0\n        Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n        Example 3:\n        Input: nums = [11,13,15,17]\n        Output: 11\n        Explanation: The original array was [11,13,15,17] and it was rotated 4 times. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":153,"row":{"number":154,"difficulty":2,"question":"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        \"\"\"\n        Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:\n            [4,5,6,7,0,1,4] if it was rotated 4 times.\n            [0,1,4,4,5,6,7] if it was rotated 7 times.\n        Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n        Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.\n        You must decrease the overall operation steps as much as possible.\n        Example 1:\n        Input: nums = [1,3,5]\n        Output: 1\n        Example 2:\n        Input: nums = [2,2,2,0,1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":154,"row":{"number":155,"difficulty":1,"question":"class MinStack:\n    def __init__(self):\n    def push(self, val: int) -> None:\n    def pop(self) -> None:\n    def top(self) -> int:\n    def getMin(self) -> int:\n        \"\"\"\n        Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n        Implement the MinStack class:\n            MinStack() initializes the stack object.\n            void push(int val) pushes the element val onto the stack.\n            void pop() removes the element on the top of the stack.\n            int top() gets the top element of the stack.\n            int getMin() retrieves the minimum element in the stack.\n        You must implement a solution with O(1) time complexity for each function.\n        Example 1:\n        Input\n        [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n        [[],[-2],[0],[-3],[],[],[],[]]\n        Output\n        [null,null,null,null,-3,null,0,-2]\n        Explanation\n        MinStack minStack = new MinStack();\n        minStack.push(-2);\n        minStack.push(0);\n        minStack.push(-3);\n        minStack.getMin(); // return -3\n        minStack.pop();\n        minStack.top();    // return 0\n        minStack.getMin(); // return -2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":155,"row":{"number":160,"difficulty":0,"question":"class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \"\"\"\n        Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\n        For example, the following two linked lists begin to intersect at node c1:\n        The test cases are generated such that there are no cycles anywhere in the entire linked structure.\n        Note that the linked lists must retain their original structure after the function returns.\n        Custom Judge:\n        The inputs to the judge are given as follows (your program is not given these inputs):\n            intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\n            listA - The first linked list.\n            listB - The second linked list.\n            skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\n            skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\n        The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.\n        Example 1:\n        Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n        Output: Intersected at '8'\n        Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\n        From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n        - Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.\n        Example 2:\n        Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n        Output: Intersected at '2'\n        Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\n        From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n        Example 3:\n        Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n        Output: No intersection\n        Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\n        Explanation: The two lists do not intersect, so return null.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":156,"row":{"number":162,"difficulty":1,"question":"class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        \"\"\"\n        A peak element is an element that is strictly greater than its neighbors.\n        Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n        You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n        You must write an algorithm that runs in O(log n) time.\n        Example 1:\n        Input: nums = [1,2,3,1]\n        Output: 2\n        Explanation: 3 is a peak element and your function should return the index number 2.\n        Example 2:\n        Input: nums = [1,2,1,3,5,6,4]\n        Output: 5\n        Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":157,"row":{"number":164,"difficulty":2,"question":"class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\n        You must write an algorithm that runs in linear time and uses linear extra space.\n        Example 1:\n        Input: nums = [3,6,9,1]\n        Output: 3\n        Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n        Example 2:\n        Input: nums = [10]\n        Output: 0\n        Explanation: The array contains less than 2 elements, therefore return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":158,"row":{"number":165,"difficulty":1,"question":"class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        \"\"\"\n        Given two version numbers, version1 and version2, compare them.\n        Version numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.1 are valid version numbers.\n        To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1.0 is less than version 1.1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 < 1.\n        Return the following:\n            If version1 < version2, return -1.\n            If version1 > version2, return 1.\n            Otherwise, return 0.\n        Example 1:\n        Input: version1 = \"1.01\", version2 = \"1.001\"\n        Output: 0\n        Explanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".\n        Example 2:\n        Input: version1 = \"1.0\", version2 = \"1.0.0\"\n        Output: 0\n        Explanation: version1 does not specify revision 2, which means it is treated as \"0\".\n        Example 3:\n        Input: version1 = \"0.1\", version2 = \"1.1\"\n        Output: -1\n        Explanation: version1's revision 0 is \"0\", while version2's revision 0 is \"1\". 0 < 1, so version1 < version2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":159,"row":{"number":166,"difficulty":1,"question":"class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        \"\"\"\n        Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n        If the fractional part is repeating, enclose the repeating part in parentheses.\n        If multiple answers are possible, return any of them.\n        It is guaranteed that the length of the answer string is less than 104 for all the given inputs.\n        Example 1:\n        Input: numerator = 1, denominator = 2\n        Output: \"0.5\"\n        Example 2:\n        Input: numerator = 2, denominator = 1\n        Output: \"2\"\n        Example 3:\n        Input: numerator = 4, denominator = 333\n        Output: \"0.(012)\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":160,"row":{"number":167,"difficulty":1,"question":"class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\n        Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n        The tests are generated such that there is exactly one solution. You may not use the same element twice.\n        Your solution must use only constant extra space.\n        Example 1:\n        Input: numbers = [2,7,11,15], target = 9\n        Output: [1,2]\n        Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n        Example 2:\n        Input: numbers = [2,3,4], target = 6\n        Output: [1,3]\n        Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\n        Example 3:\n        Input: numbers = [-1,0], target = -1\n        Output: [1,2]\n        Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":161,"row":{"number":168,"difficulty":0,"question":"class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        \"\"\"\n        Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\n        For example:\n        A -> 1\n        B -> 2\n        C -> 3\n        ...\n        Z -> 26\n        AA -> 27\n        AB -> 28 \n        ...\n        Example 1:\n        Input: columnNumber = 1\n        Output: \"A\"\n        Example 2:\n        Input: columnNumber = 28\n        Output: \"AB\"\n        Example 3:\n        Input: columnNumber = 701\n        Output: \"ZY\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":162,"row":{"number":169,"difficulty":0,"question":"class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums of size n, return the majority element.\n        The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\n        Example 1:\n        Input: nums = [3,2,3]\n        Output: 3\n        Example 2:\n        Input: nums = [2,2,1,1,1,2,2]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":163,"row":{"number":171,"difficulty":0,"question":"class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"\n        Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n        For example:\n        A -> 1\n        B -> 2\n        C -> 3\n        ...\n        Z -> 26\n        AA -> 27\n        AB -> 28 \n        ...\n        Example 1:\n        Input: columnTitle = \"A\"\n        Output: 1\n        Example 2:\n        Input: columnTitle = \"AB\"\n        Output: 28\n        Example 3:\n        Input: columnTitle = \"ZY\"\n        Output: 701\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":164,"row":{"number":172,"difficulty":1,"question":"class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the number of trailing zeroes in n!.\n        Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n        Example 1:\n        Input: n = 3\n        Output: 0\n        Explanation: 3! = 6, no trailing zero.\n        Example 2:\n        Input: n = 5\n        Output: 1\n        Explanation: 5! = 120, one trailing zero.\n        Example 3:\n        Input: n = 0\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":165,"row":{"number":173,"difficulty":1,"question":"class BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n    def next(self) -> int:\n    def hasNext(self) -> bool:\n        \"\"\"\n        Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n            BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n            boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\n            int next() Moves the pointer to the right, then returns the number at the pointer.\n        Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\n        You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\n        Example 1:\n        Input\n        [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n        [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n        Output\n        [null, 3, 7, true, 9, true, 15, true, 20, false]\n        Explanation\n        BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\n        bSTIterator.next();    // return 3\n        bSTIterator.next();    // return 7\n        bSTIterator.hasNext(); // return True\n        bSTIterator.next();    // return 9\n        bSTIterator.hasNext(); // return True\n        bSTIterator.next();    // return 15\n        bSTIterator.hasNext(); // return True\n        bSTIterator.next();    // return 20\n        bSTIterator.hasNext(); // return False\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":166,"row":{"number":174,"difficulty":2,"question":"class Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        \"\"\"\n        The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.\n        The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\n        Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n        To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n        Return the knight's minimum initial health so that he can rescue the princess.\n        Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n        Example 1:\n        Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n        Output: 7\n        Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n        Example 2:\n        Input: dungeon = [[0]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":167,"row":{"number":179,"difficulty":1,"question":"class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        \"\"\"\n        Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\n        Since the result may be very large, so you need to return a string instead of an integer.\n        Example 1:\n        Input: nums = [10,2]\n        Output: \"210\"\n        Example 2:\n        Input: nums = [3,30,34,5,9]\n        Output: \"9534330\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":168,"row":{"number":187,"difficulty":1,"question":"class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        \"\"\"\n        The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n            For example, \"ACGAATTCCG\" is a DNA sequence.\n        When studying DNA, it is useful to identify repeated sequences within the DNA.\n        Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\n        Example 1:\n        Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n        Output: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n        Example 2:\n        Input: s = \"AAAAAAAAAAAAA\"\n        Output: [\"AAAAAAAAAA\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":169,"row":{"number":188,"difficulty":2,"question":"class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        \"\"\"\n        You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\n        Find the maximum profit you can achieve. You may complete at most k transactions.\n        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n        Example 1:\n        Input: k = 2, prices = [2,4,1]\n        Output: 2\n        Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n        Example 2:\n        Input: k = 2, prices = [3,2,6,5,0,3]\n        Output: 7\n        Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":170,"row":{"number":189,"difficulty":1,"question":"class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n        Example 1:\n        Input: nums = [1,2,3,4,5,6,7], k = 3\n        Output: [5,6,7,1,2,3,4]\n        Explanation:\n        rotate 1 steps to the right: [7,1,2,3,4,5,6]\n        rotate 2 steps to the right: [6,7,1,2,3,4,5]\n        rotate 3 steps to the right: [5,6,7,1,2,3,4]\n        Example 2:\n        Input: nums = [-1,-100,3,99], k = 2\n        Output: [3,99,-1,-100]\n        Explanation: \n        rotate 1 steps to the right: [99,-1,-100,3]\n        rotate 2 steps to the right: [3,99,-1,-100]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":171,"row":{"number":190,"difficulty":0,"question":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        \"\"\"\n        Reverse bits of a given 32 bits unsigned integer.\n        Note:\n            Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n            In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.\n        Example 1:\n        Input: n = 00000010100101000001111010011100\n        Output:    964176192 (00111001011110000010100101000000)\n        Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\n        Example 2:\n        Input: n = 11111111111111111111111111111101\n        Output:   3221225471 (10111111111111111111111111111111)\n        Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":172,"row":{"number":191,"difficulty":0,"question":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        \"\"\"\n        Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\n        Note:\n            Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n            In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.\n        Example 1:\n        Input: n = 00000000000000000000000000001011\n        Output: 3\n        Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.\n        Example 2:\n        Input: n = 00000000000000000000000010000000\n        Output: 1\n        Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.\n        Example 3:\n        Input: n = 11111111111111111111111111111101\n        Output: 31\n        Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":173,"row":{"number":198,"difficulty":1,"question":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        \"\"\"\n        You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n        Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n        Example 1:\n        Input: nums = [1,2,3,1]\n        Output: 4\n        Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n        Total amount you can rob = 1 + 3 = 4.\n        Example 2:\n        Input: nums = [2,7,9,3,1]\n        Output: 12\n        Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n        Total amount you can rob = 2 + 9 + 1 = 12.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":174,"row":{"number":199,"difficulty":1,"question":"class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        \"\"\"\n        Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n        Example 1:\n        Input: root = [1,2,3,null,5,null,4]\n        Output: [1,3,4]\n        Example 2:\n        Input: root = [1,null,3]\n        Output: [1,3]\n        Example 3:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":175,"row":{"number":200,"difficulty":1,"question":"class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        \"\"\"\n        Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n        An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n        Example 1:\n        Input: grid = [\n          [\"1\",\"1\",\"1\",\"1\",\"0\"],\n          [\"1\",\"1\",\"0\",\"1\",\"0\"],\n          [\"1\",\"1\",\"0\",\"0\",\"0\"],\n          [\"0\",\"0\",\"0\",\"0\",\"0\"]\n        ]\n        Output: 1\n        Example 2:\n        Input: grid = [\n          [\"1\",\"1\",\"0\",\"0\",\"0\"],\n          [\"1\",\"1\",\"0\",\"0\",\"0\"],\n          [\"0\",\"0\",\"1\",\"0\",\"0\"],\n          [\"0\",\"0\",\"0\",\"1\",\"1\"]\n        ]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":176,"row":{"number":201,"difficulty":1,"question":"class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        \"\"\"\n        Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n        Example 1:\n        Input: left = 5, right = 7\n        Output: 4\n        Example 2:\n        Input: left = 0, right = 0\n        Output: 0\n        Example 3:\n        Input: left = 1, right = 2147483647\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":177,"row":{"number":202,"difficulty":0,"question":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        \"\"\"\n        Write an algorithm to determine if a number n is happy.\n        A happy number is a number defined by the following process:\n            Starting with any positive integer, replace the number by the sum of the squares of its digits.\n            Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n            Those numbers for which this process ends in 1 are happy.\n        Return true if n is a happy number, and false if not.\n        Example 1:\n        Input: n = 19\n        Output: true\n        Explanation:\n        12 + 92 = 82\n        82 + 22 = 68\n        62 + 82 = 100\n        12 + 02 + 02 = 1\n        Example 2:\n        Input: n = 2\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":178,"row":{"number":203,"difficulty":0,"question":"class Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\n        Example 1:\n        Input: head = [1,2,6,3,4,5,6], val = 6\n        Output: [1,2,3,4,5]\n        Example 2:\n        Input: head = [], val = 1\n        Output: []\n        Example 3:\n        Input: head = [7,7,7,7], val = 7\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":179,"row":{"number":204,"difficulty":1,"question":"class Solution:\n    def countPrimes(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the number of prime numbers that are strictly less than n.\n        Example 1:\n        Input: n = 10\n        Output: 4\n        Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n        Example 2:\n        Input: n = 0\n        Output: 0\n        Example 3:\n        Input: n = 1\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":180,"row":{"number":205,"difficulty":0,"question":"class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        \"\"\"\n        Given two strings s and t, determine if they are isomorphic.\n        Two strings s and t are isomorphic if the characters in s can be replaced to get t.\n        All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n        Example 1:\n        Input: s = \"egg\", t = \"add\"\n        Output: true\n        Example 2:\n        Input: s = \"foo\", t = \"bar\"\n        Output: false\n        Example 3:\n        Input: s = \"paper\", t = \"title\"\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":181,"row":{"number":206,"difficulty":0,"question":"class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a singly linked list, reverse the list, and return the reversed list.\n        Example 1:\n        Input: head = [1,2,3,4,5]\n        Output: [5,4,3,2,1]\n        Example 2:\n        Input: head = [1,2]\n        Output: [2,1]\n        Example 3:\n        Input: head = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":182,"row":{"number":207,"difficulty":1,"question":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        \"\"\"\n        There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n            For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n        Return true if you can finish all courses. Otherwise, return false.\n        Example 1:\n        Input: numCourses = 2, prerequisites = [[1,0]]\n        Output: true\n        Explanation: There are a total of 2 courses to take. \n        To take course 1 you should have finished course 0. So it is possible.\n        Example 2:\n        Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\n        Output: false\n        Explanation: There are a total of 2 courses to take. \n        To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":183,"row":{"number":208,"difficulty":1,"question":"class Trie:\n    def __init__(self):\n    def insert(self, word: str) -> None:\n    def search(self, word: str) -> bool:\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"\n        A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n        Implement the Trie class:\n            Trie() Initializes the trie object.\n            void insert(String word) Inserts the string word into the trie.\n            boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\n            boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n        Example 1:\n        Input\n        [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n        [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\n        Output\n        [null, null, true, false, true, null, true]\n        Explanation\n        Trie trie = new Trie();\n        trie.insert(\"apple\");\n        trie.search(\"apple\");   // return True\n        trie.search(\"app\");     // return False\n        trie.startsWith(\"app\"); // return True\n        trie.insert(\"app\");\n        trie.search(\"app\");     // return True\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":184,"row":{"number":209,"difficulty":1,"question":"class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        \"\"\"\n        Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n        Example 1:\n        Input: target = 7, nums = [2,3,1,2,4,3]\n        Output: 2\n        Explanation: The subarray [4,3] has the minimal length under the problem constraint.\n        Example 2:\n        Input: target = 4, nums = [1,4,4]\n        Output: 1\n        Example 3:\n        Input: target = 11, nums = [1,1,1,1,1,1,1,1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":185,"row":{"number":210,"difficulty":1,"question":"class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        \"\"\"\n        There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n            For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n        Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n        Example 1:\n        Input: numCourses = 2, prerequisites = [[1,0]]\n        Output: [0,1]\n        Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n        Example 2:\n        Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n        Output: [0,2,1,3]\n        Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\n        So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n        Example 3:\n        Input: numCourses = 1, prerequisites = []\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":186,"row":{"number":211,"difficulty":1,"question":"class WordDictionary:\n    def __init__(self):\n    def addWord(self, word: str) -> None:\n    def search(self, word: str) -> bool:\n        \"\"\"\n        Design a data structure that supports adding new words and finding if a string matches any previously added string.\n        Implement the WordDictionary class:\n            WordDictionary() Initializes the object.\n            void addWord(word) Adds word to the data structure, it can be matched later.\n            bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\n        Example:\n        Input\n        [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n        [[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n        Output\n        [null,null,null,null,false,true,true,true]\n        Explanation\n        WordDictionary wordDictionary = new WordDictionary();\n        wordDictionary.addWord(\"bad\");\n        wordDictionary.addWord(\"dad\");\n        wordDictionary.addWord(\"mad\");\n        wordDictionary.search(\"pad\"); // return False\n        wordDictionary.search(\"bad\"); // return True\n        wordDictionary.search(\".ad\"); // return True\n        wordDictionary.search(\"b..\"); // return True\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":187,"row":{"number":212,"difficulty":2,"question":"class Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        \"\"\"\n        Given an m x n board of characters and a list of strings words, return all words on the board.\n        Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n        Example 1:\n        Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n        Output: [\"eat\",\"oath\"]\n        Example 2:\n        Input: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":188,"row":{"number":213,"difficulty":1,"question":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        \"\"\"\n        You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n        Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n        Example 1:\n        Input: nums = [2,3,2]\n        Output: 3\n        Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n        Example 2:\n        Input: nums = [1,2,3,1]\n        Output: 4\n        Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n        Total amount you can rob = 1 + 3 = 4.\n        Example 3:\n        Input: nums = [1,2,3]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":189,"row":{"number":214,"difficulty":2,"question":"class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        \"\"\"\n        You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n        Return the shortest palindrome you can find by performing this transformation.\n        Example 1:\n        Input: s = \"aacecaaa\"\n        Output: \"aaacecaaa\"\n        Example 2:\n        Input: s = \"abcd\"\n        Output: \"dcbabcd\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":190,"row":{"number":215,"difficulty":1,"question":"class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the kth largest element in the array.\n        Note that it is the kth largest element in the sorted order, not the kth distinct element.\n        You must solve it in O(n) time complexity.\n        Example 1:\n        Input: nums = [3,2,1,5,6,4], k = 2\n        Output: 5\n        Example 2:\n        Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":191,"row":{"number":216,"difficulty":1,"question":"class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        \"\"\"\n        Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\n            Only numbers 1 through 9 are used.\n            Each number is used at most once.\n        Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\n        Example 1:\n        Input: k = 3, n = 7\n        Output: [[1,2,4]]\n        Explanation:\n        1 + 2 + 4 = 7\n        There are no other valid combinations.\n        Example 2:\n        Input: k = 3, n = 9\n        Output: [[1,2,6],[1,3,5],[2,3,4]]\n        Explanation:\n        1 + 2 + 6 = 9\n        1 + 3 + 5 = 9\n        2 + 3 + 4 = 9\n        There are no other valid combinations.\n        Example 3:\n        Input: k = 4, n = 1\n        Output: []\n        Explanation: There are no valid combinations.\n        Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":192,"row":{"number":217,"difficulty":0,"question":"class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n        Example 1:\n        Input: nums = [1,2,3,1]\n        Output: true\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: false\n        Example 3:\n        Input: nums = [1,1,1,3,3,4,3,2,4,2]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":193,"row":{"number":218,"difficulty":2,"question":"class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n        The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:\n            lefti is the x coordinate of the left edge of the ith building.\n            righti is the x coordinate of the right edge of the ith building.\n            heighti is the height of the ith building.\n        You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n        The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n        Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]\n        Example 1:\n        Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n        Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n        Explanation:\n        Figure A shows the buildings of the input.\n        Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n        Example 2:\n        Input: buildings = [[0,2,3],[2,5,3]]\n        Output: [[0,3],[5,0]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":194,"row":{"number":219,"difficulty":0,"question":"class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        \"\"\"\n        Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\n        Example 1:\n        Input: nums = [1,2,3,1], k = 3\n        Output: true\n        Example 2:\n        Input: nums = [1,0,1,1], k = 1\n        Output: true\n        Example 3:\n        Input: nums = [1,2,3,1,2,3], k = 2\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":195,"row":{"number":220,"difficulty":2,"question":"class Solution:\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\n        \"\"\"\n        You are given an integer array nums and two integers indexDiff and valueDiff.\n        Find a pair of indices (i, j) such that:\n            i != j,\n            abs(i - j) <= indexDiff.\n            abs(nums[i] - nums[j]) <= valueDiff, and\n        Return true if such pair exists or false otherwise.\n        Example 1:\n        Input: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n        Output: true\n        Explanation: We can choose (i, j) = (0, 3).\n        We satisfy the three conditions:\n        i != j --> 0 != 3\n        abs(i - j) <= indexDiff --> abs(0 - 3) <= 3\n        abs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\n        Example 2:\n        Input: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\n        Output: false\n        Explanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":196,"row":{"number":221,"difficulty":1,"question":"class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        \"\"\"\n        Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n        Example 1:\n        Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n        Output: 4\n        Example 2:\n        Input: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\n        Output: 1\n        Example 3:\n        Input: matrix = [[\"0\"]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":197,"row":{"number":222,"difficulty":1,"question":"class Solution:\n    def countNodes(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a complete binary tree, return the number of the nodes in the tree.\n        According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n        Design an algorithm that runs in less than O(n) time complexity.\n        Example 1:\n        Input: root = [1,2,3,4,5,6]\n        Output: 6\n        Example 2:\n        Input: root = []\n        Output: 0\n        Example 3:\n        Input: root = [1]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":198,"row":{"number":223,"difficulty":1,"question":"class Solution:\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        \"\"\"\n        Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.\n        The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2).\n        The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2).\n        Example 1:\n        Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n        Output: 45\n        Example 2:\n        Input: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n        Output: 16\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":199,"row":{"number":224,"difficulty":2,"question":"class Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"\n        Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\n        Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n        Example 1:\n        Input: s = \"1 + 1\"\n        Output: 2\n        Example 2:\n        Input: s = \" 2-1 + 2 \"\n        Output: 3\n        Example 3:\n        Input: s = \"(1+(4+5+2)-3)+(6+8)\"\n        Output: 23\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}