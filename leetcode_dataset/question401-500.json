{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":400,"row":{"number":516,"difficulty":1,"question":"class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the longest palindromic subsequence's length in s.\n        A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: s = \"bbbab\"\n        Output: 4\n        Explanation: One possible longest palindromic subsequence is \"bbbb\".\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: 2\n        Explanation: One possible longest palindromic subsequence is \"bb\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":401,"row":{"number":517,"difficulty":2,"question":"class Solution:\n    def findMinMoves(self, machines: List[int]) -> int:\n        \"\"\"\n        You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n        For each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n        Given an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\n        Example 1:\n        Input: machines = [1,0,5]\n        Output: 3\n        Explanation:\n        1st move:    1     0 <-- 5    =>    1     1     4\n        2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n        3rd move:    2     1 <-- 3    =>    2     2     2\n        Example 2:\n        Input: machines = [0,3,0]\n        Output: 2\n        Explanation:\n        1st move:    0 <-- 3     0    =>    1     2     0\n        2nd move:    1     2 --> 0    =>    1     1     1\n        Example 3:\n        Input: machines = [0,2,0]\n        Output: -1\n        Explanation:\n        It's impossible to make all three washing machines have the same number of dresses.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":402,"row":{"number":518,"difficulty":1,"question":"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        \"\"\"\n        You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n        Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n        You may assume that you have an infinite number of each kind of coin.\n        The answer is guaranteed to fit into a signed 32-bit integer.\n        Example 1:\n        Input: amount = 5, coins = [1,2,5]\n        Output: 4\n        Explanation: there are four ways to make up the amount:\n        5=5\n        5=2+2+1\n        5=2+1+1+1\n        5=1+1+1+1+1\n        Example 2:\n        Input: amount = 3, coins = [2]\n        Output: 0\n        Explanation: the amount of 3 cannot be made up just with coins of 2.\n        Example 3:\n        Input: amount = 10, coins = [10]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":403,"row":{"number":520,"difficulty":0,"question":"class Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        \"\"\"\n        We define the usage of capitals in a word to be right when one of the following cases holds:\n            All letters in this word are capitals, like \"USA\".\n            All letters in this word are not capitals, like \"leetcode\".\n            Only the first letter in this word is capital, like \"Google\".\n        Given a string word, return true if the usage of capitals in it is right.\n        Example 1:\n        Input: word = \"USA\"\n        Output: true\n        Example 2:\n        Input: word = \"FlaG\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":404,"row":{"number":521,"difficulty":0,"question":"class Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        \"\"\"\n        Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.\n        An uncommon subsequence between two strings is a string that is a subsequence of one but not the other.\n        A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\n            For example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).\n        Example 1:\n        Input: a = \"aba\", b = \"cdc\"\n        Output: 3\n        Explanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\n        Note that \"cdc\" is also a longest uncommon subsequence.\n        Example 2:\n        Input: a = \"aaa\", b = \"bbb\"\n        Output: 3\n        Explanation: The longest uncommon subsequences are \"aaa\" and \"bbb\".\n        Example 3:\n        Input: a = \"aaa\", b = \"aaa\"\n        Output: -1\n        Explanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":405,"row":{"number":522,"difficulty":1,"question":"class Solution:\n    def findLUSlength(self, strs: List[str]) -> int:\n        \"\"\"\n        Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.\n        An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.\n        A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\n            For example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).\n        Example 1:\n        Input: strs = [\"aba\",\"cdc\",\"eae\"]\n        Output: 3\n        Example 2:\n        Input: strs = [\"aaa\",\"aaa\",\"aa\"]\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":406,"row":{"number":523,"difficulty":1,"question":"class Solution:\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\n        \"\"\"\n        Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\n        A good subarray is a subarray where:\n            its length is at least two, and\n            the sum of the elements of the subarray is a multiple of k.\n        Note that:\n            A subarray is a contiguous part of the array.\n            An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.\n        Example 1:\n        Input: nums = [23,2,4,6,7], k = 6\n        Output: true\n        Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n        Example 2:\n        Input: nums = [23,2,6,4,7], k = 6\n        Output: true\n        Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n        42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n        Example 3:\n        Input: nums = [23,2,6,4,7], k = 13\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":407,"row":{"number":524,"difficulty":1,"question":"class Solution:\n    def findLongestWord(self, s: str, dictionary: List[str]) -> str:\n        \"\"\"\n        Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n        Example 1:\n        Input: s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n        Output: \"apple\"\n        Example 2:\n        Input: s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\n        Output: \"a\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":408,"row":{"number":525,"difficulty":1,"question":"class Solution:\n    def findMaxLength(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\n        Example 1:\n        Input: nums = [0,1]\n        Output: 2\n        Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n        Example 2:\n        Input: nums = [0,1,0]\n        Output: 2\n        Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":409,"row":{"number":526,"difficulty":1,"question":"class Solution:\n    def countArrangement(self, n: int) -> int:\n        \"\"\"\n        Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true:\n            perm[i] is divisible by i.\n            i is divisible by perm[i].\n        Given an integer n, return the number of the beautiful arrangements that you can construct.\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: \n        The first beautiful arrangement is [1,2]:\n            - perm[1] = 1 is divisible by i = 1\n            - perm[2] = 2 is divisible by i = 2\n        The second beautiful arrangement is [2,1]:\n            - perm[1] = 2 is divisible by i = 1\n            - i = 2 is divisible by perm[2] = 1\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":410,"row":{"number":1721,"difficulty":1,"question":"class Solution:\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        You are given the head of a linked list, and an integer k.\n        Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [1,4,3,2,5]\n        Example 2:\n        Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5\n        Output: [7,9,6,6,8,7,3,0,9,5]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":411,"row":{"number":529,"difficulty":1,"question":"class Solution:\n    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n        \"\"\"\n        Let's play the minesweeper game (Wikipedia, online game)!\n        You are given an m x n char matrix board representing the game board where:\n            'M' represents an unrevealed mine,\n            'E' represents an unrevealed empty square,\n            'B' represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),\n            digit ('1' to '8') represents how many mines are adjacent to this revealed square, and\n            'X' represents a revealed mine.\n        You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E').\n        Return the board after revealing this position according to the following rules:\n            If a mine 'M' is revealed, then the game is over. You should change it to 'X'.\n            If an empty square 'E' with no adjacent mines is revealed, then change it to a revealed blank 'B' and all of its adjacent unrevealed squares should be revealed recursively.\n            If an empty square 'E' with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.\n            Return the board when no more squares will be revealed.\n        Example 1:\n        Input: board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]\n        Output: [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n        Example 2:\n        Input: board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]\n        Output: [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":412,"row":{"number":530,"difficulty":0,"question":"class Solution:\n    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\n        Example 1:\n        Input: root = [4,2,6,1,3]\n        Output: 1\n        Example 2:\n        Input: root = [1,0,48,null,null,12,49]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":413,"row":{"number":532,"difficulty":1,"question":"class Solution:\n    def findPairs(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\n        A k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n            0 <= i, j < nums.length\n            i != j\n            nums[i] - nums[j] == k\n        Notice that |val| denotes the absolute value of val.\n        Example 1:\n        Input: nums = [3,1,4,1,5], k = 2\n        Output: 2\n        Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\n        Although we have two 1s in the input, we should only return the number of unique pairs.\n        Example 2:\n        Input: nums = [1,2,3,4,5], k = 1\n        Output: 4\n        Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n        Example 3:\n        Input: nums = [1,3,1,5,4], k = 0\n        Output: 1\n        Explanation: There is one 0-diff pair in the array, (1, 1).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":414,"row":{"number":535,"difficulty":1,"question":"class Codec:\n    def encode(self, longUrl: str) -> str:\n        \"\"\"Encodes a URL to a shortened URL.\n        Note: This is a companion problem to the System Design problem: Design TinyURL.\n        TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.\n        There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n        Implement the Solution class:\n            Solution() Initializes the object of the system.\n            String encode(String longUrl) Returns a tiny URL for the given longUrl.\n            String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.\n        Example 1:\n        Input: url = \"https://leetcode.com/problems/design-tinyurl\"\n        Output: \"https://leetcode.com/problems/design-tinyurl\"\n        Explanation:\n        Solution obj = new Solution();\n        string tiny = obj.encode(url); // returns the encoded tiny url.\n        string ans = obj.decode(tiny); // returns the original url after decoding it.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":415,"row":{"number":537,"difficulty":1,"question":"class Solution:\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n            real is the real part and is an integer in the range [-100, 100].\n            imaginary is the imaginary part and is an integer in the range [-100, 100].\n            i2 == -1.\n        Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.\n        Example 1:\n        Input: num1 = \"1+1i\", num2 = \"1+1i\"\n        Output: \"0+2i\"\n        Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\n        Example 2:\n        Input: num1 = \"1+-1i\", num2 = \"1+-1i\"\n        Output: \"0+-2i\"\n        Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":416,"row":{"number":538,"difficulty":1,"question":"class Solution:\n    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\n        As a reminder, a binary search tree is a tree that satisfies these constraints:\n            The left subtree of a node contains only nodes with keys less than the node's key.\n            The right subtree of a node contains only nodes with keys greater than the node's key.\n            Both the left and right subtrees must also be binary search trees.\n        Example 1:\n        Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n        Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n        Example 2:\n        Input: root = [0,null,1]\n        Output: [1,null,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":417,"row":{"number":539,"difficulty":1,"question":"class Solution:\n    def findMinDifference(self, timePoints: List[str]) -> int:\n        \"\"\"\n        Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference between any two time-points in the list.\n        Example 1:\n        Input: timePoints = [\"23:59\",\"00:00\"]\n        Output: 1\n        Example 2:\n        Input: timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":418,"row":{"number":540,"difficulty":1,"question":"class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n        Return the single element that appears only once.\n        Your solution must run in O(log n) time and O(1) space.\n        Example 1:\n        Input: nums = [1,1,2,3,3,4,4,8,8]\n        Output: 2\n        Example 2:\n        Input: nums = [3,3,7,7,10,11,11]\n        Output: 10\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":419,"row":{"number":541,"difficulty":0,"question":"class Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        \"\"\"\n        Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\n        If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.\n        Example 1:\n        Input: s = \"abcdefg\", k = 2\n        Output: \"bacdfeg\"\n        Example 2:\n        Input: s = \"abcd\", k = 2\n        Output: \"bacd\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":420,"row":{"number":542,"difficulty":1,"question":"class Solution:\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\n        The distance between two adjacent cells is 1.\n        Example 1:\n        Input: mat = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: [[0,0,0],[0,1,0],[0,0,0]]\n        Example 2:\n        Input: mat = [[0,0,0],[0,1,0],[1,1,1]]\n        Output: [[0,0,0],[0,1,0],[1,2,1]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":421,"row":{"number":543,"difficulty":0,"question":"class Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the length of the diameter of the tree.\n        The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n        The length of a path between two nodes is represented by the number of edges between them.\n        Example 1:\n        Input: root = [1,2,3,4,5]\n        Output: 3\n        Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n        Example 2:\n        Input: root = [1,2]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":422,"row":{"number":546,"difficulty":2,"question":"class Solution:\n    def removeBoxes(self, boxes: List[int]) -> int:\n        \"\"\"\n        You are given several boxes with different colors represented by different positive numbers.\n        You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k >= 1), remove them and get k * k points.\n        Return the maximum points you can get.\n        Example 1:\n        Input: boxes = [1,3,2,2,2,3,4,3,1]\n        Output: 23\n        Explanation:\n        [1, 3, 2, 2, 2, 3, 4, 3, 1] \n        ----> [1, 3, 3, 4, 3, 1] (3*3=9 points) \n        ----> [1, 3, 3, 3, 1] (1*1=1 points) \n        ----> [1, 1] (3*3=9 points) \n        ----> [] (2*2=4 points)\n        Example 2:\n        Input: boxes = [1,1,1]\n        Output: 9\n        Example 3:\n        Input: boxes = [1]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":423,"row":{"number":547,"difficulty":1,"question":"class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        \"\"\"\n        There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\n        A province is a group of directly or indirectly connected cities and no other cities outside of the group.\n        You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\n        Return the total number of provinces.\n        Example 1:\n        Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n        Output: 2\n        Example 2:\n        Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":424,"row":{"number":551,"difficulty":0,"question":"class Solution:\n    def checkRecord(self, s: str) -> bool:\n        \"\"\"\n        You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n            'A': Absent.\n            'L': Late.\n            'P': Present.\n        The student is eligible for an attendance award if they meet both of the following criteria:\n            The student was absent ('A') for strictly fewer than 2 days total.\n            The student was never late ('L') for 3 or more consecutive days.\n        Return true if the student is eligible for an attendance award, or false otherwise.\n        Example 1:\n        Input: s = \"PPALLP\"\n        Output: true\n        Explanation: The student has fewer than 2 absences and was never late 3 or more consecutive days.\n        Example 2:\n        Input: s = \"PPALLL\"\n        Output: false\n        Explanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":425,"row":{"number":552,"difficulty":2,"question":"class Solution:\n    def checkRecord(self, n: int) -> int:\n        \"\"\"\n        An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n            'A': Absent.\n            'L': Late.\n            'P': Present.\n        Any student is eligible for an attendance award if they meet both of the following criteria:\n            The student was absent ('A') for strictly fewer than 2 days total.\n            The student was never late ('L') for 3 or more consecutive days.\n        Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7.\n        Example 1:\n        Input: n = 2\n        Output: 8\n        Explanation: There are 8 records with length 2 that are eligible for an award:\n        \"PP\", \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\n        Only \"AA\" is not eligible because there are 2 absences (there need to be fewer than 2).\n        Example 2:\n        Input: n = 1\n        Output: 3\n        Example 3:\n        Input: n = 10101\n        Output: 183236316\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":426,"row":{"number":553,"difficulty":1,"question":"class Solution:\n    def optimalDivision(self, nums: List[int]) -> str:\n        \"\"\"\n        You are given an integer array nums. The adjacent integers in nums will perform the float division.\n            For example, for nums = [2,3,4], we will evaluate the expression \"2/3/4\".\n        However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\n        Return the corresponding expression that has the maximum value in string format.\n        Note: your expression should not contain redundant parenthesis.\n        Example 1:\n        Input: nums = [1000,100,10,2]\n        Output: \"1000/(100/10/2)\"\n        Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200\n        However, the bold parenthesis in \"1000/((100/10)/2)\" are redundant since they do not influence the operation priority.\n        So you should return \"1000/(100/10/2)\".\n        Other cases:\n        1000/(100/10)/2 = 50\n        1000/(100/(10/2)) = 50\n        1000/100/10/2 = 0.5\n        1000/100/(10/2) = 2\n        Example 2:\n        Input: nums = [2,3,4]\n        Output: \"2/(3/4)\"\n        Explanation: (2/(3/4)) = 8/3 = 2.667\n        It can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":427,"row":{"number":554,"difficulty":1,"question":"class Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        \"\"\"\n        There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.\n        Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.\n        Given the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line.\n        Example 1:\n        Input: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n        Output: 2\n        Example 2:\n        Input: wall = [[1],[1],[1]]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":428,"row":{"number":556,"difficulty":1,"question":"class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        \"\"\"\n        Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.\n        Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.\n        Example 1:\n        Input: n = 12\n        Output: 21\n        Example 2:\n        Input: n = 21\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":429,"row":{"number":557,"difficulty":0,"question":"class Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n        Example 1:\n        Input: s = \"Let's take LeetCode contest\"\n        Output: \"s'teL ekat edoCteeL tsetnoc\"\n        Example 2:\n        Input: s = \"God Ding\"\n        Output: \"doG gniD\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":430,"row":{"number":560,"difficulty":1,"question":"class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,1,1], k = 2\n        Output: 2\n        Example 2:\n        Input: nums = [1,2,3], k = 3\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":431,"row":{"number":561,"difficulty":0,"question":"class Solution:\n    def arrayPairSum(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.\n        Example 1:\n        Input: nums = [1,4,3,2]\n        Output: 4\n        Explanation: All possible pairings (ignoring the ordering of elements) are:\n        1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n        2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n        3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\n        So the maximum possible sum is 4.\n        Example 2:\n        Input: nums = [6,2,6,5,1,2]\n        Output: 9\n        Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":432,"row":{"number":563,"difficulty":0,"question":"class Solution:\n    def findTilt(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the sum of every tree node's tilt.\n        The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child.\n        Example 1:\n        Input: root = [1,2,3]\n        Output: 1\n        Explanation: \n        Tilt of node 2 : |0-0| = 0 (no children)\n        Tilt of node 3 : |0-0| = 0 (no children)\n        Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\n        Sum of every tilt : 0 + 0 + 1 = 1\n        Example 2:\n        Input: root = [4,2,9,3,5,null,7]\n        Output: 15\n        Explanation: \n        Tilt of node 3 : |0-0| = 0 (no children)\n        Tilt of node 5 : |0-0| = 0 (no children)\n        Tilt of node 7 : |0-0| = 0 (no children)\n        Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\n        Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\n        Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\n        Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n        Example 3:\n        Input: root = [21,7,14,1,1,2,2,3,3]\n        Output: 9\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":433,"row":{"number":564,"difficulty":2,"question":"class Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        \"\"\"\n        Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.\n        The closest is defined as the absolute difference minimized between two integers.\n        Example 1:\n        Input: n = \"123\"\n        Output: \"121\"\n        Example 2:\n        Input: n = \"1\"\n        Output: \"0\"\n        Explanation: 0 and 2 are the closest palindromes but we return the smallest which is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":434,"row":{"number":565,"difficulty":1,"question":"class Solution:\n    def arrayNesting(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].\n        You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:\n            The first element in s[k] starts with the selection of the element nums[k] of index = k.\n            The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.\n            We stop adding right before a duplicate element occurs in s[k].\n        Return the longest length of a set s[k].\n        Example 1:\n        Input: nums = [5,4,0,3,1,6,2]\n        Output: 4\n        Explanation: \n        nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\n        One of the longest sets s[k]:\n        s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\n        Example 2:\n        Input: nums = [0,1,2]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":435,"row":{"number":566,"difficulty":0,"question":"class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\n        \"\"\"\n        In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.\n        You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.\n        The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n        If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\n        Example 1:\n        Input: mat = [[1,2],[3,4]], r = 1, c = 4\n        Output: [[1,2,3,4]]\n        Example 2:\n        Input: mat = [[1,2],[3,4]], r = 2, c = 4\n        Output: [[1,2],[3,4]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":436,"row":{"number":567,"difficulty":1,"question":"class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        \"\"\"\n        Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n        In other words, return true if one of s1's permutations is the substring of s2.\n        Example 1:\n        Input: s1 = \"ab\", s2 = \"eidbaooo\"\n        Output: true\n        Explanation: s2 contains one permutation of s1 (\"ba\").\n        Example 2:\n        Input: s1 = \"ab\", s2 = \"eidboaoo\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":437,"row":{"number":572,"difficulty":0,"question":"class Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\n        A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\n        Example 1:\n        Input: root = [3,4,5,1,2], subRoot = [4,1,2]\n        Output: true\n        Example 2:\n        Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":438,"row":{"number":575,"difficulty":0,"question":"class Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        \"\"\"\n        Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\n        The doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n        Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.\n        Example 1:\n        Input: candyType = [1,1,2,2,3,3]\n        Output: 3\n        Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n        Example 2:\n        Input: candyType = [1,1,2,3]\n        Output: 2\n        Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.\n        Example 3:\n        Input: candyType = [6,6,6,6]\n        Output: 1\n        Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":439,"row":{"number":576,"difficulty":1,"question":"class Solution:\n    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:\n        \"\"\"\n        There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball.\n        Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n        Output: 6\n        Example 2:\n        Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n        Output: 12\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":440,"row":{"number":581,"difficulty":1,"question":"class Solution:\n    def findUnsortedSubarray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\n        Return the shortest such subarray and output its length.\n        Example 1:\n        Input: nums = [2,6,4,8,10,9,15]\n        Output: 5\n        Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: 0\n        Example 3:\n        Input: nums = [1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":441,"row":{"number":583,"difficulty":1,"question":"class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\n        In one step, you can delete exactly one character in either string.\n        Example 1:\n        Input: word1 = \"sea\", word2 = \"eat\"\n        Output: 2\n        Explanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".\n        Example 2:\n        Input: word1 = \"leetcode\", word2 = \"etco\"\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":442,"row":{"number":587,"difficulty":2,"question":"class Solution:\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\n        Fence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\n        Return the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.\n        Example 1:\n        Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n        Output: [[1,1],[2,0],[4,2],[3,3],[2,4]]\n        Explanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.\n        Example 2:\n        Input: trees = [[1,2],[2,2],[4,2]]\n        Output: [[4,2],[2,2],[1,2]]\n        Explanation: The fence forms a line that passes through all the trees.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":443,"row":{"number":591,"difficulty":2,"question":"class Solution:\n    def isValid(self, code: str) -> bool:\n        \"\"\"\n        Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.\n        A code snippet is valid if all the following rules hold:\n            The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\n            A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\n            A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\n            A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.\n            A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n            A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME (not necessarily valid).\n            The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.\n            CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.\n        Example 1:\n        Input: code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\n        Output: true\n        Explanation: \n        The code is wrapped in a closed tag : <DIV> and </DIV>. \n        The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \n        Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.\n        So TAG_CONTENT is valid, and then the code is valid. Thus return true.\n        Example 2:\n        Input: code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\n        Output: true\n        Explanation:\n        We first separate the code into : start_tag|tag_content|end_tag.\n        start_tag -> \"<DIV>\"\n        end_tag -> \"</DIV>\"\n        tag_content could also be separated into : text1|cdata|text2.\n        text1 -> \">>  ![cdata[]] \"\n        cdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\"\n        text2 -> \"]]>>]\"\n        The reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6.\n        The reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7.\n        Example 3:\n        Input: code = \"<A>  <B> </A>   </B>\"\n        Output: false\n        Explanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":444,"row":{"number":592,"difficulty":1,"question":"class Solution:\n    def fractionAddition(self, expression: str) -> str:\n        \"\"\"\n        Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.\n        The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.\n        Example 1:\n        Input: expression = \"-1/2+1/2\"\n        Output: \"0/1\"\n        Example 2:\n        Input: expression = \"-1/2+1/2+1/3\"\n        Output: \"1/3\"\n        Example 3:\n        Input: expression = \"1/3-1/2\"\n        Output: \"-1/6\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":445,"row":{"number":593,"difficulty":1,"question":"class Solution:\n    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\n        \"\"\"\n        Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points construct a square.\n        The coordinate of a point pi is represented as [xi, yi]. The input is not given in any order.\n        A valid square has four equal sides with positive length and four equal angles (90-degree angles).\n        Example 1:\n        Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n        Output: true\n        Example 2:\n        Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n        Output: false\n        Example 3:\n        Input: p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":446,"row":{"number":594,"difficulty":0,"question":"class Solution:\r\n    def findLHS(self, nums: List[int]) -> int:\n        \"\"\"\n        We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\r\n        Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\r\n        A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\r\n        Example 1:\r\n        Input: nums = [1,3,2,2,5,2,3,7]\r\n        Output: 5\r\n        Explanation: The longest harmonious subsequence is [3,2,2,2,3].\r\n        Example 2:\r\n        Input: nums = [1,2,3,4]\r\n        Output: 2\r\n        Example 3:\r\n        Input: nums = [1,1,1,1]\r\n        Output: 0\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":447,"row":{"number":598,"difficulty":0,"question":"class Solution:\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi.\n        Count and return the number of maximum integers in the matrix after performing all the operations.\n        Example 1:\n        Input: m = 3, n = 3, ops = [[2,2],[3,3]]\n        Output: 4\n        Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.\n        Example 2:\n        Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n        Output: 4\n        Example 3:\n        Input: m = 3, n = 3, ops = []\n        Output: 9\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":448,"row":{"number":599,"difficulty":0,"question":"class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        \"\"\"\n        Given two arrays of strings list1 and list2, find the common strings with the least index sum.\n        A common string is a string that appeared in both list1 and list2.\n        A common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\n        Return all the common strings with the least index sum. Return the answer in any order.\n        Example 1:\n        Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\n        Output: [\"Shogun\"]\n        Explanation: The only common string is \"Shogun\".\n        Example 2:\n        Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\n        Output: [\"Shogun\"]\n        Explanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.\n        Example 3:\n        Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\n        Output: [\"sad\",\"happy\"]\n        Explanation: There are three common strings:\n        \"happy\" with index sum = (0 + 1) = 1.\n        \"sad\" with index sum = (1 + 0) = 1.\n        \"good\" with index sum = (2 + 2) = 4.\n        The strings with the least index sum are \"sad\" and \"happy\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":449,"row":{"number":600,"difficulty":2,"question":"class Solution:\n    def findIntegers(self, n: int) -> int:\n        \"\"\"\n        Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.\n        Example 1:\n        Input: n = 5\n        Output: 5\n        Explanation:\n        Here are the non-negative integers <= 5 with their corresponding binary representations:\n        0 : 0\n        1 : 1\n        2 : 10\n        3 : 11\n        4 : 100\n        5 : 101\n        Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n        Example 2:\n        Input: n = 1\n        Output: 2\n        Example 3:\n        Input: n = 2\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":450,"row":{"number":605,"difficulty":0,"question":"class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        \"\"\"\n        You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\n        Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.\n        Example 1:\n        Input: flowerbed = [1,0,0,0,1], n = 1\n        Output: true\n        Example 2:\n        Input: flowerbed = [1,0,0,0,1], n = 2\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":451,"row":{"number":606,"difficulty":0,"question":"class Solution:\n    def tree2str(self, root: Optional[TreeNode]) -> str:\n        \"\"\"\n        Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.\n        Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.\n        Example 1:\n        Input: root = [1,2,3,4]\n        Output: \"1(2(4))(3)\"\n        Explanation: Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\"\n        Example 2:\n        Input: root = [1,2,3,null,4]\n        Output: \"1(2()(4))(3)\"\n        Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":452,"row":{"number":609,"difficulty":1,"question":"class Solution:\n    def findDuplicate(self, paths: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.\n        A group of duplicate files consists of at least two files that have the same content.\n        A single directory info string in the input list has the following format:\n            \"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"\n        It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory \"root/d1/d2/.../dm\". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.\n        The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:\n            \"directory_path/file_name.txt\"\n        Example 1:\n        Input: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\n        Output: [[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n        Example 2:\n        Input: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\n        Output: [[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":453,"row":{"number":611,"difficulty":1,"question":"class Solution:\n    def triangleNumber(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n        Example 1:\n        Input: nums = [2,2,3,4]\n        Output: 3\n        Explanation: Valid combinations are: \n        2,3,4 (using the first 2)\n        2,3,4 (using the second 2)\n        2,2,3\n        Example 2:\n        Input: nums = [4,2,3,4]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":454,"row":{"number":617,"difficulty":0,"question":"class Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        \"\"\"\n        You are given two binary trees root1 and root2.\n        Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\n        Return the merged tree.\n        Note: The merging process must start from the root nodes of both trees.\n        Example 1:\n        Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n        Output: [3,4,5,5,4,null,7]\n        Example 2:\n        Input: root1 = [1], root2 = [1,2]\n        Output: [2,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":455,"row":{"number":621,"difficulty":1,"question":"class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        \"\"\"\n        Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n        However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\n        Return the least number of units of times that the CPU will take to finish all the given tasks.\n        Example 1:\n        Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n        Output: 8\n        Explanation: \n        A -> B -> idle -> A -> B -> idle -> A -> B\n        There is at least 2 units of time between any two same tasks.\n        Example 2:\n        Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\n        Output: 6\n        Explanation: On this case any permutation of size 6 would work since n = 0.\n        [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n        [\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n        [\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n        ...\n        And so on.\n        Example 3:\n        Input: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\n        Output: 16\n        Explanation: \n        One possible solution is\n        A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":456,"row":{"number":623,"difficulty":1,"question":"class Solution:\n    def addOneRow(self, root: Optional[TreeNode], val: int, depth: int) -> Optional[TreeNode]:\n        \"\"\"\n        Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.\n        Note that the root node is at depth 1.\n        The adding rule is:\n            Given the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root.\n            cur's original left subtree should be the left subtree of the new left subtree root.\n            cur's original right subtree should be the right subtree of the new right subtree root.\n            If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root's left subtree.\n        Example 1:\n        Input: root = [4,2,6,3,1,5], val = 1, depth = 2\n        Output: [4,1,1,2,null,null,6,3,1,5]\n        Example 2:\n        Input: root = [4,2,null,3,1], val = 1, depth = 3\n        Output: [4,2,null,1,1,3,null,null,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":457,"row":{"number":628,"difficulty":0,"question":"class Solution:\n    def maximumProduct(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find three numbers whose product is maximum and return the maximum product.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: 6\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: 24\n        Example 3:\n        Input: nums = [-1,-2,-3]\n        Output: -6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":458,"row":{"number":629,"difficulty":2,"question":"class Solution:\n    def kInversePairs(self, n: int, k: int) -> int:\n        \"\"\"\n        For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j].\n        Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 3, k = 0\n        Output: 1\n        Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n        Example 2:\n        Input: n = 3, k = 1\n        Output: 2\n        Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":459,"row":{"number":630,"difficulty":2,"question":"class Solution:\n    def scheduleCourse(self, courses: List[List[int]]) -> int:\n        \"\"\"\n        There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.\n        You will start on the 1st day and you cannot take two or more courses simultaneously.\n        Return the maximum number of courses that you can take.\n        Example 1:\n        Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\n        Output: 3\n        Explanation: \n        There are totally 4 courses, but you can take 3 courses at most:\n        First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\n        Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \n        Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \n        The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n        Example 2:\n        Input: courses = [[1,2]]\n        Output: 1\n        Example 3:\n        Input: courses = [[3,2],[4,3]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":460,"row":{"number":632,"difficulty":2,"question":"class Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        \"\"\"\n        You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.\n        We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.\n        Example 1:\n        Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\n        Output: [20,24]\n        Explanation: \n        List 1: [4, 10, 15, 24,26], 24 is in range [20,24].\n        List 2: [0, 9, 12, 20], 20 is in range [20,24].\n        List 3: [5, 18, 22, 30], 22 is in range [20,24].\n        Example 2:\n        Input: nums = [[1,2,3],[1,2,3],[1,2,3]]\n        Output: [1,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":461,"row":{"number":633,"difficulty":1,"question":"class Solution:\n    def judgeSquareSum(self, c: int) -> bool:\n        \"\"\"\n        Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.\n        Example 1:\n        Input: c = 5\n        Output: true\n        Explanation: 1 * 1 + 2 * 2 = 5\n        Example 2:\n        Input: c = 3\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":462,"row":{"number":636,"difficulty":1,"question":"class Solution:\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\n        \"\"\"\n        On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1.\n        Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\n        You are given a list logs, where logs[i] represents the ith log message formatted as a string \"{function_id}:{\"start\" | \"end\"}:{timestamp}\". For example, \"0:start:3\" means a function call with function ID 0 started at the beginning of timestamp 3, and \"1:end:2\" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively.\n        A function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3.\n        Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.\n        Example 1:\n        Input: n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n        Output: [3,4]\n        Explanation:\n        Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\n        Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\n        Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\n        So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n        Example 2:\n        Input: n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n        Output: [8]\n        Explanation:\n        Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\n        Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\n        Function 0 (initial call) resumes execution then immediately calls itself again.\n        Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\n        Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\n        So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n        Example 3:\n        Input: n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n        Output: [7,1]\n        Explanation:\n        Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\n        Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\n        Function 0 (initial call) resumes execution then immediately calls function 1.\n        Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\n        Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\n        So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":463,"row":{"number":637,"difficulty":0,"question":"class Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        \"\"\"\n        Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: [3.00000,14.50000,11.00000]\n        Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\n        Hence return [3, 14.5, 11].\n        Example 2:\n        Input: root = [3,9,20,15,7]\n        Output: [3.00000,14.50000,11.00000]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":464,"row":{"number":638,"difficulty":1,"question":"class Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        \"\"\"\n        In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\n        You are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy.\n        You are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer.\n        Return the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.\n        Example 1:\n        Input: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n        Output: 14\n        Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. \n        In special offer 1, you can pay $5 for 3A and 0B\n        In special offer 2, you can pay $10 for 1A and 2B. \n        You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n        Example 2:\n        Input: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\n        Output: 11\n        Explanation: The price of A is $2, and $3 for B, $4 for C. \n        You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \n        You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \n        You cannot add more items, though only $9 for 2A ,2B and 1C.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":465,"row":{"number":639,"difficulty":2,"question":"class Solution:\n    def numDecodings(self, s: str) -> int:\n        \"\"\"\n        A message containing letters from A-Z can be encoded into numbers using the following mapping:\n        'A' -> \"1\"\n        'B' -> \"2\"\n        ...\n        'Z' -> \"26\"\n        To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n            \"AAJF\" with the grouping (1 1 10 6)\n            \"KJF\" with the grouping (11 10 6)\n        Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\n        In addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message \"1*\" may represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Decoding \"1*\" is equivalent to decoding any of the encoded messages it can represent.\n        Given a string s consisting of digits and '*' characters, return the number of ways to decode it.\n        Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: s = \"*\"\n        Output: 9\n        Explanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\".\n        Each of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively.\n        Hence, there are a total of 9 ways to decode \"*\".\n        Example 2:\n        Input: s = \"1*\"\n        Output: 18\n        Explanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\".\n        Each of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\").\n        Hence, there are a total of 9 * 2 = 18 ways to decode \"1*\".\n        Example 3:\n        Input: s = \"2*\"\n        Output: 15\n        Explanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\".\n        \"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way.\n        Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":466,"row":{"number":640,"difficulty":1,"question":"class Solution:\n    def solveEquation(self, equation: str) -> str:\n        \"\"\"\n        Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation contains only '+', '-' operation, the variable 'x' and its coefficient. You should return \"No solution\" if there is no solution for the equation, or \"Infinite solutions\" if there are infinite solutions for the equation.\n        If there is exactly one solution for the equation, we ensure that the value of 'x' is an integer.\n        Example 1:\n        Input: equation = \"x+5-3+x=6+x-2\"\n        Output: \"x=2\"\n        Example 2:\n        Input: equation = \"x=x\"\n        Output: \"Infinite solutions\"\n        Example 3:\n        Input: equation = \"2x=x\"\n        Output: \"x=0\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":467,"row":{"number":643,"difficulty":0,"question":"class Solution:\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\n        \"\"\"\n        You are given an integer array nums consisting of n elements, and an integer k.\n        Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.\n        Example 1:\n        Input: nums = [1,12,-5,-6,50,3], k = 4\n        Output: 12.75000\n        Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n        Example 2:\n        Input: nums = [5], k = 1\n        Output: 5.00000\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":468,"row":{"number":645,"difficulty":0,"question":"class Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\n        You are given an integer array nums representing the data status of this set after the error.\n        Find the number that occurs twice and the number that is missing and return them in the form of an array.\n        Example 1:\n        Input: nums = [1,2,2,4]\n        Output: [2,3]\n        Example 2:\n        Input: nums = [1,1]\n        Output: [1,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":469,"row":{"number":646,"difficulty":1,"question":"class Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        \"\"\"\n        You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n        A pair p2 = [c, d] follows a pair p1 = [a, b] if b < c. A chain of pairs can be formed in this fashion.\n        Return the length longest chain which can be formed.\n        You do not need to use up all the given intervals. You can select pairs in any order.\n        Example 1:\n        Input: pairs = [[1,2],[2,3],[3,4]]\n        Output: 2\n        Explanation: The longest chain is [1,2] -> [3,4].\n        Example 2:\n        Input: pairs = [[1,2],[7,8],[4,5]]\n        Output: 3\n        Explanation: The longest chain is [1,2] -> [4,5] -> [7,8].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":470,"row":{"number":647,"difficulty":1,"question":"class Solution:\n    def countSubstrings(self, s: str) -> int:\n        \"\"\"\n        Given a string s, return the number of palindromic substrings in it.\n        A string is a palindrome when it reads the same backward as forward.\n        A substring is a contiguous sequence of characters within the string.\n        Example 1:\n        Input: s = \"abc\"\n        Output: 3\n        Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n        Example 2:\n        Input: s = \"aaa\"\n        Output: 6\n        Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":471,"row":{"number":648,"difficulty":1,"question":"class Solution:\n    def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n        \"\"\"\n        In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word successor. For example, when the root \"an\" is followed by the successor word \"other\", we can form a new word \"another\".\n        Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. If a successor can be replaced by more than one root, replace it with the root that has the shortest length.\n        Return the sentence after the replacement.\n        Example 1:\n        Input: dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n        Output: \"the cat was rat by the bat\"\n        Example 2:\n        Input: dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\n        Output: \"a a b c\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":472,"row":{"number":649,"difficulty":1,"question":"class Solution:\n    def predictPartyVictory(self, senate: str) -> str:\n        \"\"\"\n        In the world of Dota2, there are two parties: the Radiant and the Dire.\n        The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n            Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.\n            Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\n        Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.\n        The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n        Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be \"Radiant\" or \"Dire\".\n        Example 1:\n        Input: senate = \"RD\"\n        Output: \"Radiant\"\n        Explanation: \n        The first senator comes from Radiant and he can just ban the next senator's right in round 1. \n        And the second senator can't exercise any rights anymore since his right has been banned. \n        And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n        Example 2:\n        Input: senate = \"RDD\"\n        Output: \"Dire\"\n        Explanation: \n        The first senator comes from Radiant and he can just ban the next senator's right in round 1. \n        And the second senator can't exercise any rights anymore since his right has been banned. \n        And the third senator comes from Dire and he can ban the first senator's right in round 1. \n        And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":473,"row":{"number":650,"difficulty":1,"question":"class Solution:\n    def minSteps(self, n: int) -> int:\n        \"\"\"\n        There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:\n            Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).\n            Paste: You can paste the characters which are copied last time.\n        Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.\n        Example 1:\n        Input: n = 3\n        Output: 3\n        Explanation: Initially, we have one character 'A'.\n        In step 1, we use Copy All operation.\n        In step 2, we use Paste operation to get 'AA'.\n        In step 3, we use Paste operation to get 'AAA'.\n        Example 2:\n        Input: n = 1\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":474,"row":{"number":652,"difficulty":1,"question":"class Solution:\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\n        \"\"\"\n        Given the root of a binary tree, return all duplicate subtrees.\n        For each kind of duplicate subtrees, you only need to return the root node of any one of them.\n        Two trees are duplicate if they have the same structure with the same node values.\n        Example 1:\n        Input: root = [1,2,3,4,null,2,4,null,null,4]\n        Output: [[2,4],[4]]\n        Example 2:\n        Input: root = [2,1,1]\n        Output: [[1]]\n        Example 3:\n        Input: root = [2,2,2,3,null,3,null]\n        Output: [[2,3],[3]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":475,"row":{"number":653,"difficulty":0,"question":"class Solution:\n    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n        \"\"\"\n        Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.\n        Example 1:\n        Input: root = [5,3,6,2,4,null,7], k = 9\n        Output: true\n        Example 2:\n        Input: root = [5,3,6,2,4,null,7], k = 28\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":476,"row":{"number":654,"difficulty":1,"question":"class Solution:\n    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\n        \"\"\"\n        You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\n            Create a root node whose value is the maximum value in nums.\n            Recursively build the left subtree on the subarray prefix to the left of the maximum value.\n            Recursively build the right subtree on the subarray suffix to the right of the maximum value.\n        Return the maximum binary tree built from nums.\n        Example 1:\n        Input: nums = [3,2,1,6,0,5]\n        Output: [6,3,5,null,2,0,null,null,1]\n        Explanation: The recursive calls are as follow:\n        - The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n            - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n                - Empty array, so no child.\n                - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n                    - Empty array, so no child.\n                    - Only one element, so child is a node with value 1.\n            - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n                - Only one element, so child is a node with value 0.\n                - Empty array, so no child.\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [3,null,2,null,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":477,"row":{"number":655,"difficulty":1,"question":"class Solution:\n    def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:\n        \"\"\"\n        Given the root of a binary tree, construct a 0-indexed m x n string matrix res that represents a formatted layout of the tree. The formatted layout matrix should be constructed using the following rules:\n            The height of the tree is height and the number of rows m should be equal to height + 1.\n            The number of columns n should be equal to 2height+1 - 1.\n            Place the root node in the middle of the top row (more formally, at location res[0][(n-1)/2]).\n            For each node that has been placed in the matrix at position res[r][c], place its left child at res[r+1][c-2height-r-1] and its right child at res[r+1][c+2height-r-1].\n            Continue this process until all the nodes in the tree have been placed.\n            Any empty cells should contain the empty string \"\".\n        Return the constructed matrix res.\n        Example 1:\n        Input: root = [1,2]\n        Output: \n        [[\"\",\"1\",\"\"],\n         [\"2\",\"\",\"\"]]\n        Example 2:\n        Input: root = [1,2,3,null,4]\n        Output: \n        [[\"\",\"\",\"\",\"1\",\"\",\"\",\"\"],\n         [\"\",\"2\",\"\",\"\",\"\",\"3\",\"\"],\n         [\"\",\"\",\"4\",\"\",\"\",\"\",\"\"]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":478,"row":{"number":657,"difficulty":0,"question":"class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        \"\"\"\n        There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.\n        You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up), and 'D' (down).\n        Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise.\n        Note: The way that the robot is \"facing\" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n        Example 1:\n        Input: moves = \"UD\"\n        Output: true\n        Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n        Example 2:\n        Input: moves = \"LL\"\n        Output: false\n        Explanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":479,"row":{"number":658,"difficulty":1,"question":"class Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n        \"\"\"\n        Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\n        An integer a is closer to x than an integer b if:\n            |a - x| < |b - x|, or\n            |a - x| == |b - x| and a < b\n        Example 1:\n        Input: arr = [1,2,3,4,5], k = 4, x = 3\n        Output: [1,2,3,4]\n        Example 2:\n        Input: arr = [1,2,3,4,5], k = 4, x = -1\n        Output: [1,2,3,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":480,"row":{"number":659,"difficulty":1,"question":"class Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums that is sorted in non-decreasing order.\n        Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:\n            Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\n            All subsequences have a length of 3 or more.\n        Return true if you can split nums according to the above conditions, or false otherwise.\n        A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).\n        Example 1:\n        Input: nums = [1,2,3,3,4,5]\n        Output: true\n        Explanation: nums can be split into the following subsequences:\n        [1,2,3,3,4,5] --> 1, 2, 3\n        [1,2,3,3,4,5] --> 3, 4, 5\n        Example 2:\n        Input: nums = [1,2,3,3,4,4,5,5]\n        Output: true\n        Explanation: nums can be split into the following subsequences:\n        [1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5\n        [1,2,3,3,4,4,5,5] --> 3, 4, 5\n        Example 3:\n        Input: nums = [1,2,3,4,4,5]\n        Output: false\n        Explanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":481,"row":{"number":661,"difficulty":0,"question":"class Solution:\n    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\n        Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.\n        Example 1:\n        Input: img = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[0,0,0],[0,0,0],[0,0,0]]\n        Explanation:\n        For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\n        For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\n        For the point (1,1): floor(8/9) = floor(0.88888889) = 0\n        Example 2:\n        Input: img = [[100,200,100],[200,50,200],[100,200,100]]\n        Output: [[137,141,137],[141,138,141],[137,141,137]]\n        Explanation:\n        For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\n        For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\n        For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":482,"row":{"number":662,"difficulty":1,"question":"class Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the maximum width of the given tree.\n        The maximum width of a tree is the maximum width among all levels.\n        The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.\n        It is guaranteed that the answer will in the range of a 32-bit signed integer.\n        Example 1:\n        Input: root = [1,3,2,5,3,null,9]\n        Output: 4\n        Explanation: The maximum width exists in the third level with length 4 (5,3,null,9).\n        Example 2:\n        Input: root = [1,3,2,5,null,null,9,6,null,7]\n        Output: 7\n        Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).\n        Example 3:\n        Input: root = [1,3,2,5]\n        Output: 2\n        Explanation: The maximum width exists in the second level with length 2 (3,2).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":483,"row":{"number":664,"difficulty":2,"question":"class Solution:\n    def strangePrinter(self, s: str) -> int:\n        \"\"\"\n        There is a strange printer with the following two special properties:\n            The printer can only print a sequence of the same character each time.\n            At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n        Given a string s, return the minimum number of turns the printer needed to print it.\n        Example 1:\n        Input: s = \"aaabbb\"\n        Output: 2\n        Explanation: Print \"aaa\" first and then print \"bbb\".\n        Example 2:\n        Input: s = \"aba\"\n        Output: 2\n        Explanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":484,"row":{"number":665,"difficulty":1,"question":"class Solution:\n    def checkPossibility(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.\n        We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).\n        Example 1:\n        Input: nums = [4,2,3]\n        Output: true\n        Explanation: You could modify the first 4 to 1 to get a non-decreasing array.\n        Example 2:\n        Input: nums = [4,2,1]\n        Output: false\n        Explanation: You cannot get a non-decreasing array by modifying at most one element.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":485,"row":{"number":667,"difficulty":1,"question":"class Solution:\n    def constructArray(self, n: int, k: int) -> List[int]:\n        \"\"\"\n        Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement:\n            Suppose this list is answer = [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.\n        Return the list answer. If there multiple valid answers, return any of them.\n        Example 1:\n        Input: n = 3, k = 1\n        Output: [1,2,3]\n        Explanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1\n        Example 2:\n        Input: n = 3, k = 2\n        Output: [1,3,2]\n        Explanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":486,"row":{"number":668,"difficulty":2,"question":"class Solution:\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\n        \"\"\"\n        Nearly everyone has used the Multiplication Table. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed).\n        Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table.\n        Example 1:\n        Input: m = 3, n = 3, k = 5\n        Output: 3\n        Explanation: The 5th smallest number is 3.\n        Example 2:\n        Input: m = 2, n = 3, k = 6\n        Output: 6\n        Explanation: The 6th smallest number is 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":487,"row":{"number":669,"difficulty":1,"question":"class Solution:\n    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:\n        \"\"\"\n        Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer.\n        Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.\n        Example 1:\n        Input: root = [1,0,2], low = 1, high = 2\n        Output: [1,null,2]\n        Example 2:\n        Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n        Output: [3,2,null,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":488,"row":{"number":670,"difficulty":1,"question":"class Solution:\n    def maximumSwap(self, num: int) -> int:\n        \"\"\"\n        You are given an integer num. You can swap two digits at most once to get the maximum valued number.\n        Return the maximum valued number you can get.\n        Example 1:\n        Input: num = 2736\n        Output: 7236\n        Explanation: Swap the number 2 and the number 7.\n        Example 2:\n        Input: num = 9973\n        Output: 9973\n        Explanation: No swap.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":489,"row":{"number":671,"difficulty":0,"question":"class Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.\n        Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.\n        If no such second minimum value exists, output -1 instead.\n        Example 1:\n        Input: root = [2,2,5,null,null,5,7]\n        Output: 5\n        Explanation: The smallest value is 2, the second smallest value is 5.\n        Example 2:\n        Input: root = [2,2,2]\n        Output: -1\n        Explanation: The smallest value is 2, but there isn't any second smallest value.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":490,"row":{"number":672,"difficulty":1,"question":"class Solution:\n    def flipLights(self, n: int, presses: int) -> int:\n        \"\"\"\n        There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons on the wall. Each of the four buttons has a different functionality where:\n            Button 1: Flips the status of all the bulbs.\n            Button 2: Flips the status of all the bulbs with even labels (i.e., 2, 4, ...).\n            Button 3: Flips the status of all the bulbs with odd labels (i.e., 1, 3, ...).\n            Button 4: Flips the status of all the bulbs with a label j = 3k + 1 where k = 0, 1, 2, ... (i.e., 1, 4, 7, 10, ...).\n        You must make exactly presses button presses in total. For each press, you may pick any of the four buttons to press.\n        Given the two integers n and presses, return the number of different possible statuses after performing all presses button presses.\n        Example 1:\n        Input: n = 1, presses = 1\n        Output: 2\n        Explanation: Status can be:\n        - [off] by pressing button 1\n        - [on] by pressing button 2\n        Example 2:\n        Input: n = 2, presses = 1\n        Output: 3\n        Explanation: Status can be:\n        - [off, off] by pressing button 1\n        - [on, off] by pressing button 2\n        - [off, on] by pressing button 3\n        Example 3:\n        Input: n = 3, presses = 1\n        Output: 4\n        Explanation: Status can be:\n        - [off, off, off] by pressing button 1\n        - [off, on, off] by pressing button 2\n        - [on, off, on] by pressing button 3\n        - [off, on, on] by pressing button 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":491,"row":{"number":673,"difficulty":1,"question":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the number of longest increasing subsequences.\n        Notice that the sequence has to be strictly increasing.\n        Example 1:\n        Input: nums = [1,3,5,4,7]\n        Output: 2\n        Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\n        Example 2:\n        Input: nums = [2,2,2,2,2]\n        Output: 5\n        Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":492,"row":{"number":674,"difficulty":0,"question":"class Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.\n        A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].\n        Example 1:\n        Input: nums = [1,3,5,4,7]\n        Output: 3\n        Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.\n        Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n        4.\n        Example 2:\n        Input: nums = [2,2,2,2,2]\n        Output: 1\n        Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly\n        increasing.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":493,"row":{"number":675,"difficulty":2,"question":"class Solution:\n    def cutOffTree(self, forest: List[List[int]]) -> int:\n        \"\"\"\n        You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an m x n matrix. In this matrix:\n            0 means the cell cannot be walked through.\n            1 represents an empty cell that can be walked through.\n            A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree's height.\n        In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n        You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes 1 (an empty cell).\n        Starting from the point (0, 0), return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return -1.\n        Note: The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n        Example 1:\n        Input: forest = [[1,2,3],[0,0,4],[7,6,5]]\n        Output: 6\n        Explanation: Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n        Example 2:\n        Input: forest = [[1,2,3],[0,0,0],[7,6,5]]\n        Output: -1\n        Explanation: The trees in the bottom row cannot be accessed as the middle row is blocked.\n        Example 3:\n        Input: forest = [[2,3,4],[0,0,5],[8,7,6]]\n        Output: 6\n        Explanation: You can follow the same path as Example 1 to cut off all the trees.\n        Note that you can cut off the first tree at (0, 0) before making any steps.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":494,"row":{"number":676,"difficulty":1,"question":"class MagicDictionary:\n    def __init__(self):\n    def buildDict(self, dictionary: List[str]) -> None:\n    def search(self, searchWord: str) -> bool:\n        \"\"\"\n        Design a data structure that is initialized with a list of different words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure.\n        Implement the MagicDictionary class:\n            MagicDictionary() Initializes the object.\n            void buildDict(String[] dictionary) Sets the data structure with an array of distinct strings dictionary.\n            bool search(String searchWord) Returns true if you can change exactly one character in searchWord to match any string in the data structure, otherwise returns false.\n        Example 1:\n        Input\n        [\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\n        [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\n        Output\n        [null, null, false, true, false, false]\n        Explanation\n        MagicDictionary magicDictionary = new MagicDictionary();\n        magicDictionary.buildDict([\"hello\", \"leetcode\"]);\n        magicDictionary.search(\"hello\"); // return False\n        magicDictionary.search(\"hhllo\"); // We can change the second 'h' to 'e' to match \"hello\" so we return True\n        magicDictionary.search(\"hell\"); // return False\n        magicDictionary.search(\"leetcoded\"); // return False\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":495,"row":{"number":677,"difficulty":1,"question":"class MapSum:\n    def __init__(self):\n    def insert(self, key: str, val: int) -> None:\n    def sum(self, prefix: str) -> int:\n        \"\"\"\n        Design a map that allows you to do the following:\n            Maps a string key to a given value.\n            Returns the sum of the values that have a key with a prefix equal to a given string.\n        Implement the MapSum class:\n            MapSum() Initializes the MapSum object.\n            void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one.\n            int sum(string prefix) Returns the sum of all the pairs' value whose key starts with the prefix.\n        Example 1:\n        Input\n        [\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"]\n        [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]\n        Output\n        [null, null, 3, null, 5]\n        Explanation\n        MapSum mapSum = new MapSum();\n        mapSum.insert(\"apple\", 3);  \n        mapSum.sum(\"ap\");           // return 3 (apple = 3)\n        mapSum.insert(\"app\", 2);    \n        mapSum.sum(\"ap\");           // return 5 (apple + app = 3 + 2 = 5)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":496,"row":{"number":678,"difficulty":1,"question":"class Solution:\n    def checkValidString(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\n        The following rules define a valid string:\n            Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n            Any right parenthesis ')' must have a corresponding left parenthesis '('.\n            Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n            '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"(*)\"\n        Output: true\n        Example 3:\n        Input: s = \"(*))\"\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":497,"row":{"number":679,"difficulty":2,"question":"class Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.\n        You are restricted with the following rules:\n            The division operator '/' represents real division, not integer division.\n                For example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.\n            Every operation done is between two numbers. In particular, we cannot use '-' as a unary operator.\n                For example, if cards = [1, 1, 1, 1], the expression \"-1 - 1 - 1 - 1\" is not allowed.\n            You cannot concatenate numbers together\n                For example, if cards = [1, 2, 1, 2], the expression \"12 + 12\" is not valid.\n        Return true if you can get such expression that evaluates to 24, and false otherwise.\n        Example 1:\n        Input: cards = [4,1,8,7]\n        Output: true\n        Explanation: (8-4) * (7-1) = 24\n        Example 2:\n        Input: cards = [1,2,1,2]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":498,"row":{"number":680,"difficulty":0,"question":"class Solution:\n    def validPalindrome(self, s: str) -> bool:\n        \"\"\"\n        Given a string s, return true if the s can be palindrome after deleting at most one character from it.\n        Example 1:\n        Input: s = \"aba\"\n        Output: true\n        Example 2:\n        Input: s = \"abca\"\n        Output: true\n        Explanation: You could delete the character 'c'.\n        Example 3:\n        Input: s = \"abc\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":499,"row":{"number":682,"difficulty":0,"question":"class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        \"\"\"\n        You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n        You are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n            An integer x.\n                Record a new score of x.\n            '+'.\n                Record a new score that is the sum of the previous two scores.\n            'D'.\n                Record a new score that is the double of the previous score.\n            'C'.\n                Invalidate the previous score, removing it from the record.\n        Return the sum of all the scores on the record after applying all the operations.\n        The test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.\n        Example 1:\n        Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\n        Output: 30\n        Explanation:\n        \"5\" - Add 5 to the record, record is now [5].\n        \"2\" - Add 2 to the record, record is now [5, 2].\n        \"C\" - Invalidate and remove the previous score, record is now [5].\n        \"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n        \"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\n        The total sum is 5 + 10 + 15 = 30.\n        Example 2:\n        Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\n        Output: 27\n        Explanation:\n        \"5\" - Add 5 to the record, record is now [5].\n        \"-2\" - Add -2 to the record, record is now [5, -2].\n        \"4\" - Add 4 to the record, record is now [5, -2, 4].\n        \"C\" - Invalidate and remove the previous score, record is now [5, -2].\n        \"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n        \"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n        \"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n        \"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\n        The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n        Example 3:\n        Input: ops = [\"1\",\"C\"]\n        Output: 0\n        Explanation:\n        \"1\" - Add 1 to the record, record is now [1].\n        \"C\" - Invalidate and remove the previous score, record is now [].\n        Since the record is empty, the total sum is 0.\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}