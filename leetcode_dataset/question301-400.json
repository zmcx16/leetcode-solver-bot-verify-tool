{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":300,"row":{"number":388,"difficulty":1,"question":"class Solution:\n    def lengthLongestPath(self, input: str) -> int:\n        \"\"\"\n        Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:\n        Here, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext.\n        In text form, it looks like this (with ⟶ representing the tab character):\n        dir\n        ⟶ subdir1\n        ⟶ ⟶ file1.ext\n        ⟶ ⟶ subsubdir1\n        ⟶ subdir2\n        ⟶ ⟶ subsubdir2\n        ⟶ ⟶ ⟶ file2.ext\n        If we were to write this representation in code, it will look like this: \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\". Note that the '\\n' and '\\t' are the new-line and tab characters.\n        Every file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is \"dir/subdir2/subsubdir2/file2.ext\". Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces.\n        Given a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.\n        Note that the testcases are generated such that the file system is valid and no file or directory name has length 0.\n        Example 1:\n        Input: input = \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"\n        Output: 20\n        Explanation: We have only one file, and the absolute path is \"dir/subdir2/file.ext\" of length 20.\n        Example 2:\n        Input: input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\n        Output: 32\n        Explanation: We have two files:\n        \"dir/subdir1/file1.ext\" of length 21\n        \"dir/subdir2/subsubdir2/file2.ext\" of length 32.\n        We return 32 since it is the longest absolute path to a file.\n        Example 3:\n        Input: input = \"a\"\n        Output: 0\n        Explanation: We do not have any files, just a single directory named \"a\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":301,"row":{"number":389,"difficulty":0,"question":"class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        \"\"\"\n        You are given two strings s and t.\n        String t is generated by random shuffling string s and then add one more letter at a random position.\n        Return the letter that was added to t.\n        Example 1:\n        Input: s = \"abcd\", t = \"abcde\"\n        Output: \"e\"\n        Explanation: 'e' is the letter that was added.\n        Example 2:\n        Input: s = \"\", t = \"y\"\n        Output: \"y\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":302,"row":{"number":390,"difficulty":1,"question":"class Solution:\n    def lastRemaining(self, n: int) -> int:\n        \"\"\"\n        You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:\n            Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n            Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.\n            Keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n        Given the integer n, return the last number that remains in arr.\n        Example 1:\n        Input: n = 9\n        Output: 6\n        Explanation:\n        arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        arr = [2, 4, 6, 8]\n        arr = [2, 6]\n        arr = [6]\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":303,"row":{"number":391,"difficulty":2,"question":"class Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        \"\"\"\n        Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).\n        Return true if all the rectangles together form an exact cover of a rectangular region.\n        Example 1:\n        Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n        Output: true\n        Explanation: All 5 rectangles together form an exact cover of a rectangular region.\n        Example 2:\n        Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n        Output: false\n        Explanation: Because there is a gap between the two rectangular regions.\n        Example 3:\n        Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n        Output: false\n        Explanation: Because two of the rectangles overlap with each other.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":304,"row":{"number":392,"difficulty":0,"question":"class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        \"\"\"\n        Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n        A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n        Example 1:\n        Input: s = \"abc\", t = \"ahbgdc\"\n        Output: true\n        Example 2:\n        Input: s = \"axc\", t = \"ahbgdc\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":305,"row":{"number":393,"difficulty":1,"question":"class Solution:\n    def validUtf8(self, data: List[int]) -> bool:\n        \"\"\"\n        Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n        A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n            For a 1-byte character, the first bit is a 0, followed by its Unicode code.\n            For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.\n        This is how the UTF-8 encoding would work:\n             Number of Bytes   |        UTF-8 Octet Sequence\n                               |              (binary)\n           --------------------+-----------------------------------------\n                    1          |   0xxxxxxx\n                    2          |   110xxxxx 10xxxxxx\n                    3          |   1110xxxx 10xxxxxx 10xxxxxx\n                    4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n        x denotes a bit in the binary form of a byte that may be either 0 or 1.\n        Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n        Example 1:\n        Input: data = [197,130,1]\n        Output: true\n        Explanation: data represents the octet sequence: 11000101 10000010 00000001.\n        It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n        Example 2:\n        Input: data = [235,140,4]\n        Output: false\n        Explanation: data represented the octet sequence: 11101011 10001100 00000100.\n        The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\n        The next byte is a continuation byte which starts with 10 and that's correct.\n        But the second continuation byte does not start with 10, so it is invalid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":306,"row":{"number":394,"difficulty":1,"question":"class Solution:\n    def decodeString(self, s: str) -> str:\n        \"\"\"\n        Given an encoded string, return its decoded string.\n        The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n        You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].\n        The test cases are generated so that the length of the output will never exceed 105.\n        Example 1:\n        Input: s = \"3[a]2[bc]\"\n        Output: \"aaabcbc\"\n        Example 2:\n        Input: s = \"3[a2[c]]\"\n        Output: \"accaccacc\"\n        Example 3:\n        Input: s = \"2[abc]3[cd]ef\"\n        Output: \"abcabccdcdcdef\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":307,"row":{"number":395,"difficulty":1,"question":"class Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        \"\"\"\n        Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.\n        Example 1:\n        Input: s = \"aaabb\", k = 3\n        Output: 3\n        Explanation: The longest substring is \"aaa\", as 'a' is repeated 3 times.\n        Example 2:\n        Input: s = \"ababbc\", k = 2\n        Output: 5\n        Explanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":308,"row":{"number":396,"difficulty":1,"question":"class Solution:\n    def maxRotateFunction(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums of length n.\n        Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n            F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n        Return the maximum value of F(0), F(1), ..., F(n-1).\n        The test cases are generated so that the answer fits in a 32-bit integer.\n        Example 1:\n        Input: nums = [4,3,2,6]\n        Output: 26\n        Explanation:\n        F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\n        F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\n        F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\n        F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n        So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n        Example 2:\n        Input: nums = [100]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":309,"row":{"number":397,"difficulty":1,"question":"class Solution:\n    def integerReplacement(self, n: int) -> int:\n        \"\"\"\n        Given a positive integer n, you can apply one of the following operations:\n            If n is even, replace n with n / 2.\n            If n is odd, replace n with either n + 1 or n - 1.\n        Return the minimum number of operations needed for n to become 1.\n        Example 1:\n        Input: n = 8\n        Output: 3\n        Explanation: 8 -> 4 -> 2 -> 1\n        Example 2:\n        Input: n = 7\n        Output: 4\n        Explanation: 7 -> 8 -> 4 -> 2 -> 1\n        or 7 -> 6 -> 3 -> 2 -> 1\n        Example 3:\n        Input: n = 4\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":310,"row":{"number":398,"difficulty":1,"question":"class Solution:\n    def __init__(self, nums: List[int]):\n    def pick(self, target: int) -> int:\n        \"\"\"\n        Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\n        Implement the Solution class:\n            Solution(int[] nums) Initializes the object with the array nums.\n            int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning.\n        Example 1:\n        Input\n        [\"Solution\", \"pick\", \"pick\", \"pick\"]\n        [[[1, 2, 3, 3, 3]], [3], [1], [3]]\n        Output\n        [null, 4, 0, 2]\n        Explanation\n        Solution solution = new Solution([1, 2, 3, 3, 3]);\n        solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\n        solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.\n        solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":311,"row":{"number":399,"difficulty":1,"question":"class Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        \"\"\"\n        You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\n        You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\n        Return the answers to all queries. If a single answer cannot be determined, return -1.0.\n        Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n        Example 1:\n        Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n        Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n        Explanation: \n        Given: a / b = 2.0, b / c = 3.0\n        queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\n        return: [6.0, 0.5, -1.0, 1.0, -1.0 ]\n        Example 2:\n        Input: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n        Output: [3.75000,0.40000,5.00000,0.20000]\n        Example 3:\n        Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n        Output: [0.50000,2.00000,-1.00000,-1.00000]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":312,"row":{"number":400,"difficulty":1,"question":"class Solution:\n    def findNthDigit(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].\n        Example 1:\n        Input: n = 3\n        Output: 3\n        Example 2:\n        Input: n = 11\n        Output: 0\n        Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":313,"row":{"number":401,"difficulty":0,"question":"class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        \"\"\"\n        A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n            For example, the below binary watch reads \"4:51\".\n        Given an integer turnedOn which represents the number of LEDs that are currently on (ignoring the PM), return all possible times the watch could represent. You may return the answer in any order.\n        The hour must not contain a leading zero.\n            For example, \"01:00\" is not valid. It should be \"1:00\".\n        The minute must be consist of two digits and may contain a leading zero.\n            For example, \"10:2\" is not valid. It should be \"10:02\".\n        Example 1:\n        Input: turnedOn = 1\n        Output: [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n        Example 2:\n        Input: turnedOn = 9\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":314,"row":{"number":402,"difficulty":1,"question":"class Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        \"\"\"\n        Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\n        Example 1:\n        Input: num = \"1432219\", k = 3\n        Output: \"1219\"\n        Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n        Example 2:\n        Input: num = \"10200\", k = 1\n        Output: \"200\"\n        Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n        Example 3:\n        Input: num = \"10\", k = 2\n        Output: \"0\"\n        Explanation: Remove all the digits from the number and it is left with nothing which is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":315,"row":{"number":403,"difficulty":2,"question":"class Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        \"\"\"\n        A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n        Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n        If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n        Example 1:\n        Input: stones = [0,1,3,5,6,8,12,17]\n        Output: true\n        Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n        Example 2:\n        Input: stones = [0,1,2,3,4,8,9,11]\n        Output: false\n        Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":316,"row":{"number":404,"difficulty":0,"question":"class Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the sum of all left leaves.\n        A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: 24\n        Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.\n        Example 2:\n        Input: root = [1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":317,"row":{"number":405,"difficulty":0,"question":"class Solution:\n    def toHex(self, num: int) -> str:\n        \"\"\"\n        Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.\n        All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\n        Note: You are not allowed to use any built-in library method to directly solve this problem.\n        Example 1:\n        Input: num = 26\n        Output: \"1a\"\n        Example 2:\n        Input: num = -1\n        Output: \"ffffffff\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":318,"row":{"number":406,"difficulty":1,"question":"class Solution:\n    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n        Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n        Example 1:\n        Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n        Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n        Explanation:\n        Person 0 has height 5 with no other people taller or the same height in front.\n        Person 1 has height 7 with no other people taller or the same height in front.\n        Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.\n        Person 3 has height 6 with one person taller or the same height in front, which is person 1.\n        Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.\n        Person 5 has height 7 with one person taller or the same height in front, which is person 1.\n        Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.\n        Example 2:\n        Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n        Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":319,"row":{"number":407,"difficulty":2,"question":"class Solution:\n    def trapRainWater(self, heightMap: List[List[int]]) -> int:\n        \"\"\"\n        Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.\n        Example 1:\n        Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n        Output: 4\n        Explanation: After the rain, water is trapped between the blocks.\n        We have two small ponds 1 and 3 units trapped.\n        The total volume of water trapped is 4.\n        Example 2:\n        Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n        Output: 10\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":320,"row":{"number":409,"difficulty":0,"question":"class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        \"\"\"\n        Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\n        Letters are case sensitive, for example, \"Aa\" is not considered a palindrome here.\n        Example 1:\n        Input: s = \"abccccdd\"\n        Output: 7\n        Explanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7.\n        Example 2:\n        Input: s = \"a\"\n        Output: 1\n        Explanation: The longest palindrome that can be built is \"a\", whose length is 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":321,"row":{"number":410,"difficulty":2,"question":"class Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\n        Return the minimized largest sum of the split.\n        A subarray is a contiguous part of the array.\n        Example 1:\n        Input: nums = [7,2,5,10,8], k = 2\n        Output: 18\n        Explanation: There are four ways to split nums into two subarrays.\n        The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\n        Example 2:\n        Input: nums = [1,2,3,4,5], k = 2\n        Output: 9\n        Explanation: There are four ways to split nums into two subarrays.\n        The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":322,"row":{"number":412,"difficulty":0,"question":"class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        \"\"\"\n        Given an integer n, return a string array answer (1-indexed) where:\n            answer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\n            answer[i] == \"Fizz\" if i is divisible by 3.\n            answer[i] == \"Buzz\" if i is divisible by 5.\n            answer[i] == i (as a string) if none of the above conditions are true.\n        Example 1:\n        Input: n = 3\n        Output: [\"1\",\"2\",\"Fizz\"]\n        Example 2:\n        Input: n = 5\n        Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n        Example 3:\n        Input: n = 15\n        Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":323,"row":{"number":413,"difficulty":1,"question":"class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        \"\"\"\n        An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n            For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.\n        Given an integer array nums, return the number of arithmetic subarrays of nums.\n        A subarray is a contiguous subsequence of the array.\n        Example 1:\n        Input: nums = [1,2,3,4]\n        Output: 3\n        Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\n        Example 2:\n        Input: nums = [1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":324,"row":{"number":414,"difficulty":0,"question":"class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.\n        Example 1:\n        Input: nums = [3,2,1]\n        Output: 1\n        Explanation:\n        The first distinct maximum is 3.\n        The second distinct maximum is 2.\n        The third distinct maximum is 1.\n        Example 2:\n        Input: nums = [1,2]\n        Output: 2\n        Explanation:\n        The first distinct maximum is 2.\n        The second distinct maximum is 1.\n        The third distinct maximum does not exist, so the maximum (2) is returned instead.\n        Example 3:\n        Input: nums = [2,2,3,1]\n        Output: 1\n        Explanation:\n        The first distinct maximum is 3.\n        The second distinct maximum is 2 (both 2's are counted together since they have the same value).\n        The third distinct maximum is 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":325,"row":{"number":415,"difficulty":0,"question":"class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\n        You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.\n        Example 1:\n        Input: num1 = \"11\", num2 = \"123\"\n        Output: \"134\"\n        Example 2:\n        Input: num1 = \"456\", num2 = \"77\"\n        Output: \"533\"\n        Example 3:\n        Input: num1 = \"0\", num2 = \"0\"\n        Output: \"0\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":326,"row":{"number":416,"difficulty":1,"question":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\n        Example 1:\n        Input: nums = [1,5,11,5]\n        Output: true\n        Explanation: The array can be partitioned as [1, 5, 5] and [11].\n        Example 2:\n        Input: nums = [1,2,3,5]\n        Output: false\n        Explanation: The array cannot be partitioned into equal sum subsets.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":327,"row":{"number":417,"difficulty":1,"question":"class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\n        The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\n        The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n        Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.\n        Example 1:\n        Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n        Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n        Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n        [0,4]: [0,4] -> Pacific Ocean \n               [0,4] -> Atlantic Ocean\n        [1,3]: [1,3] -> [0,3] -> Pacific Ocean \n               [1,3] -> [1,4] -> Atlantic Ocean\n        [1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n               [1,4] -> Atlantic Ocean\n        [2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n               [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n        [3,0]: [3,0] -> Pacific Ocean \n               [3,0] -> [4,0] -> Atlantic Ocean\n        [3,1]: [3,1] -> [3,0] -> Pacific Ocean \n               [3,1] -> [4,1] -> Atlantic Ocean\n        [4,0]: [4,0] -> Pacific Ocean \n               [4,0] -> Atlantic Ocean\n        Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n        Example 2:\n        Input: heights = [[1]]\n        Output: [[0,0]]\n        Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":328,"row":{"number":419,"difficulty":1,"question":"class Solution:\n    def countBattleships(self, board: List[List[str]]) -> int:\n        \"\"\"\n        Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.\n        Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).\n        Example 1:\n        Input: board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n        Output: 2\n        Example 2:\n        Input: board = [[\".\"]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":329,"row":{"number":420,"difficulty":2,"question":"class Solution:\n    def strongPasswordChecker(self, password: str) -> int:\n        \"\"\"\n        A password is considered strong if the below conditions are all met:\n            It has at least 6 characters and at most 20 characters.\n            It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\n            It does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\n        Given a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.\n        In one step, you can:\n            Insert one character to password,\n            Delete one character from password, or\n            Replace one character of password with another character.\n        Example 1:\n        Input: password = \"a\"\n        Output: 5\n        Example 2:\n        Input: password = \"aA1\"\n        Output: 3\n        Example 3:\n        Input: password = \"1337C0d3\"\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":330,"row":{"number":421,"difficulty":1,"question":"class Solution:\n    def findMaximumXOR(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.\n        Example 1:\n        Input: nums = [3,10,5,25,2,8]\n        Output: 28\n        Explanation: The maximum result is 5 XOR 25 = 28.\n        Example 2:\n        Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n        Output: 127\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":331,"row":{"number":423,"difficulty":1,"question":"class Solution:\n    def originalDigits(self, s: str) -> str:\n        \"\"\"\n        Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\n        Example 1:\n        Input: s = \"owoztneoer\"\n        Output: \"012\"\n        Example 2:\n        Input: s = \"fviefuro\"\n        Output: \"45\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":332,"row":{"number":424,"difficulty":1,"question":"class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        \"\"\"\n        You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\n        Return the length of the longest substring containing the same letter you can get after performing the above operations.\n        Example 1:\n        Input: s = \"ABAB\", k = 2\n        Output: 4\n        Explanation: Replace the two 'A's with two 'B's or vice versa.\n        Example 2:\n        Input: s = \"AABABBA\", k = 1\n        Output: 4\n        Explanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\n        The substring \"BBBB\" has the longest repeating letters, which is 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":333,"row":{"number":432,"difficulty":2,"question":"class AllOne:\n    def __init__(self):\n    def inc(self, key: str) -> None:\n    def dec(self, key: str) -> None:\n    def getMaxKey(self) -> str:\n    def getMinKey(self) -> str:\n        \"\"\"\n        Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.\n        Implement the AllOne class:\n            AllOne() Initializes the object of the data structure.\n            inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.\n            dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.\n            getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string \"\".\n            getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string \"\".\n        Note that each function must run in O(1) average time complexity.\n        Example 1:\n        Input\n        [\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n        [[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]\n        Output\n        [null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]\n        Explanation\n        AllOne allOne = new AllOne();\n        allOne.inc(\"hello\");\n        allOne.inc(\"hello\");\n        allOne.getMaxKey(); // return \"hello\"\n        allOne.getMinKey(); // return \"hello\"\n        allOne.inc(\"leet\");\n        allOne.getMaxKey(); // return \"hello\"\n        allOne.getMinKey(); // return \"leet\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":334,"row":{"number":433,"difficulty":1,"question":"class Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        \"\"\"\n        A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\n        Suppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n            For example, \"AACCGGTT\" --> \"AACCGGTA\" is one mutation.\n        There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\n        Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\n        Note that the starting point is assumed to be valid, so it might not be included in the bank.\n        Example 1:\n        Input: startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n        Output: 1\n        Example 2:\n        Input: startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":335,"row":{"number":434,"difficulty":0,"question":"class Solution:\n    def countSegments(self, s: str) -> int:\n        \"\"\"\n        Given a string s, return the number of segments in the string.\n        A segment is defined to be a contiguous sequence of non-space characters.\n        Example 1:\n        Input: s = \"Hello, my name is John\"\n        Output: 5\n        Explanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\n        Example 2:\n        Input: s = \"Hello\"\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":336,"row":{"number":435,"difficulty":1,"question":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        \"\"\"\n        Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n        Example 1:\n        Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\n        Output: 1\n        Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n        Example 2:\n        Input: intervals = [[1,2],[1,2],[1,2]]\n        Output: 2\n        Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n        Example 3:\n        Input: intervals = [[1,2],[2,3]]\n        Output: 0\n        Explanation: You don't need to remove any of the intervals since they're already non-overlapping.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":337,"row":{"number":436,"difficulty":1,"question":"class Solution:\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n        The right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j.\n        Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.\n        Example 1:\n        Input: intervals = [[1,2]]\n        Output: [-1]\n        Explanation: There is only one interval in the collection, so it outputs -1.\n        Example 2:\n        Input: intervals = [[3,4],[2,3],[1,2]]\n        Output: [-1,0,1]\n        Explanation: There is no right interval for [3,4].\n        The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.\n        The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.\n        Example 3:\n        Input: intervals = [[1,4],[2,3],[3,4]]\n        Output: [-1,2,-1]\n        Explanation: There is no right interval for [1,4] and [3,4].\n        The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":338,"row":{"number":437,"difficulty":1,"question":"class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        \"\"\"\n        Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\n        The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n        Example 1:\n        Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n        Output: 3\n        Explanation: The paths that sum to 8 are shown.\n        Example 2:\n        Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":339,"row":{"number":438,"difficulty":1,"question":"class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        \"\"\"\n        Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: s = \"cbaebabacd\", p = \"abc\"\n        Output: [0,6]\n        Explanation:\n        The substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\n        The substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\n        Example 2:\n        Input: s = \"abab\", p = \"ab\"\n        Output: [0,1,2]\n        Explanation:\n        The substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\n        The substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\n        The substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":340,"row":{"number":440,"difficulty":2,"question":"class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \"\"\"\n        Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].\n        Example 1:\n        Input: n = 13, k = 2\n        Output: 10\n        Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":341,"row":{"number":441,"difficulty":0,"question":"class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        \"\"\"\n        You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n        Given the integer n, return the number of complete rows of the staircase you will build.\n        Example 1:\n        Input: n = 5\n        Output: 2\n        Explanation: Because the 3rd row is incomplete, we return 2.\n        Example 2:\n        Input: n = 8\n        Output: 3\n        Explanation: Because the 4th row is incomplete, we return 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":342,"row":{"number":442,"difficulty":1,"question":"class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.\n        You must write an algorithm that runs in O(n) time and uses only constant extra space.\n        Example 1:\n        Input: nums = [4,3,2,7,8,2,3,1]\n        Output: [2,3]\n        Example 2:\n        Input: nums = [1,1,2]\n        Output: [1]\n        Example 3:\n        Input: nums = [1]\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":343,"row":{"number":443,"difficulty":1,"question":"class Solution:\n    def compress(self, chars: List[str]) -> int:\n        \"\"\"\n        Given an array of characters chars, compress it using the following algorithm:\n        Begin with an empty string s. For each group of consecutive repeating characters in chars:\n            If the group's length is 1, append the character to s.\n            Otherwise, append the character followed by the group's length.\n        The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\n        After you are done modifying the input array, return the new length of the array.\n        You must write an algorithm that uses only constant extra space.\n        Example 1:\n        Input: chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n        Output: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n        Explanation: The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\n        Example 2:\n        Input: chars = [\"a\"]\n        Output: Return 1, and the first character of the input array should be: [\"a\"]\n        Explanation: The only group is \"a\", which remains uncompressed since it's a single character.\n        Example 3:\n        Input: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n        Output: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\n        Explanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":344,"row":{"number":445,"difficulty":1,"question":"class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [7,2,4,3], l2 = [5,6,4]\n        Output: [7,8,0,7]\n        Example 2:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [8,0,7]\n        Example 3:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":345,"row":{"number":446,"difficulty":2,"question":"class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n        A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n            For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\n            For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n        A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n            For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n        The test cases are generated so that the answer fits in 32-bit integer.\n        Example 1:\n        Input: nums = [2,4,6,8,10]\n        Output: 7\n        Explanation: All arithmetic subsequence slices are:\n        [2,4,6]\n        [4,6,8]\n        [6,8,10]\n        [2,4,6,8]\n        [4,6,8,10]\n        [2,4,6,8,10]\n        [2,6,10]\n        Example 2:\n        Input: nums = [7,7,7,7,7]\n        Output: 16\n        Explanation: Any subsequence of this array is arithmetic.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":346,"row":{"number":447,"difficulty":1,"question":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        \"\"\"\n        You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).\n        Return the number of boomerangs.\n        Example 1:\n        Input: points = [[0,0],[1,0],[2,0]]\n        Output: 2\n        Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].\n        Example 2:\n        Input: points = [[1,1],[2,2],[3,3]]\n        Output: 2\n        Example 3:\n        Input: points = [[1,1]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":347,"row":{"number":448,"difficulty":0,"question":"class Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\n        Example 1:\n        Input: nums = [4,3,2,7,8,2,3,1]\n        Output: [5,6]\n        Example 2:\n        Input: nums = [1,1]\n        Output: [2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":348,"row":{"number":449,"difficulty":1,"question":"class Codec:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        \"\"\"Encodes a tree to a single string.\n        Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n        Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.\n        The encoded string should be as compact as possible.\n        Example 1:\n        Input: root = [2,1,3]\n        Output: [2,1,3]\n        Example 2:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":349,"row":{"number":450,"difficulty":1,"question":"class Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        \"\"\"\n        Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n        Basically, the deletion can be divided into two stages:\n            Search for a node to remove.\n            If the node is found, delete the node.\n        Example 1:\n        Input: root = [5,3,6,2,4,null,7], key = 3\n        Output: [5,4,6,2,null,null,7]\n        Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.\n        One valid answer is [5,4,6,2,null,null,7], shown in the above BST.\n        Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.\n        Example 2:\n        Input: root = [5,3,6,2,4,null,7], key = 0\n        Output: [5,3,6,2,4,null,7]\n        Explanation: The tree does not contain a node with value = 0.\n        Example 3:\n        Input: root = [], key = 0\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":350,"row":{"number":451,"difficulty":1,"question":"class Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\n        Return the sorted string. If there are multiple answers, return any of them.\n        Example 1:\n        Input: s = \"tree\"\n        Output: \"eert\"\n        Explanation: 'e' appears twice while 'r' and 't' both appear once.\n        So 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\n        Example 2:\n        Input: s = \"cccaaa\"\n        Output: \"aaaccc\"\n        Explanation: Both 'c' and 'a' appear three times, so both \"cccaaa\" and \"aaaccc\" are valid answers.\n        Note that \"cacaca\" is incorrect, as the same characters must be together.\n        Example 3:\n        Input: s = \"Aabb\"\n        Output: \"bbAa\"\n        Explanation: \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\n        Note that 'A' and 'a' are treated as two different characters.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":351,"row":{"number":452,"difficulty":1,"question":"class Solution:\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\n        \"\"\"\n        There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\n        Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n        Given the array points, return the minimum number of arrows that must be shot to burst all balloons.\n        Example 1:\n        Input: points = [[10,16],[2,8],[1,6],[7,12]]\n        Output: 2\n        Explanation: The balloons can be burst by 2 arrows:\n        - Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n        - Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\n        Example 2:\n        Input: points = [[1,2],[3,4],[5,6],[7,8]]\n        Output: 4\n        Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.\n        Example 3:\n        Input: points = [[1,2],[2,3],[3,4],[4,5]]\n        Output: 2\n        Explanation: The balloons can be burst by 2 arrows:\n        - Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n        - Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":352,"row":{"number":453,"difficulty":1,"question":"class Solution:\n    def minMoves(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\n        In one move, you can increment n - 1 elements of the array by 1.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: 3\n        Explanation: Only three moves are needed (remember each move increments two elements):\n        [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\n        Example 2:\n        Input: nums = [1,1,1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":353,"row":{"number":454,"difficulty":1,"question":"class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        \"\"\"\n        Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n            0 <= i, j, k, l < n\n            nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\n        Example 1:\n        Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n        Output: 2\n        Explanation:\n        The two tuples are:\n        1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n        2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n        Example 2:\n        Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":354,"row":{"number":455,"difficulty":0,"question":"class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        \"\"\"\n        Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n        Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n        Example 1:\n        Input: g = [1,2,3], s = [1,1]\n        Output: 1\n        Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \n        And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\n        You need to output 1.\n        Example 2:\n        Input: g = [1,2], s = [1,2,3]\n        Output: 2\n        Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \n        You have 3 cookies and their sizes are big enough to gratify all of the children, \n        You need to output 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":355,"row":{"number":456,"difficulty":1,"question":"class Solution:\n    def find132pattern(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].\n        Return true if there is a 132 pattern in nums, otherwise, return false.\n        Example 1:\n        Input: nums = [1,2,3,4]\n        Output: false\n        Explanation: There is no 132 pattern in the sequence.\n        Example 2:\n        Input: nums = [3,1,4,2]\n        Output: true\n        Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n        Example 3:\n        Input: nums = [-1,3,2,0]\n        Output: true\n        Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":356,"row":{"number":457,"difficulty":1,"question":"class Solution:\n    def circularArrayLoop(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:\n            If nums[i] is positive, move nums[i] steps forward, and\n            If nums[i] is negative, move nums[i] steps backward.\n        Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.\n        A cycle in the array consists of a sequence of indices seq of length k where:\n            Following the movement rules above results in the repeating index sequence seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...\n            Every nums[seq[j]] is either all positive or all negative.\n            k > 1\n        Return true if there is a cycle in nums, or false otherwise.\n        Example 1:\n        Input: nums = [2,-1,1,2,2]\n        Output: true\n        Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\n        We can see the cycle 0 --> 2 --> 3 --> 0 --> ..., and all of its nodes are white (jumping in the same direction).\n        Example 2:\n        Input: nums = [-1,-2,-3,-4,-5,6]\n        Output: false\n        Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\n        The only cycle is of size 1, so we return false.\n        Example 3:\n        Input: nums = [1,-1,5,1,4]\n        Output: true\n        Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\n        We can see the cycle 0 --> 1 --> 0 --> ..., and while it is of size > 1, it has a node jumping forward and a node jumping backward, so it is not a cycle.\n        We can see the cycle 3 --> 4 --> 3 --> ..., and all of its nodes are white (jumping in the same direction).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":357,"row":{"number":458,"difficulty":2,"question":"class Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        \"\"\"\n        There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n        You can feed the pigs according to these steps:\n            Choose some live pigs to feed.\n            For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n            Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n            After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n            Repeat this process until you run out of time.\n        Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n        Example 1:\n        Input: buckets = 4, minutesToDie = 15, minutesToTest = 15\n        Output: 2\n        Explanation: We can determine the poisonous bucket as follows:\n        At time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\n        At time 15, there are 4 possible outcomes:\n        - If only the first pig dies, then bucket 1 must be poisonous.\n        - If only the second pig dies, then bucket 3 must be poisonous.\n        - If both pigs die, then bucket 2 must be poisonous.\n        - If neither pig dies, then bucket 4 must be poisonous.\n        Example 2:\n        Input: buckets = 4, minutesToDie = 15, minutesToTest = 30\n        Output: 2\n        Explanation: We can determine the poisonous bucket as follows:\n        At time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\n        At time 15, there are 2 possible outcomes:\n        - If either pig dies, then the poisonous bucket is the one it was fed.\n        - If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\n        At time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":358,"row":{"number":459,"difficulty":0,"question":"class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        \"\"\"\n        Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\n        Example 1:\n        Input: s = \"abab\"\n        Output: true\n        Explanation: It is the substring \"ab\" twice.\n        Example 2:\n        Input: s = \"aba\"\n        Output: false\n        Example 3:\n        Input: s = \"abcabcabcabc\"\n        Output: true\n        Explanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":359,"row":{"number":460,"difficulty":2,"question":"class LFUCache:\n    def __init__(self, capacity: int):\n    def get(self, key: int) -> int:\n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        Design and implement a data structure for a Least Frequently Used (LFU) cache.\n        Implement the LFUCache class:\n            LFUCache(int capacity) Initializes the object with the capacity of the data structure.\n            int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.\n            void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.\n        To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.\n        When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.\n        The functions get and put must each run in O(1) average time complexity.\n        Example 1:\n        Input\n        [\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n        [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n        Output\n        [null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n        Explanation\n        // cnt(x) = the use counter for key x\n        // cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\n        LFUCache lfu = new LFUCache(2);\n        lfu.put(1, 1);   // cache=[1,_], cnt(1)=1\n        lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\n        lfu.get(1);      // return 1\n                         // cache=[1,2], cnt(2)=1, cnt(1)=2\n        lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n                         // cache=[3,1], cnt(3)=1, cnt(1)=2\n        lfu.get(2);      // return -1 (not found)\n        lfu.get(3);      // return 3\n                         // cache=[3,1], cnt(3)=2, cnt(1)=2\n        lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                         // cache=[4,3], cnt(4)=1, cnt(3)=2\n        lfu.get(1);      // return -1 (not found)\n        lfu.get(3);      // return 3\n                         // cache=[3,4], cnt(4)=1, cnt(3)=3\n        lfu.get(4);      // return 4\n                         // cache=[4,3], cnt(4)=2, cnt(3)=3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":360,"row":{"number":461,"difficulty":0,"question":"class Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        \"\"\"\n        The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n        Given two integers x and y, return the Hamming distance between them.\n        Example 1:\n        Input: x = 1, y = 4\n        Output: 2\n        Explanation:\n        1   (0 0 0 1)\n        4   (0 1 0 0)\n               ↑   ↑\n        The above arrows point to positions where the corresponding bits are different.\n        Example 2:\n        Input: x = 3, y = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":361,"row":{"number":462,"difficulty":1,"question":"class Solution:\n    def minMoves2(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\n        In one move, you can increment or decrement an element of the array by 1.\n        Test cases are designed so that the answer will fit in a 32-bit integer.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: 2\n        Explanation:\n        Only two moves are needed (remember each move increments or decrements one element):\n        [1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n        Example 2:\n        Input: nums = [1,10,2,9]\n        Output: 16\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":362,"row":{"number":463,"difficulty":0,"question":"class Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\n        Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n        The island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n        Example 1:\n        Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n        Output: 16\n        Explanation: The perimeter is the 16 yellow stripes in the image above.\n        Example 2:\n        Input: grid = [[1]]\n        Output: 4\n        Example 3:\n        Input: grid = [[1,0]]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":363,"row":{"number":464,"difficulty":1,"question":"class Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        \"\"\"\n        In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n        What if we change the game so that players cannot re-use integers?\n        For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n        Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n        Example 1:\n        Input: maxChoosableInteger = 10, desiredTotal = 11\n        Output: false\n        Explanation:\n        No matter which integer the first player choose, the first player will lose.\n        The first player can choose an integer from 1 up to 10.\n        If the first player choose 1, the second player can only choose integers from 2 up to 10.\n        The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\n        Same with other integers chosen by the first player, the second player will always win.\n        Example 2:\n        Input: maxChoosableInteger = 10, desiredTotal = 0\n        Output: true\n        Example 3:\n        Input: maxChoosableInteger = 10, desiredTotal = 1\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":364,"row":{"number":466,"difficulty":2,"question":"class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        \"\"\"\n        We define str = [s, n] as the string str which consists of the string s concatenated n times.\n            For example, str == [\"abc\", 3] ==\"abcabcabc\".\n        We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n            For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n        You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n        Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n        Example 1:\n        Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n        Output: 2\n        Example 2:\n        Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":365,"row":{"number":467,"difficulty":1,"question":"class Solution:\n    def findSubstringInWraproundString(self, s: str) -> int:\n        \"\"\"\n        We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so base will look like this:\n            \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n        Given a string s, return the number of unique non-empty substrings of s are present in base.\n        Example 1:\n        Input: s = \"a\"\n        Output: 1\n        Explanation: Only the substring \"a\" of s is in base.\n        Example 2:\n        Input: s = \"cac\"\n        Output: 2\n        Explanation: There are two substrings (\"a\", \"c\") of s in base.\n        Example 3:\n        Input: s = \"zab\"\n        Output: 6\n        Explanation: There are six substrings (\"z\", \"a\", \"b\", \"za\", \"ab\", and \"zab\") of s in base.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":366,"row":{"number":468,"difficulty":1,"question":"class Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        \"\"\"\n        Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 address or \"Neither\" if IP is not a correct IP of any type.\n        A valid IPv4 address is an IP in the form \"x1.x2.x3.x4\" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, \"192.168.1.1\" and \"192.168.1.0\" are valid IPv4 addresses while \"192.168.01.1\", \"192.168.1.00\", and \"192.168@1.1\" are invalid IPv4 addresses.\n        A valid IPv6 address is an IP in the form \"x1:x2:x3:x4:x5:x6:x7:x8\" where:\n            1 <= xi.length <= 4\n            xi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').\n            Leading zeros are allowed in xi.\n        For example, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" and \"2001:db8:85a3:0:0:8A2E:0370:7334\" are valid IPv6 addresses, while \"2001:0db8:85a3::8A2E:037j:7334\" and \"02001:0db8:85a3:0000:0000:8a2e:0370:7334\" are invalid IPv6 addresses.\n        Example 1:\n        Input: queryIP = \"172.16.254.1\"\n        Output: \"IPv4\"\n        Explanation: This is a valid IPv4 address, return \"IPv4\".\n        Example 2:\n        Input: queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\n        Output: \"IPv6\"\n        Explanation: This is a valid IPv6 address, return \"IPv6\".\n        Example 3:\n        Input: queryIP = \"256.256.256.256\"\n        Output: \"Neither\"\n        Explanation: This is neither a IPv4 address nor a IPv6 address.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":367,"row":{"number":472,"difficulty":2,"question":"class Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        \"\"\"\n        Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n        A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.\n        Example 1:\n        Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n        Output: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n        Explanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n        \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n        \"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n        Example 2:\n        Input: words = [\"cat\",\"dog\",\"catdog\"]\n        Output: [\"catdog\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":368,"row":{"number":473,"difficulty":1,"question":"class Solution:\n    def makesquare(self, matchsticks: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n        Return true if you can make this square and false otherwise.\n        Example 1:\n        Input: matchsticks = [1,1,2,2,2]\n        Output: true\n        Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n        Example 2:\n        Input: matchsticks = [3,3,3,3,4]\n        Output: false\n        Explanation: You cannot find a way to form a square with all the matchsticks.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":369,"row":{"number":474,"difficulty":1,"question":"class Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        \"\"\"\n        You are given an array of binary strings strs and two integers m and n.\n        Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.\n        A set x is a subset of a set y if all elements of x are also elements of y.\n        Example 1:\n        Input: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n        Output: 4\n        Explanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\n        Other valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n        {\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n        Example 2:\n        Input: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n        Output: 2\n        Explanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":370,"row":{"number":475,"difficulty":1,"question":"class Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        \"\"\"\n        Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.\n        Every house can be warmed, as long as the house is within the heater's warm radius range. \n        Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.\n        Notice that all the heaters follow your radius standard, and the warm radius will the same.\n        Example 1:\n        Input: houses = [1,2,3], heaters = [2]\n        Output: 1\n        Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n        Example 2:\n        Input: houses = [1,2,3,4], heaters = [1,4]\n        Output: 1\n        Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n        Example 3:\n        Input: houses = [1,5], heaters = [2]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":371,"row":{"number":476,"difficulty":0,"question":"class Solution:\n    def findComplement(self, num: int) -> int:\n        \"\"\"\n        The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n            For example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n        Given an integer num, return its complement.\n        Example 1:\n        Input: num = 5\n        Output: 2\n        Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n        Example 2:\n        Input: num = 1\n        Output: 0\n        Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":372,"row":{"number":477,"difficulty":1,"question":"class Solution:\n    def totalHammingDistance(self, nums: List[int]) -> int:\n        \"\"\"\n        The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n        Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.\n        Example 1:\n        Input: nums = [4,14,2]\n        Output: 6\n        Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n        showing the four bits relevant in this case).\n        The answer will be:\n        HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n        Example 2:\n        Input: nums = [4,14,4]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":373,"row":{"number":479,"difficulty":2,"question":"class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the largest palindromic integer that can be represented as the product of two n-digits integers. Since the answer can be very large, return it modulo 1337.\n        Example 1:\n        Input: n = 2\n        Output: 987\n        Explanation: 99 x 91 = 9009, 9009 % 1337 = 987\n        Example 2:\n        Input: n = 1\n        Output: 9\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":374,"row":{"number":480,"difficulty":2,"question":"class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        \"\"\"\n        The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n            For examples, if arr = [2,3,4], the median is 3.\n            For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n        You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n        Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.\n        Example 1:\n        Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\n        Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\n        Explanation: \n        Window position                Median\n        ---------------                -----\n        [1  3  -1] -3  5  3  6  7        1\n         1 [3  -1  -3] 5  3  6  7       -1\n         1  3 [-1  -3  5] 3  6  7       -1\n         1  3  -1 [-3  5  3] 6  7        3\n         1  3  -1  -3 [5  3  6] 7        5\n         1  3  -1  -3  5 [3  6  7]       6\n        Example 2:\n        Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\n        Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":375,"row":{"number":481,"difficulty":1,"question":"class Solution:\n    def magicalString(self, n: int) -> int:\n        \"\"\"\n        A magical string s consists of only '1' and '2' and obeys the following rules:\n            The string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n        The first few elements of s is s = \"1221121221221121122……\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\n        Given an integer n, return the number of 1's in the first n number in the magical string s.\n        Example 1:\n        Input: n = 6\n        Output: 3\n        Explanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":376,"row":{"number":482,"difficulty":0,"question":"class Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        \"\"\"\n        You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.\n        We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\n        Return the reformatted license key.\n        Example 1:\n        Input: s = \"5F3Z-2e-9-w\", k = 4\n        Output: \"5F3Z-2E9W\"\n        Explanation: The string s has been split into two parts, each part has 4 characters.\n        Note that the two extra dashes are not needed and can be removed.\n        Example 2:\n        Input: s = \"2-5g-3-J\", k = 2\n        Output: \"2-5G-3J\"\n        Explanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":377,"row":{"number":483,"difficulty":2,"question":"class Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        \"\"\"\n        Given an integer n represented as a string, return the smallest good base of n.\n        We call k >= 2 a good base of n, if all digits of n base k are 1's.\n        Example 1:\n        Input: n = \"13\"\n        Output: \"3\"\n        Explanation: 13 base 3 is 111.\n        Example 2:\n        Input: n = \"4681\"\n        Output: \"8\"\n        Explanation: 4681 base 8 is 11111.\n        Example 3:\n        Input: n = \"1000000000000000000\"\n        Output: \"999999999999999999\"\n        Explanation: 1000000000000000000 base 999999999999999999 is 11.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":378,"row":{"number":485,"difficulty":0,"question":"class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a binary array nums, return the maximum number of consecutive 1's in the array.\n        Example 1:\n        Input: nums = [1,1,0,1,1,1]\n        Output: 3\n        Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n        Example 2:\n        Input: nums = [1,0,1,1,0,1]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":379,"row":{"number":486,"difficulty":1,"question":"class Solution:\n    def PredictTheWinner(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.\n        Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n        Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.\n        Example 1:\n        Input: nums = [1,5,2]\n        Output: false\n        Explanation: Initially, player 1 can choose between 1 and 2. \n        If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \n        So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \n        Hence, player 1 will never be the winner and you need to return false.\n        Example 2:\n        Input: nums = [1,5,233,7]\n        Output: true\n        Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\n        Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":380,"row":{"number":488,"difficulty":2,"question":"class Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        \"\"\"\n        You are playing a variation of the game Zuma.\n        In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand.\n        Your goal is to clear all of the balls from the board. On each turn:\n            Pick any ball from your hand and insert it in between two balls in the row or on either end of the row.\n            If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.\n                If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\n            If there are no more balls on the board, then you win the game.\n            Repeat this process until you either win or do not have any more balls in your hand.\n        Given a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.\n        Example 1:\n        Input: board = \"WRRBBW\", hand = \"RB\"\n        Output: -1\n        Explanation: It is impossible to clear all the balls. The best you can do is:\n        - Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n        - Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\n        There are still balls remaining on the board, and you are out of balls to insert.\n        Example 2:\n        Input: board = \"WWRRBBWW\", hand = \"WRBRW\"\n        Output: 2\n        Explanation: To make the board empty:\n        - Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n        - Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n        2 balls from your hand were needed to clear the board.\n        Example 3:\n        Input: board = \"G\", hand = \"GGGGG\"\n        Output: 2\n        Explanation: To make the board empty:\n        - Insert 'G' so the board becomes GG.\n        - Insert 'G' so the board becomes GGG. GGG -> empty.\n        2 balls from your hand were needed to clear the board.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":381,"row":{"number":1643,"difficulty":2,"question":"class Solution:\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\n        \"\"\"\n        Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob by providing instructions for him to reach destination.\n        The instructions are represented as a string, where each character is either:\n            'H', meaning move horizontally (go right), or\n            'V', meaning move vertically (go down).\n        Multiple instructions will lead Bob to destination. For example, if destination is (2, 3), both \"HHHVV\" and \"HVHVH\" are valid instructions.\n        However, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed.\n        Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination.\n        Example 1:\n        Input: destination = [2,3], k = 1\n        Output: \"HHHVV\"\n        Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows:\n        [\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].\n        Example 2:\n        Input: destination = [2,3], k = 2\n        Output: \"HHVHV\"\n        Example 3:\n        Input: destination = [2,3], k = 3\n        Output: \"HHVVH\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":382,"row":{"number":491,"difficulty":1,"question":"class Solution:\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.\n        Example 1:\n        Input: nums = [4,6,7,7]\n        Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n        Example 2:\n        Input: nums = [4,4,3,2,1]\n        Output: [[4,4]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":383,"row":{"number":492,"difficulty":0,"question":"class Solution:\n    def constructRectangle(self, area: int) -> List[int]:\n        \"\"\"\n        A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n            The area of the rectangular web page you designed must equal to the given target area.\n            The width W should not be larger than the length L, which means L >= W.\n            The difference between length L and width W should be as small as possible.\n        Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.\n        Example 1:\n        Input: area = 4\n        Output: [2,2]\n        Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \n        But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\n        Example 2:\n        Input: area = 37\n        Output: [37,1]\n        Example 3:\n        Input: area = 122122\n        Output: [427,286]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":384,"row":{"number":493,"difficulty":2,"question":"class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the number of reverse pairs in the array.\n        A reverse pair is a pair (i, j) where:\n            0 <= i < j < nums.length and\n            nums[i] > 2 * nums[j].\n        Example 1:\n        Input: nums = [1,3,2,3,1]\n        Output: 2\n        Explanation: The reverse pairs are:\n        (1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n        (3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1\n        Example 2:\n        Input: nums = [2,4,3,5,1]\n        Output: 3\n        Explanation: The reverse pairs are:\n        (1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n        (2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n        (3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":385,"row":{"number":494,"difficulty":1,"question":"class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer target.\n        You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n            For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\n        Return the number of different expressions that you can build, which evaluates to target.\n        Example 1:\n        Input: nums = [1,1,1,1,1], target = 3\n        Output: 5\n        Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n        -1 + 1 + 1 + 1 + 1 = 3\n        +1 - 1 + 1 + 1 + 1 = 3\n        +1 + 1 - 1 + 1 + 1 = 3\n        +1 + 1 + 1 - 1 + 1 = 3\n        +1 + 1 + 1 + 1 - 1 = 3\n        Example 2:\n        Input: nums = [1], target = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":386,"row":{"number":495,"difficulty":0,"question":"class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        \"\"\"\n        Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.\n        You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.\n        Return the total number of seconds that Ashe is poisoned.\n        Example 1:\n        Input: timeSeries = [1,4], duration = 2\n        Output: 4\n        Explanation: Teemo's attacks on Ashe go as follows:\n        - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n        - At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\n        Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n        Example 2:\n        Input: timeSeries = [1,2], duration = 2\n        Output: 3\n        Explanation: Teemo's attacks on Ashe go as follows:\n        - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n        - At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\n        Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":387,"row":{"number":496,"difficulty":0,"question":"class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \"\"\"\n        The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\n        You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\n        For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\n        Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.\n        Example 1:\n        Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\n        Output: [-1,3,-1]\n        Explanation: The next greater element for each value of nums1 is as follows:\n        - 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n        - 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n        - 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n        Example 2:\n        Input: nums1 = [2,4], nums2 = [1,2,3,4]\n        Output: [3,-1]\n        Explanation: The next greater element for each value of nums1 is as follows:\n        - 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n        - 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":388,"row":{"number":498,"difficulty":1,"question":"class Solution:\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.\n        Example 1:\n        Input: mat = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,4,7,5,3,6,8,9]\n        Example 2:\n        Input: mat = [[1,2],[3,4]]\n        Output: [1,2,3,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":389,"row":{"number":500,"difficulty":0,"question":"class Solution:\n    def findWords(self, words: List[str]) -> List[str]:\n        \"\"\"\n        Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.\n        In the American keyboard:\n            the first row consists of the characters \"qwertyuiop\",\n            the second row consists of the characters \"asdfghjkl\", and\n            the third row consists of the characters \"zxcvbnm\".\n        Example 1:\n        Input: words = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]\n        Output: [\"Alaska\",\"Dad\"]\n        Example 2:\n        Input: words = [\"omk\"]\n        Output: []\n        Example 3:\n        Input: words = [\"adsdf\",\"sfd\"]\n        Output: [\"adsdf\",\"sfd\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":390,"row":{"number":501,"difficulty":0,"question":"class Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        \"\"\"\n        Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.\n        If the tree has more than one mode, return them in any order.\n        Assume a BST is defined as follows:\n            The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n            The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n            Both the left and right subtrees must also be binary search trees.\n        Example 1:\n        Input: root = [1,null,2,2]\n        Output: [2]\n        Example 2:\n        Input: root = [0]\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":391,"row":{"number":502,"difficulty":2,"question":"class Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        \"\"\"\n        Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\n        You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\n        Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n        Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\n        The answer is guaranteed to fit in a 32-bit signed integer.\n        Example 1:\n        Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n        Output: 4\n        Explanation: Since your initial capital is 0, you can only start the project indexed 0.\n        After finishing it you will obtain profit 1 and your capital becomes 1.\n        With capital 1, you can either start the project indexed 1 or the project indexed 2.\n        Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\n        Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n        Example 2:\n        Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n        Output: 6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":392,"row":{"number":503,"difficulty":1,"question":"class Solution:\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.\n        The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.\n        Example 1:\n        Input: nums = [1,2,1]\n        Output: [2,-1,2]\n        Explanation: The first 1's next greater number is 2; \n        The number 2 can't find next greater number. \n        The second 1's next greater number needs to search circularly, which is also 2.\n        Example 2:\n        Input: nums = [1,2,3,4,3]\n        Output: [2,3,4,-1,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":393,"row":{"number":504,"difficulty":0,"question":"class Solution:\n    def convertToBase7(self, num: int) -> str:\n        \"\"\"\n        Given an integer num, return a string of its base 7 representation.\n        Example 1:\n        Input: num = 100\n        Output: \"202\"\n        Example 2:\n        Input: num = -7\n        Output: \"-10\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":394,"row":{"number":506,"difficulty":0,"question":"class Solution:\n    def findRelativeRanks(self, score: List[int]) -> List[str]:\n        \"\"\"\n        You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\n        The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n            The 1st place athlete's rank is \"Gold Medal\".\n            The 2nd place athlete's rank is \"Silver Medal\".\n            The 3rd place athlete's rank is \"Bronze Medal\".\n            For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n        Return an array answer of size n where answer[i] is the rank of the ith athlete.\n        Example 1:\n        Input: score = [5,4,3,2,1]\n        Output: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\n        Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].\n        Example 2:\n        Input: score = [10,3,8,9,4]\n        Output: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\n        Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":395,"row":{"number":507,"difficulty":0,"question":"class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        \"\"\"\n        A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.\n        Given an integer n, return true if n is a perfect number, otherwise return false.\n        Example 1:\n        Input: num = 28\n        Output: true\n        Explanation: 28 = 1 + 2 + 4 + 7 + 14\n        1, 2, 4, 7, and 14 are all divisors of 28.\n        Example 2:\n        Input: num = 7\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":396,"row":{"number":508,"difficulty":1,"question":"class Solution:\n    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:\n        \"\"\"\n        Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.\n        The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).\n        Example 1:\n        Input: root = [5,2,-3]\n        Output: [2,-3,4]\n        Example 2:\n        Input: root = [5,2,-5]\n        Output: [2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":397,"row":{"number":513,"difficulty":1,"question":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the leftmost value in the last row of the tree.\n        Example 1:\n        Input: root = [2,1,3]\n        Output: 1\n        Example 2:\n        Input: root = [1,2,3,4,null,5,6,null,null,7]\n        Output: 7\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":398,"row":{"number":514,"difficulty":2,"question":"class Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        \"\"\"\n        In the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\" and use the dial to spell a specific keyword to open the door.\n        Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.\n        Initially, the first character of the ring is aligned at the \"12:00\" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the \"12:00\" direction and then by pressing the center button.\n        At the stage of rotating the ring to spell the key character key[i]:\n            You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the \"12:00\" direction, where this character must equal key[i].\n            If the character key[i] has been aligned at the \"12:00\" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\n        Example 1:\n        Input: ring = \"godding\", key = \"gd\"\n        Output: 4\n        Explanation:\n        For the first key character 'g', since it is already in place, we just need 1 step to spell this character. \n        For the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\".\n        Also, we need 1 more step for spelling.\n        So the final output is 4.\n        Example 2:\n        Input: ring = \"godding\", key = \"godding\"\n        Output: 13\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":399,"row":{"number":515,"difficulty":1,"question":"class Solution:\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\n        \"\"\"\n        Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).\n        Example 1:\n        Input: root = [1,3,2,5,3,null,9]\n        Output: [1,3,9]\n        Example 2:\n        Input: root = [1,2,3]\n        Output: [1,3]\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}