{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1100,"row":{"number":1352,"difficulty":1,"question":"class ProductOfNumbers:\n    def __init__(self):\n    def add(self, num: int) -> None:\n    def getProduct(self, k: int) -> int:\n        \"\"\"\n        Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.\n        Implement the ProductOfNumbers class:\n            ProductOfNumbers() Initializes the object with an empty stream.\n            void add(int num) Appends the integer num to the stream.\n            int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.\n        The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.\n        Example:\n        Input\n        [\"ProductOfNumbers\",\"add\",\"add\",\"add\",\"add\",\"add\",\"getProduct\",\"getProduct\",\"getProduct\",\"add\",\"getProduct\"]\n        [[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]\n        Output\n        [null,null,null,null,null,null,20,40,0,null,32]\n        Explanation\n        ProductOfNumbers productOfNumbers = new ProductOfNumbers();\n        productOfNumbers.add(3);        // [3]\n        productOfNumbers.add(0);        // [3,0]\n        productOfNumbers.add(2);        // [3,0,2]\n        productOfNumbers.add(5);        // [3,0,2,5]\n        productOfNumbers.add(4);        // [3,0,2,5,4]\n        productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20\n        productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40\n        productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0\n        productOfNumbers.add(8);        // [3,0,2,5,4,8]\n        productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1101,"row":{"number":1353,"difficulty":1,"question":"class Solution:\n    def maxEvents(self, events: List[List[int]]) -> int:\n        \"\"\"\n        You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.\n        You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d.\n        Return the maximum number of events you can attend.\n        Example 1:\n        Input: events = [[1,2],[2,3],[3,4]]\n        Output: 3\n        Explanation: You can attend all the three events.\n        One way to attend them all is as shown.\n        Attend the first event on day 1.\n        Attend the second event on day 2.\n        Attend the third event on day 3.\n        Example 2:\n        Input: events= [[1,2],[2,3],[3,4],[1,2]]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1102,"row":{"number":1354,"difficulty":2,"question":"class Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        \"\"\"\n        You are given an array target of n integers. From a starting array arr consisting of n 1's, you may perform the following procedure :\n            let x be the sum of all elements currently in your array.\n            choose index i, such that 0 <= i < n and set the value of arr at index i to x.\n            You may repeat this procedure as many times as needed.\n        Return true if it is possible to construct the target array from arr, otherwise, return false.\n        Example 1:\n        Input: target = [9,3,5]\n        Output: true\n        Explanation: Start with arr = [1, 1, 1] \n        [1, 1, 1], sum = 3 choose index 1\n        [1, 3, 1], sum = 5 choose index 2\n        [1, 3, 5], sum = 9 choose index 0\n        [9, 3, 5] Done\n        Example 2:\n        Input: target = [1,1,1,2]\n        Output: false\n        Explanation: Impossible to create target array from [1,1,1,1].\n        Example 3:\n        Input: target = [8,5]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1103,"row":{"number":1365,"difficulty":0,"question":"class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].\n        Return the answer in an array.\n        Example 1:\n        Input: nums = [8,1,2,2,3]\n        Output: [4,0,1,1,3]\n        Explanation: \n        For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \n        For nums[1]=1 does not exist any smaller number than it.\n        For nums[2]=2 there exist one smaller number than it (1). \n        For nums[3]=2 there exist one smaller number than it (1). \n        For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).\n        Example 2:\n        Input: nums = [6,5,4,8]\n        Output: [2,1,0,3]\n        Example 3:\n        Input: nums = [7,7,7,7]\n        Output: [0,0,0,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1104,"row":{"number":1366,"difficulty":1,"question":"class Solution:\n    def rankTeams(self, votes: List[str]) -> str:\n        \"\"\"\n        In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition.\n        The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.\n        You are given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.\n        Return a string of all teams sorted by the ranking system.\n        Example 1:\n        Input: votes = [\"ABC\",\"ACB\",\"ABC\",\"ACB\",\"ACB\"]\n        Output: \"ACB\"\n        Explanation: \n        Team A was ranked first place by 5 voters. No other team was voted as first place, so team A is the first team.\n        Team B was ranked second by 2 voters and ranked third by 3 voters.\n        Team C was ranked second by 3 voters and ranked third by 2 voters.\n        As most of the voters ranked C second, team C is the second team, and team B is the third.\n        Example 2:\n        Input: votes = [\"WXYZ\",\"XYZW\"]\n        Output: \"XWYZ\"\n        Explanation:\n        X is the winner due to the tie-breaking rule. X has the same votes as W for the first position, but X has one vote in the second position, while W does not have any votes in the second position. \n        Example 3:\n        Input: votes = [\"ZMNAGUEDSJYLBOPHRQICWFXTVK\"]\n        Output: \"ZMNAGUEDSJYLBOPHRQICWFXTVK\"\n        Explanation: Only one voter, so their votes are used for the ranking.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1105,"row":{"number":1367,"difficulty":1,"question":"class Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Given a binary tree root and a linked list with head as the first node. \n        Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.\n        In this context downward path means a path that starts at some node and goes downwards.\n        Example 1:\n        Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n        Output: true\n        Explanation: Nodes in blue form a subpath in the binary Tree.  \n        Example 2:\n        Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n        Output: true\n        Example 3:\n        Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n        Output: false\n        Explanation: There is no path in the binary tree that contains all the elements of the linked list from head.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1106,"row":{"number":1368,"difficulty":2,"question":"class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n            1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n            2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n            3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n            4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n        Notice that there could be some signs on the cells of the grid that point outside the grid.\n        You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\n        You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\n        Return the minimum cost to make the grid have at least one valid path.\n        Example 1:\n        Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n        Output: 3\n        Explanation: You will start at point (0, 0).\n        The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\n        The total cost = 3.\n        Example 2:\n        Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\n        Output: 0\n        Explanation: You can follow the path from (0, 0) to (2, 2).\n        Example 3:\n        Input: grid = [[1,2],[4,3]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1107,"row":{"number":1385,"difficulty":0,"question":"class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        \"\"\"\n        Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.\n        The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\n        Example 1:\n        Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\n        Output: 2\n        Explanation: \n        For arr1[0]=4 we have: \n        |4-10|=6 > d=2 \n        |4-9|=5 > d=2 \n        |4-1|=3 > d=2 \n        |4-8|=4 > d=2 \n        For arr1[1]=5 we have: \n        |5-10|=5 > d=2 \n        |5-9|=4 > d=2 \n        |5-1|=4 > d=2 \n        |5-8|=3 > d=2\n        For arr1[2]=8 we have:\n        |8-10|=2 <= d=2\n        |8-9|=1 <= d=2\n        |8-1|=7 > d=2\n        |8-8|=0 <= d=2\n        Example 2:\n        Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\n        Output: 2\n        Example 3:\n        Input: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1108,"row":{"number":1386,"difficulty":1,"question":"class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \"\"\"\n        A cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.\n        Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8] means the seat located in row 3 and labelled with 8 is already reserved.\n        Return the maximum number of four-person groups you can assign on the cinema seats. A four-person group occupies four adjacent seats in one single row. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side.\n        Example 1:\n        Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]\n        Output: 4\n        Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.\n        Example 2:\n        Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]\n        Output: 2\n        Example 3:\n        Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1109,"row":{"number":1387,"difficulty":1,"question":"class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \"\"\"\n        The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps:\n            if x is even then x = x / 2\n            if x is odd then x = 3 * x + 1\n        For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).\n        Given three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, if two or more integers have the same power value sort them by ascending order.\n        Return the kth integer in the range [lo, hi] sorted by the power value.\n        Notice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in a 32-bit signed integer.\n        Example 1:\n        Input: lo = 12, hi = 15, k = 2\n        Output: 13\n        Explanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)\n        The power of 13 is 9\n        The power of 14 is 17\n        The power of 15 is 17\n        The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13.\n        Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.\n        Example 2:\n        Input: lo = 7, hi = 11, k = 4\n        Output: 7\n        Explanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14].\n        The interval sorted by power is [8, 10, 11, 7, 9].\n        The fourth number in the sorted array is 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1110,"row":{"number":1388,"difficulty":2,"question":"class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        \"\"\"\n        There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:\n            You will pick any pizza slice.\n            Your friend Alice will pick the next slice in the anti-clockwise direction of your pick.\n            Your friend Bob will pick the next slice in the clockwise direction of your pick.\n            Repeat until there are no more slices of pizzas.\n        Given an integer array slices that represent the sizes of the pizza slices in a clockwise direction, return the maximum possible sum of slice sizes that you can pick.\n        Example 1:\n        Input: slices = [1,2,3,4,5,6]\n        Output: 10\n        Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n        Example 2:\n        Input: slices = [8,9,8,6,1,1]\n        Output: 16\n        Explanation: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1111,"row":{"number":1374,"difficulty":0,"question":"class Solution:\n    def generateTheString(self, n: int) -> str:\n        \"\"\"\n        Given an integer n, return a string with n characters such that each character in such string occurs an odd number of times.\n        The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them.  \n        Example 1:\n        Input: n = 4\n        Output: \"pppz\"\n        Explanation: \"pppz\" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as \"ohhh\" and \"love\".\n        Example 2:\n        Input: n = 2\n        Output: \"xy\"\n        Explanation: \"xy\" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as \"ag\" and \"ur\".\n        Example 3:\n        Input: n = 7\n        Output: \"holasss\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1112,"row":{"number":1375,"difficulty":1,"question":"class Solution:\n    def numTimesAllBlue(self, flips: List[int]) -> int:\n        \"\"\"\n        You have a 1-indexed binary string of length n where all the bits are 0 initially. We will flip all the bits of this binary string (i.e., change them from 0 to 1) one by one. You are given a 1-indexed integer array flips where flips[i] indicates that the bit at index i will be flipped in the ith step.\n        A binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros.\n        Return the number of times the binary string is prefix-aligned during the flipping process.\n        Example 1:\n        Input: flips = [3,2,4,1,5]\n        Output: 2\n        Explanation: The binary string is initially \"00000\".\n        After applying step 1: The string becomes \"00100\", which is not prefix-aligned.\n        After applying step 2: The string becomes \"01100\", which is not prefix-aligned.\n        After applying step 3: The string becomes \"01110\", which is not prefix-aligned.\n        After applying step 4: The string becomes \"11110\", which is prefix-aligned.\n        After applying step 5: The string becomes \"11111\", which is prefix-aligned.\n        We can see that the string was prefix-aligned 2 times, so we return 2.\n        Example 2:\n        Input: flips = [4,1,2,3]\n        Output: 1\n        Explanation: The binary string is initially \"0000\".\n        After applying step 1: The string becomes \"0001\", which is not prefix-aligned.\n        After applying step 2: The string becomes \"1001\", which is not prefix-aligned.\n        After applying step 3: The string becomes \"1101\", which is not prefix-aligned.\n        After applying step 4: The string becomes \"1111\", which is prefix-aligned.\n        We can see that the string was prefix-aligned 1 time, so we return 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1113,"row":{"number":1376,"difficulty":1,"question":"class Solution:\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\n        \"\"\"\n        A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.\n        Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure.\n        The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n        The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).\n        Return the number of minutes needed to inform all the employees about the urgent news.\n        Example 1:\n        Input: n = 1, headID = 0, manager = [-1], informTime = [0]\n        Output: 0\n        Explanation: The head of the company is the only employee in the company.\n        Example 2:\n        Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n        Output: 1\n        Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\n        The tree structure of the employees in the company is shown.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1114,"row":{"number":1377,"difficulty":2,"question":"class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        \"\"\"\n        Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\n        The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\n        Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n        Output: 0.16666666666666666 \n        Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n        Example 2:\n        Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n        Output: 0.3333333333333333\n        Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1115,"row":{"number":1380,"difficulty":0,"question":"class Solution:\n    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.\n        A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.\n        Example 1:\n        Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]\n        Output: [15]\n        Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column.\n        Example 2:\n        Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\n        Output: [12]\n        Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\n        Example 3:\n        Input: matrix = [[7,8],[1,2]]\n        Output: [7]\n        Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1116,"row":{"number":1381,"difficulty":1,"question":"class CustomStack:\n    def __init__(self, maxSize: int):\n    def push(self, x: int) -> None:\n    def pop(self) -> int:\n    def increment(self, k: int, val: int) -> None:\n        \"\"\"\n        Design a stack that supports increment operations on its elements.\n        Implement the CustomStack class:\n            CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack.\n            void push(int x) Adds x to the top of the stack if the stack has not reached the maxSize.\n            int pop() Pops and returns the top of the stack or -1 if the stack is empty.\n            void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack.\n        Example 1:\n        Input\n        [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n        [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n        Output\n        [null,null,null,2,null,null,null,null,null,103,202,201,-1]\n        Explanation\n        CustomStack stk = new CustomStack(3); // Stack is Empty []\n        stk.push(1);                          // stack becomes [1]\n        stk.push(2);                          // stack becomes [1, 2]\n        stk.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]\n        stk.push(2);                          // stack becomes [1, 2]\n        stk.push(3);                          // stack becomes [1, 2, 3]\n        stk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4\n        stk.increment(5, 100);                // stack becomes [101, 102, 103]\n        stk.increment(2, 100);                // stack becomes [201, 202, 103]\n        stk.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]\n        stk.pop();                            // return 202 --> Return top of the stack 202, stack becomes [201]\n        stk.pop();                            // return 201 --> Return top of the stack 201, stack becomes []\n        stk.pop();                            // return -1 --> Stack is empty return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1117,"row":{"number":1379,"difficulty":0,"question":"class Solution:\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\n        \"\"\"\n        Given two binary trees original and cloned and given a reference to a node target in the original tree.\n        The cloned tree is a copy of the original tree.\n        Return a reference to the same node in the cloned tree.\n        Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.\n        Example 1:\n        Input: tree = [7,4,3,null,null,6,19], target = 3\n        Output: 3\n        Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\n        Example 2:\n        Input: tree = [7], target =  7\n        Output: 7\n        Example 3:\n        Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1118,"row":{"number":1383,"difficulty":2,"question":"class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        \"\"\"\n        You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively.\n        Choose at most k different engineers out of the n engineers to form a team with the maximum performance.\n        The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\n        Return the maximum performance of this team. Since the answer can be a huge number, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\n        Output: 60\n        Explanation: \n        We have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.\n        Example 2:\n        Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3\n        Output: 68\n        Explanation:\n        This is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.\n        Example 3:\n        Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4\n        Output: 72\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1119,"row":{"number":1399,"difficulty":0,"question":"class Solution:\n    def countLargestGroup(self, n: int) -> int:\n        \"\"\"\n        You are given an integer n.\n        Each number from 1 to n is grouped according to the sum of its digits.\n        Return the number of groups that have the largest size.\n        Example 1:\n        Input: n = 13\n        Output: 4\n        Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n        [1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\n        There are 4 groups with largest size.\n        Example 2:\n        Input: n = 2\n        Output: 2\n        Explanation: There are 2 groups [1], [2] of size 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1120,"row":{"number":1401,"difficulty":1,"question":"class Solution:\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\n        \"\"\"\n        You are given a circle represented as (radius, xCenter, yCenter) and an axis-aligned rectangle represented as (x1, y1, x2, y2), where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the rectangle.\n        Return true if the circle and rectangle are overlapped otherwise return false. In other words, check if there is any point (xi, yi) that belongs to the circle and the rectangle at the same time.\n        Example 1:\n        Input: radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1\n        Output: true\n        Explanation: Circle and rectangle share the point (1,0).\n        Example 2:\n        Input: radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1\n        Output: false\n        Example 3:\n        Input: radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1121,"row":{"number":1400,"difficulty":1,"question":"class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        \"\"\"\n        Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.\n        Example 1:\n        Input: s = \"annabelle\", k = 2\n        Output: true\n        Explanation: You can construct two palindromes using all characters in s.\n        Some possible constructions \"anna\" + \"elble\", \"anbna\" + \"elle\", \"anellena\" + \"b\"\n        Example 2:\n        Input: s = \"leetcode\", k = 3\n        Output: false\n        Explanation: It is impossible to construct 3 palindromes using all the characters of s.\n        Example 3:\n        Input: s = \"true\", k = 4\n        Output: true\n        Explanation: The only possible solution is to put each character in a separate string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1122,"row":{"number":1402,"difficulty":2,"question":"class Solution:\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\n        \"\"\"\n        A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.\n        Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i].\n        Return the maximum sum of like-time coefficient that the chef can obtain after dishes preparation.\n        Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\n        Example 1:\n        Input: satisfaction = [-1,-8,0,5,-9]\n        Output: 14\n        Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14).\n        Each dish is prepared in one unit of time.\n        Example 2:\n        Input: satisfaction = [4,3,2]\n        Output: 20\n        Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\n        Example 3:\n        Input: satisfaction = [-1,-4,-5]\n        Output: 0\n        Explanation: People do not like the dishes. No dish is prepared.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1123,"row":{"number":1389,"difficulty":0,"question":"class Solution:\n    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:\n        \"\"\"\n        Given two arrays of integers nums and index. Your task is to create target array under the following rules:\n            Initially target array is empty.\n            From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.\n            Repeat the previous step until there are no elements to read in nums and index.\n        Return the target array.\n        It is guaranteed that the insertion operations will be valid.\n        Example 1:\n        Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]\n        Output: [0,4,1,3,2]\n        Explanation:\n        nums       index     target\n        0            0        [0]\n        1            1        [0,1]\n        2            2        [0,1,2]\n        3            2        [0,1,3,2]\n        4            1        [0,4,1,3,2]\n        Example 2:\n        Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]\n        Output: [0,1,2,3,4]\n        Explanation:\n        nums       index     target\n        1            0        [1]\n        2            1        [1,2]\n        3            2        [1,2,3]\n        4            3        [1,2,3,4]\n        0            0        [0,1,2,3,4]\n        Example 3:\n        Input: nums = [1], index = [0]\n        Output: [1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1124,"row":{"number":1391,"difficulty":1,"question":"class Solution:\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\n        \"\"\"\n        You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n            1 which means a street connecting the left cell and the right cell.\n            2 which means a street connecting the upper cell and the lower cell.\n            3 which means a street connecting the left cell and the lower cell.\n            4 which means a street connecting the right cell and the lower cell.\n            5 which means a street connecting the left cell and the upper cell.\n            6 which means a street connecting the right cell and the upper cell.\n        You will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\n        Notice that you are not allowed to change any street.\n        Return true if there is a valid path in the grid or false otherwise.\n        Example 1:\n        Input: grid = [[2,4,3],[6,5,2]]\n        Output: true\n        Explanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n        Example 2:\n        Input: grid = [[1,2,1],[1,2,1]]\n        Output: false\n        Explanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n        Example 3:\n        Input: grid = [[1,1,2]]\n        Output: false\n        Explanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1125,"row":{"number":1392,"difficulty":2,"question":"class Solution:\n    def longestPrefix(self, s: str) -> str:\n        \"\"\"\n        A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\n        Given a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.\n        Example 1:\n        Input: s = \"level\"\n        Output: \"l\"\n        Explanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".\n        Example 2:\n        Input: s = \"ababab\"\n        Output: \"abab\"\n        Explanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1126,"row":{"number":1394,"difficulty":0,"question":"class Solution:\n    def findLucky(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.\n        Return the largest lucky integer in the array. If there is no lucky integer return -1.\n        Example 1:\n        Input: arr = [2,2,3,4]\n        Output: 2\n        Explanation: The only lucky number in the array is 2 because frequency[2] == 2.\n        Example 2:\n        Input: arr = [1,2,2,3,3,3]\n        Output: 3\n        Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.\n        Example 3:\n        Input: arr = [2,2,2,3,3]\n        Output: -1\n        Explanation: There are no lucky numbers in the array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1127,"row":{"number":1395,"difficulty":1,"question":"class Solution:\n    def numTeams(self, rating: List[int]) -> int:\n        \"\"\"\n        There are n soldiers standing in a line. Each soldier is assigned a unique rating value.\n        You have to form a team of 3 soldiers amongst them under the following rules:\n            Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).\n            A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).\n        Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n        Example 1:\n        Input: rating = [2,5,3,4,1]\n        Output: 3\n        Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n        Example 2:\n        Input: rating = [2,1,3]\n        Output: 0\n        Explanation: We can't form any team given the conditions.\n        Example 3:\n        Input: rating = [1,2,3,4]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1128,"row":{"number":1396,"difficulty":1,"question":"class UndergroundSystem:\n    def __init__(self):\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\n        \"\"\"\n        An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.\n        Implement the UndergroundSystem class:\n            void checkIn(int id, string stationName, int t)\n                A customer with a card ID equal to id, checks in at the station stationName at time t.\n                A customer can only be checked into one place at a time.\n            void checkOut(int id, string stationName, int t)\n                A customer with a card ID equal to id, checks out from the station stationName at time t.\n            double getAverageTime(string startStation, string endStation)\n                Returns the average time it takes to travel from startStation to endStation.\n                The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation.\n                The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation.\n                There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.\n        You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order.\n        Example 1:\n        Input\n        [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"]\n        [[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]]\n        Output\n        [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]\n        Explanation\n        UndergroundSystem undergroundSystem = new UndergroundSystem();\n        undergroundSystem.checkIn(45, \"Leyton\", 3);\n        undergroundSystem.checkIn(32, \"Paradise\", 8);\n        undergroundSystem.checkIn(27, \"Leyton\", 10);\n        undergroundSystem.checkOut(45, \"Waterloo\", 15);  // Customer 45 \"Leyton\" -> \"Waterloo\" in 15-3 = 12\n        undergroundSystem.checkOut(27, \"Waterloo\", 20);  // Customer 27 \"Leyton\" -> \"Waterloo\" in 20-10 = 10\n        undergroundSystem.checkOut(32, \"Cambridge\", 22); // Customer 32 \"Paradise\" -> \"Cambridge\" in 22-8 = 14\n        undergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // return 14.00000. One trip \"Paradise\" -> \"Cambridge\", (14) / 1 = 14\n        undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // return 11.00000. Two trips \"Leyton\" -> \"Waterloo\", (10 + 12) / 2 = 11\n        undergroundSystem.checkIn(10, \"Leyton\", 24);\n        undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // return 11.00000\n        undergroundSystem.checkOut(10, \"Waterloo\", 38);  // Customer 10 \"Leyton\" -> \"Waterloo\" in 38-24 = 14\n        undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // return 12.00000. Three trips \"Leyton\" -> \"Waterloo\", (10 + 12 + 14) / 3 = 12\n        Example 2:\n        Input\n        [\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n        [[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]]\n        Output\n        [null,null,null,5.00000,null,null,5.50000,null,null,6.66667]\n        Explanation\n        UndergroundSystem undergroundSystem = new UndergroundSystem();\n        undergroundSystem.checkIn(10, \"Leyton\", 3);\n        undergroundSystem.checkOut(10, \"Paradise\", 8); // Customer 10 \"Leyton\" -> \"Paradise\" in 8-3 = 5\n        undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.00000, (5) / 1 = 5\n        undergroundSystem.checkIn(5, \"Leyton\", 10);\n        undergroundSystem.checkOut(5, \"Paradise\", 16); // Customer 5 \"Leyton\" -> \"Paradise\" in 16-10 = 6\n        undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.50000, (5 + 6) / 2 = 5.5\n        undergroundSystem.checkIn(2, \"Leyton\", 21);\n        undergroundSystem.checkOut(2, \"Paradise\", 30); // Customer 2 \"Leyton\" -> \"Paradise\" in 30-21 = 9\n        undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1129,"row":{"number":1397,"difficulty":2,"question":"class Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        \"\"\"\n        Given the strings s1 and s2 of size n and the string evil, return the number of good strings.\n        A good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. Since the answer can be a huge number, return this modulo 109 + 7.\n        Example 1:\n        Input: n = 2, s1 = \"aa\", s2 = \"da\", evil = \"b\"\n        Output: 51 \n        Explanation: There are 25 good strings starting with 'a': \"aa\",\"ac\",\"ad\",...,\"az\". Then there are 25 good strings starting with 'c': \"ca\",\"cc\",\"cd\",...,\"cz\" and finally there is one good string starting with 'd': \"da\". \n        Example 2:\n        Input: n = 8, s1 = \"leetcode\", s2 = \"leetgoes\", evil = \"leet\"\n        Output: 0 \n        Explanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix \"leet\", therefore, there is not any good string.\n        Example 3:\n        Input: n = 2, s1 = \"gx\", s2 = \"gz\", evil = \"x\"\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1130,"row":{"number":1413,"difficulty":0,"question":"class Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array of integers nums, you start with an initial positive value startValue.\n        In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).\n        Return the minimum positive value of startValue such that the step by step sum is never less than 1.\n        Example 1:\n        Input: nums = [-3,2,-3,4,2]\n        Output: 5\n        Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.\n        step by step sum\n        startValue = 4 | startValue = 5 | nums\n          (4 -3 ) = 1  | (5 -3 ) = 2    |  -3\n          (1 +2 ) = 3  | (2 +2 ) = 4    |   2\n          (3 -3 ) = 0  | (4 -3 ) = 1    |  -3\n          (0 +4 ) = 4  | (1 +4 ) = 5    |   4\n          (4 +2 ) = 6  | (5 +2 ) = 7    |   2\n        Example 2:\n        Input: nums = [1,2]\n        Output: 1\n        Explanation: Minimum start value should be positive. \n        Example 3:\n        Input: nums = [1,-2,-3]\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1131,"row":{"number":1414,"difficulty":1,"question":"class Solution:\n    def findMinFibonacciNumbers(self, k: int) -> int:\n        \"\"\"\n        Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k. The same Fibonacci number can be used multiple times.\n        The Fibonacci numbers are defined as:\n            F1 = 1\n            F2 = 1\n            Fn = Fn-1 + Fn-2 for n > 2.\n        It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to k.\n        Example 1:\n        Input: k = 7\n        Output: 2 \n        Explanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... \n        For k = 7 we can use 2 + 5 = 7.\n        Example 2:\n        Input: k = 10\n        Output: 2 \n        Explanation: For k = 10 we can use 2 + 8 = 10.\n        Example 3:\n        Input: k = 19\n        Output: 3 \n        Explanation: For k = 19 we can use 1 + 5 + 13 = 19.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1132,"row":{"number":1415,"difficulty":1,"question":"class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        \"\"\"\n        A happy string is a string that:\n            consists only of letters of the set ['a', 'b', 'c'].\n            s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).\n        For example, strings \"abc\", \"ac\", \"b\" and \"abcbabcbcb\" are all happy strings and strings \"aa\", \"baa\" and \"ababbc\" are not happy strings.\n        Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.\n        Return the kth string of this list or return an empty string if there are less than k happy strings of length n.\n        Example 1:\n        Input: n = 1, k = 3\n        Output: \"c\"\n        Explanation: The list [\"a\", \"b\", \"c\"] contains all happy strings of length 1. The third string is \"c\".\n        Example 2:\n        Input: n = 1, k = 4\n        Output: \"\"\n        Explanation: There are only 3 happy strings of length 1.\n        Example 3:\n        Input: n = 3, k = 9\n        Output: \"cab\"\n        Explanation: There are 12 different happy string of length 3 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]. You will find the 9th string = \"cab\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1133,"row":{"number":1416,"difficulty":2,"question":"class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        \"\"\"\n        A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\n        Given the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: s = \"1000\", k = 10000\n        Output: 1\n        Explanation: The only possible array is [1000]\n        Example 2:\n        Input: s = \"1000\", k = 10\n        Output: 0\n        Explanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.\n        Example 3:\n        Input: s = \"1317\", k = 2000\n        Output: 8\n        Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1134,"row":{"number":1403,"difficulty":0,"question":"class Solution:\n    def minSubsequence(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. \n        If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. \n        Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.\n        Example 1:\n        Input: nums = [4,3,10,9,8]\n        Output: [10,9] \n        Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements. \n        Example 2:\n        Input: nums = [4,4,7,6,7]\n        Output: [7,7,6] \n        Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-decreasing order.  \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1135,"row":{"number":1404,"difficulty":1,"question":"class Solution:\n    def numSteps(self, s: str) -> int:\n        \"\"\"\n        Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:\n            If the current number is even, you have to divide it by 2.\n            If the current number is odd, you have to add 1 to it.\n        It is guaranteed that you can always reach one for all test cases.\n        Example 1:\n        Input: s = \"1101\"\n        Output: 6\n        Explanation: \"1101\" corressponds to number 13 in their decimal representation.\n        Step 1) 13 is odd, add 1 and obtain 14. \n        Step 2) 14 is even, divide by 2 and obtain 7.\n        Step 3) 7 is odd, add 1 and obtain 8.\n        Step 4) 8 is even, divide by 2 and obtain 4.  \n        Step 5) 4 is even, divide by 2 and obtain 2. \n        Step 6) 2 is even, divide by 2 and obtain 1.  \n        Example 2:\n        Input: s = \"10\"\n        Output: 1\n        Explanation: \"10\" corressponds to number 2 in their decimal representation.\n        Step 1) 2 is even, divide by 2 and obtain 1.  \n        Example 3:\n        Input: s = \"1\"\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1136,"row":{"number":1406,"difficulty":2,"question":"class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \"\"\"\n        Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\n        Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row.\n        The score of each player is the sum of the values of the stones taken. The score of each player is 0 initially.\n        The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n        Assume Alice and Bob play optimally.\n        Return \"Alice\" if Alice will win, \"Bob\" if Bob will win, or \"Tie\" if they will end the game with the same score.\n        Example 1:\n        Input: values = [1,2,3,7]\n        Output: \"Bob\"\n        Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n        Example 2:\n        Input: values = [1,2,3,-9]\n        Output: \"Alice\"\n        Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\n        If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\n        If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\n        Remember that both play optimally so here Alice will choose the scenario that makes her win.\n        Example 3:\n        Input: values = [1,2,3,6]\n        Output: \"Tie\"\n        Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1137,"row":{"number":1408,"difficulty":0,"question":"class Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        \"\"\"\n        Given an array of string words, return all strings in words that is a substring of another word. You can return the answer in any order.\n        A substring is a contiguous sequence of characters within a string\n        Example 1:\n        Input: words = [\"mass\",\"as\",\"hero\",\"superhero\"]\n        Output: [\"as\",\"hero\"]\n        Explanation: \"as\" is substring of \"mass\" and \"hero\" is substring of \"superhero\".\n        [\"hero\",\"as\"] is also a valid answer.\n        Example 2:\n        Input: words = [\"leetcode\",\"et\",\"code\"]\n        Output: [\"et\",\"code\"]\n        Explanation: \"et\", \"code\" are substring of \"leetcode\".\n        Example 3:\n        Input: words = [\"blue\",\"green\",\"bu\"]\n        Output: []\n        Explanation: No string of words is substring of another string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1138,"row":{"number":1409,"difficulty":1,"question":"class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \"\"\"\n        Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:\r\n            In the beginning, you have the permutation P=[1,2,3,...,m].\r\n            For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].\r\n        Return an array containing the result for the given queries.\r\n        Example 1:\r\n        Input: queries = [3,1,2,1], m = 5\r\n        Output: [2,1,2,1] \r\n        Explanation: The queries are processed as follow: \r\n        For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. \r\n        For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. \r\n        For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. \r\n        For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. \r\n        Therefore, the array containing the result is [2,1,2,1].  \r\n        Example 2:\r\n        Input: queries = [4,1,2,2], m = 4\r\n        Output: [3,1,2,0]\r\n        Example 3:\r\n        Input: queries = [7,5,5,8,3], m = 8\r\n        Output: [6,5,0,7,5]\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1139,"row":{"number":1410,"difficulty":1,"question":"class Solution:\n    def entityParser(self, text: str) -> str:\n        \"\"\"\n        HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.\n        The special characters and their entities for HTML are:\n            Quotation Mark: the entity is &quot; and symbol character is \".\n            Single Quote Mark: the entity is &apos; and symbol character is '.\n            Ampersand: the entity is &amp; and symbol character is &.\n            Greater Than Sign: the entity is &gt; and symbol character is >.\n            Less Than Sign: the entity is &lt; and symbol character is <.\n            Slash: the entity is &frasl; and symbol character is /.\n        Given the input text string to the HTML parser, you have to implement the entity parser.\n        Return the text after replacing the entities by the special characters.\n        Example 1:\n        Input: text = \"&amp; is an HTML entity but &ambassador; is not.\"\n        Output: \"& is an HTML entity but &ambassador; is not.\"\n        Explanation: The parser will replace the &amp; entity by &\n        Example 2:\n        Input: text = \"and I quote: &quot;...&quot;\"\n        Output: \"and I quote: \\\"...\\\"\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1140,"row":{"number":1411,"difficulty":2,"question":"class Solution:\n    def numOfWays(self, n: int) -> int:\n        \"\"\"\n        You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\n        Given n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 109 + 7.\n        Example 1:\n        Input: n = 1\n        Output: 12\n        Explanation: There are 12 possible way to paint the grid as shown.\n        Example 2:\n        Input: n = 5000\n        Output: 30228214\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1141,"row":{"number":1431,"difficulty":0,"question":"class Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        \"\"\"\n        There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.\n        Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.\n        Note that multiple kids can have the greatest number of candies.\n        Example 1:\n        Input: candies = [2,3,5,1,3], extraCandies = 3\n        Output: [true,true,true,false,true] \n        Explanation: If you give all extraCandies to:\n        - Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n        - Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n        - Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n        - Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n        - Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n        Example 2:\n        Input: candies = [4,2,1,1,2], extraCandies = 1\n        Output: [true,false,false,false,false] \n        Explanation: There is only 1 extra candy.\n        Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n        Example 3:\n        Input: candies = [12,1,12], extraCandies = 10\n        Output: [true,false,true]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1142,"row":{"number":1432,"difficulty":1,"question":"class Solution:\n    def maxDiff(self, num: int) -> int:\n        \"\"\"\n        You are given an integer num. You will apply the following steps exactly two times:\n            Pick a digit x (0 <= x <= 9).\n            Pick another digit y (0 <= y <= 9). The digit y can be equal to x.\n            Replace all the occurrences of x in the decimal representation of num by y.\n            The new integer cannot have any leading zeros, also the new integer cannot be 0.\n        Let a and b be the results of applying the operations to num the first and second times, respectively.\n        Return the max difference between a and b.\n        Example 1:\n        Input: num = 555\n        Output: 888\n        Explanation: The first time pick x = 5 and y = 9 and store the new integer in a.\n        The second time pick x = 5 and y = 1 and store the new integer in b.\n        We have now a = 999 and b = 111 and max difference = 888\n        Example 2:\n        Input: num = 9\n        Output: 8\n        Explanation: The first time pick x = 9 and y = 9 and store the new integer in a.\n        The second time pick x = 9 and y = 1 and store the new integer in b.\n        We have now a = 9 and b = 1 and max difference = 8\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1143,"row":{"number":1433,"difficulty":1,"question":"class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        \"\"\"\n        Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa. In other words s2 can break s1 or vice-versa.\n        A string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1.\n        Example 1:\n        Input: s1 = \"abc\", s2 = \"xya\"\n        Output: true\n        Explanation: \"ayx\" is a permutation of s2=\"xya\" which can break to string \"abc\" which is a permutation of s1=\"abc\".\n        Example 2:\n        Input: s1 = \"abe\", s2 = \"acd\"\n        Output: false \n        Explanation: All permutations for s1=\"abe\" are: \"abe\", \"aeb\", \"bae\", \"bea\", \"eab\" and \"eba\" and all permutation for s2=\"acd\" are: \"acd\", \"adc\", \"cad\", \"cda\", \"dac\" and \"dca\". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa.\n        Example 3:\n        Input: s1 = \"leetcodee\", s2 = \"interview\"\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1144,"row":{"number":1434,"difficulty":2,"question":"class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        \"\"\"\n        There are n people and 40 types of hats labeled from 1 to 40.\n        Given a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person.\n        Return the number of ways that the n people wear different hats to each other.\n        Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: hats = [[3,4],[4,5],[5]]\n        Output: 1\n        Explanation: There is only one way to choose hats given the conditions. \n        First person choose hat 3, Second person choose hat 4 and last one hat 5.\n        Example 2:\n        Input: hats = [[3,5,1],[3,5]]\n        Output: 4\n        Explanation: There are 4 ways to choose hats:\n        (3,5), (5,3), (1,3) and (1,5)\n        Example 3:\n        Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\n        Output: 24\n        Explanation: Each person can choose hats labeled from 1 to 4.\n        Number of Permutations of (1,2,3,4) = 24.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1145,"row":{"number":1417,"difficulty":0,"question":"class Solution:\n    def reformat(self, s: str) -> str:\n        \"\"\"\n        You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).\n        You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.\n        Return the reformatted string or return an empty string if it is impossible to reformat the string.\n        Example 1:\n        Input: s = \"a0b1c2\"\n        Output: \"0a1b2c\"\n        Explanation: No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations.\n        Example 2:\n        Input: s = \"leetcode\"\n        Output: \"\"\n        Explanation: \"leetcode\" has only characters so we cannot separate them by digits.\n        Example 3:\n        Input: s = \"1229857369\"\n        Output: \"\"\n        Explanation: \"1229857369\" has only digits so we cannot separate them by characters.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1146,"row":{"number":1418,"difficulty":1,"question":"class Solution:\r\n    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:\n        \"\"\"\n        Given the array orders, which represents the orders that customers have done in a restaurant. More specifically orders[i]=[customerNamei,tableNumberi,foodItemi] where customerNamei is the name of the customer, tableNumberi is the table customer sit at, and foodItemi is the item customer orders.\r\n        Return the restaurant's display table. The display table is a table whose row entries denote how many of each food item each table ordered. The first column is the table number and the remaining columns correspond to each food item in alphabetical order. The first row should be a header whose first column is Table, followed by the names of the food items. Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order.\r\n        Example 1:\r\n        Input: orders = [[\"David\",\"3\",\"Ceviche\"],[\"Corina\",\"10\",\"Beef Burrito\"],[\"David\",\"3\",\"Fried Chicken\"],[\"Carla\",\"5\",\"Water\"],[\"Carla\",\"5\",\"Ceviche\"],[\"Rous\",\"3\",\"Ceviche\"]]\r\n        Output: [[\"Table\",\"Beef Burrito\",\"Ceviche\",\"Fried Chicken\",\"Water\"],[\"3\",\"0\",\"2\",\"1\",\"0\"],[\"5\",\"0\",\"1\",\"0\",\"1\"],[\"10\",\"1\",\"0\",\"0\",\"0\"]] \r\n        Explanation:\r\n        The displaying table looks like:\r\n        Table,Beef Burrito,Ceviche,Fried Chicken,Water\r\n        3    ,0           ,2      ,1            ,0\r\n        5    ,0           ,1      ,0            ,1\r\n        10   ,1           ,0      ,0            ,0\r\n        For the table 3: David orders \"Ceviche\" and \"Fried Chicken\", and Rous orders \"Ceviche\".\r\n        For the table 5: Carla orders \"Water\" and \"Ceviche\".\r\n        For the table 10: Corina orders \"Beef Burrito\". \r\n        Example 2:\r\n        Input: orders = [[\"James\",\"12\",\"Fried Chicken\"],[\"Ratesh\",\"12\",\"Fried Chicken\"],[\"Amadeus\",\"12\",\"Fried Chicken\"],[\"Adam\",\"1\",\"Canadian Waffles\"],[\"Brianna\",\"1\",\"Canadian Waffles\"]]\r\n        Output: [[\"Table\",\"Canadian Waffles\",\"Fried Chicken\"],[\"1\",\"2\",\"0\"],[\"12\",\"0\",\"3\"]] \r\n        Explanation: \r\n        For the table 1: Adam and Brianna order \"Canadian Waffles\".\r\n        For the table 12: James, Ratesh and Amadeus order \"Fried Chicken\".\r\n        Example 3:\r\n        Input: orders = [[\"Laura\",\"2\",\"Bean Burrito\"],[\"Jhon\",\"2\",\"Beef Burrito\"],[\"Melissa\",\"2\",\"Soda\"]]\r\n        Output: [[\"Table\",\"Bean Burrito\",\"Beef Burrito\",\"Soda\"],[\"2\",\"1\",\"1\",\"1\"]]\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1147,"row":{"number":1419,"difficulty":1,"question":"class Solution:\n    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n        \"\"\"\n        You are given the string croakOfFrogs, which represents a combination of the string \"croak\" from different frogs, that is, multiple frogs can croak at the same time, so multiple \"croak\" are mixed.\n        Return the minimum number of different frogs to finish all the croaks in the given string.\n        A valid \"croak\" means a frog is printing five letters 'c', 'r', 'o', 'a', and 'k' sequentially. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid \"croak\" return -1.\n        Example 1:\n        Input: croakOfFrogs = \"croakcroak\"\n        Output: 1 \n        Explanation: One frog yelling \"croak\" twice.\n        Example 2:\n        Input: croakOfFrogs = \"crcoakroak\"\n        Output: 2 \n        Explanation: The minimum number of frogs is two. \n        The first frog could yell \"crcoakroak\".\n        The second frog could yell later \"crcoakroak\".\n        Example 3:\n        Input: croakOfFrogs = \"croakcrook\"\n        Output: -1\n        Explanation: The given string is an invalid combination of \"croak\" from different frogs.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1148,"row":{"number":1420,"difficulty":2,"question":"class Solution:\n    def numOfArrays(self, n: int, m: int, k: int) -> int:\n        \"\"\"\n        You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:\n        You should build the array arr which has the following properties:\n            arr has exactly n integers.\n            1 <= arr[i] <= m where (0 <= i < n).\n            After applying the mentioned algorithm to arr, the value search_cost is equal to k.\n        Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.\n        Example 1:\n        Input: n = 2, m = 3, k = 1\n        Output: 6\n        Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n        Example 2:\n        Input: n = 5, m = 2, k = 3\n        Output: 0\n        Explanation: There are no possible arrays that satisify the mentioned conditions.\n        Example 3:\n        Input: n = 9, m = 1, k = 1\n        Output: 1\n        Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1149,"row":{"number":1422,"difficulty":0,"question":"class Solution:\n    def maxScore(self, s: str) -> int:\n        \"\"\"\n        Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).\n        The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.\n        Example 1:\n        Input: s = \"011101\"\n        Output: 5 \n        Explanation: \n        All possible ways of splitting s into two non-empty substrings are:\n        left = \"0\" and right = \"11101\", score = 1 + 4 = 5 \n        left = \"01\" and right = \"1101\", score = 1 + 3 = 4 \n        left = \"011\" and right = \"101\", score = 1 + 2 = 3 \n        left = \"0111\" and right = \"01\", score = 1 + 1 = 2 \n        left = \"01110\" and right = \"1\", score = 2 + 1 = 3\n        Example 2:\n        Input: s = \"00111\"\n        Output: 5\n        Explanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5\n        Example 3:\n        Input: s = \"1111\"\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1150,"row":{"number":1423,"difficulty":1,"question":"class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        \"\"\"\n        There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.\n        In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.\n        Your score is the sum of the points of the cards you have taken.\n        Given the integer array cardPoints and the integer k, return the maximum score you can obtain.\n        Example 1:\n        Input: cardPoints = [1,2,3,4,5,6,1], k = 3\n        Output: 12\n        Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.\n        Example 2:\n        Input: cardPoints = [2,2,2], k = 2\n        Output: 4\n        Explanation: Regardless of which two cards you take, your score will always be 4.\n        Example 3:\n        Input: cardPoints = [9,7,7,9,7,7,9], k = 7\n        Output: 55\n        Explanation: You have to take all the cards. Your score is the sum of points of all cards.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1151,"row":{"number":1424,"difficulty":1,"question":"class Solution:\n    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.\n        Example 1:\n        Input: nums = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,4,2,7,5,3,8,6,9]\n        Example 2:\n        Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\n        Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1152,"row":{"number":1446,"difficulty":0,"question":"class Solution:\n    def maxPower(self, s: str) -> int:\n        \"\"\"\n        The power of the string is the maximum length of a non-empty substring that contains only one unique character.\n        Given a string s, return the power of s.\n        Example 1:\n        Input: s = \"leetcode\"\n        Output: 2\n        Explanation: The substring \"ee\" is of length 2 with the character 'e' only.\n        Example 2:\n        Input: s = \"abbcccddddeeeeedcba\"\n        Output: 5\n        Explanation: The substring \"eeeee\" is of length 5 with the character 'e' only.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1153,"row":{"number":1447,"difficulty":1,"question":"class Solution:\n    def simplifiedFractions(self, n: int) -> List[str]:\n        \"\"\"\n        Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. You can return the answer in any order.\n        Example 1:\n        Input: n = 2\n        Output: [\"1/2\"]\n        Explanation: \"1/2\" is the only unique fraction with a denominator less-than-or-equal-to 2.\n        Example 2:\n        Input: n = 3\n        Output: [\"1/2\",\"1/3\",\"2/3\"]\n        Example 3:\n        Input: n = 4\n        Output: [\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"]\n        Explanation: \"2/4\" is not a simplified fraction because it can be simplified to \"1/2\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1154,"row":{"number":1448,"difficulty":1,"question":"class Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \"\"\"\n        Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\r\n        Return the number of good nodes in the binary tree.\r\n        Example 1:\r\n        Input: root = [3,1,4,3,null,1,5]\r\n        Output: 4\r\n        Explanation: Nodes in blue are good.\r\n        Root Node (3) is always a good node.\r\n        Node 4 -> (3,4) is the maximum value in the path starting from the root.\r\n        Node 5 -> (3,4,5) is the maximum value in the path\r\n        Node 3 -> (3,1,3) is the maximum value in the path.\r\n        Example 2:\r\n        Input: root = [3,3,null,4,2]\r\n        Output: 3\r\n        Explanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.\r\n        Example 3:\r\n        Input: root = [1]\r\n        Output: 1\r\n        Explanation: Root is considered as good.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1155,"row":{"number":1449,"difficulty":2,"question":"class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        \"\"\"\n        Given an array of integers cost and an integer target, return the maximum integer you can paint under the following rules:\n            The cost of painting a digit (i + 1) is given by cost[i] (0-indexed).\n            The total cost used must be equal to target.\n            The integer does not have 0 digits.\n        Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return \"0\".\n        Example 1:\n        Input: cost = [4,3,2,5,6,7,2,5,5], target = 9\n        Output: \"7772\"\n        Explanation: The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(\"7772\") = 2*3+ 3*1 = 9. You could also paint \"977\", but \"7772\" is the largest number.\n        Digit    cost\n          1  ->   4\n          2  ->   3\n          3  ->   2\n          4  ->   5\n          5  ->   6\n          6  ->   7\n          7  ->   2\n          8  ->   5\n          9  ->   5\n        Example 2:\n        Input: cost = [7,6,5,5,5,6,8,7,8], target = 12\n        Output: \"85\"\n        Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(\"85\") = 7 + 5 = 12.\n        Example 3:\n        Input: cost = [2,4,6,2,4,6,4,4,4], target = 5\n        Output: \"0\"\n        Explanation: It is impossible to paint any integer with total cost equal to target.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1156,"row":{"number":1436,"difficulty":0,"question":"class Solution:\n    def destCity(self, paths: List[List[str]]) -> str:\n        \"\"\"\n        You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\n        It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n        Example 1:\n        Input: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\n        Output: \"Sao Paulo\" \n        Explanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\".\n        Example 2:\n        Input: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\n        Output: \"A\"\n        Explanation: All possible trips are: \n        \"D\" -> \"B\" -> \"C\" -> \"A\". \n        \"B\" -> \"C\" -> \"A\". \n        \"C\" -> \"A\". \n        \"A\". \n        Clearly the destination city is \"A\".\n        Example 3:\n        Input: paths = [[\"A\",\"Z\"]]\n        Output: \"Z\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1157,"row":{"number":1437,"difficulty":0,"question":"class Solution:\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\n        \"\"\"\n        Given an binary array nums and an integer k, return true if all 1's are at least k places away from each other, otherwise return false.\n        Example 1:\n        Input: nums = [1,0,0,0,1,0,0,1], k = 2\n        Output: true\n        Explanation: Each of the 1s are at least 2 places away from each other.\n        Example 2:\n        Input: nums = [1,0,0,1,0,1], k = 2\n        Output: false\n        Explanation: The second 1 and third 1 are only one apart from each other.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1158,"row":{"number":1438,"difficulty":1,"question":"class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        \"\"\"\n        Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.\n        Example 1:\n        Input: nums = [8,2,4,7], limit = 4\n        Output: 2 \n        Explanation: All subarrays are: \n        [8] with maximum absolute diff |8-8| = 0 <= 4.\n        [8,2] with maximum absolute diff |8-2| = 6 > 4. \n        [8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n        [8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n        [2] with maximum absolute diff |2-2| = 0 <= 4.\n        [2,4] with maximum absolute diff |2-4| = 2 <= 4.\n        [2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n        [4] with maximum absolute diff |4-4| = 0 <= 4.\n        [4,7] with maximum absolute diff |4-7| = 3 <= 4.\n        [7] with maximum absolute diff |7-7| = 0 <= 4. \n        Therefore, the size of the longest subarray is 2.\n        Example 2:\n        Input: nums = [10,1,2,4,7,2], limit = 5\n        Output: 4 \n        Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\n        Example 3:\n        Input: nums = [4,2,2,2,4,4,2,2], limit = 0\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1159,"row":{"number":1439,"difficulty":2,"question":"class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        \"\"\"\n        You are given an m x n matrix mat that has its rows sorted in non-decreasing order and an integer k.\n        You are allowed to choose exactly one element from each row to form an array.\n        Return the kth smallest array sum among all possible arrays.\n        Example 1:\n        Input: mat = [[1,3,11],[2,4,6]], k = 5\n        Output: 7\n        Explanation: Choosing one element from each row, the first k smallest sum are:\n        [1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.\n        Example 2:\n        Input: mat = [[1,3,11],[2,4,6]], k = 9\n        Output: 17\n        Example 3:\n        Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n        Output: 9\n        Explanation: Choosing one element from each row, the first k smallest sum are:\n        [1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1160,"row":{"number":1441,"difficulty":1,"question":"class Solution:\n    def buildArray(self, target: List[int], n: int) -> List[str]:\n        \"\"\"\n        You are given an integer array target and an integer n.\n        You have an empty stack with the two following operations:\n            \"Push\": pushes an integer to the top of the stack.\n            \"Pop\": removes the integer on the top of the stack.\n        You also have a stream of the integers in the range [1, n].\n        Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:\n            If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.\n            If the stack is not empty, pop the integer at the top of the stack.\n            If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.\n        Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.\n        Example 1:\n        Input: target = [1,3], n = 3\n        Output: [\"Push\",\"Push\",\"Pop\",\"Push\"]\n        Explanation: Initially the stack s is empty. The last element is the top of the stack.\n        Read 1 from the stream and push it to the stack. s = [1].\n        Read 2 from the stream and push it to the stack. s = [1,2].\n        Pop the integer on the top of the stack. s = [1].\n        Read 3 from the stream and push it to the stack. s = [1,3].\n        Example 2:\n        Input: target = [1,2,3], n = 3\n        Output: [\"Push\",\"Push\",\"Push\"]\n        Explanation: Initially the stack s is empty. The last element is the top of the stack.\n        Read 1 from the stream and push it to the stack. s = [1].\n        Read 2 from the stream and push it to the stack. s = [1,2].\n        Read 3 from the stream and push it to the stack. s = [1,2,3].\n        Example 3:\n        Input: target = [1,2], n = 4\n        Output: [\"Push\",\"Push\"]\n        Explanation: Initially the stack s is empty. The last element is the top of the stack.\n        Read 1 from the stream and push it to the stack. s = [1].\n        Read 2 from the stream and push it to the stack. s = [1,2].\n        Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.\n        The answers that read integer 3 from the stream are not accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1161,"row":{"number":1442,"difficulty":1,"question":"class Solution:\n    def countTriplets(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array of integers arr.\n        We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).\n        Let's define a and b as follows:\n            a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]\n            b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\n        Note that ^ denotes the bitwise-xor operation.\n        Return the number of triplets (i, j and k) Where a == b.\n        Example 1:\n        Input: arr = [2,3,1,6,7]\n        Output: 4\n        Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)\n        Example 2:\n        Input: arr = [1,1,1,1,1]\n        Output: 10\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1162,"row":{"number":1443,"difficulty":1,"question":"class Solution:\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\n        \"\"\"\n        Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex.\n        The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple.\n        Example 1:\n        Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n        Output: 8 \n        Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  \n        Example 2:\n        Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n        Output: 6\n        Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  \n        Example 3:\n        Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1163,"row":{"number":1444,"difficulty":2,"question":"class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        \"\"\"\n        Given a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts. \r\n        For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\r\n        Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.\r\n        Example 1:\r\n        Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\r\n        Output: 3 \r\n        Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\r\n        Example 2:\r\n        Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\r\n        Output: 1\r\n        Example 3:\r\n        Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\r\n        Output: 1\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1164,"row":{"number":1460,"difficulty":0,"question":"class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        \"\"\"\n        You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty subarray of arr and reverse it. You are allowed to make any number of steps.\n        Return true if you can make arr equal to target or false otherwise.\n        Example 1:\n        Input: target = [1,2,3,4], arr = [2,4,1,3]\n        Output: true\n        Explanation: You can follow the next steps to convert arr to target:\n        1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]\n        2- Reverse subarray [4,2], arr becomes [1,2,4,3]\n        3- Reverse subarray [4,3], arr becomes [1,2,3,4]\n        There are multiple ways to convert arr to target, this is not the only way to do so.\n        Example 2:\n        Input: target = [7], arr = [7]\n        Output: true\n        Explanation: arr is equal to target without any reverses.\n        Example 3:\n        Input: target = [3,7,9], arr = [3,7,11]\n        Output: false\n        Explanation: arr does not have value 9 and it can never be converted to target.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1165,"row":{"number":1461,"difficulty":1,"question":"class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        \"\"\"\n        Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.\n        Example 1:\n        Input: s = \"00110110\", k = 2\n        Output: true\n        Explanation: The binary codes of length 2 are \"00\", \"01\", \"10\" and \"11\". They can be all found as substrings at indices 0, 1, 3 and 2 respectively.\n        Example 2:\n        Input: s = \"0110\", k = 1\n        Output: true\n        Explanation: The binary codes of length 1 are \"0\" and \"1\", it is clear that both exist as a substring. \n        Example 3:\n        Input: s = \"0110\", k = 2\n        Output: false\n        Explanation: The binary code \"00\" is of length 2 and does not exist in the array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1166,"row":{"number":1462,"difficulty":1,"question":"class Solution:\n    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        \"\"\"\n        There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi.\n            For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1.\n        Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c.\n        You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not.\n        Return a boolean array answer, where answer[j] is the answer to the jth query.\n        Example 1:\n        Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]\n        Output: [false,true]\n        Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.\n        Course 0 is not a prerequisite of course 1, but the opposite is true.\n        Example 2:\n        Input: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]\n        Output: [false,false]\n        Explanation: There are no prerequisites, and each course is independent.\n        Example 3:\n        Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]\n        Output: [true,true]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1167,"row":{"number":1463,"difficulty":2,"question":"class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.\n        You have two robots that can collect cherries for you:\n            Robot #1 is located at the top-left corner (0, 0), and\n            Robot #2 is located at the top-right corner (0, cols - 1).\n        Return the maximum number of cherries collection using both robots by following the rules below:\n            From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1).\n            When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n            When both robots stay in the same cell, only one takes the cherries.\n            Both robots cannot move outside of the grid at any moment.\n            Both robots should reach the bottom row in grid.\n        Example 1:\n        Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n        Output: 24\n        Explanation: Path of robot #1 and #2 are described in color green and blue respectively.\n        Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\n        Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\n        Total of cherries: 12 + 12 = 24.\n        Example 2:\n        Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n        Output: 28\n        Explanation: Path of robot #1 and #2 are described in color green and blue respectively.\n        Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\n        Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\n        Total of cherries: 17 + 11 = 28.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1168,"row":{"number":1450,"difficulty":0,"question":"class Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\n        \"\"\"\n        Given two integer arrays startTime and endTime and given an integer queryTime.\n        The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\n        Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.\n        Example 1:\n        Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\n        Output: 1\n        Explanation: We have 3 students where:\n        The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\n        The second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\n        The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\n        Example 2:\n        Input: startTime = [4], endTime = [4], queryTime = 4\n        Output: 1\n        Explanation: The only student was doing their homework at the queryTime.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1169,"row":{"number":1451,"difficulty":1,"question":"class Solution:\n    def arrangeWords(self, text: str) -> str:\n        \"\"\"\n        Given a sentence text (A sentence is a string of space-separated words) in the following format:\n            First letter is in upper case.\n            Each word in text are separated by a single space.\n        Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\n        Return the new text following the format shown above.\n        Example 1:\n        Input: text = \"Leetcode is cool\"\n        Output: \"Is cool leetcode\"\n        Explanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\n        Output is ordered by length and the new first word starts with capital letter.\n        Example 2:\n        Input: text = \"Keep calm and code on\"\n        Output: \"On and keep calm code\"\n        Explanation: Output is ordered as follows:\n        \"On\" 2 letters.\n        \"and\" 3 letters.\n        \"keep\" 4 letters in case of tie order by position in original text.\n        \"calm\" 4 letters.\n        \"code\" 4 letters.\n        Example 3:\n        Input: text = \"To be or not to be\"\n        Output: \"To be or to be not\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1170,"row":{"number":1452,"difficulty":1,"question":"class Solution:\n    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:\n        \"\"\"\n        Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0).\n        Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.\n        Example 1:\n        Input: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"google\",\"microsoft\"],[\"google\",\"facebook\"],[\"google\"],[\"amazon\"]]\n        Output: [0,1,4] \n        Explanation: \n        Person with index=2 has favoriteCompanies[2]=[\"google\",\"facebook\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] corresponding to the person with index 0. \n        Person with index=3 has favoriteCompanies[3]=[\"google\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] and favoriteCompanies[1]=[\"google\",\"microsoft\"]. \n        Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].\n        Example 2:\n        Input: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"leetcode\",\"amazon\"],[\"facebook\",\"google\"]]\n        Output: [0,1] \n        Explanation: In this case favoriteCompanies[2]=[\"facebook\",\"google\"] is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"], therefore, the answer is [0,1].\n        Example 3:\n        Input: favoriteCompanies = [[\"leetcode\"],[\"google\"],[\"facebook\"],[\"amazon\"]]\n        Output: [0,1,2,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1171,"row":{"number":1453,"difficulty":2,"question":"class Solution:\n    def numPoints(self, darts: List[List[int]], r: int) -> int:\n        \"\"\"\n        Alice is throwing n darts on a very large wall. You are given an array darts where darts[i] = [xi, yi] is the position of the ith dart that Alice threw on the wall.\n        Bob knows the positions of the n darts on the wall. He wants to place a dartboard of radius r on the wall so that the maximum number of darts that Alice throws lies on the dartboard.\n        Given the integer r, return the maximum number of darts that can lie on the dartboard.\n        Example 1:\n        Input: darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\n        Output: 4\n        Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.\n        Example 2:\n        Input: darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\n        Output: 5\n        Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1172,"row":{"number":1455,"difficulty":0,"question":"class Solution:\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n        \"\"\"\n        Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence.\n        Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.\n        A prefix of a string s is any leading contiguous substring of s.\n        Example 1:\n        Input: sentence = \"i love eating burger\", searchWord = \"burg\"\n        Output: 4\n        Explanation: \"burg\" is prefix of \"burger\" which is the 4th word in the sentence.\n        Example 2:\n        Input: sentence = \"this problem is an easy problem\", searchWord = \"pro\"\n        Output: 2\n        Explanation: \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index.\n        Example 3:\n        Input: sentence = \"i am tired\", searchWord = \"you\"\n        Output: -1\n        Explanation: \"you\" is not a prefix of any word in the sentence.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1173,"row":{"number":1456,"difficulty":1,"question":"class Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        \"\"\"\n        Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.\n        Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.\n        Example 1:\n        Input: s = \"abciiidef\", k = 3\n        Output: 3\n        Explanation: The substring \"iii\" contains 3 vowel letters.\n        Example 2:\n        Input: s = \"aeiou\", k = 2\n        Output: 2\n        Explanation: Any substring of length 2 contains 2 vowels.\n        Example 3:\n        Input: s = \"leetcode\", k = 3\n        Output: 2\n        Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1174,"row":{"number":1457,"difficulty":1,"question":"class Solution:\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.\n        Return the number of pseudo-palindromic paths going from the root node to leaf nodes.\n        Example 1:\n        Input: root = [2,3,1,3,1,null,1]\n        Output: 2 \n        Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).\n        Example 2:\n        Input: root = [2,1,1,1,3,null,null,null,null,null,1]\n        Output: 1 \n        Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).\n        Example 3:\n        Input: root = [9]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1175,"row":{"number":1458,"difficulty":2,"question":"class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        Given two arrays nums1 and nums2.\n        Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.\n        A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).\n        Example 1:\n        Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\n        Output: 18\n        Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\n        Their dot product is (2*3 + (-2)*(-6)) = 18.\n        Example 2:\n        Input: nums1 = [3,-2], nums2 = [2,-6,7]\n        Output: 21\n        Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\n        Their dot product is (3*7) = 21.\n        Example 3:\n        Input: nums1 = [-1,-1], nums2 = [1,1]\n        Output: -1\n        Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\n        Their dot product is -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1176,"row":{"number":1475,"difficulty":0,"question":"class Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer array prices where prices[i] is the price of the ith item in a shop.\n        There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.\n        Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.\n        Example 1:\n        Input: prices = [8,4,6,2,3]\n        Output: [4,2,4,2,3]\n        Explanation: \n        For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.\n        For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.\n        For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.\n        For items 3 and 4 you will not receive any discount at all.\n        Example 2:\n        Input: prices = [1,2,3,4,5]\n        Output: [1,2,3,4,5]\n        Explanation: In this case, for all items, you will not receive any discount at all.\n        Example 3:\n        Input: prices = [10,1,1,6]\n        Output: [9,0,1,6]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1177,"row":{"number":1478,"difficulty":2,"question":"class Solution:\n    def minDistance(self, houses: List[int], k: int) -> int:\n        \"\"\"\n        Given the array houses where houses[i] is the location of the ith house along a street and an integer k, allocate k mailboxes in the street.\n        Return the minimum total distance between each house and its nearest mailbox.\n        The test cases are generated so that the answer fits in a 32-bit integer.\n        Example 1:\n        Input: houses = [1,4,8,10,20], k = 3\n        Output: 5\n        Explanation: Allocate mailboxes in position 3, 9 and 20.\n        Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n        Example 2:\n        Input: houses = [2,3,5,12,18], k = 2\n        Output: 9\n        Explanation: Allocate mailboxes in position 3 and 14.\n        Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1178,"row":{"number":1476,"difficulty":1,"question":"class SubrectangleQueries:\n    def __init__(self, rectangle: List[List[int]]):\n    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:\n    def getValue(self, row: int, col: int) -> int:\n        \"\"\"\n        Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:\n        1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)\n            Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).\n        2. getValue(int row, int col)\n            Returns the current value of the coordinate (row,col) from the rectangle.\n        Example 1:\n        Input\n        [\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\"]\n        [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]\n        Output\n        [null,1,null,5,5,null,10,5]\n        Explanation\n        SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  \n        // The initial rectangle (4x3) looks like:\n        // 1 2 1\n        // 4 3 4\n        // 3 2 1\n        // 1 1 1\n        subrectangleQueries.getValue(0, 2); // return 1\n        subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);\n        // After this update the rectangle looks like:\n        // 5 5 5\n        // 5 5 5\n        // 5 5 5\n        // 5 5 5 \n        subrectangleQueries.getValue(0, 2); // return 5\n        subrectangleQueries.getValue(3, 1); // return 5\n        subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);\n        // After this update the rectangle looks like:\n        // 5   5   5\n        // 5   5   5\n        // 5   5   5\n        // 10  10  10 \n        subrectangleQueries.getValue(3, 1); // return 10\n        subrectangleQueries.getValue(0, 2); // return 5\n        Example 2:\n        Input\n        [\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\"]\n        [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]\n        Output\n        [null,1,null,100,100,null,20]\n        Explanation\n        SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);\n        subrectangleQueries.getValue(0, 0); // return 1\n        subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);\n        subrectangleQueries.getValue(0, 0); // return 100\n        subrectangleQueries.getValue(2, 2); // return 100\n        subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);\n        subrectangleQueries.getValue(2, 2); // return 20\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1179,"row":{"number":1477,"difficulty":1,"question":"class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        \"\"\"\n        You are given an array of integers arr and an integer target.\n        You have to find two non-overlapping sub-arrays of arr each with a sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.\n        Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.\n        Example 1:\n        Input: arr = [3,2,2,4,3], target = 3\n        Output: 2\n        Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\n        Example 2:\n        Input: arr = [7,3,4,7], target = 7\n        Output: 2\n        Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n        Example 3:\n        Input: arr = [4,3,2,6,2,3,4], target = 6\n        Output: -1\n        Explanation: We have only one sub-array of sum = 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1180,"row":{"number":1464,"difficulty":0,"question":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        \"\"\"\n        Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).\n        Example 1:\n        Input: nums = [3,4,5,2]\n        Output: 12 \n        Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. \n        Example 2:\n        Input: nums = [1,5,4,5]\n        Output: 16\n        Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.\n        Example 3:\n        Input: nums = [3,7]\n        Output: 12\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1181,"row":{"number":1465,"difficulty":1,"question":"class Solution:\n    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:\n        \"\"\"\n        You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:\n            horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and\n            verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.\n        Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 109 + 7.\n        Example 1:\n        Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]\n        Output: 4 \n        Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.\n        Example 2:\n        Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]\n        Output: 6\n        Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.\n        Example 3:\n        Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]\n        Output: 9\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1182,"row":{"number":1466,"difficulty":1,"question":"class Solution:\n    def minReorder(self, n: int, connections: List[List[int]]) -> int:\n        \"\"\"\n        There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n        Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.\n        This year, there will be a big event in the capital (city 0), and many people want to travel to this city.\n        Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.\n        It's guaranteed that each city can reach city 0 after reorder.\n        Example 1:\n        Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\n        Output: 3\n        Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).\n        Example 2:\n        Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\n        Output: 2\n        Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).\n        Example 3:\n        Input: n = 3, connections = [[1,0],[2,0]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1183,"row":{"number":1467,"difficulty":2,"question":"class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        \"\"\"\n        Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\n        All the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\n        Please note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\n        Return the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.\n        Example 1:\n        Input: balls = [1,1]\n        Output: 1.00000\n        Explanation: Only 2 ways to divide the balls equally:\n        - A ball of color 1 to box 1 and a ball of color 2 to box 2\n        - A ball of color 2 to box 1 and a ball of color 1 to box 2\n        In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1\n        Example 2:\n        Input: balls = [2,1,1]\n        Output: 0.66667\n        Explanation: We have the set of balls [1, 1, 2, 3]\n        This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n        [1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\n        After that, we add the first two balls to the first box and the second two balls to the second box.\n        We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\n        Probability is 8/12 = 0.66667\n        Example 3:\n        Input: balls = [1,2,1,2]\n        Output: 0.60000\n        Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\n        Probability = 108 / 180 = 0.6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1184,"row":{"number":1470,"difficulty":0,"question":"class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        \"\"\"\n        Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].\r\n        Return the array in the form [x1,y1,x2,y2,...,xn,yn].\r\n        Example 1:\r\n        Input: nums = [2,5,1,3,4,7], n = 3\r\n        Output: [2,3,5,4,1,7] \r\n        Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].\r\n        Example 2:\r\n        Input: nums = [1,2,3,4,4,3,2,1], n = 4\r\n        Output: [1,4,2,3,3,2,4,1]\r\n        Example 3:\r\n        Input: nums = [1,1,2,2], n = 2\r\n        Output: [1,2,1,2]\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1185,"row":{"number":1471,"difficulty":1,"question":"class Solution:\n    def getStrongest(self, arr: List[int], k: int) -> List[int]:\n        \"\"\"\n        Given an array of integers arr and an integer k.\n        A value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array.\n        If |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j].\n        Return a list of the strongest k values in the array. return the answer in any arbitrary order.\n        Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed).\n            For arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] where m = ((5 - 1) / 2) = 2. The median is 6.\n            For arr = [-7, 22, 17,3], n = 4 and the median is obtained by sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] where m = ((4 - 1) / 2) = 1. The median is 3.\n        Example 1:\n        Input: arr = [1,2,3,4,5], k = 2\n        Output: [5,1]\n        Explanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.\n        Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.\n        Example 2:\n        Input: arr = [1,1,3,5,5], k = 2\n        Output: [5,5]\n        Explanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].\n        Example 3:\n        Input: arr = [6,7,11,7,6,8], k = 5\n        Output: [11,8,6,6,7]\n        Explanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].\n        Any permutation of [11,8,6,6,7] is accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1186,"row":{"number":1472,"difficulty":1,"question":"class BrowserHistory:\n    def __init__(self, homepage: str):\n    def visit(self, url: str) -> None:\n    def back(self, steps: int) -> str:\n    def forward(self, steps: int) -> str:\n        \"\"\"\n        You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.\n        Implement the BrowserHistory class:\n            BrowserHistory(string homepage) Initializes the object with the homepage of the browser.\n            void visit(string url) Visits url from the current page. It clears up all the forward history.\n            string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.\n            string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.\n        Example:\n        Input:\n        [\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"]\n        [[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]]\n        Output:\n        [null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"]\n        Explanation:\n        BrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\");\n        browserHistory.visit(\"google.com\");       // You are in \"leetcode.com\". Visit \"google.com\"\n        browserHistory.visit(\"facebook.com\");     // You are in \"google.com\". Visit \"facebook.com\"\n        browserHistory.visit(\"youtube.com\");      // You are in \"facebook.com\". Visit \"youtube.com\"\n        browserHistory.back(1);                   // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"\n        browserHistory.back(1);                   // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"\n        browserHistory.forward(1);                // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"\n        browserHistory.visit(\"linkedin.com\");     // You are in \"facebook.com\". Visit \"linkedin.com\"\n        browserHistory.forward(2);                // You are in \"linkedin.com\", you cannot move forward any steps.\n        browserHistory.back(2);                   // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"\n        browserHistory.back(7);                   // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1187,"row":{"number":1473,"difficulty":2,"question":"class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \"\"\"\n        There is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), some houses that have been painted last summer should not be painted again.\n        A neighborhood is a maximal group of continuous houses that are painted with the same color.\n            For example: houses = [1,2,2,3,3,2,1,1] contains 5 neighborhoods [{1}, {2,2}, {3,3}, {2}, {1,1}].\n        Given an array houses, an m x n matrix cost and an integer target where:\n            houses[i]: is the color of the house i, and 0 if the house is not painted yet.\n            cost[i][j]: is the cost of paint the house i with the color j + 1.\n        Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods. If it is not possible, return -1.\n        Example 1:\n        Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n        Output: 9\n        Explanation: Paint houses of this way [1,2,2,1,1]\n        This array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].\n        Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.\n        Example 2:\n        Input: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n        Output: 11\n        Explanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]\n        This array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. \n        Cost of paint the first and last house (10 + 1) = 11.\n        Example 3:\n        Input: houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\n        Output: -1\n        Explanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1188,"row":{"number":1491,"difficulty":0,"question":"class Solution:\n    def average(self, salary: List[int]) -> float:\n        \"\"\"\n        You are given an array of unique integers salary where salary[i] is the salary of the ith employee.\n        Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: salary = [4000,3000,1000,2000]\n        Output: 2500.00000\n        Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.\n        Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500\n        Example 2:\n        Input: salary = [1000,2000,3000]\n        Output: 2000.00000\n        Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.\n        Average salary excluding minimum and maximum salary is (2000) / 1 = 2000\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1189,"row":{"number":1492,"difficulty":1,"question":"class Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        \"\"\"\n        You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.\n        Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.\n        Example 1:\n        Input: n = 12, k = 3\n        Output: 3\n        Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.\n        Example 2:\n        Input: n = 7, k = 2\n        Output: 7\n        Explanation: Factors list is [1, 7], the 2nd factor is 7.\n        Example 3:\n        Input: n = 4, k = 4\n        Output: -1\n        Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1190,"row":{"number":1493,"difficulty":1,"question":"class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a binary array nums, you should delete one element from it.\n        Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.\n        Example 1:\n        Input: nums = [1,1,0,1]\n        Output: 3\n        Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.\n        Example 2:\n        Input: nums = [0,1,1,1,0,1,1,0,1]\n        Output: 5\n        Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].\n        Example 3:\n        Input: nums = [1,1,1]\n        Output: 2\n        Explanation: You must delete one element.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1191,"row":{"number":1494,"difficulty":2,"question":"class Solution:\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\n        \"\"\"\n        You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k.\n        In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking.\n        Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.\n        Example 1:\n        Input: n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\n        Output: 3\n        Explanation: The figure above represents the given graph.\n        In the first semester, you can take courses 2 and 3.\n        In the second semester, you can take course 1.\n        In the third semester, you can take course 4.\n        Example 2:\n        Input: n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\n        Output: 4\n        Explanation: The figure above represents the given graph.\n        In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\n        In the second semester, you can take course 4.\n        In the third semester, you can take course 1.\n        In the fourth semester, you can take course 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1192,"row":{"number":1480,"difficulty":0,"question":"class Solution:\r\n    def runningSum(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]nums[i]).\r\n        Return the running sum of nums.\r\n        Example 1:\r\n        Input: nums = [1,2,3,4]\r\n        Output: [1,3,6,10]\r\n        Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\r\n        Example 2:\r\n        Input: nums = [1,1,1,1,1]\r\n        Output: [1,2,3,4,5]\r\n        Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].\r\n        Example 3:\r\n        Input: nums = [3,1,2,10,1]\r\n        Output: [3,4,6,16,17]\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1193,"row":{"number":1481,"difficulty":1,"question":"class Solution:\r\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \"\"\"\n        Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.\r\n        Example 1:\r\n        Input: arr = [5,5,4], k = 1\r\n        Output: 1\r\n        Explanation: Remove the single 4, only 5 is left.\r\n        Example 2:\r\n        Input: arr = [4,3,1,1,3,3,2], k = 3\r\n        Output: 2\r\n        Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1194,"row":{"number":1482,"difficulty":1,"question":"class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \"\"\"\n        You are given an integer array bloomDay, an integer m and an integer k.\n        You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\n        The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\n        Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\n        Example 1:\n        Input: bloomDay = [1,10,3,10,2], m = 3, k = 1\n        Output: 3\n        Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\n        We need 3 bouquets each should contain 1 flower.\n        After day 1: [x, _, _, _, _]   // we can only make one bouquet.\n        After day 2: [x, _, _, _, x]   // we can only make two bouquets.\n        After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\n        Example 2:\n        Input: bloomDay = [1,10,3,10,2], m = 3, k = 2\n        Output: -1\n        Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n        Example 3:\n        Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n        Output: 12\n        Explanation: We need 2 bouquets each should have 3 flowers.\n        Here is the garden after the 7 and 12 days:\n        After day 7: [x, x, x, x, _, x, x]\n        We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\n        After day 12: [x, x, x, x, x, x, x]\n        It is obvious that we can make two bouquets in different ways.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1195,"row":{"number":1486,"difficulty":0,"question":"class Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        \"\"\"\n        You are given an integer n and an integer start.\n        Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length.\n        Return the bitwise XOR of all elements of nums.\n        Example 1:\n        Input: n = 5, start = 0\n        Output: 8\n        Explanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\n        Where \"^\" corresponds to bitwise XOR operator.\n        Example 2:\n        Input: n = 4, start = 3\n        Output: 8\n        Explanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1196,"row":{"number":1487,"difficulty":1,"question":"class Solution:\n    def getFolderNames(self, names: List[str]) -> List[str]:\n        \"\"\"\n        Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].\n        Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\n        Return an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\n        Example 1:\n        Input: names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\n        Output: [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\n        Explanation: Let's see how the file system creates folder names:\n        \"pes\" --> not assigned before, remains \"pes\"\n        \"fifa\" --> not assigned before, remains \"fifa\"\n        \"gta\" --> not assigned before, remains \"gta\"\n        \"pes(2019)\" --> not assigned before, remains \"pes(2019)\"\n        Example 2:\n        Input: names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\n        Output: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\n        Explanation: Let's see how the file system creates folder names:\n        \"gta\" --> not assigned before, remains \"gta\"\n        \"gta(1)\" --> not assigned before, remains \"gta(1)\"\n        \"gta\" --> the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\"\n        \"avalon\" --> not assigned before, remains \"avalon\"\n        Example 3:\n        Input: names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\n        Output: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\n        Explanation: When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1197,"row":{"number":1488,"difficulty":1,"question":"class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        \"\"\"\n        Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake.\n        Given an integer array rains where:\n            rains[i] > 0 means there will be rains over the rains[i] lake.\n            rains[i] == 0 means there are no rains this day and you can choose one lake this day and dry it.\n        Return an array ans where:\n            ans.length == rains.length\n            ans[i] == -1 if rains[i] > 0.\n            ans[i] is the lake you choose to dry in the ith day if rains[i] == 0.\n        If there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array.\n        Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.\n        Example 1:\n        Input: rains = [1,2,3,4]\n        Output: [-1,-1,-1,-1]\n        Explanation: After the first day full lakes are [1]\n        After the second day full lakes are [1,2]\n        After the third day full lakes are [1,2,3]\n        After the fourth day full lakes are [1,2,3,4]\n        There's no day to dry any lake and there is no flood in any lake.\n        Example 2:\n        Input: rains = [1,2,0,0,2,1]\n        Output: [-1,-1,2,1,-1,-1]\n        Explanation: After the first day full lakes are [1]\n        After the second day full lakes are [1,2]\n        After the third day, we dry lake 2. Full lakes are [1]\n        After the fourth day, we dry lake 1. There is no full lakes.\n        After the fifth day, full lakes are [2].\n        After the sixth day, full lakes are [1,2].\n        It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario.\n        Example 3:\n        Input: rains = [1,2,0,1,2]\n        Output: []\n        Explanation: After the second day, full lakes are  [1,2]. We have to dry one lake in the third day.\n        After that, it will rain over lakes [1,2]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1198,"row":{"number":1489,"difficulty":2,"question":"class Solution:\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.\n        Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.\n        Note that you can return the indices of the edges in any order.\n        Example 1:\n        Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\n        Output: [[0,1],[2,3,4,5]]\n        Explanation: The figure above describes the graph.\n        The following figure shows all the possible MSTs:\n        Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\n        The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.\n        Example 2:\n        Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\n        Output: [[],[0,1,2,3]]\n        Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1199,"row":{"number":1508,"difficulty":1,"question":"class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \"\"\"\n        You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.\n        Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.\n        Example 1:\n        Input: nums = [1,2,3,4], n = 4, left = 1, right = 5\n        Output: 13 \n        Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. \n        Example 2:\n        Input: nums = [1,2,3,4], n = 4, left = 3, right = 4\n        Output: 6\n        Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.\n        Example 3:\n        Input: nums = [1,2,3,4], n = 4, left = 1, right = 10\n        Output: 50\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}