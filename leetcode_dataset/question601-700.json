{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":600,"row":{"number":705,"difficulty":0,"question":"class MyHashSet:\n    def __init__(self):\n    def add(self, key: int) -> None:\n    def remove(self, key: int) -> None:\n    def contains(self, key: int) -> bool:\n        \"\"\"\n        Design a HashSet without using any built-in hash table libraries.\n        Implement MyHashSet class:\n            void add(key) Inserts the value key into the HashSet.\n            bool contains(key) Returns whether the value key exists in the HashSet or not.\n            void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.\n        Example 1:\n        Input\n        [\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n        [[], [1], [2], [1], [3], [2], [2], [2], [2]]\n        Output\n        [null, null, null, true, false, null, true, null, false]\n        Explanation\n        MyHashSet myHashSet = new MyHashSet();\n        myHashSet.add(1);      // set = [1]\n        myHashSet.add(2);      // set = [1, 2]\n        myHashSet.contains(1); // return True\n        myHashSet.contains(3); // return False, (not found)\n        myHashSet.add(2);      // set = [1, 2]\n        myHashSet.contains(2); // return True\n        myHashSet.remove(2);   // set = [1]\n        myHashSet.contains(2); // return False, (already removed)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":601,"row":{"number":706,"difficulty":0,"question":"class MyHashMap:\n    def __init__(self):\n    def put(self, key: int, value: int) -> None:\n    def get(self, key: int) -> int:\n    def remove(self, key: int) -> None:\n        \"\"\"\n        Design a HashMap without using any built-in hash table libraries.\n        Implement the MyHashMap class:\n            MyHashMap() initializes the object with an empty map.\n            void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.\n            int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\n            void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.\n        Example 1:\n        Input\n        [\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n        [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n        Output\n        [null, null, null, 1, -1, null, 1, null, -1]\n        Explanation\n        MyHashMap myHashMap = new MyHashMap();\n        myHashMap.put(1, 1); // The map is now [[1,1]]\n        myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\n        myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\n        myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\n        myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\n        myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\n        myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\n        myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":602,"row":{"number":801,"difficulty":2,"question":"class Solution:\n    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two integer arrays of the same length nums1 and nums2. In one operation, you are allowed to swap nums1[i] with nums2[i].\n            For example, if nums1 = [1,2,3,8], and nums2 = [5,6,7,4], you can swap the element at i = 3 to obtain nums1 = [1,2,3,4] and nums2 = [5,6,7,8].\n        Return the minimum number of needed operations to make nums1 and nums2 strictly increasing. The test cases are generated so that the given input always makes it possible.\n        An array arr is strictly increasing if and only if arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1].\n        Example 1:\n        Input: nums1 = [1,3,5,4], nums2 = [1,2,3,7]\n        Output: 1\n        Explanation: \n        Swap nums1[3] and nums2[3]. Then the sequences are:\n        nums1 = [1, 3, 5, 7] and nums2 = [1, 2, 3, 4]\n        which are both strictly increasing.\n        Example 2:\n        Input: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":603,"row":{"number":802,"difficulty":1,"question":"class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \"\"\"\n        There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].\n        A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).\n        Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.\n        Example 1:\n        Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n        Output: [2,4,5,6]\n        Explanation: The given graph is shown above.\n        Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\n        Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n        Example 2:\n        Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n        Output: [4]\n        Explanation:\n        Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":604,"row":{"number":803,"difficulty":2,"question":"class Solution:\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if:\n            It is directly connected to the top of the grid, or\n            At least one other brick in its four adjacent cells is stable.\n        You are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks).\n        Return an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied.\n        Note that an erasure may refer to a location with no brick, and if it does, no bricks drop.\n        Example 1:\n        Input: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\n        Output: [2]\n        Explanation: Starting with the grid:\n        [[1,0,0,0],\n         [1,1,1,0]]\n        We erase the underlined brick at (1,0), resulting in the grid:\n        [[1,0,0,0],\n         [0,1,1,0]]\n        The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:\n        [[1,0,0,0],\n         [0,0,0,0]]\n        Hence the result is [2].\n        Example 2:\n        Input: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\n        Output: [0,0]\n        Explanation: Starting with the grid:\n        [[1,0,0,0],\n         [1,1,0,0]]\n        We erase the underlined brick at (1,1), resulting in the grid:\n        [[1,0,0,0],\n         [1,0,0,0]]\n        All remaining bricks are still stable, so no bricks fall. The grid remains the same:\n        [[1,0,0,0],\n         [1,0,0,0]]\n        Next, we erase the underlined brick at (1,0), resulting in the grid:\n        [[1,0,0,0],\n         [0,0,0,0]]\n        Once again, all remaining bricks are still stable, so no bricks fall.\n        Hence the result is [0,0].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":605,"row":{"number":804,"difficulty":0,"question":"class Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        \"\"\"\n        International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\n            'a' maps to \".-\",\n            'b' maps to \"-...\",\n            'c' maps to \"-.-.\", and so on.\n        For convenience, the full table for the 26 letters of the English alphabet is given below:\n        [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter.\n            For example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word.\n        Return the number of different transformations among all words we have.\n        Example 1:\n        Input: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\n        Output: 2\n        Explanation: The transformation of each word is:\n        \"gin\" -> \"--...-.\"\n        \"zen\" -> \"--...-.\"\n        \"gig\" -> \"--...--.\"\n        \"msg\" -> \"--...--.\"\n        There are 2 different transformations: \"--...-.\" and \"--...--.\".\n        Example 2:\n        Input: words = [\"a\"]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":606,"row":{"number":805,"difficulty":2,"question":"class Solution:\n    def splitArraySameAverage(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums.\n        You should move each element of nums into one of the two arrays A and B such that A and B are non-empty, and average(A) == average(B).\n        Return true if it is possible to achieve that and false otherwise.\n        Note that for an array arr, average(arr) is the sum of all the elements of arr over the length of arr.\n        Example 1:\n        Input: nums = [1,2,3,4,5,6,7,8]\n        Output: true\n        Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5.\n        Example 2:\n        Input: nums = [3,1]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":607,"row":{"number":806,"difficulty":0,"question":"class Solution:\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\n        \"\"\"\n        You are given a string s of lowercase English letters and an array widths denoting how many pixels wide each lowercase English letter is. Specifically, widths[0] is the width of 'a', widths[1] is the width of 'b', and so on.\n        You are trying to write s across several lines, where each line is no longer than 100 pixels. Starting at the beginning of s, write as many letters on the first line such that the total width does not exceed 100 pixels. Then, from where you stopped in s, continue writing as many letters as you can on the second line. Continue this process until you have written all of s.\n        Return an array result of length 2 where:\n            result[0] is the total number of lines.\n            result[1] is the width of the last line in pixels.\n        Example 1:\n        Input: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\"\n        Output: [3,60]\n        Explanation: You can write s as follows:\n        abcdefghij  // 100 pixels wide\n        klmnopqrst  // 100 pixels wide\n        uvwxyz      // 60 pixels wide\n        There are a total of 3 lines, and the last line is 60 pixels wide.\n        Example 2:\n        Input: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaa\"\n        Output: [2,4]\n        Explanation: You can write s as follows:\n        bbbcccdddaa  // 98 pixels wide\n        a            // 4 pixels wide\n        There are a total of 2 lines, and the last line is 4 pixels wide.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":608,"row":{"number":807,"difficulty":1,"question":"class Solution:\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c.\n        A city's skyline is the the outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different.\n        We are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction.\n        Return the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\n        Example 1:\n        Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\n        Output: 35\n        Explanation: The building heights are shown in the center of the above image.\n        The skylines when viewed from each cardinal direction are drawn in red.\n        The grid after increasing the height of buildings without affecting skylines is:\n        gridNew = [ [8, 4, 8, 7],\n                    [7, 4, 7, 7],\n                    [9, 4, 8, 7],\n                    [3, 3, 3, 3] ]\n        Example 2:\n        Input: grid = [[0,0,0],[0,0,0],[0,0,0]]\n        Output: 0\n        Explanation: Increasing the height of any building will result in the skyline changing.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":609,"row":{"number":808,"difficulty":1,"question":"class Solution:\n    def soupServings(self, n: int) -> float:\n        \"\"\"\n        There are two types of soup: type A and type B. Initially, we have n ml of each type of soup. There are four kinds of operations:\n            Serve 100 ml of soup A and 0 ml of soup B,\n            Serve 75 ml of soup A and 25 ml of soup B,\n            Serve 50 ml of soup A and 50 ml of soup B, and\n            Serve 25 ml of soup A and 75 ml of soup B.\n        When we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.\n        Note that we do not have an operation where all 100 ml's of soup B are used first.\n        Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: n = 50\n        Output: 0.62500\n        Explanation: If we choose the first two operations, A will become empty first.\n        For the third operation, A and B will become empty at the same time.\n        For the fourth operation, B will become empty first.\n        So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.\n        Example 2:\n        Input: n = 100\n        Output: 0.71875\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":610,"row":{"number":809,"difficulty":1,"question":"class Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        \"\"\"\n        Sometimes people repeat letters to represent extra feeling. For example:\n            \"hello\" -> \"heeellooo\"\n            \"hi\" -> \"hiiii\"\n        In these strings like \"heeellooo\", we have groups of adjacent letters that are all the same: \"h\", \"eee\", \"ll\", \"ooo\".\n        You are given a string s and an array of query strings words. A query word is stretchy if it can be made to be equal to s by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is three or more.\n            For example, starting with \"hello\", we could do an extension on the group \"o\" to get \"hellooo\", but we cannot get \"helloo\" since the group \"oo\" has a size less than three. Also, we could do another extension like \"ll\" -> \"lllll\" to get \"helllllooo\". If s = \"helllllooo\", then the query word \"hello\" would be stretchy because of these two extension operations: query = \"hello\" -> \"hellooo\" -> \"helllllooo\" = s.\n        Return the number of query strings that are stretchy.\n        Example 1:\n        Input: s = \"heeellooo\", words = [\"hello\", \"hi\", \"helo\"]\n        Output: 1\n        Explanation: \n        We can extend \"e\" and \"o\" in the word \"hello\" to get \"heeellooo\".\n        We can't extend \"helo\" to get \"heeellooo\" because the group \"ll\" is not size 3 or more.\n        Example 2:\n        Input: s = \"zzzzzyyyyy\", words = [\"zzyy\",\"zy\",\"zyy\"]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":611,"row":{"number":810,"difficulty":2,"question":"class Solution:\n    def xorGame(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an array of integers nums represents the numbers written on a chalkboard.\n        Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.\n        Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.\n        Return true if and only if Alice wins the game, assuming both players play optimally.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: false\n        Explanation: \n        Alice has two choices: erase 1 or erase 2. \n        If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \n        If Alice erases 2 first, now nums become [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\n        Example 2:\n        Input: nums = [0,1]\n        Output: true\n        Example 3:\n        Input: nums = [1,2,3]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":612,"row":{"number":811,"difficulty":1,"question":"class Solution:\n    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:\n        \"\"\"\n        A website domain \"discuss.leetcode.com\" consists of various subdomains. At the top level, we have \"com\", at the next level, we have \"leetcode.com\" and at the lowest level, \"discuss.leetcode.com\". When we visit a domain like \"discuss.leetcode.com\", we will also visit the parent domains \"leetcode.com\" and \"com\" implicitly.\n        A count-paired domain is a domain that has one of the two formats \"rep d1.d2.d3\" or \"rep d1.d2\" where rep is the number of visits to the domain and d1.d2.d3 is the domain itself.\n            For example, \"9001 discuss.leetcode.com\" is a count-paired domain that indicates that discuss.leetcode.com was visited 9001 times.\n        Given an array of count-paired domains cpdomains, return an array of the count-paired domains of each subdomain in the input. You may return the answer in any order.\n        Example 1:\n        Input: cpdomains = [\"9001 discuss.leetcode.com\"]\n        Output: [\"9001 leetcode.com\",\"9001 discuss.leetcode.com\",\"9001 com\"]\n        Explanation: We only have one website domain: \"discuss.leetcode.com\".\n        As discussed above, the subdomain \"leetcode.com\" and \"com\" will also be visited. So they will all be visited 9001 times.\n        Example 2:\n        Input: cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]\n        Output: [\"901 mail.com\",\"50 yahoo.com\",\"900 google.mail.com\",\"5 wiki.org\",\"5 org\",\"1 intel.mail.com\",\"951 com\"]\n        Explanation: We will visit \"google.mail.com\" 900 times, \"yahoo.com\" 50 times, \"intel.mail.com\" once and \"wiki.org\" 5 times.\n        For the subdomains, we will visit \"mail.com\" 900 + 1 = 901 times, \"com\" 900 + 50 + 1 = 951 times, and \"org\" 5 times.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":613,"row":{"number":812,"difficulty":0,"question":"class Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        \"\"\"\n        Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n        Output: 2.00000\n        Explanation: The five points are shown in the above figure. The red triangle is the largest.\n        Example 2:\n        Input: points = [[1,0],[0,0],[0,1]]\n        Output: 0.50000\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":614,"row":{"number":813,"difficulty":1,"question":"class Solution:\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\n        \"\"\"\n        You are given an integer array nums and an integer k. You can partition the array into at most k non-empty adjacent subarrays. The score of a partition is the sum of the averages of each subarray.\n        Note that the partition must use every integer in nums, and that the score is not necessarily an integer.\n        Return the maximum score you can achieve of all the possible partitions. Answers within 10-6 of the actual answer will be accepted.\n        Example 1:\n        Input: nums = [9,1,2,3,9], k = 3\n        Output: 20.00000\n        Explanation: \n        The best choice is to partition nums into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\n        We could have also partitioned nums into [9, 1], [2], [3, 9], for example.\n        That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n        Example 2:\n        Input: nums = [1,2,3,4,5,6,7], k = 4\n        Output: 20.50000\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":615,"row":{"number":814,"difficulty":1,"question":"class Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.\n        A subtree of a node node is node plus every node that is a descendant of node.\n        Example 1:\n        Input: root = [1,null,0,0,1]\n        Output: [1,null,0,null,1]\n        Explanation: \n        Only the red nodes satisfy the property \"every subtree not containing a 1\".\n        The diagram on the right represents the answer.\n        Example 2:\n        Input: root = [1,0,1,0,0,0,1]\n        Output: [1,null,1,null,1]\n        Example 3:\n        Input: root = [1,1,0,1,1,0,1,0]\n        Output: [1,1,0,1,1,null,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":616,"row":{"number":815,"difficulty":2,"question":"class Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        \"\"\"\n        You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.\n            For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.\n        You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.\n        Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.\n        Example 1:\n        Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n        Output: 2\n        Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n        Example 2:\n        Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":617,"row":{"number":816,"difficulty":1,"question":"class Solution:\n    def ambiguousCoordinates(self, s: str) -> List[str]:\n        \"\"\"\n        We had some 2-dimensional coordinates, like \"(1, 3)\" or \"(2, 0.5)\". Then, we removed all commas, decimal points, and spaces and ended up with the string s.\n            For example, \"(1, 3)\" becomes s = \"(13)\" and \"(2, 0.5)\" becomes s = \"(205)\".\n        Return a list of strings representing all possibilities for what our original coordinates could have been.\n        Our original representation never had extraneous zeroes, so we never started with numbers like \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like \".1\".\n        The final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)\n        Example 1:\n        Input: s = \"(123)\"\n        Output: [\"(1, 2.3)\",\"(1, 23)\",\"(1.2, 3)\",\"(12, 3)\"]\n        Example 2:\n        Input: s = \"(0123)\"\n        Output: [\"(0, 1.23)\",\"(0, 12.3)\",\"(0, 123)\",\"(0.1, 2.3)\",\"(0.1, 23)\",\"(0.12, 3)\"]\n        Explanation: 0.0, 00, 0001 or 00.01 are not allowed.\n        Example 3:\n        Input: s = \"(00011)\"\n        Output: [\"(0, 0.011)\",\"(0.001, 1)\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":618,"row":{"number":817,"difficulty":1,"question":"class Solution:\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\n        \"\"\"\n        You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values.\n        Return the number of connected components in nums where two values are connected if they appear consecutively in the linked list.\n        Example 1:\n        Input: head = [0,1,2,3], nums = [0,1,3]\n        Output: 2\n        Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\n        Example 2:\n        Input: head = [0,1,2,3,4], nums = [0,3,1,4]\n        Output: 2\n        Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":619,"row":{"number":818,"difficulty":2,"question":"class Solution:\n    def racecar(self, target: int) -> int:\n        \"\"\"\n        Your car starts at position 0 and speed +1 on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions 'A' (accelerate) and 'R' (reverse):\n            When you get an instruction 'A', your car does the following:\n                position += speed\n                speed *= 2\n            When you get an instruction 'R', your car does the following:\n                If your speed is positive then speed = -1\n                otherwise speed = 1\n            Your position stays the same.\n        For example, after commands \"AAR\", your car goes to positions 0 --> 1 --> 3 --> 3, and your speed goes to 1 --> 2 --> 4 --> -1.\n        Given a target position target, return the length of the shortest sequence of instructions to get there.\n        Example 1:\n        Input: target = 3\n        Output: 2\n        Explanation: \n        The shortest instruction sequence is \"AA\".\n        Your position goes from 0 --> 1 --> 3.\n        Example 2:\n        Input: target = 6\n        Output: 5\n        Explanation: \n        The shortest instruction sequence is \"AAARA\".\n        Your position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":620,"row":{"number":819,"difficulty":0,"question":"class Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        \"\"\"\n        Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\n        The words in paragraph are case-insensitive and the answer should be returned in lowercase.\n        Example 1:\n        Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\n        Output: \"ball\"\n        Explanation: \n        \"hit\" occurs 3 times, but it is a banned word.\n        \"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \n        Note that words in the paragraph are not case sensitive,\n        that punctuation is ignored (even if adjacent to words, such as \"ball,\"), \n        and that \"hit\" isn't the answer even though it occurs more because it is banned.\n        Example 2:\n        Input: paragraph = \"a.\", banned = []\n        Output: \"a\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":621,"row":{"number":707,"difficulty":1,"question":"class MyLinkedList:\n    def __init__(self):\n    def get(self, index: int) -> int:\n    def addAtHead(self, val: int) -> None:\n    def addAtTail(self, val: int) -> None:\n    def addAtIndex(self, index: int, val: int) -> None:\n    def deleteAtIndex(self, index: int) -> None:\n        \"\"\"\n        Design your implementation of the linked list. You can choose to use a singly or doubly linked list.\n        A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.\n        If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.\n        Implement the MyLinkedList class:\n            MyLinkedList() Initializes the MyLinkedList object.\n            int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.\n            void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n            void addAtTail(int val) Append a node of value val as the last element of the linked list.\n            void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.\n            void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.\n        Example 1:\n        Input\n        [\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n        [[], [1], [3], [1, 2], [1], [1], [1]]\n        Output\n        [null, null, null, null, 2, null, 3]\n        Explanation\n        MyLinkedList myLinkedList = new MyLinkedList();\n        myLinkedList.addAtHead(1);\n        myLinkedList.addAtTail(3);\n        myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3\n        myLinkedList.get(1);              // return 2\n        myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3\n        myLinkedList.get(1);              // return 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":622,"row":{"number":820,"difficulty":1,"question":"class Solution:\n    def minimumLengthEncoding(self, words: List[str]) -> int:\n        \"\"\"\n        A valid encoding of an array of words is any reference string s and array of indices indices such that:\n            words.length == indices.length\n            The reference string s ends with the '#' character.\n            For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i].\n        Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.\n        Example 1:\n        Input: words = [\"time\", \"me\", \"bell\"]\n        Output: 10\n        Explanation: A valid encoding would be s = \"time#bell#\" and indices = [0, 2, 5].\n        words[0] = \"time\", the substring of s starting from indices[0] = 0 to the next '#' is underlined in \"time#bell#\"\n        words[1] = \"me\", the substring of s starting from indices[1] = 2 to the next '#' is underlined in \"time#bell#\"\n        words[2] = \"bell\", the substring of s starting from indices[2] = 5 to the next '#' is underlined in \"time#bell#\"\n        Example 2:\n        Input: words = [\"t\"]\n        Output: 2\n        Explanation: A valid encoding would be s = \"t#\" and indices = [0].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":623,"row":{"number":821,"difficulty":0,"question":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\n        The distance between two indices i and j is abs(i - j), where abs is the absolute value function.\n        Example 1:\n        Input: s = \"loveleetcode\", c = \"e\"\n        Output: [3,2,1,0,1,0,0,1,2,2,1,0]\n        Explanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\n        The closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\n        The closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.\n        For index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\n        The closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\n        Example 2:\n        Input: s = \"aaab\", c = \"b\"\n        Output: [3,2,1,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":624,"row":{"number":822,"difficulty":1,"question":"class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        \"\"\"\n        You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero).\n        After flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card.\n        Return the minimum possible good integer after flipping the cards. If there are no good integers, return 0.\n        Example 1:\n        Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\n        Output: 2\n        Explanation:\n        If we flip the second card, the face up numbers are [1,3,4,4,7] and the face down are [1,2,4,1,3].\n        2 is the minimum good integer as it appears facing down but not facing up.\n        It can be shown that 2 is the minimum possible good integer obtainable after flipping some cards.\n        Example 2:\n        Input: fronts = [1], backs = [1]\n        Output: 0\n        Explanation:\n        There are no good integers no matter how we flip the cards, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":625,"row":{"number":823,"difficulty":1,"question":"class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\n        We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\n        Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.\n        Example 1:\n        Input: arr = [2,4]\n        Output: 3\n        Explanation: We can make these trees: [2], [4], [4, 2, 2]\n        Example 2:\n        Input: arr = [2,4,5,10]\n        Output: 7\n        Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":626,"row":{"number":824,"difficulty":0,"question":"class Solution:\n    def toGoatLatin(self, sentence: str) -> str:\n        \"\"\"\n        You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\n        We would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n            If a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n                For example, the word \"apple\" becomes \"applema\".\n            If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n                For example, the word \"goat\" becomes \"oatgma\".\n            Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n                For example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n        Return the final sentence representing the conversion from sentence to Goat Latin.\n        Example 1:\n        Input: sentence = \"I speak Goat Latin\"\n        Output: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n        Example 2:\n        Input: sentence = \"The quick brown fox jumped over the lazy dog\"\n        Output: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":627,"row":{"number":825,"difficulty":1,"question":"class Solution:\n    def numFriendRequests(self, ages: List[int]) -> int:\n        \"\"\"\n        There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person.\n        A Person x will not send a friend request to a person y (x != y) if any of the following conditions is true:\n            age[y] <= 0.5 * age[x] + 7\n            age[y] > age[x]\n            age[y] > 100 && age[x] < 100\n        Otherwise, x will send a friend request to y.\n        Note that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself.\n        Return the total number of friend requests made.\n        Example 1:\n        Input: ages = [16,16]\n        Output: 2\n        Explanation: 2 people friend request each other.\n        Example 2:\n        Input: ages = [16,17,18]\n        Output: 2\n        Explanation: Friend requests are made 17 -> 16, 18 -> 17.\n        Example 3:\n        Input: ages = [20,30,100,110,120]\n        Output: 3\n        Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":628,"row":{"number":826,"difficulty":1,"question":"class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        \"\"\"\n        You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n            difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\n            worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n        Every worker can be assigned at most one job, but one job can be completed multiple times.\n            For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n        Return the maximum profit we can achieve after assigning the workers to the jobs.\n        Example 1:\n        Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\n        Output: 100\n        Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n        Example 2:\n        Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":629,"row":{"number":827,"difficulty":2,"question":"class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\r\n        Return the size of the largest island in grid after applying this operation.\r\n        An island is a 4-directionally connected group of 1s.\r\n        Example 1:\r\n        Input: grid = [[1,0],[0,1]]\r\n        Output: 3\r\n        Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\r\n        Example 2:\r\n        Input: grid = [[1,1],[1,0]]\r\n        Output: 4\r\n        Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.\r\n        Example 3:\r\n        Input: grid = [[1,1],[1,1]]\r\n        Output: 4\r\n        Explanation: Can't change any 0 to 1, only one island with area = 4.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":630,"row":{"number":828,"difficulty":2,"question":"class Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        \"\"\"\n        Let's define a function countUniqueChars(s) that returns the number of unique characters on s.\n            For example, calling countUniqueChars(s) if s = \"LEETCODE\" then \"L\", \"T\", \"C\", \"O\", \"D\" are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5.\n        Given a string s, return the sum of countUniqueChars(t) where t is a substring of s. The test cases are generated such that the answer fits in a 32-bit integer.\n        Notice that some substrings can be repeated so in this case you have to count the repeated ones too.\n        Example 1:\n        Input: s = \"ABC\"\n        Output: 10\n        Explanation: All possible substrings are: \"A\",\"B\",\"C\",\"AB\",\"BC\" and \"ABC\".\n        Every substring is composed with only unique letters.\n        Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n        Example 2:\n        Input: s = \"ABA\"\n        Output: 8\n        Explanation: The same as example 1, except countUniqueChars(\"ABA\") = 1.\n        Example 3:\n        Input: s = \"LEETCODE\"\n        Output: 92\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":631,"row":{"number":829,"difficulty":2,"question":"class Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.\n        Example 1:\n        Input: n = 5\n        Output: 2\n        Explanation: 5 = 2 + 3\n        Example 2:\n        Input: n = 9\n        Output: 3\n        Explanation: 9 = 4 + 5 = 2 + 3 + 4\n        Example 3:\n        Input: n = 15\n        Output: 4\n        Explanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":632,"row":{"number":830,"difficulty":0,"question":"class Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        \"\"\"\n        In a string s of lowercase letters, these letters form consecutive groups of the same character.\n        For example, a string like s = \"abbxxxxzyy\" has the groups \"a\", \"bb\", \"xxxx\", \"z\", and \"yy\".\n        A group is identified by an interval [start, end], where start and end denote the start and end indices (inclusive) of the group. In the above example, \"xxxx\" has the interval [3,6].\n        A group is considered large if it has 3 or more characters.\n        Return the intervals of every large group sorted in increasing order by start index.\n        Example 1:\n        Input: s = \"abbxxxxzzy\"\n        Output: [[3,6]]\n        Explanation: \"xxxx\" is the only large group with start index 3 and end index 6.\n        Example 2:\n        Input: s = \"abc\"\n        Output: []\n        Explanation: We have groups \"a\", \"b\", and \"c\", none of which are large groups.\n        Example 3:\n        Input: s = \"abcdddeeeeaabbbcd\"\n        Output: [[3,5],[6,9],[12,14]]\n        Explanation: The large groups are \"ddd\", \"eeee\", and \"bbb\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":633,"row":{"number":831,"difficulty":1,"question":"class Solution:\n    def maskPII(self, s: str) -> str:\n        \"\"\"\n        You are given a personal information string s, representing either an email address or a phone number. Return the masked personal information using the below rules.\n        Email address:\n        An email address is:\n            A name consisting of uppercase and lowercase English letters, followed by\n            The '@' symbol, followed by\n            The domain consisting of uppercase and lowercase English letters with a dot '.' somewhere in the middle (not the first or last character).\n        To mask an email:\n            The uppercase letters in the name and domain must be converted to lowercase letters.\n            The middle letters of the name (i.e., all but the first and last letters) must be replaced by 5 asterisks \"*****\".\n        Phone number:\n        A phone number is formatted as follows:\n            The phone number contains 10-13 digits.\n            The last 10 digits make up the local number.\n            The remaining 0-3 digits, in the beginning, make up the country code.\n            Separation characters from the set {'+', '-', '(', ')', ' '} separate the above digits in some way.\n        To mask a phone number:\n            Remove all separation characters.\n            The masked phone number should have the form:\n                \"***-***-XXXX\" if the country code has 0 digits.\n                \"+*-***-***-XXXX\" if the country code has 1 digit.\n                \"+**-***-***-XXXX\" if the country code has 2 digits.\n                \"+***-***-***-XXXX\" if the country code has 3 digits.\n            \"XXXX\" is the last 4 digits of the local number.\n        Example 1:\n        Input: s = \"LeetCode@LeetCode.com\"\n        Output: \"l*****e@leetcode.com\"\n        Explanation: s is an email address.\n        The name and domain are converted to lowercase, and the middle of the name is replaced by 5 asterisks.\n        Example 2:\n        Input: s = \"AB@qq.com\"\n        Output: \"a*****b@qq.com\"\n        Explanation: s is an email address.\n        The name and domain are converted to lowercase, and the middle of the name is replaced by 5 asterisks.\n        Note that even though \"ab\" is 2 characters, it still must have 5 asterisks in the middle.\n        Example 3:\n        Input: s = \"1(234)567-890\"\n        Output: \"***-***-7890\"\n        Explanation: s is a phone number.\n        There are 10 digits, so the local number is 10 digits and the country code is 0 digits.\n        Thus, the resulting masked number is \"***-***-7890\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":634,"row":{"number":641,"difficulty":1,"question":"class MyCircularDeque:\n    def __init__(self, k: int):\n    def insertFront(self, value: int) -> bool:\n    def insertLast(self, value: int) -> bool:\n    def deleteFront(self) -> bool:\n    def deleteLast(self) -> bool:\n    def getFront(self) -> int:\n    def getRear(self) -> int:\n    def isEmpty(self) -> bool:\n    def isFull(self) -> bool:\n        \"\"\"\n        Design your implementation of the circular double-ended queue (deque).\n        Implement the MyCircularDeque class:\n            MyCircularDeque(int k) Initializes the deque with a maximum size of k.\n            boolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise.\n            boolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise.\n            boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise.\n            boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise.\n            int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty.\n            int getRear() Returns the last item from Deque. Returns -1 if the deque is empty.\n            boolean isEmpty() Returns true if the deque is empty, or false otherwise.\n            boolean isFull() Returns true if the deque is full, or false otherwise.\n        Example 1:\n        Input\n        [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\n        [[3], [1], [2], [3], [4], [], [], [], [4], []]\n        Output\n        [null, true, true, true, false, 2, true, true, true, 4]\n        Explanation\n        MyCircularDeque myCircularDeque = new MyCircularDeque(3);\n        myCircularDeque.insertLast(1);  // return True\n        myCircularDeque.insertLast(2);  // return True\n        myCircularDeque.insertFront(3); // return True\n        myCircularDeque.insertFront(4); // return False, the queue is full.\n        myCircularDeque.getRear();      // return 2\n        myCircularDeque.isFull();       // return True\n        myCircularDeque.deleteLast();   // return True\n        myCircularDeque.insertFront(4); // return True\n        myCircularDeque.getFront();     // return 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":635,"row":{"number":622,"difficulty":1,"question":"class MyCircularQueue:\n    def __init__(self, k: int):\n    def enQueue(self, value: int) -> bool:\n    def deQueue(self) -> bool:\n    def Front(self) -> int:\n    def Rear(self) -> int:\n    def isEmpty(self) -> bool:\n    def isFull(self) -> bool:\n        \"\"\"\n        Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\".\n        One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.\n        Implement the MyCircularQueue class:\n            MyCircularQueue(k) Initializes the object with the size of the queue to be k.\n            int Front() Gets the front item from the queue. If the queue is empty, return -1.\n            int Rear() Gets the last item from the queue. If the queue is empty, return -1.\n            boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.\n            boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.\n            boolean isEmpty() Checks whether the circular queue is empty or not.\n            boolean isFull() Checks whether the circular queue is full or not.\n        You must solve the problem without using the built-in queue data structure in your programming language. \n        Example 1:\n        Input\n        [\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n        [[3], [1], [2], [3], [4], [], [], [], [4], []]\n        Output\n        [null, true, true, true, false, 3, true, true, true, 4]\n        Explanation\n        MyCircularQueue myCircularQueue = new MyCircularQueue(3);\n        myCircularQueue.enQueue(1); // return True\n        myCircularQueue.enQueue(2); // return True\n        myCircularQueue.enQueue(3); // return True\n        myCircularQueue.enQueue(4); // return False\n        myCircularQueue.Rear();     // return 3\n        myCircularQueue.isFull();   // return True\n        myCircularQueue.deQueue();  // return True\n        myCircularQueue.enQueue(4); // return True\n        myCircularQueue.Rear();     // return 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":636,"row":{"number":832,"difficulty":0,"question":"class Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n        To flip an image horizontally means that each row of the image is reversed.\n            For example, flipping [1,1,0] horizontally results in [0,1,1].\n        To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n            For example, inverting [0,1,1] results in [1,0,0].\n        Example 1:\n        Input: image = [[1,1,0],[1,0,1],[0,0,0]]\n        Output: [[1,0,0],[0,1,0],[1,1,1]]\n        Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\n        Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n        Example 2:\n        Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n        Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n        Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\n        Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":637,"row":{"number":833,"difficulty":1,"question":"class Solution:\n    def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:\n        \"\"\"\n        You are given a 0-indexed string s that you must perform k replacement operations on. The replacement operations are given as three 0-indexed parallel arrays, indices, sources, and targets, all of length k.\n        To complete the ith replacement operation:\n            Check if the substring sources[i] occurs at index indices[i] in the original string s.\n            If it does not occur, do nothing.\n            Otherwise if it does occur, replace that substring with targets[i].\n        For example, if s = \"abcd\", indices[i] = 0, sources[i] = \"ab\", and targets[i] = \"eee\", then the result of this replacement will be \"eeecd\".\n        All replacement operations must occur simultaneously, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will not overlap.\n            For example, a testcase with s = \"abc\", indices = [0, 1], and sources = [\"ab\",\"bc\"] will not be generated because the \"ab\" and \"bc\" replacements overlap.\n        Return the resulting string after performing all replacement operations on s.\n        A substring is a contiguous sequence of characters in a string.\n        Example 1:\n        Input: s = \"abcd\", indices = [0, 2], sources = [\"a\", \"cd\"], targets = [\"eee\", \"ffff\"]\n        Output: \"eeebffff\"\n        Explanation:\n        \"a\" occurs at index 0 in s, so we replace it with \"eee\".\n        \"cd\" occurs at index 2 in s, so we replace it with \"ffff\".\n        Example 2:\n        Input: s = \"abcd\", indices = [0, 2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"]\n        Output: \"eeecd\"\n        Explanation:\n        \"ab\" occurs at index 0 in s, so we replace it with \"eee\".\n        \"ec\" does not occur at index 2 in s, so we do nothing.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":638,"row":{"number":834,"difficulty":2,"question":"class Solution:\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\n        You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\n        Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.\n        Example 1:\n        Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n        Output: [8,12,6,10,10,10]\n        Explanation: The tree is shown above.\n        We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\n        equals 1 + 1 + 2 + 2 + 2 = 8.\n        Hence, answer[0] = 8, and so on.\n        Example 2:\n        Input: n = 1, edges = []\n        Output: [0]\n        Example 3:\n        Input: n = 2, edges = [[1,0]]\n        Output: [1,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":639,"row":{"number":835,"difficulty":1,"question":"class Solution:\n    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\n        \"\"\"\n        You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.\n        We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images.\n        Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix borders are erased.\n        Return the largest possible overlap.\n        Example 1:\n        Input: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\n        Output: 3\n        Explanation: We translate img1 to right by 1 unit and down by 1 unit.\n        The number of positions that have a 1 in both images is 3 (shown in red).\n        Example 2:\n        Input: img1 = [[1]], img2 = [[1]]\n        Output: 1\n        Example 3:\n        Input: img1 = [[0]], img2 = [[0]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":640,"row":{"number":836,"difficulty":0,"question":"class Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        \"\"\"\n        An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n        Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n        Given two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n        Example 1:\n        Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n        Output: true\n        Example 2:\n        Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n        Output: false\n        Example 3:\n        Input: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":641,"row":{"number":837,"difficulty":1,"question":"class Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        \"\"\"\n        Alice plays the following game, loosely based on the card game \"21\".\n        Alice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.\n        Alice stops drawing numbers when she gets k or more points.\n        Return the probability that Alice has n or fewer points.\n        Answers within 10-5 of the actual answer are considered accepted.\n        Example 1:\n        Input: n = 10, k = 1, maxPts = 10\n        Output: 1.00000\n        Explanation: Alice gets a single card, then stops.\n        Example 2:\n        Input: n = 6, k = 1, maxPts = 10\n        Output: 0.60000\n        Explanation: Alice gets a single card, then stops.\n        In 6 out of 10 possibilities, she is at or below 6 points.\n        Example 3:\n        Input: n = 21, k = 17, maxPts = 10\n        Output: 0.73278\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":642,"row":{"number":838,"difficulty":1,"question":"class Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        \"\"\"\n        There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n        After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\n        When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\n        For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\n        You are given a string dominoes representing the initial state where:\n            dominoes[i] = 'L', if the ith domino has been pushed to the left,\n            dominoes[i] = 'R', if the ith domino has been pushed to the right, and\n            dominoes[i] = '.', if the ith domino has not been pushed.\n        Return a string representing the final state.\n        Example 1:\n        Input: dominoes = \"RR.L\"\n        Output: \"RR.L\"\n        Explanation: The first domino expends no additional force on the second domino.\n        Example 2:\n        Input: dominoes = \".L.R...LR..L..\"\n        Output: \"LL.RR.LLRRLL..\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":643,"row":{"number":839,"difficulty":2,"question":"class Solution:\n    def numSimilarGroups(self, strs: List[str]) -> int:\n        \"\"\"\n        Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. Also two strings X and Y are similar if they are equal.\n        For example, \"tars\" and \"rats\" are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\n        Together, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}.  Notice that \"tars\" and \"arts\" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\n        We are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?\n        Example 1:\n        Input: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\n        Output: 2\n        Example 2:\n        Input: strs = [\"omv\",\"ovm\"]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":644,"row":{"number":840,"difficulty":1,"question":"class Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\n        Given a row x col grid of integers, how many 3 x 3 \"magic square\" subgrids are there?  (Each subgrid is contiguous).\n        Example 1:\n        Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\n        Output: 1\n        Explanation: \n        The following subgrid is a 3 x 3 magic square:\n        while this one is not:\n        In total, there is only one magic square inside the given grid.\n        Example 2:\n        Input: grid = [[8]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":645,"row":{"number":841,"difficulty":1,"question":"class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        \"\"\"\n        There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n        When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n        Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\n        Example 1:\n        Input: rooms = [[1],[2],[3],[]]\n        Output: true\n        Explanation: \n        We visit room 0 and pick up key 1.\n        We then visit room 1 and pick up key 2.\n        We then visit room 2 and pick up key 3.\n        We then visit room 3.\n        Since we were able to visit every room, we return true.\n        Example 2:\n        Input: rooms = [[1,3],[3,0,1],[2],[0]]\n        Output: false\n        Explanation: We can not enter room number 2 since the only key that unlocks it is in that room.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":646,"row":{"number":842,"difficulty":1,"question":"class Solution:\n    def splitIntoFibonacci(self, num: str) -> List[int]:\n        \"\"\"\n        You are given a string of digits num, such as \"123456579\". We can split it into a Fibonacci-like sequence [123, 456, 579].\n        Formally, a Fibonacci-like sequence is a list f of non-negative integers such that:\n            0 <= f[i] < 231, (that is, each integer fits in a 32-bit signed integer type),\n            f.length >= 3, and\n            f[i] + f[i + 1] == f[i + 2] for all 0 <= i < f.length - 2.\n        Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.\n        Return any Fibonacci-like sequence split from num, or return [] if it cannot be done.\n        Example 1:\n        Input: num = \"1101111\"\n        Output: [11,0,11,11]\n        Explanation: The output [110, 1, 111] would also be accepted.\n        Example 2:\n        Input: num = \"112358130\"\n        Output: []\n        Explanation: The task is impossible.\n        Example 3:\n        Input: num = \"0123\"\n        Output: []\n        Explanation: Leading zeroes are not allowed, so \"01\", \"2\", \"3\" is not valid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":647,"row":{"number":843,"difficulty":2,"question":"        \"\"\"\n        You are given an array of unique strings words where words[i] is six letters long. One word of words was chosen as a secret word.\n        You are also given the helper object Master. You may call Master.guess(word) where word is a six-letter-long string, and it must be from words. Master.guess(word) returns:\n            -1 if word is not from words, or\n            an integer representing the number of exact matches (value and position) of your guess to the secret word.\n        There is a parameter allowedGuesses for each test case where allowedGuesses is the maximum number of times you can call Master.guess(word).\n        For each test case, you should call Master.guess with the secret word without exceeding the maximum number of allowed guesses. You will get:\n            \"Either you took too many guesses, or you did not find the secret word.\" if you called Master.guess more than allowedGuesses times or if you did not call Master.guess with the secret word, or\n            \"You guessed the secret word correctly.\" if you called Master.guess with the secret word with the number of calls to Master.guess less than or equal to allowedGuesses.\n        The test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method).\n        Example 1:\n        Input: secret = \"acckzz\", words = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], allowedGuesses = 10\n        Output: You guessed the secret word correctly.\n        Explanation:\n        master.guess(\"aaaaaa\") returns -1, because \"aaaaaa\" is not in wordlist.\n        master.guess(\"acckzz\") returns 6, because \"acckzz\" is secret and has all 6 matches.\n        master.guess(\"ccbazz\") returns 3, because \"ccbazz\" has 3 matches.\n        master.guess(\"eiowzz\") returns 2, because \"eiowzz\" has 2 matches.\n        master.guess(\"abcczz\") returns 4, because \"abcczz\" has 4 matches.\n        We made 5 calls to master.guess, and one of them was the secret, so we pass the test case.\n        Example 2:\n        Input: secret = \"hamada\", words = [\"hamada\",\"khaled\"], allowedGuesses = 10\n        Output: You guessed the secret word correctly.\n        Explanation: Since there are two words, you can guess both.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":648,"row":{"number":844,"difficulty":0,"question":"class Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        \"\"\"\n        Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n        Note that after backspacing an empty text, the text will continue empty.\n        Example 1:\n        Input: s = \"ab#c\", t = \"ad#c\"\n        Output: true\n        Explanation: Both s and t become \"ac\".\n        Example 2:\n        Input: s = \"ab##\", t = \"c#d#\"\n        Output: true\n        Explanation: Both s and t become \"\".\n        Example 3:\n        Input: s = \"a#c\", t = \"b\"\n        Output: false\n        Explanation: s becomes \"c\" while t becomes \"b\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":649,"row":{"number":845,"difficulty":1,"question":"class Solution:\n    def longestMountain(self, arr: List[int]) -> int:\n        \"\"\"\n        You may recall that an array arr is a mountain array if and only if:\n            arr.length >= 3\n            There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n                arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n                arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n        Given an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\n        Example 1:\n        Input: arr = [2,1,4,7,3,2,5]\n        Output: 5\n        Explanation: The largest mountain is [1,4,7,3,2] which has length 5.\n        Example 2:\n        Input: arr = [2,2,2]\n        Output: 0\n        Explanation: There is no mountain.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":650,"row":{"number":846,"difficulty":1,"question":"class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        \"\"\"\n        Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\n        Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.\n        Example 1:\n        Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n        Output: true\n        Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]\n        Example 2:\n        Input: hand = [1,2,3,4,5], groupSize = 4\n        Output: false\n        Explanation: Alice's hand can not be rearranged into groups of 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":651,"row":{"number":847,"difficulty":2,"question":"class Solution:\n    def shortestPathLength(self, graph: List[List[int]]) -> int:\n        \"\"\"\n        You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge.\n        Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n        Example 1:\n        Input: graph = [[1,2,3],[0],[0],[0]]\n        Output: 4\n        Explanation: One possible path is [1,0,2,0,3]\n        Example 2:\n        Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\n        Output: 4\n        Explanation: One possible path is [0,1,4,2,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":652,"row":{"number":848,"difficulty":1,"question":"class Solution:\n    def shiftingLetters(self, s: str, shifts: List[int]) -> str:\n        \"\"\"\n        You are given a string s of lowercase English letters and an integer array shifts of the same length.\n        Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').\n            For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.\n        Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.\n        Return the final string after all such shifts to s are applied.\n        Example 1:\n        Input: s = \"abc\", shifts = [3,5,9]\n        Output: \"rpl\"\n        Explanation: We start with \"abc\".\n        After shifting the first 1 letters of s by 3, we have \"dbc\".\n        After shifting the first 2 letters of s by 5, we have \"igc\".\n        After shifting the first 3 letters of s by 9, we have \"rpl\", the answer.\n        Example 2:\n        Input: s = \"aaa\", shifts = [1,2,3]\n        Output: \"gfd\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":653,"row":{"number":849,"difficulty":1,"question":"class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        \"\"\"\n        You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed).\n        There is at least one empty seat, and at least one person sitting.\n        Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. \n        Return that maximum distance to the closest person.\n        Example 1:\n        Input: seats = [1,0,0,0,1,0,1]\n        Output: 2\n        Explanation: \n        If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.\n        If Alex sits in any other open seat, the closest person has distance 1.\n        Thus, the maximum distance to the closest person is 2.\n        Example 2:\n        Input: seats = [1,0,0,0]\n        Output: 3\n        Explanation: \n        If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.\n        This is the maximum distance possible, so the answer is 3.\n        Example 3:\n        Input: seats = [0,1]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":654,"row":{"number":850,"difficulty":2,"question":"class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D array of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner.\n        Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once.\n        Return the total area. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\n        Output: 6\n        Explanation: A total area of 6 is covered by all three rectangles, as illustrated in the picture.\n        From (1,1) to (2,2), the green and red rectangles overlap.\n        From (1,0) to (2,3), all three rectangles overlap.\n        Example 2:\n        Input: rectangles = [[0,0,1000000000,1000000000]]\n        Output: 49\n        Explanation: The answer is 1018 modulo (109 + 7), which is 49.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":655,"row":{"number":851,"difficulty":1,"question":"class Solution:\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\n        \"\"\"\n        There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\n        You are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\n        Return an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.\n        Example 1:\n        Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\n        Output: [5,5,2,5,4,5,6,7]\n        Explanation: \n        answer[0] = 5.\n        Person 5 has more money than 3, which has more money than 1, which has more money than 0.\n        The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\n        answer[7] = 7.\n        Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\n        The other answers can be filled out with similar reasoning.\n        Example 2:\n        Input: richer = [], quiet = [0]\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":656,"row":{"number":852,"difficulty":1,"question":"class Solution:\n    def peakIndexInMountainArray(self, arr: List[int]) -> int:\n        \"\"\"\n        An array arr a mountain if the following properties hold:\n            arr.length >= 3\n            There exists some i with 0 < i < arr.length - 1 such that:\n                arr[0] < arr[1] < ... < arr[i - 1] < arr[i] \n                arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n        Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].\n        You must solve it in O(log(arr.length)) time complexity.\n        Example 1:\n        Input: arr = [0,1,0]\n        Output: 1\n        Example 2:\n        Input: arr = [0,2,1,0]\n        Output: 1\n        Example 3:\n        Input: arr = [0,10,5,2]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":657,"row":{"number":853,"difficulty":1,"question":"class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        \"\"\"\n        There are n cars going to the same destination along a one-lane road. The destination is target miles away.\n        You are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\n        A car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n        A car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\n        If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\n        Return the number of car fleets that will arrive at the destination.\n        Example 1:\n        Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n        Output: 3\n        Explanation:\n        The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\n        The car starting at 0 does not catch up to any other car, so it is a fleet by itself.\n        The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n        Note that no other cars meet these fleets before the destination, so the answer is 3.\n        Example 2:\n        Input: target = 10, position = [3], speed = [3]\n        Output: 1\n        Explanation: There is only one car, hence there is only one fleet.\n        Example 3:\n        Input: target = 100, position = [0,2,4], speed = [4,2,1]\n        Output: 1\n        Explanation:\n        The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\n        Then, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":658,"row":{"number":854,"difficulty":2,"question":"class Solution:\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        \"\"\"\n        Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2.\n        Given two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar.\n        Example 1:\n        Input: s1 = \"ab\", s2 = \"ba\"\n        Output: 1\n        Explanation: The two string are 1-similar because we can use one swap to change s1 to s2: \"ab\" --> \"ba\".\n        Example 2:\n        Input: s1 = \"abc\", s2 = \"bca\"\n        Output: 2\n        Explanation: The two strings are 2-similar because we can use two swaps to change s1 to s2: \"abc\" --> \"bac\" --> \"bca\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":659,"row":{"number":855,"difficulty":1,"question":"class ExamRoom:\n    def __init__(self, n: int):\n    def seat(self) -> int:\n    def leave(self, p: int) -> None:\n        \"\"\"\n        There is an exam room with n seats in a single row labeled from 0 to n - 1.\n        When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0.\n        Design a class that simulates the mentioned exam room.\n        Implement the ExamRoom class:\n            ExamRoom(int n) Initializes the object of the exam room with the number of the seats n.\n            int seat() Returns the label of the seat at which the next student will set.\n            void leave(int p) Indicates that the student sitting at seat p will leave the room. It is guaranteed that there will be a student sitting at seat p.\n        Example 1:\n        Input\n        [\"ExamRoom\", \"seat\", \"seat\", \"seat\", \"seat\", \"leave\", \"seat\"]\n        [[10], [], [], [], [], [4], []]\n        Output\n        [null, 0, 9, 4, 2, null, 5]\n        Explanation\n        ExamRoom examRoom = new ExamRoom(10);\n        examRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0.\n        examRoom.seat(); // return 9, the student sits at the last seat number 9.\n        examRoom.seat(); // return 4, the student sits at the last seat number 4.\n        examRoom.seat(); // return 2, the student sits at the last seat number 2.\n        examRoom.leave(4);\n        examRoom.seat(); // return 5, the student sits at the last seat number 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":660,"row":{"number":856,"difficulty":1,"question":"class Solution:\n    def scoreOfParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a balanced parentheses string s, return the score of the string.\n        The score of a balanced parentheses string is based on the following rule:\n            \"()\" has score 1.\n            AB has score A + B, where A and B are balanced parentheses strings.\n            (A) has score 2 * A, where A is a balanced parentheses string.\n        Example 1:\n        Input: s = \"()\"\n        Output: 1\n        Example 2:\n        Input: s = \"(())\"\n        Output: 2\n        Example 3:\n        Input: s = \"()()\"\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":661,"row":{"number":857,"difficulty":2,"question":"class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        \"\"\"\n        There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\n        We want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n            Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n            Every worker in the paid group must be paid at least their minimum wage expectation.\n        Given the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: quality = [10,20,5], wage = [70,50,30], k = 2\n        Output: 105.00000\n        Explanation: We pay 70 to 0th worker and 35 to 2nd worker.\n        Example 2:\n        Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\n        Output: 30.66667\n        Explanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":662,"row":{"number":858,"difficulty":1,"question":"class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        \"\"\"\n        There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.\n        The square room has walls of length p and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.\n        Given the two integers p and q, return the number of the receptor that the ray meets first.\n        The test cases are guaranteed so that the ray will meet a receptor eventually.\n        Example 1:\n        Input: p = 2, q = 1\n        Output: 2\n        Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.\n        Example 2:\n        Input: p = 3, q = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":663,"row":{"number":859,"difficulty":0,"question":"class Solution:\n    def buddyStrings(self, s: str, goal: str) -> bool:\n        \"\"\"\n        Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\n        Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n            For example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".\n        Example 1:\n        Input: s = \"ab\", goal = \"ba\"\n        Output: true\n        Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.\n        Example 2:\n        Input: s = \"ab\", goal = \"ab\"\n        Output: false\n        Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.\n        Example 3:\n        Input: s = \"aa\", goal = \"aa\"\n        Output: true\n        Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":664,"row":{"number":860,"difficulty":0,"question":"class Solution:\n    def lemonadeChange(self, bills: List[int]) -> bool:\n        \"\"\"\n        At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.\n        Note that you do not have any change in hand at first.\n        Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.\n        Example 1:\n        Input: bills = [5,5,5,10,20]\n        Output: true\n        Explanation: \n        From the first 3 customers, we collect three $5 bills in order.\n        From the fourth customer, we collect a $10 bill and give back a $5.\n        From the fifth customer, we give a $10 bill and a $5 bill.\n        Since all customers got correct change, we output true.\n        Example 2:\n        Input: bills = [5,5,10,10,20]\n        Output: false\n        Explanation: \n        From the first two customers in order, we collect two $5 bills.\n        For the next two customers in order, we collect a $10 bill and give back a $5 bill.\n        For the last customer, we can not give the change of $15 back because we only have two $10 bills.\n        Since not every customer received the correct change, the answer is false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":665,"row":{"number":861,"difficulty":1,"question":"class Solution:\n    def matrixScore(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n binary matrix grid.\n        A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\n        Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\n        Return the highest possible score after making any number of moves (including zero moves).\n        Example 1:\n        Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n        Output: 39\n        Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n        Example 2:\n        Input: grid = [[0]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":666,"row":{"number":862,"difficulty":2,"question":"class Solution:\n    def shortestSubarray(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.\n        A subarray is a contiguous part of an array.\n        Example 1:\n        Input: nums = [1], k = 1\n        Output: 1\n        Example 2:\n        Input: nums = [1,2], k = 4\n        Output: -1\n        Example 3:\n        Input: nums = [2,-1,2], k = 3\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":667,"row":{"number":863,"difficulty":1,"question":"class Solution:\n    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\n        \"\"\"\n        Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.\n        You can return the answer in any order.\n        Example 1:\n        Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n        Output: [7,4,1]\n        Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.\n        Example 2:\n        Input: root = [1], target = 1, k = 3\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":668,"row":{"number":710,"difficulty":2,"question":"class Solution:\n    def __init__(self, n: int, blacklist: List[int]):\n    def pick(self) -> int:\n        \"\"\"\n        You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned.\n        Optimize your algorithm such that it minimizes the number of calls to the built-in random function of your language.\n        Implement the Solution class:\n            Solution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist.\n            int pick() Returns a random integer in the range [0, n - 1] and not in blacklist.\n        Example 1:\n        Input\n        [\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n        [[7, [2, 3, 5]], [], [], [], [], [], [], []]\n        Output\n        [null, 0, 4, 1, 6, 1, 0, 4]\n        Explanation\n        Solution solution = new Solution(7, [2, 3, 5]);\n        solution.pick(); // return 0, any integer from [0,1,4,6] should be ok. Note that for every call of pick,\n                         // 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/4).\n        solution.pick(); // return 4\n        solution.pick(); // return 1\n        solution.pick(); // return 6\n        solution.pick(); // return 1\n        solution.pick(); // return 0\n        solution.pick(); // return 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":669,"row":{"number":864,"difficulty":2,"question":"class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        \"\"\"\n        You are given an m x n grid grid where:\n            '.' is an empty cell.\n            '#' is a wall.\n            '@' is the starting point.\n            Lowercase letters represent keys.\n            Uppercase letters represent locks.\n        You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n        If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n        For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n        Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n        Example 1:\n        Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\n        Output: 8\n        Explanation: Note that the goal is to obtain all the keys not to open all the locks.\n        Example 2:\n        Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\n        Output: 6\n        Example 3:\n        Input: grid = [\"@Aa\"]\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":670,"row":{"number":865,"difficulty":1,"question":"class Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        Given the root of a binary tree, the depth of each node is the shortest distance to the root.\n        Return the smallest subtree such that it contains all the deepest nodes in the original tree.\n        A node is called the deepest if it has the largest depth possible among any node in the entire tree.\n        The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node.\n        Example 1:\n        Input: root = [3,5,1,6,2,0,8,null,null,7,4]\n        Output: [2,7,4]\n        Explanation: We return the node with value 2, colored in yellow in the diagram.\n        The nodes coloured in blue are the deepest nodes of the tree.\n        Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.\n        Example 2:\n        Input: root = [1]\n        Output: [1]\n        Explanation: The root is the deepest node in the tree.\n        Example 3:\n        Input: root = [0,1,3,null,2]\n        Output: [2]\n        Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":671,"row":{"number":866,"difficulty":1,"question":"class Solution:\n    def primePalindrome(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the smallest prime palindrome greater than or equal to n.\n        An integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n            For example, 2, 3, 5, 7, 11, and 13 are all primes.\n        An integer is a palindrome if it reads the same from left to right as it does from right to left.\n            For example, 101 and 12321 are palindromes.\n        The test cases are generated so that the answer always exists and is in the range [2, 2 * 108].\n        Example 1:\n        Input: n = 6\n        Output: 7\n        Example 2:\n        Input: n = 8\n        Output: 11\n        Example 3:\n        Input: n = 13\n        Output: 101\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":672,"row":{"number":867,"difficulty":0,"question":"class Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given a 2D integer array matrix, return the transpose of matrix.\n        The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[1,4,7],[2,5,8],[3,6,9]]\n        Example 2:\n        Input: matrix = [[1,2,3],[4,5,6]]\n        Output: [[1,4],[2,5],[3,6]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":673,"row":{"number":868,"difficulty":0,"question":"class Solution:\n    def binaryGap(self, n: int) -> int:\n        \"\"\"\n        Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\n        Two 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.\n        Example 1:\n        Input: n = 22\n        Output: 2\n        Explanation: 22 in binary is \"10110\".\n        The first adjacent pair of 1's is \"10110\" with a distance of 2.\n        The second adjacent pair of 1's is \"10110\" with a distance of 1.\n        The answer is the largest of these two distances, which is 2.\n        Note that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined.\n        Example 2:\n        Input: n = 8\n        Output: 0\n        Explanation: 8 in binary is \"1000\".\n        There are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n        Example 3:\n        Input: n = 5\n        Output: 2\n        Explanation: 5 in binary is \"101\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":674,"row":{"number":869,"difficulty":1,"question":"class Solution:\n    def reorderedPowerOf2(self, n: int) -> bool:\n        \"\"\"\n        You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero.\n        Return true if and only if we can do this so that the resulting number is a power of two.\n        Example 1:\n        Input: n = 1\n        Output: true\n        Example 2:\n        Input: n = 10\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":675,"row":{"number":870,"difficulty":1,"question":"class Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \"\"\"\n        You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] > nums2[i].\n        Return any permutation of nums1 that maximizes its advantage with respect to nums2.\n        Example 1:\n        Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n        Output: [2,11,7,15]\n        Example 2:\n        Input: nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n        Output: [24,32,8,12]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":676,"row":{"number":871,"difficulty":2,"question":"class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        \"\"\"\n        A car travels from a starting position to a destination which is target miles east of the starting position.\n        There are gas stations along the way. The gas stations are represented as an array stations where stations[i] = [positioni, fueli] indicates that the ith gas station is positioni miles east of the starting position and has fueli liters of gas.\n        The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n        Return the minimum number of refueling stops the car must make in order to reach its destination. If it cannot reach the destination, return -1.\n        Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived.\n        Example 1:\n        Input: target = 1, startFuel = 1, stations = []\n        Output: 0\n        Explanation: We can reach the target without refueling.\n        Example 2:\n        Input: target = 100, startFuel = 1, stations = [[10,100]]\n        Output: -1\n        Explanation: We can not reach the target (or even the first gas station).\n        Example 3:\n        Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\n        Output: 2\n        Explanation: We start with 10 liters of fuel.\n        We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\n        Then, we drive from position 10 to position 60 (expending 50 liters of fuel),\n        and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\n        We made 2 refueling stops along the way, so we return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":677,"row":{"number":470,"difficulty":1,"question":"class Solution:\n    def rand10(self):\n        \"\"\"\n        :rtype: int\n        Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn't call any other API. Please do not use a language's built-in random API.\n        Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().\n        Example 1:\n        Input: n = 1\n        Output: [2]\n        Example 2:\n        Input: n = 2\n        Output: [2,8]\n        Example 3:\n        Input: n = 3\n        Output: [3,8,10]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":678,"row":{"number":872,"difficulty":0,"question":"class Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.\n        For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\n        Two binary trees are considered leaf-similar if their leaf value sequence is the same.\n        Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.\n        Example 1:\n        Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n        Output: true\n        Example 2:\n        Input: root1 = [1,2,3], root2 = [1,3,2]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":679,"row":{"number":873,"difficulty":1,"question":"class Solution:\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\n        \"\"\"\n        A sequence x1, x2, ..., xn is Fibonacci-like if:\n            n >= 3\n            xi + xi+1 == xi+2 for all i + 2 <= n\n        Given a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\n        A subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].\n        Example 1:\n        Input: arr = [1,2,3,4,5,6,7,8]\n        Output: 5\n        Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].\n        Example 2:\n        Input: arr = [1,3,7,11,12,14,18]\n        Output: 3\n        Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":680,"row":{"number":874,"difficulty":1,"question":"class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \"\"\"\n        A robot on an infinite XY-plane starts at point (0, 0) facing north. The robot can receive a sequence of these three possible types of commands:\n            -2: Turn left 90 degrees.\n            -1: Turn right 90 degrees.\n            1 <= k <= 9: Move forward k units, one unit at a time.\n        Some of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, then it will instead stay in its current location and move on to the next command.\n        Return the maximum Euclidean distance that the robot ever gets from the origin squared (i.e. if the distance is 5, return 25).\n        Note:\n            North means +Y direction.\n            East means +X direction.\n            South means -Y direction.\n            West means -X direction.\n        Example 1:\n        Input: commands = [4,-1,3], obstacles = []\n        Output: 25\n        Explanation: The robot starts at (0, 0):\n        1. Move north 4 units to (0, 4).\n        2. Turn right.\n        3. Move east 3 units to (3, 4).\n        The furthest point the robot ever gets from the origin is (3, 4), which squared is 32 + 42 = 25 units away.\n        Example 2:\n        Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]\n        Output: 65\n        Explanation: The robot starts at (0, 0):\n        1. Move north 4 units to (0, 4).\n        2. Turn right.\n        3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).\n        4. Turn left.\n        5. Move north 4 units to (1, 8).\n        The furthest point the robot ever gets from the origin is (1, 8), which squared is 12 + 82 = 65 units away.\n        Example 3:\n        Input: commands = [6,-1,-1,6], obstacles = []\n        Output: 36\n        Explanation: The robot starts at (0, 0):\n        1. Move north 6 units to (0, 6).\n        2. Turn right.\n        3. Turn right.\n        4. Move south 6 units to (0, 0).\n        The furthest point the robot ever gets from the origin is (0, 6), which squared is 62 = 36 units away.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":681,"row":{"number":875,"difficulty":1,"question":"class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        \"\"\"\n        Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n        Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n        Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n        Return the minimum integer k such that she can eat all the bananas within h hours.\n        Example 1:\n        Input: piles = [3,6,7,11], h = 8\n        Output: 4\n        Example 2:\n        Input: piles = [30,11,23,4,20], h = 5\n        Output: 30\n        Example 3:\n        Input: piles = [30,11,23,4,20], h = 6\n        Output: 23\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":682,"row":{"number":876,"difficulty":0,"question":"class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a singly linked list, return the middle node of the linked list.\n        If there are two middle nodes, return the second middle node.\n        Example 1:\n        Input: head = [1,2,3,4,5]\n        Output: [3,4,5]\n        Explanation: The middle node of the list is node 3.\n        Example 2:\n        Input: head = [1,2,3,4,5,6]\n        Output: [4,5,6]\n        Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":683,"row":{"number":877,"difficulty":1,"question":"class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        \"\"\"\n        Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].\n        The objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties.\n        Alice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.\n        Assuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\n        Example 1:\n        Input: piles = [5,3,4,5]\n        Output: true\n        Explanation: \n        Alice starts first, and can only take the first 5 or the last 5.\n        Say she takes the first 5, so that the row becomes [3, 4, 5].\n        If Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points.\n        If Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points.\n        This demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n        Example 2:\n        Input: piles = [3,7,2,3]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":684,"row":{"number":878,"difficulty":2,"question":"class Solution:\n    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n        \"\"\"\n        A positive integer is magical if it is divisible by either a or b.\n        Given the three integers n, a, and b, return the nth magical number. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 1, a = 2, b = 3\n        Output: 2\n        Example 2:\n        Input: n = 4, a = 2, b = 3\n        Output: 6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":685,"row":{"number":879,"difficulty":2,"question":"class Solution:\n    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:\n        \"\"\"\n        There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime.\n        Let's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n.\n        Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n        Output: 2\n        Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.\n        In total, there are 2 schemes.\n        Example 2:\n        Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n        Output: 7\n        Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one.\n        There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":686,"row":{"number":528,"difficulty":1,"question":"class Solution:\n    def __init__(self, w: List[int]):\n    def pickIndex(self) -> int:\n        \"\"\"\n        You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.\n        You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).\n            For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).\n        Example 1:\n        Input\n        [\"Solution\",\"pickIndex\"]\n        [[[1]],[]]\n        Output\n        [null,0]\n        Explanation\n        Solution solution = new Solution([1]);\n        solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n        Example 2:\n        Input\n        [\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n        [[[1,3]],[],[],[],[],[]]\n        Output\n        [null,1,1,1,1,0]\n        Explanation\n        Solution solution = new Solution([1, 3]);\n        solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\n        solution.pickIndex(); // return 1\n        solution.pickIndex(); // return 1\n        solution.pickIndex(); // return 1\n        solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\n        Since this is a randomization problem, multiple answers are allowed.\n        All of the following outputs can be considered correct:\n        [null,1,1,1,1,0]\n        [null,1,1,1,1,1]\n        [null,1,1,1,0,0]\n        [null,1,1,1,0,1]\n        [null,1,0,1,0,0]\n        ......\n        and so on.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":687,"row":{"number":519,"difficulty":1,"question":"class Solution:\n    def __init__(self, m: int, n: int):\n    def flip(self) -> List[int]:\n    def reset(self) -> None:\n        \"\"\"\n        There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to randomly pick an index (i, j) where matrix[i][j] == 0 and flips it to 1. All the indices (i, j) where matrix[i][j] == 0 should be equally likely to be returned.\n        Optimize your algorithm to minimize the number of calls made to the built-in random function of your language and optimize the time and space complexity.\n        Implement the Solution class:\n            Solution(int m, int n) Initializes the object with the size of the binary matrix m and n.\n            int[] flip() Returns a random index [i, j] of the matrix where matrix[i][j] == 0 and flips it to 1.\n            void reset() Resets all the values of the matrix to be 0.\n        Example 1:\n        Input\n        [\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"]\n        [[3, 1], [], [], [], [], []]\n        Output\n        [null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n        Explanation\n        Solution solution = new Solution(3, 1);\n        solution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.\n        solution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0]\n        solution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned.\n        solution.reset(); // All the values are reset to 0 and can be returned.\n        solution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":688,"row":{"number":497,"difficulty":1,"question":"class Solution:\n    def __init__(self, rects: List[List[int]]):\n    def pick(self) -> List[int]:\n        \"\"\"\n        You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.\n        Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned.\n        Note that an integer point is a point that has integer coordinates.\n        Implement the Solution class:\n            Solution(int[][] rects) Initializes the object with the given rectangles rects.\n            int[] pick() Returns a random integer point [u, v] inside the space covered by one of the given rectangles.\n        Example 1:\n        Input\n        [\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n        [[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\n        Output\n        [null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n        Explanation\n        Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\n        solution.pick(); // return [1, -2]\n        solution.pick(); // return [1, -1]\n        solution.pick(); // return [-1, -2]\n        solution.pick(); // return [-2, -2]\n        solution.pick(); // return [0, 0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":689,"row":{"number":478,"difficulty":1,"question":"class Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n    def randPoint(self) -> List[float]:\n        \"\"\"\n        Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\n        Implement the Solution class:\n            Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\n            randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].\n        Example 1:\n        Input\n        [\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n        [[1.0, 0.0, 0.0], [], [], []]\n        Output\n        [null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n        Explanation\n        Solution solution = new Solution(1.0, 0.0, 0.0);\n        solution.randPoint(); // return [-0.02493, -0.38077]\n        solution.randPoint(); // return [0.82314, 0.38945]\n        solution.randPoint(); // return [0.36572, 0.17248]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":690,"row":{"number":880,"difficulty":1,"question":"class Solution:\n    def decodeAtIndex(self, s: str, k: int) -> str:\n        \"\"\"\n        You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:\n            If the character read is a letter, that letter is written onto the tape.\n            If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.\n        Given an integer k, return the kth letter (1-indexed) in the decoded string.\n        Example 1:\n        Input: s = \"leet2code3\", k = 10\n        Output: \"o\"\n        Explanation: The decoded string is \"leetleetcodeleetleetcodeleetleetcode\".\n        The 10th letter in the string is \"o\".\n        Example 2:\n        Input: s = \"ha22\", k = 5\n        Output: \"h\"\n        Explanation: The decoded string is \"hahahaha\".\n        The 5th letter is \"h\".\n        Example 3:\n        Input: s = \"a2345678999999999999999\", k = 1\n        Output: \"a\"\n        Explanation: The decoded string is \"a\" repeated 8301530446056247680 times.\n        The 1st letter is \"a\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":691,"row":{"number":881,"difficulty":1,"question":"class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        \"\"\"\n        You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\n        Return the minimum number of boats to carry every given person.\n        Example 1:\n        Input: people = [1,2], limit = 3\n        Output: 1\n        Explanation: 1 boat (1, 2)\n        Example 2:\n        Input: people = [3,2,2,1], limit = 3\n        Output: 3\n        Explanation: 3 boats (1, 2), (2) and (3)\n        Example 3:\n        Input: people = [3,5,3,4], limit = 5\n        Output: 4\n        Explanation: 4 boats (3), (3), (4), (5)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":692,"row":{"number":882,"difficulty":2,"question":"class Solution:\n    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n        \"\"\"\n        You are given an undirected graph (the \"original graph\") with n nodes labeled from 0 to n - 1. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.\n        The graph is given as a 2D array of edges where edges[i] = [ui, vi, cnti] indicates that there is an edge between nodes ui and vi in the original graph, and cnti is the total number of new nodes that you will subdivide the edge into. Note that cnti == 0 means you will not subdivide the edge.\n        To subdivide the edge [ui, vi], replace it with (cnti + 1) new edges and cnti new nodes. The new nodes are x1, x2, ..., xcnti, and the new edges are [ui, x1], [x1, x2], [x2, x3], ..., [xcnti-1, xcnti], [xcnti, vi].\n        In this new graph, you want to know how many nodes are reachable from the node 0, where a node is reachable if the distance is maxMoves or less.\n        Given the original graph and maxMoves, return the number of nodes that are reachable from node 0 in the new graph.\n        Example 1:\n        Input: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\n        Output: 13\n        Explanation: The edge subdivisions are shown in the image above.\n        The nodes that are reachable are highlighted in yellow.\n        Example 2:\n        Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\n        Output: 23\n        Example 3:\n        Input: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\n        Output: 1\n        Explanation: Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":693,"row":{"number":883,"difficulty":0,"question":"class Solution:\n    def projectionArea(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes.\n        Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j).\n        We view the projection of these cubes onto the xy, yz, and zx planes.\n        A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side.\n        Return the total area of all three projections.\n        Example 1:\n        Input: grid = [[1,2],[3,4]]\n        Output: 17\n        Explanation: Here are the three projections (\"shadows\") of the shape made with each axis-aligned plane.\n        Example 2:\n        Input: grid = [[2]]\n        Output: 5\n        Example 3:\n        Input: grid = [[1,0],[0,2]]\n        Output: 8\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":694,"row":{"number":884,"difficulty":0,"question":"class Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        \"\"\"\n        A sentence is a string of single-space separated words where each word consists only of lowercase letters.\n        A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\n        Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.\n        Example 1:\n        Input: s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n        Output: [\"sweet\",\"sour\"]\n        Example 2:\n        Input: s1 = \"apple apple\", s2 = \"banana\"\n        Output: [\"banana\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":695,"row":{"number":885,"difficulty":1,"question":"class Solution:\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\n        \"\"\"\n        You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\n        You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.\n        Return an array of coordinates representing the positions of the grid in the order you visited them.\n        Example 1:\n        Input: rows = 1, cols = 4, rStart = 0, cStart = 0\n        Output: [[0,0],[0,1],[0,2],[0,3]]\n        Example 2:\n        Input: rows = 5, cols = 6, rStart = 1, cStart = 4\n        Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":696,"row":{"number":886,"difficulty":1,"question":"class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        \"\"\"\n        We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.\n        Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.\n        Example 1:\n        Input: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n        Output: true\n        Explanation: The first group has [1,4], and the second group has [2,3].\n        Example 2:\n        Input: n = 3, dislikes = [[1,2],[1,3],[2,3]]\n        Output: false\n        Explanation: We need at least 3 groups to divide them. We cannot put them in two groups.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":697,"row":{"number":887,"difficulty":2,"question":"class Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        \"\"\"\n        You are given k identical eggs and you have access to a building with n floors labeled from 1 to n.\n        You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.\n        Each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.\n        Return the minimum number of moves that you need to determine with certainty what the value of f is.\n        Example 1:\n        Input: k = 1, n = 2\n        Output: 2\n        Explanation: \n        Drop the egg from floor 1. If it breaks, we know that f = 0.\n        Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\n        If it does not break, then we know f = 2.\n        Hence, we need at minimum 2 moves to determine with certainty what the value of f is.\n        Example 2:\n        Input: k = 2, n = 6\n        Output: 3\n        Example 3:\n        Input: k = 3, n = 14\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":698,"row":{"number":888,"difficulty":0,"question":"class Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        \"\"\"\n        Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has.\n        Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\n        Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.\n        Example 1:\n        Input: aliceSizes = [1,1], bobSizes = [2,2]\n        Output: [1,2]\n        Example 2:\n        Input: aliceSizes = [1,2], bobSizes = [2,3]\n        Output: [1,2]\n        Example 3:\n        Input: aliceSizes = [2], bobSizes = [1,3]\n        Output: [2,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":699,"row":{"number":889,"difficulty":1,"question":"class Solution:\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        \"\"\"\n        Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and postorder is the postorder traversal of the same tree, reconstruct and return the binary tree.\n        If there exist multiple answers, you can return any of them.\n        Example 1:\n        Input: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n        Output: [1,2,3,4,5,6,7]\n        Example 2:\n        Input: preorder = [1], postorder = [1]\n        Output: [1]\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}