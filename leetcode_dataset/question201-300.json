{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":200,"row":{"number":225,"difficulty":0,"question":"class MyStack:\n    def __init__(self):\n    def push(self, x: int) -> None:\n    def pop(self) -> int:\n    def top(self) -> int:\n    def empty(self) -> bool:\n        \"\"\"\n        Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\n        Implement the MyStack class:\n            void push(int x) Pushes element x to the top of the stack.\n            int pop() Removes the element on the top of the stack and returns it.\n            int top() Returns the element on the top of the stack.\n            boolean empty() Returns true if the stack is empty, false otherwise.\n        Notes:\n            You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.\n            Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.\n        Example 1:\n        Input\n        [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n        [[], [1], [2], [], [], []]\n        Output\n        [null, null, null, 2, 2, false]\n        Explanation\n        MyStack myStack = new MyStack();\n        myStack.push(1);\n        myStack.push(2);\n        myStack.top(); // return 2\n        myStack.pop(); // return 2\n        myStack.empty(); // return False\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":201,"row":{"number":226,"difficulty":0,"question":"class Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Given the root of a binary tree, invert the tree, and return its root.\n        Example 1:\n        Input: root = [4,2,7,1,3,6,9]\n        Output: [4,7,2,9,6,3,1]\n        Example 2:\n        Input: root = [2,1,3]\n        Output: [2,3,1]\n        Example 3:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":202,"row":{"number":227,"difficulty":1,"question":"class Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"\n        Given a string s which represents an expression, evaluate this expression and return its value. \n        The integer division should truncate toward zero.\n        You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].\n        Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n        Example 1:\n        Input: s = \"3+2*2\"\n        Output: 7\n        Example 2:\n        Input: s = \" 3/2 \"\n        Output: 1\n        Example 3:\n        Input: s = \" 3+5 / 2 \"\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":203,"row":{"number":228,"difficulty":0,"question":"class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        \"\"\"\n        You are given a sorted unique integer array nums.\n        A range [a,b] is the set of all integers from a to b (inclusive).\n        Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\n        Each range [a,b] in the list should be output as:\n            \"a->b\" if a != b\n            \"a\" if a == b\n        Example 1:\n        Input: nums = [0,1,2,4,5,7]\n        Output: [\"0->2\",\"4->5\",\"7\"]\n        Explanation: The ranges are:\n        [0,2] --> \"0->2\"\n        [4,5] --> \"4->5\"\n        [7,7] --> \"7\"\n        Example 2:\n        Input: nums = [0,2,3,4,6,8,9]\n        Output: [\"0\",\"2->4\",\"6\",\"8->9\"]\n        Explanation: The ranges are:\n        [0,0] --> \"0\"\n        [2,4] --> \"2->4\"\n        [6,6] --> \"6\"\n        [8,9] --> \"8->9\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":204,"row":{"number":229,"difficulty":1,"question":"class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.\n        Example 1:\n        Input: nums = [3,2,3]\n        Output: [3]\n        Example 2:\n        Input: nums = [1]\n        Output: [1]\n        Example 3:\n        Input: nums = [1,2]\n        Output: [1,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":205,"row":{"number":230,"difficulty":1,"question":"class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        \"\"\"\n        Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n        Example 1:\n        Input: root = [3,1,4,null,2], k = 1\n        Output: 1\n        Example 2:\n        Input: root = [5,3,6,2,4,null,null,1], k = 3\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":206,"row":{"number":231,"difficulty":0,"question":"class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        \"\"\"\n        Given an integer n, return true if it is a power of two. Otherwise, return false.\n        An integer n is a power of two, if there exists an integer x such that n == 2x.\n        Example 1:\n        Input: n = 1\n        Output: true\n        Explanation: 20 = 1\n        Example 2:\n        Input: n = 16\n        Output: true\n        Explanation: 24 = 16\n        Example 3:\n        Input: n = 3\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":207,"row":{"number":232,"difficulty":0,"question":"class MyQueue:\n    def __init__(self):\n    def push(self, x: int) -> None:\n    def pop(self) -> int:\n    def peek(self) -> int:\n    def empty(self) -> bool:\n        \"\"\"\n        Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\n        Implement the MyQueue class:\n            void push(int x) Pushes element x to the back of the queue.\n            int pop() Removes the element from the front of the queue and returns it.\n            int peek() Returns the element at the front of the queue.\n            boolean empty() Returns true if the queue is empty, false otherwise.\n        Notes:\n            You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\n            Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n        Example 1:\n        Input\n        [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n        [[], [1], [2], [], [], []]\n        Output\n        [null, null, null, 1, 1, false]\n        Explanation\n        MyQueue myQueue = new MyQueue();\n        myQueue.push(1); // queue is: [1]\n        myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n        myQueue.peek(); // return 1\n        myQueue.pop(); // return 1, queue is [2]\n        myQueue.empty(); // return false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":208,"row":{"number":233,"difficulty":2,"question":"class Solution:\n    def countDigitOne(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n        Example 1:\n        Input: n = 13\n        Output: 6\n        Example 2:\n        Input: n = 0\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":209,"row":{"number":234,"difficulty":0,"question":"class Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        \"\"\"\n        Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\n        Example 1:\n        Input: head = [1,2,2,1]\n        Output: true\n        Example 2:\n        Input: head = [1,2]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":210,"row":{"number":235,"difficulty":1,"question":"class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        \"\"\"\n        Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n        According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n        Example 1:\n        Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n        Output: 6\n        Explanation: The LCA of nodes 2 and 8 is 6.\n        Example 2:\n        Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n        Output: 2\n        Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n        Example 3:\n        Input: root = [2,1], p = 2, q = 1\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":211,"row":{"number":236,"difficulty":1,"question":"class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        \"\"\"\n        Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n        According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n        Example 1:\n        Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n        Output: 3\n        Explanation: The LCA of nodes 5 and 1 is 3.\n        Example 2:\n        Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n        Output: 5\n        Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n        Example 3:\n        Input: root = [1,2], p = 1, q = 2\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":212,"row":{"number":237,"difficulty":1,"question":"class Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        There is a singly-linked list head and we want to delete a node node in it.\n        You are given the node to be deleted node. You will not be given access to the first node of head.\n        All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\n        Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n            The value of the given node should not exist in the linked list.\n            The number of nodes in the linked list should decrease by one.\n            All the values before node should be in the same order.\n            All the values after node should be in the same order.\n        Custom testing:\n            For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.\n            We will build the linked list and pass the node to your function.\n            The output will be the entire list after calling your function.\n        Example 1:\n        Input: head = [4,5,1,9], node = 5\n        Output: [4,1,9]\n        Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n        Example 2:\n        Input: head = [4,5,1,9], node = 1\n        Output: [4,5,9]\n        Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":213,"row":{"number":238,"difficulty":1,"question":"class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n        The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n        You must write an algorithm that runs in O(n) time and without using the division operation.\n        Example 1:\n        Input: nums = [1,2,3,4]\n        Output: [24,12,8,6]\n        Example 2:\n        Input: nums = [-1,1,0,-3,3]\n        Output: [0,0,9,0,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":214,"row":{"number":239,"difficulty":2,"question":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n        Return the max sliding window.\n        Example 1:\n        Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\n        Output: [3,3,5,5,6,7]\n        Explanation: \n        Window position                Max\n        ---------------               -----\n        [1  3  -1] -3  5  3  6  7       3\n         1 [3  -1  -3] 5  3  6  7       3\n         1  3 [-1  -3  5] 3  6  7       5\n         1  3  -1 [-3  5  3] 6  7       5\n         1  3  -1  -3 [5  3  6] 7       6\n         1  3  -1  -3  5 [3  6  7]      7\n        Example 2:\n        Input: nums = [1], k = 1\n        Output: [1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":215,"row":{"number":240,"difficulty":1,"question":"class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\n            Integers in each row are sorted in ascending from left to right.\n            Integers in each column are sorted in ascending from top to bottom.\n        Example 1:\n        Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n        Output: true\n        Example 2:\n        Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":216,"row":{"number":241,"difficulty":1,"question":"class Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        \"\"\"\n        Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\n        The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 104.\n        Example 1:\n        Input: expression = \"2-1-1\"\n        Output: [0,2]\n        Explanation:\n        ((2-1)-1) = 0 \n        (2-(1-1)) = 2\n        Example 2:\n        Input: expression = \"2*3-4*5\"\n        Output: [-34,-14,-10,-10,10]\n        Explanation:\n        (2*(3-(4*5))) = -34 \n        ((2*3)-(4*5)) = -14 \n        ((2*(3-4))*5) = -10 \n        (2*((3-4)*5)) = -10 \n        (((2*3)-4)*5) = 10\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":217,"row":{"number":242,"difficulty":0,"question":"class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \"\"\"\n        Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: s = \"anagram\", t = \"nagaram\"\n        Output: true\n        Example 2:\n        Input: s = \"rat\", t = \"car\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":218,"row":{"number":257,"difficulty":0,"question":"class Solution:\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n        \"\"\"\n        Given the root of a binary tree, return all root-to-leaf paths in any order.\n        A leaf is a node with no children.\n        Example 1:\n        Input: root = [1,2,3,null,5]\n        Output: [\"1->2->5\",\"1->3\"]\n        Example 2:\n        Input: root = [1]\n        Output: [\"1\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":219,"row":{"number":258,"difficulty":0,"question":"class Solution:\n    def addDigits(self, num: int) -> int:\n        \"\"\"\n        Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.\n        Example 1:\n        Input: num = 38\n        Output: 2\n        Explanation: The process is\n        38 --> 3 + 8 --> 11\n        11 --> 1 + 1 --> 2 \n        Since 2 has only one digit, return it.\n        Example 2:\n        Input: num = 0\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":220,"row":{"number":260,"difficulty":1,"question":"class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.\n        You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\n        Example 1:\n        Input: nums = [1,2,1,3,2,5]\n        Output: [3,5]\n        Explanation:  [5, 3] is also a valid answer.\n        Example 2:\n        Input: nums = [-1,0]\n        Output: [-1,0]\n        Example 3:\n        Input: nums = [0,1]\n        Output: [1,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":221,"row":{"number":263,"difficulty":0,"question":"class Solution:\n    def isUgly(self, n: int) -> bool:\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return true if n is an ugly number.\n        Example 1:\n        Input: n = 6\n        Output: true\n        Explanation: 6 = 2 × 3\n        Example 2:\n        Input: n = 1\n        Output: true\n        Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n        Example 3:\n        Input: n = 14\n        Output: false\n        Explanation: 14 is not ugly since it includes the prime factor 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":222,"row":{"number":264,"difficulty":1,"question":"class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        Example 1:\n        Input: n = 10\n        Output: 12\n        Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":223,"row":{"number":268,"difficulty":0,"question":"class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\n        Example 1:\n        Input: nums = [3,0,1]\n        Output: 2\n        Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n        Example 2:\n        Input: nums = [0,1]\n        Output: 2\n        Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n        Example 3:\n        Input: nums = [9,6,4,2,3,5,7,0,1]\n        Output: 8\n        Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":224,"row":{"number":273,"difficulty":2,"question":"class Solution:\n    def numberToWords(self, num: int) -> str:\n        \"\"\"\n        Convert a non-negative integer num to its English words representation.\n        Example 1:\n        Input: num = 123\n        Output: \"One Hundred Twenty Three\"\n        Example 2:\n        Input: num = 12345\n        Output: \"Twelve Thousand Three Hundred Forty Five\"\n        Example 3:\n        Input: num = 1234567\n        Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":225,"row":{"number":274,"difficulty":1,"question":"class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        \"\"\"\n        Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index.\n        According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each.\n        If there are several possible values for h, the maximum one is taken as the h-index.\n        Example 1:\n        Input: citations = [3,0,6,1,5]\n        Output: 3\n        Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\n        Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n        Example 2:\n        Input: citations = [1,3,1]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":226,"row":{"number":275,"difficulty":1,"question":"class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        \"\"\"\n        Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in an ascending order, return compute the researcher's h-index.\n        According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each.\n        If there are several possible values for h, the maximum one is taken as the h-index.\n        You must write an algorithm that runs in logarithmic time.\n        Example 1:\n        Input: citations = [0,1,3,5,6]\n        Output: 3\n        Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\n        Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n        Example 2:\n        Input: citations = [1,2,100]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":227,"row":{"number":278,"difficulty":0,"question":"class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        \"\"\"\n        You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n        Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\n        You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n        Example 1:\n        Input: n = 5, bad = 4\n        Output: 4\n        Explanation:\n        call isBadVersion(3) -> false\n        call isBadVersion(5) -> true\n        call isBadVersion(4) -> true\n        Then 4 is the first bad version.\n        Example 2:\n        Input: n = 1, bad = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":228,"row":{"number":279,"difficulty":1,"question":"class Solution:\n    def numSquares(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the least number of perfect square numbers that sum to n.\n        A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n        Example 1:\n        Input: n = 12\n        Output: 3\n        Explanation: 12 = 4 + 4 + 4.\n        Example 2:\n        Input: n = 13\n        Output: 2\n        Explanation: 13 = 4 + 9.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":229,"row":{"number":282,"difficulty":2,"question":"class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        \"\"\"\n        Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.\n        Note that operands in the returned expressions should not contain leading zeros.\n        Example 1:\n        Input: num = \"123\", target = 6\n        Output: [\"1*2*3\",\"1+2+3\"]\n        Explanation: Both \"1*2*3\" and \"1+2+3\" evaluate to 6.\n        Example 2:\n        Input: num = \"232\", target = 8\n        Output: [\"2*3+2\",\"2+3*2\"]\n        Explanation: Both \"2*3+2\" and \"2+3*2\" evaluate to 8.\n        Example 3:\n        Input: num = \"3456237490\", target = 9191\n        Output: []\n        Explanation: There are no expressions that can be created from \"3456237490\" to evaluate to 9191.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":230,"row":{"number":283,"difficulty":0,"question":"class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n        Note that you must do this in-place without making a copy of the array.\n        Example 1:\n        Input: nums = [0,1,0,3,12]\n        Output: [1,3,12,0,0]\n        Example 2:\n        Input: nums = [0]\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":231,"row":{"number":284,"difficulty":1,"question":"        \"\"\"\n        Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.\n        Implement the PeekingIterator class:\n            PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator.\n            int next() Returns the next element in the array and moves the pointer to the next element.\n            boolean hasNext() Returns true if there are still elements in the array.\n            int peek() Returns the next element in the array without moving the pointer.\n        Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.\n        Example 1:\n        Input\n        [\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"]\n        [[[1, 2, 3]], [], [], [], [], []]\n        Output\n        [null, 1, 2, 2, 3, false]\n        Explanation\n        PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]\n        peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].\n        peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].\n        peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]\n        peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]\n        peekingIterator.hasNext(); // return False\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":232,"row":{"number":287,"difficulty":1,"question":"class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n        There is only one repeated number in nums, return this repeated number.\n        You must solve the problem without modifying the array nums and uses only constant extra space.\n        Example 1:\n        Input: nums = [1,3,4,2,2]\n        Output: 2\n        Example 2:\n        Input: nums = [3,1,3,4,2]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":233,"row":{"number":289,"difficulty":1,"question":"class Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\n        The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n            Any live cell with fewer than two live neighbors dies as if caused by under-population.\n            Any live cell with two or three live neighbors lives on to the next generation.\n            Any live cell with more than three live neighbors dies, as if by over-population.\n            Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n        The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.\n        Example 1:\n        Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n        Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n        Example 2:\n        Input: board = [[1,1],[1,0]]\n        Output: [[1,1],[1,1]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":234,"row":{"number":290,"difficulty":0,"question":"class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        \"\"\"\n        Given a pattern and a string s, find if s follows the same pattern.\n        Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\n        Example 1:\n        Input: pattern = \"abba\", s = \"dog cat cat dog\"\n        Output: true\n        Example 2:\n        Input: pattern = \"abba\", s = \"dog cat cat fish\"\n        Output: false\n        Example 3:\n        Input: pattern = \"aaaa\", s = \"dog cat cat dog\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":235,"row":{"number":292,"difficulty":0,"question":"class Solution:\n    def canWinNim(self, n: int) -> bool:\n        \"\"\"\n        You are playing the following Nim Game with your friend:\n            Initially, there is a heap of stones on the table.\n            You and your friend will alternate taking turns, and you go first.\n            On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n            The one who removes the last stone is the winner.\n        Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.\n        Example 1:\n        Input: n = 4\n        Output: false\n        Explanation: These are the possible outcomes:\n        1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n        2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n        3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\n        In all outcomes, your friend wins.\n        Example 2:\n        Input: n = 1\n        Output: true\n        Example 3:\n        Input: n = 2\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":236,"row":{"number":295,"difficulty":2,"question":"class MedianFinder:\n    def __init__(self):\n    def addNum(self, num: int) -> None:\n    def findMedian(self) -> float:\n        \"\"\"\n        The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n            For example, for arr = [2,3,4], the median is 3.\n            For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\n        Implement the MedianFinder class:\n            MedianFinder() initializes the MedianFinder object.\n            void addNum(int num) adds the integer num from the data stream to the data structure.\n            double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input\n        [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n        [[], [1], [2], [], [3], []]\n        Output\n        [null, null, null, 1.5, null, 2.0]\n        Explanation\n        MedianFinder medianFinder = new MedianFinder();\n        medianFinder.addNum(1);    // arr = [1]\n        medianFinder.addNum(2);    // arr = [1, 2]\n        medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\n        medianFinder.addNum(3);    // arr[1, 2, 3]\n        medianFinder.findMedian(); // return 2.0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":237,"row":{"number":297,"difficulty":2,"question":"class Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        :type root: TreeNode\n        :rtype: str\n        Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n        Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n        Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n        Example 1:\n        Input: root = [1,2,3,null,null,4,5]\n        Output: [1,2,3,null,null,4,5]\n        Example 2:\n        Input: root = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":238,"row":{"number":299,"difficulty":1,"question":"class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        \"\"\"\n        You are playing the Bulls and Cows game with your friend.\n        You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n            The number of \"bulls\", which are digits in the guess that are in the correct position.\n            The number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\n        Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.\n        The hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.\n        Example 1:\n        Input: secret = \"1807\", guess = \"7810\"\n        Output: \"1A3B\"\n        Explanation: Bulls are connected with a '|' and cows are underlined:\n        \"1807\"\n          |\n        \"7810\"\n        Example 2:\n        Input: secret = \"1123\", guess = \"0111\"\n        Output: \"1A1B\"\n        Explanation: Bulls are connected with a '|' and cows are underlined:\n        \"1123\"        \"1123\"\n          |      or     |\n        \"0111\"        \"0111\"\n        Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":239,"row":{"number":300,"difficulty":1,"question":"class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the length of the longest strictly increasing subsequence.\n        Example 1:\n        Input: nums = [10,9,2,5,3,7,101,18]\n        Output: 4\n        Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n        Example 2:\n        Input: nums = [0,1,0,3,2,3]\n        Output: 4\n        Example 3:\n        Input: nums = [7,7,7,7,7,7,7]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":240,"row":{"number":301,"difficulty":2,"question":"class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        \"\"\"\n        Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n        Return a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.\n        Example 1:\n        Input: s = \"()())()\"\n        Output: [\"(())()\",\"()()()\"]\n        Example 2:\n        Input: s = \"(a)())()\"\n        Output: [\"(a())()\",\"(a)()()\"]\n        Example 3:\n        Input: s = \")(\"\n        Output: [\"\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":241,"row":{"number":303,"difficulty":0,"question":"class NumArray:\n    def __init__(self, nums: List[int]):\n    def sumRange(self, left: int, right: int) -> int:\n        \"\"\"\n        Given an integer array nums, handle multiple queries of the following type:\n            Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.\n        Implement the NumArray class:\n            NumArray(int[] nums) Initializes the object with the integer array nums.\n            int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n        Example 1:\n        Input\n        [\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n        [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n        Output\n        [null, 1, -1, -3]\n        Explanation\n        NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\n        numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\n        numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\n        numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":242,"row":{"number":304,"difficulty":1,"question":"class NumMatrix:\n    def __init__(self, matrix: List[List[int]]):\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        \"\"\"\n        Given a 2D matrix matrix, handle multiple queries of the following type:\n            Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n        Implement the NumMatrix class:\n            NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.\n            int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n        You must design an algorithm where sumRegion works on O(1) time complexity.\n        Example 1:\n        Input\n        [\"NumMatrix\", \"sumRegion\", \"sumRegion\", \"sumRegion\"]\n        [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]\n        Output\n        [null, 8, 11, 12]\n        Explanation\n        NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);\n        numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)\n        numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)\n        numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":243,"row":{"number":306,"difficulty":1,"question":"class Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        \"\"\"\n        An additive number is a string whose digits can form an additive sequence.\n        A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\n        Given a string containing only digits, return true if it is an additive number or false otherwise.\n        Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\n        Example 1:\n        Input: \"112358\"\n        Output: true\n        Explanation: \n        The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n        1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n        Example 2:\n        Input: \"199100199\"\n        Output: true\n        Explanation: \n        The additive sequence is: 1, 99, 100, 199. \n        1 + 99 = 100, 99 + 100 = 199\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":244,"row":{"number":307,"difficulty":1,"question":"class NumArray:\n    def __init__(self, nums: List[int]):\n    def update(self, index: int, val: int) -> None:\n    def sumRange(self, left: int, right: int) -> int:\n        \"\"\"\n        Given an integer array nums, handle multiple queries of the following types:\n            Update the value of an element in nums.\n            Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.\n        Implement the NumArray class:\n            NumArray(int[] nums) Initializes the object with the integer array nums.\n            void update(int index, int val) Updates the value of nums[index] to be val.\n            int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n        Example 1:\n        Input\n        [\"NumArray\", \"sumRange\", \"update\", \"sumRange\"]\n        [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\n        Output\n        [null, 9, null, 8]\n        Explanation\n        NumArray numArray = new NumArray([1, 3, 5]);\n        numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9\n        numArray.update(1, 2);   // nums = [1, 2, 5]\n        numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":245,"row":{"number":309,"difficulty":1,"question":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        \"\"\"\n        You are given an array prices where prices[i] is the price of a given stock on the ith day.\n        Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n            After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n        Example 1:\n        Input: prices = [1,2,3,0,2]\n        Output: 3\n        Explanation: transactions = [buy, sell, cooldown, buy, sell]\n        Example 2:\n        Input: prices = [1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":246,"row":{"number":310,"difficulty":1,"question":"class Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\n        Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).\n        Return a list of all MHTs' root labels. You can return the answer in any order.\n        The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n        Example 1:\n        Input: n = 4, edges = [[1,0],[1,2],[1,3]]\n        Output: [1]\n        Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n        Example 2:\n        Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n        Output: [3,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":247,"row":{"number":312,"difficulty":2,"question":"class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n        If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n        Return the maximum coins you can collect by bursting the balloons wisely.\n        Example 1:\n        Input: nums = [3,1,5,8]\n        Output: 167\n        Explanation:\n        nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\n        coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n        Example 2:\n        Input: nums = [1,5]\n        Output: 10\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":248,"row":{"number":313,"difficulty":1,"question":"class Solution:\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n        \"\"\"\n        A super ugly number is a positive integer whose prime factors are in the array primes.\n        Given an integer n and an array of integers primes, return the nth super ugly number.\n        The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n        Example 1:\n        Input: n = 12, primes = [2,7,13,19]\n        Output: 32\n        Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\n        Example 2:\n        Input: n = 1, primes = [2,3,5]\n        Output: 1\n        Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":249,"row":{"number":315,"difficulty":2,"question":"class Solution:\n    def countSmaller(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].\n        Example 1:\n        Input: nums = [5,2,6,1]\n        Output: [2,1,1,0]\n        Explanation:\n        To the right of 5 there are 2 smaller elements (2 and 1).\n        To the right of 2 there is only 1 smaller element (1).\n        To the right of 6 there is 1 smaller element (1).\n        To the right of 1 there is 0 smaller element.\n        Example 2:\n        Input: nums = [-1]\n        Output: [0]\n        Example 3:\n        Input: nums = [-1,-1]\n        Output: [0,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":250,"row":{"number":316,"difficulty":1,"question":"class Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        \"\"\"\n        Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n        Example 1:\n        Input: s = \"bcabc\"\n        Output: \"abc\"\n        Example 2:\n        Input: s = \"cbacdcbc\"\n        Output: \"acdb\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":251,"row":{"number":318,"difficulty":1,"question":"class Solution:\n    def maxProduct(self, words: List[str]) -> int:\n        \"\"\"\n        Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.\n        Example 1:\n        Input: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\n        Output: 16\n        Explanation: The two words can be \"abcw\", \"xtfn\".\n        Example 2:\n        Input: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\n        Output: 4\n        Explanation: The two words can be \"ab\", \"cd\".\n        Example 3:\n        Input: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        Output: 0\n        Explanation: No such pair of words.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":252,"row":{"number":319,"difficulty":1,"question":"class Solution:\n    def bulbSwitch(self, n: int) -> int:\n        \"\"\"\n        There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n        On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.\n        Return the number of bulbs that are on after n rounds.\n        Example 1:\n        Input: n = 3\n        Output: 1\n        Explanation: At first, the three bulbs are [off, off, off].\n        After the first round, the three bulbs are [on, on, on].\n        After the second round, the three bulbs are [on, off, on].\n        After the third round, the three bulbs are [on, off, off]. \n        So you should return 1 because there is only one bulb is on.\n        Example 2:\n        Input: n = 0\n        Output: 0\n        Example 3:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":253,"row":{"number":321,"difficulty":2,"question":"class Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        \"\"\"\n        You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\n        Create the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n        Return an array of the k digits representing the answer.\n        Example 1:\n        Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\n        Output: [9,8,6,5,3]\n        Example 2:\n        Input: nums1 = [6,7], nums2 = [6,0,4], k = 5\n        Output: [6,7,6,0,4]\n        Example 3:\n        Input: nums1 = [3,9], nums2 = [8,9], k = 3\n        Output: [9,8,9]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":254,"row":{"number":322,"difficulty":1,"question":"class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \"\"\"\n        You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n        Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n        You may assume that you have an infinite number of each kind of coin.\n        Example 1:\n        Input: coins = [1,2,5], amount = 11\n        Output: 3\n        Explanation: 11 = 5 + 5 + 1\n        Example 2:\n        Input: coins = [2], amount = 3\n        Output: -1\n        Example 3:\n        Input: coins = [1], amount = 0\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":255,"row":{"number":324,"difficulty":1,"question":"class Solution:\n    def wiggleSort(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n        You may assume the input array always has a valid answer.\n        Example 1:\n        Input: nums = [1,5,1,1,6,4]\n        Output: [1,6,1,5,1,4]\n        Explanation: [1,4,1,5,1,6] is also accepted.\n        Example 2:\n        Input: nums = [1,3,2,2,3,1]\n        Output: [2,3,1,3,1,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":256,"row":{"number":326,"difficulty":0,"question":"class Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        \"\"\"\n        Given an integer n, return true if it is a power of three. Otherwise, return false.\n        An integer n is a power of three, if there exists an integer x such that n == 3x.\n        Example 1:\n        Input: n = 27\n        Output: true\n        Explanation: 27 = 33\n        Example 2:\n        Input: n = 0\n        Output: false\n        Explanation: There is no x where 3x = 0.\n        Example 3:\n        Input: n = -1\n        Output: false\n        Explanation: There is no x where 3x = (-1).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":257,"row":{"number":327,"difficulty":2,"question":"class Solution:\n    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n        \"\"\"\n        Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\n        Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\n        Example 1:\n        Input: nums = [-2,5,-1], lower = -2, upper = 2\n        Output: 3\n        Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\n        Example 2:\n        Input: nums = [0], lower = 0, upper = 0\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":258,"row":{"number":328,"difficulty":1,"question":"class Solution:\n    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\n        The first node is considered odd, and the second node is even, and so on.\n        Note that the relative order inside both the even and odd groups should remain as it was in the input.\n        You must solve the problem in O(1) extra space complexity and O(n) time complexity.\n        Example 1:\n        Input: head = [1,2,3,4,5]\n        Output: [1,3,5,2,4]\n        Example 2:\n        Input: head = [2,1,3,5,6,4,7]\n        Output: [2,3,6,7,1,5,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":259,"row":{"number":329,"difficulty":2,"question":"class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        \"\"\"\n        Given an m x n integers matrix, return the length of the longest increasing path in matrix.\n        From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n        Example 1:\n        Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]\n        Output: 4\n        Explanation: The longest increasing path is [1, 2, 6, 9].\n        Example 2:\n        Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]\n        Output: 4\n        Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n        Example 3:\n        Input: matrix = [[1]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":260,"row":{"number":330,"difficulty":2,"question":"class Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        \"\"\"\n        Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.\n        Return the minimum number of patches required.\n        Example 1:\n        Input: nums = [1,3], n = 6\n        Output: 1\n        Explanation:\n        Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\n        Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\n        Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\n        So we only need 1 patch.\n        Example 2:\n        Input: nums = [1,5,10], n = 20\n        Output: 2\n        Explanation: The two patches can be [2, 4].\n        Example 3:\n        Input: nums = [1,2,2], n = 5\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":261,"row":{"number":331,"difficulty":1,"question":"class Solution:\n    def isValidSerialization(self, preorder: str) -> bool:\n        \"\"\"\n        One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'.\n        For example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where '#' represents a null node.\n        Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.\n        It is guaranteed that each comma-separated value in the string must be either an integer or a character '#' representing null pointer.\n        You may assume that the input format is always valid.\n            For example, it could never contain two consecutive commas, such as \"1,,3\".\n        Note: You are not allowed to reconstruct the tree.\n        Example 1:\n        Input: preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n        Output: true\n        Example 2:\n        Input: preorder = \"1,#\"\n        Output: false\n        Example 3:\n        Input: preorder = \"9,#,#,1\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":262,"row":{"number":332,"difficulty":2,"question":"class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        \"\"\"\n        You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n        All of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n            For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\n        You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n        Example 1:\n        Input: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n        Output: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n        Example 2:\n        Input: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n        Output: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n        Explanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":263,"row":{"number":334,"difficulty":1,"question":"class Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.\n        Example 1:\n        Input: nums = [1,2,3,4,5]\n        Output: true\n        Explanation: Any triplet where i < j < k is valid.\n        Example 2:\n        Input: nums = [5,4,3,2,1]\n        Output: false\n        Explanation: No triplet exists.\n        Example 3:\n        Input: nums = [2,1,5,0,4,6]\n        Output: true\n        Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":264,"row":{"number":335,"difficulty":2,"question":"class Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        \"\"\"\n        You are given an array of integers distance.\n        You start at the point (0, 0) on an X-Y plane, and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\n        Return true if your path crosses itself or false if it does not.\n        Example 1:\n        Input: distance = [2,1,1,2]\n        Output: true\n        Explanation: The path crosses itself at the point (0, 1).\n        Example 2:\n        Input: distance = [1,2,3,4]\n        Output: false\n        Explanation: The path does not cross itself at any point.\n        Example 3:\n        Input: distance = [1,1,1,2,1]\n        Output: true\n        Explanation: The path crosses itself at the point (0, 0).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":265,"row":{"number":336,"difficulty":2,"question":"class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        \"\"\"\n        You are given a 0-indexed array of unique strings words.\n        A palindrome pair is a pair of integers (i, j) such that:\n            0 <= i, j < words.length,\n            i != j, and\n            words[i] + words[j] (the concatenation of the two strings) is a palindrome.\n        Return an array of all the palindrome pairs of words.\n        Example 1:\n        Input: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n        Output: [[0,1],[1,0],[3,2],[2,4]]\n        Explanation: The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]\n        Example 2:\n        Input: words = [\"bat\",\"tab\",\"cat\"]\n        Output: [[0,1],[1,0]]\n        Explanation: The palindromes are [\"battab\",\"tabbat\"]\n        Example 3:\n        Input: words = [\"a\",\"\"]\n        Output: [[0,1],[1,0]]\n        Explanation: The palindromes are [\"a\",\"a\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":266,"row":{"number":337,"difficulty":1,"question":"class Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.\n        Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.\n        Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\n        Example 1:\n        Input: root = [3,2,3,null,3,null,1]\n        Output: 7\n        Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n        Example 2:\n        Input: root = [3,4,5,1,3,null,1]\n        Output: 9\n        Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":267,"row":{"number":338,"difficulty":0,"question":"class Solution:\n    def countBits(self, n: int) -> List[int]:\n        \"\"\"\n        Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n        Example 1:\n        Input: n = 2\n        Output: [0,1,1]\n        Explanation:\n        0 --> 0\n        1 --> 1\n        2 --> 10\n        Example 2:\n        Input: n = 5\n        Output: [0,1,1,2,1,2]\n        Explanation:\n        0 --> 0\n        1 --> 1\n        2 --> 10\n        3 --> 11\n        4 --> 100\n        5 --> 101\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":268,"row":{"number":341,"difficulty":1,"question":"        \"\"\"\n        You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.\n        Implement the NestedIterator class:\n            NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.\n            int next() Returns the next integer in the nested list.\n            boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.\n        Your code will be tested with the following pseudocode:\n        initialize iterator with nestedList\n        res = []\n        while iterator.hasNext()\n            append iterator.next() to the end of res\n        return res\n        If res matches the expected flattened list, then your code will be judged as correct.\n        Example 1:\n        Input: nestedList = [[1,1],2,[1,1]]\n        Output: [1,1,2,1,1]\n        Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n        Example 2:\n        Input: nestedList = [1,[4,[6]]]\n        Output: [1,4,6]\n        Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":269,"row":{"number":342,"difficulty":0,"question":"class Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        \"\"\"\n        Given an integer n, return true if it is a power of four. Otherwise, return false.\n        An integer n is a power of four, if there exists an integer x such that n == 4x.\n        Example 1:\n        Input: n = 16\n        Output: true\n        Example 2:\n        Input: n = 5\n        Output: false\n        Example 3:\n        Input: n = 1\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":270,"row":{"number":343,"difficulty":1,"question":"class Solution:\n    def integerBreak(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\n        Return the maximum product you can get.\n        Example 1:\n        Input: n = 2\n        Output: 1\n        Explanation: 2 = 1 + 1, 1 × 1 = 1.\n        Example 2:\n        Input: n = 10\n        Output: 36\n        Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":271,"row":{"number":344,"difficulty":0,"question":"class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        Write a function that reverses a string. The input string is given as an array of characters s.\n        You must do this by modifying the input array in-place with O(1) extra memory.\n        Example 1:\n        Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n        Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n        Example 2:\n        Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n        Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":272,"row":{"number":345,"difficulty":0,"question":"class Solution:\n    def reverseVowels(self, s: str) -> str:\n        \"\"\"\n        Given a string s, reverse only all the vowels in the string and return it.\n        The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n        Example 1:\n        Input: s = \"hello\"\n        Output: \"holle\"\n        Example 2:\n        Input: s = \"leetcode\"\n        Output: \"leotcede\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":273,"row":{"number":347,"difficulty":1,"question":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,1,1,2,2,3], k = 2\n        Output: [1,2]\n        Example 2:\n        Input: nums = [1], k = 1\n        Output: [1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":274,"row":{"number":349,"difficulty":0,"question":"class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \"\"\"\n        Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\n        Example 1:\n        Input: nums1 = [1,2,2,1], nums2 = [2,2]\n        Output: [2]\n        Example 2:\n        Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n        Output: [9,4]\n        Explanation: [4,9] is also accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":275,"row":{"number":350,"difficulty":0,"question":"class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \"\"\"\n        Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\n        Example 1:\n        Input: nums1 = [1,2,2,1], nums2 = [2,2]\n        Output: [2,2]\n        Example 2:\n        Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n        Output: [4,9]\n        Explanation: [9,4] is also accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":276,"row":{"number":352,"difficulty":2,"question":"class SummaryRanges:\n    def __init__(self):\n    def addNum(self, value: int) -> None:\n    def getIntervals(self) -> List[List[int]]:\n        \"\"\"\n        Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.\n        Implement the SummaryRanges class:\n            SummaryRanges() Initializes the object with an empty stream.\n            void addNum(int value) Adds the integer value to the stream.\n            int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti.\n        Example 1:\n        Input\n        [\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n        [[], [1], [], [3], [], [7], [], [2], [], [6], []]\n        Output\n        [null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n        Explanation\n        SummaryRanges summaryRanges = new SummaryRanges();\n        summaryRanges.addNum(1);      // arr = [1]\n        summaryRanges.getIntervals(); // return [[1, 1]]\n        summaryRanges.addNum(3);      // arr = [1, 3]\n        summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\n        summaryRanges.addNum(7);      // arr = [1, 3, 7]\n        summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\n        summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\n        summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\n        summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\n        summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":277,"row":{"number":354,"difficulty":2,"question":"class Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n        One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n        Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n        Note: You cannot rotate an envelope.\n        Example 1:\n        Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]\n        Output: 3\n        Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n        Example 2:\n        Input: envelopes = [[1,1],[1,1],[1,1]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":278,"row":{"number":355,"difficulty":1,"question":"class Twitter:\n    def __init__(self):\n    def postTweet(self, userId: int, tweetId: int) -> None:\n    def getNewsFeed(self, userId: int) -> List[int]:\n    def follow(self, followerId: int, followeeId: int) -> None:\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        \"\"\"\n        Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\n        Implement the Twitter class:\n            Twitter() Initializes your twitter object.\n            void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\n            List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\n            void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\n            void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\n        Example 1:\n        Input\n        [\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n        [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n        Output\n        [null, null, [5], null, null, [6, 5], null, [5]]\n        Explanation\n        Twitter twitter = new Twitter();\n        twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\n        twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\n        twitter.follow(1, 2);    // User 1 follows user 2.\n        twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\n        twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\n        twitter.unfollow(1, 2);  // User 1 unfollows user 2.\n        twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":279,"row":{"number":357,"difficulty":1,"question":"class Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n        Example 1:\n        Input: n = 2\n        Output: 91\n        Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100, excluding 11,22,33,44,55,66,77,88,99\n        Example 2:\n        Input: n = 0\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":280,"row":{"number":363,"difficulty":2,"question":"class Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        \"\"\"\n        Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\n        It is guaranteed that there will be a rectangle with a sum no larger than k.\n        Example 1:\n        Input: matrix = [[1,0,1],[0,-2,3]], k = 2\n        Output: 2\n        Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n        Example 2:\n        Input: matrix = [[2,2,-1]], k = 3\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":281,"row":{"number":365,"difficulty":1,"question":"class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool:\n        \"\"\"\n        You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.\n        If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.\n        Operations allowed:\n            Fill any of the jugs with water.\n            Empty any of the jugs.\n            Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.\n        Example 1:\n        Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\n        Output: true\n        Explanation: The famous Die Hard example \n        Example 2:\n        Input: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5\n        Output: false\n        Example 3:\n        Input: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":282,"row":{"number":367,"difficulty":0,"question":"class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        \"\"\"\n        Given a positive integer num, return true if num is a perfect square or false otherwise.\n        A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\n        You must not use any built-in library function, such as sqrt.\n        Example 1:\n        Input: num = 16\n        Output: true\n        Explanation: We return true because 4 * 4 = 16 and 4 is an integer.\n        Example 2:\n        Input: num = 14\n        Output: false\n        Explanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":283,"row":{"number":368,"difficulty":1,"question":"class Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n            answer[i] % answer[j] == 0, or\n            answer[j] % answer[i] == 0\n        If there are multiple solutions, return any of them.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,2]\n        Explanation: [1,3] is also accepted.\n        Example 2:\n        Input: nums = [1,2,4,8]\n        Output: [1,2,4,8]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":284,"row":{"number":371,"difficulty":1,"question":"class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        \"\"\"\n        Given two integers a and b, return the sum of the two integers without using the operators + and -.\n        Example 1:\n        Input: a = 1, b = 2\n        Output: 3\n        Example 2:\n        Input: a = 2, b = 3\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":285,"row":{"number":372,"difficulty":1,"question":"class Solution:\n    def superPow(self, a: int, b: List[int]) -> int:\n        \"\"\"\n        Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\n        Example 1:\n        Input: a = 2, b = [3]\n        Output: 8\n        Example 2:\n        Input: a = 2, b = [1,0]\n        Output: 1024\n        Example 3:\n        Input: a = 1, b = [4,3,3,8,5,2]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":286,"row":{"number":373,"difficulty":1,"question":"class Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        \"\"\"\n        You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\n        Define a pair (u, v) which consists of one element from the first array and one element from the second array.\n        Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\n        Example 1:\n        Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n        Output: [[1,2],[1,4],[1,6]]\n        Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n        Example 2:\n        Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n        Output: [[1,1],[1,1]]\n        Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n        Example 3:\n        Input: nums1 = [1,2], nums2 = [3], k = 3\n        Output: [[1,3],[2,3]]\n        Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":287,"row":{"number":374,"difficulty":0,"question":"class Solution:\n    def guessNumber(self, n: int) -> int:\n        \"\"\"\n        We are playing the Guess Game. The game is as follows:\n        I pick a number from 1 to n. You have to guess which number I picked.\n        Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n        You call a pre-defined API int guess(int num), which returns three possible results:\n            -1: Your guess is higher than the number I picked (i.e. num > pick).\n            1: Your guess is lower than the number I picked (i.e. num < pick).\n            0: your guess is equal to the number I picked (i.e. num == pick).\n        Return the number that I picked.\n        Example 1:\n        Input: n = 10, pick = 6\n        Output: 6\n        Example 2:\n        Input: n = 1, pick = 1\n        Output: 1\n        Example 3:\n        Input: n = 2, pick = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":288,"row":{"number":375,"difficulty":1,"question":"class Solution:\n    def getMoneyAmount(self, n: int) -> int:\n        \"\"\"\n        We are playing the Guessing Game. The game will work as follows:\n            I pick a number between 1 and n.\n            You guess a number.\n            If you guess the right number, you win the game.\n            If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.\n            Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.\n        Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.\n        Example 1:\n        Input: n = 10\n        Output: 16\n        Explanation: The winning strategy is as follows:\n        - The range is [1,10]. Guess 7.\n            - If this is my number, your total is $0. Otherwise, you pay $7.\n            - If my number is higher, the range is [8,10]. Guess 9.\n                - If this is my number, your total is $7. Otherwise, you pay $9.\n                - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n                - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n            - If my number is lower, the range is [1,6]. Guess 3.\n                - If this is my number, your total is $7. Otherwise, you pay $3.\n                - If my number is higher, the range is [4,6]. Guess 5.\n                    - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n                    - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n                    - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n                - If my number is lower, the range is [1,2]. Guess 1.\n                    - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n                    - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\n        The worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n        Example 2:\n        Input: n = 1\n        Output: 0\n        Explanation: There is only one possible number, so you can guess 1 and not have to pay anything.\n        Example 3:\n        Input: n = 2\n        Output: 1\n        Explanation: There are two possible numbers, 1 and 2.\n        - Guess 1.\n            - If this is my number, your total is $0. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $1.\n        The worst case is that you pay $1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":289,"row":{"number":376,"difficulty":1,"question":"class Solution:\n    def wiggleMaxLength(self, nums: List[int]) -> int:\n        \"\"\"\n        A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n            For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.\n            In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n        A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n        Given an integer array nums, return the length of the longest wiggle subsequence of nums.\n        Example 1:\n        Input: nums = [1,7,4,9,2,5]\n        Output: 6\n        Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n        Example 2:\n        Input: nums = [1,17,5,10,13,15,10,5,16,8]\n        Output: 7\n        Explanation: There are several subsequences that achieve this length.\n        One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\n        Example 3:\n        Input: nums = [1,2,3,4,5,6,7,8,9]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":290,"row":{"number":377,"difficulty":1,"question":"class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\n        The test cases are generated so that the answer can fit in a 32-bit integer.\n        Example 1:\n        Input: nums = [1,2,3], target = 4\n        Output: 7\n        Explanation:\n        The possible combination ways are:\n        (1, 1, 1, 1)\n        (1, 1, 2)\n        (1, 2, 1)\n        (1, 3)\n        (2, 1, 1)\n        (2, 2)\n        (3, 1)\n        Note that different sequences are counted as different combinations.\n        Example 2:\n        Input: nums = [9], target = 3\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":291,"row":{"number":378,"difficulty":1,"question":"class Solution:\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\n        \"\"\"\n        Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.\n        Note that it is the kth smallest element in the sorted order, not the kth distinct element.\n        You must find a solution with a memory complexity better than O(n2).\n        Example 1:\n        Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n        Output: 13\n        Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13\n        Example 2:\n        Input: matrix = [[-5]], k = 1\n        Output: -5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":292,"row":{"number":380,"difficulty":1,"question":"class RandomizedSet:\n    def __init__(self):\n    def insert(self, val: int) -> bool:\n    def remove(self, val: int) -> bool:\n    def getRandom(self) -> int:\n        \"\"\"\n        Implement the RandomizedSet class:\n            RandomizedSet() Initializes the RandomizedSet object.\n            bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.\n            bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.\n            int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\n        You must implement the functions of the class such that each function works in average O(1) time complexity.\n        Example 1:\n        Input\n        [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n        [[], [1], [2], [2], [], [1], [2], []]\n        Output\n        [null, true, false, true, 2, true, false, 2]\n        Explanation\n        RandomizedSet randomizedSet = new RandomizedSet();\n        randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\n        randomizedSet.remove(2); // Returns false as 2 does not exist in the set.\n        randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\n        randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\n        randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\n        randomizedSet.insert(2); // 2 was already in the set, so return false.\n        randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":293,"row":{"number":381,"difficulty":2,"question":"class RandomizedCollection:\n    def __init__(self):\n    def insert(self, val: int) -> bool:\n    def remove(self, val: int) -> bool:\n    def getRandom(self) -> int:\n        \"\"\"\n        RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n        Implement the RandomizedCollection class:\n            RandomizedCollection() Initializes the empty RandomizedCollection object.\n            bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.\n            bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.\n            int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.\n        You must implement the functions of the class such that each function works on average O(1) time complexity.\n        Note: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.\n        Example 1:\n        Input\n        [\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n        [[], [1], [1], [2], [], [1], []]\n        Output\n        [null, true, false, true, 2, true, 1]\n        Explanation\n        RandomizedCollection randomizedCollection = new RandomizedCollection();\n        randomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                          // Inserts 1 into the collection.\n        randomizedCollection.insert(1);   // return false since the collection contains 1.\n                                          // Inserts another 1 into the collection. Collection now contains [1,1].\n        randomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                          // Inserts 2 into the collection. Collection now contains [1,1,2].\n        randomizedCollection.getRandom(); // getRandom should:\n                                          // - return 1 with probability 2/3, or\n                                          // - return 2 with probability 1/3.\n        randomizedCollection.remove(1);   // return true since the collection contains 1.\n                                          // Removes 1 from the collection. Collection now contains [1,2].\n        randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":294,"row":{"number":382,"difficulty":1,"question":"class Solution:\n    def __init__(self, head: Optional[ListNode]):\n    def getRandom(self) -> int:\n        \"\"\"\n        Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.\n        Implement the Solution class:\n            Solution(ListNode head) Initializes the object with the head of the singly-linked list head.\n            int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.\n        Example 1:\n        Input\n        [\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"]\n        [[[1, 2, 3]], [], [], [], [], []]\n        Output\n        [null, 1, 3, 2, 2, 3]\n        Explanation\n        Solution solution = new Solution([1, 2, 3]);\n        solution.getRandom(); // return 1\n        solution.getRandom(); // return 3\n        solution.getRandom(); // return 2\n        solution.getRandom(); // return 2\n        solution.getRandom(); // return 3\n        // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":295,"row":{"number":383,"difficulty":0,"question":"class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        \"\"\"\n        Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\n        Each letter in magazine can only be used once in ransomNote.\n        Example 1:\n        Input: ransomNote = \"a\", magazine = \"b\"\n        Output: false\n        Example 2:\n        Input: ransomNote = \"aa\", magazine = \"ab\"\n        Output: false\n        Example 3:\n        Input: ransomNote = \"aa\", magazine = \"aab\"\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":296,"row":{"number":384,"difficulty":1,"question":"class Solution:\n    def __init__(self, nums: List[int]):\n    def reset(self) -> List[int]:\n    def shuffle(self) -> List[int]:\n        \"\"\"\n        Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.\n        Implement the Solution class:\n            Solution(int[] nums) Initializes the object with the integer array nums.\n            int[] reset() Resets the array to its original configuration and returns it.\n            int[] shuffle() Returns a random shuffling of the array.\n        Example 1:\n        Input\n        [\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\n        [[[1, 2, 3]], [], [], []]\n        Output\n        [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n        Explanation\n        Solution solution = new Solution([1, 2, 3]);\n        solution.shuffle();    // Shuffle the array [1,2,3] and return its result.\n                               // Any permutation of [1,2,3] must be equally likely to be returned.\n                               // Example: return [3, 1, 2]\n        solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]\n        solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":297,"row":{"number":385,"difficulty":1,"question":"        \"\"\"\n        Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return the deserialized NestedInteger.\n        Each element is either an integer or a list whose elements may also be integers or other lists.\n        Example 1:\n        Input: s = \"324\"\n        Output: 324\n        Explanation: You should return a NestedInteger object which contains a single integer 324.\n        Example 2:\n        Input: s = \"[123,[456,[789]]]\"\n        Output: [123,[456,[789]]]\n        Explanation: Return a NestedInteger object containing a nested list with 2 elements:\n        1. An integer containing value 123.\n        2. A nested list containing two elements:\n            i.  An integer containing value 456.\n            ii. A nested list with one element:\n                 a. An integer containing value 789\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":298,"row":{"number":386,"difficulty":1,"question":"class Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        \"\"\"\n        Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n        You must write an algorithm that runs in O(n) time and uses O(1) extra space. \n        Example 1:\n        Input: n = 13\n        Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n        Example 2:\n        Input: n = 2\n        Output: [1,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":299,"row":{"number":387,"difficulty":0,"question":"class Solution:\n    def firstUniqChar(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\n        Example 1:\n        Input: s = \"leetcode\"\n        Output: 0\n        Example 2:\n        Input: s = \"loveleetcode\"\n        Output: 2\n        Example 3:\n        Input: s = \"aabb\"\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}