{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":900,"row":{"number":1122,"difficulty":0,"question":"class Solution:\n    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        \"\"\"\n        Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\n        Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.\n        Example 1:\n        Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\n        Output: [2,2,2,1,4,3,3,9,6,7,19]\n        Example 2:\n        Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\n        Output: [22,28,8,6,17,44]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":901,"row":{"number":1123,"difficulty":1,"question":"class Solution:\n    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Given the root of a binary tree, return the lowest common ancestor of its deepest leaves.\n        Recall that:\n            The node of a binary tree is a leaf if and only if it has no children\n            The depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1.\n            The lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.\n        Example 1:\n        Input: root = [3,5,1,6,2,0,8,null,null,7,4]\n        Output: [2,7,4]\n        Explanation: We return the node with value 2, colored in yellow in the diagram.\n        The nodes coloured in blue are the deepest leaf-nodes of the tree.\n        Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.\n        Example 2:\n        Input: root = [1]\n        Output: [1]\n        Explanation: The root is the deepest node in the tree, and it's the lca of itself.\n        Example 3:\n        Input: root = [0,1,3,null,2]\n        Output: [2]\n        Explanation: The deepest leaf node in the tree is 2, the lca of one node is itself.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":902,"row":{"number":1124,"difficulty":1,"question":"class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        \"\"\"\n        We are given hours, a list of the number of hours worked per day for a given employee.\n        A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\n        A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\n        Return the length of the longest well-performing interval.\n        Example 1:\n        Input: hours = [9,9,6,0,6,6,9]\n        Output: 3\n        Explanation: The longest well-performing interval is [9,9,6].\n        Example 2:\n        Input: hours = [6,6,6]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":903,"row":{"number":1125,"difficulty":2,"question":"class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \"\"\"\n        In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.\n        Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n            For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].\n        Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.\n        It is guaranteed an answer exists.\n        Example 1:\n        Input: req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\n        Output: [0,2]\n        Example 2:\n        Input: req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]\n        Output: [1,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":904,"row":{"number":1287,"difficulty":0,"question":"class Solution:\n    def findSpecialInteger(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.\n        Example 1:\n        Input: arr = [1,2,2,6,6,6,6,7,10]\n        Output: 6\n        Example 2:\n        Input: arr = [1,1]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":905,"row":{"number":1288,"difficulty":1,"question":"class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \"\"\"\n        Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.\n        The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.\n        Return the number of remaining intervals.\n        Example 1:\n        Input: intervals = [[1,4],[3,6],[2,8]]\n        Output: 2\n        Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.\n        Example 2:\n        Input: intervals = [[1,4],[2,3]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":906,"row":{"number":1627,"difficulty":2,"question":"class Solution:\n    def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n        \"\"\"\n        We have n cities labeled from 1 to n. Two different cities with labels x and y are directly connected by a bidirectional road if and only if x and y share a common divisor strictly greater than some threshold. More formally, cities with labels x and y have a road between them if there exists an integer z such that all of the following are true:\n            x % z == 0,\n            y % z == 0, and\n            z > threshold.\n        Given the two integers, n and threshold, and an array of queries, you must determine for each queries[i] = [ai, bi] if cities ai and bi are connected directly or indirectly. (i.e. there is some path between them).\n        Return an array answer, where answer.length == queries.length and answer[i] is true if for the ith query, there is a path between ai and bi, or answer[i] is false if there is no path.\n        Example 1:\n        Input: n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]\n        Output: [false,false,true]\n        Explanation: The divisors for each number:\n        1:   1\n        2:   1, 2\n        3:   1, 3\n        4:   1, 2, 4\n        5:   1, 5\n        6:   1, 2, 3, 6\n        Using the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the\n        only ones directly connected. The result of each query:\n        [1,4]   1 is not connected to 4\n        [2,5]   2 is not connected to 5\n        [3,6]   3 is connected to 6 through path 3--6\n        Example 2:\n        Input: n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]\n        Output: [true,true,true,true,true]\n        Explanation: The divisors for each number are the same as the previous example. However, since the threshold is 0,\n        all divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.\n        Example 3:\n        Input: n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]\n        Output: [false,false,false,false,false]\n        Explanation: Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.\n        Please notice that there can be multiple queries for the same pair of nodes [x, y], and that the query [x, y] is equivalent to the query [y, x].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":907,"row":{"number":1289,"difficulty":2,"question":"class Solution:\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\n        A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.\n        Example 1:\n        Input: arr = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: 13\n        Explanation: \n        The possible falling paths are:\n        [1,5,9], [1,5,7], [1,6,7], [1,6,8],\n        [2,4,8], [2,4,9], [2,6,7], [2,6,8],\n        [3,4,8], [3,4,9], [3,5,7], [3,5,9]\n        The falling path with the smallest sum is [1,5,7], so the answer is 13.\n        Example 2:\n        Input: grid = [[7]]\n        Output: 7\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":908,"row":{"number":1128,"difficulty":0,"question":"class Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        \"\"\"\n        Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.\n        Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\n        Example 1:\n        Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]\n        Output: 1\n        Example 2:\n        Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":909,"row":{"number":1130,"difficulty":1,"question":"class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array arr of positive integers, consider all binary trees such that:\n            Each node has either 0 or 2 children;\n            The values of arr correspond to the values of each leaf in an in-order traversal of the tree.\n            The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n        Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.\n        A node is a leaf if and only if it has zero children.\n        Example 1:\n        Input: arr = [6,2,4]\n        Output: 32\n        Explanation: There are two possible trees shown.\n        The first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n        Example 2:\n        Input: arr = [4,11]\n        Output: 44\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":910,"row":{"number":1129,"difficulty":1,"question":"class Solution:\n    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n        You are given two arrays redEdges and blueEdges where:\n            redEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\n            blueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n        Return an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n        Example 1:\n        Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\n        Output: [0,1,-1]\n        Example 2:\n        Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\n        Output: [0,1,-1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":911,"row":{"number":1131,"difficulty":1,"question":"class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        \"\"\"\n        Given two arrays of integers with equal lengths, return the maximum value of:\r\n        |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\r\n        where the maximum is taken over all 0 <= i, j < arr1.length.\r\n        Example 1:\n        Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\n        Output: 13\n        Example 2:\n        Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\n        Output: 20\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":912,"row":{"number":1299,"difficulty":0,"question":"class Solution:\n    def replaceElements(self, arr: List[int]) -> List[int]:\n        \"\"\"\n        Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.\n        After doing so, return the array.\n        Example 1:\n        Input: arr = [17,18,5,4,6,1]\n        Output: [18,6,6,6,1,-1]\n        Explanation: \n        - index 0 --> the greatest element to the right of index 0 is index 1 (18).\n        - index 1 --> the greatest element to the right of index 1 is index 4 (6).\n        - index 2 --> the greatest element to the right of index 2 is index 4 (6).\n        - index 3 --> the greatest element to the right of index 3 is index 4 (6).\n        - index 4 --> the greatest element to the right of index 4 is index 5 (1).\n        - index 5 --> there are no elements to the right of index 5, so we put -1.\n        Example 2:\n        Input: arr = [400]\n        Output: [-1]\n        Explanation: There are no elements to the right of index 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":913,"row":{"number":1300,"difficulty":1,"question":"class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.\n        In case of a tie, return the minimum such integer.\n        Notice that the answer is not neccesarilly a number from arr.\n        Example 1:\n        Input: arr = [4,9,3], target = 10\n        Output: 3\n        Explanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer.\n        Example 2:\n        Input: arr = [2,3,5], target = 10\n        Output: 5\n        Example 3:\n        Input: arr = [60864,25176,27249,21296,20204], target = 56803\n        Output: 11361\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":914,"row":{"number":1301,"difficulty":2,"question":"class Solution:\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n        \"\"\"\n        You are given a square board of characters. You can move on the board starting at the bottom right square marked with the character 'S'.\r\n        You need to reach the top left square marked with the character 'E'. The rest of the squares are labeled either with a numeric character 1, 2, ..., 9 or with an obstacle 'X'. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.\r\n        Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, taken modulo 10^9 + 7.\r\n        In case there is no path, return [0, 0].\r\n        Example 1:\r\n        Input: board = [\"E23\",\"2X2\",\"12S\"]\r\n        Output: [7,1]\r\n        Example 2:\r\n        Input: board = [\"E12\",\"1X1\",\"21S\"]\r\n        Output: [4,2]\r\n        Example 3:\r\n        Input: board = [\"E11\",\"XXX\",\"11S\"]\r\n        Output: [0,0]\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":915,"row":{"number":1137,"difficulty":0,"question":"class Solution:\n    def tribonacci(self, n: int) -> int:\n        \"\"\"\n        The Tribonacci sequence Tn is defined as follows: \r\n        T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\r\n        Given n, return the value of Tn.\r\n        Example 1:\r\n        Input: n = 4\r\n        Output: 4\r\n        Explanation:\r\n        T_3 = 0 + 1 + 1 = 2\r\n        T_4 = 1 + 1 + 2 = 4\r\n        Example 2:\r\n        Input: n = 25\r\n        Output: 1389537\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":916,"row":{"number":1138,"difficulty":1,"question":"class Solution:\n    def alphabetBoardPath(self, target: str) -> str:\n        \"\"\"\n        On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].\r\n        Here, board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"], as shown in the diagram below.\r\n        We may make the following moves:\r\n            'U' moves our position up one row, if the position exists on the board;\r\n            'D' moves our position down one row, if the position exists on the board;\r\n            'L' moves our position left one column, if the position exists on the board;\r\n            'R' moves our position right one column, if the position exists on the board;\r\n            '!' adds the character board[r][c] at our current position (r, c) to the answer.\r\n        (Here, the only positions that exist on the board are positions with letters on them.)\r\n        Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\r\n        Example 1:\r\n        Input: target = \"leet\"\r\n        Output: \"DDR!UURRR!!DDD!\"\r\n        Example 2:\r\n        Input: target = \"code\"\r\n        Output: \"RR!DDRR!UUL!R!\"\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":917,"row":{"number":1139,"difficulty":1,"question":"class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.\r\n        Example 1:\r\n        Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\r\n        Output: 9\r\n        Example 2:\r\n        Input: grid = [[1,1,0,0]]\r\n        Output: 1\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":918,"row":{"number":1140,"difficulty":1,"question":"class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        \"\"\"\n        Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones. \n        Alice and Bob take turns, with Alice starting first.  Initially, M = 1.\n        On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).\n        The game continues until all the stones have been taken.\n        Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n        Example 1:\n        Input: piles = [2,7,9,4,4]\n        Output: 10\n        Explanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n        Example 2:\n        Input: piles = [1,2,3,4,5,100]\n        Output: 104\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":919,"row":{"number":1313,"difficulty":0,"question":"class Solution:\n    def decompressRLElist(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        We are given a list nums of integers representing a list compressed with run-length encoding.\n        Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.\n        Return the decompressed list.\n        Example 1:\n        Input: nums = [1,2,3,4]\n        Output: [2,4,4,4]\n        Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].\n        The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].\n        At the end the concatenation [2] + [4,4,4] is [2,4,4,4].\n        Example 2:\n        Input: nums = [1,1,2,3]\n        Output: [1,3,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":920,"row":{"number":1314,"difficulty":1,"question":"class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        \"\"\"\n        Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:\n            i - k <= r <= i + k,\n            j - k <= c <= j + k, and\n            (r, c) is a valid position in the matrix.\n        Example 1:\n        Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n        Output: [[12,21,16],[27,45,33],[24,39,28]]\n        Example 2:\n        Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\n        Output: [[45,45,45],[45,45,45],[45,45,45]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":921,"row":{"number":1315,"difficulty":1,"question":"class Solution:\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0.\n        A grandparent of a node is the parent of its parent if it exists.\n        Example 1:\n        Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n        Output: 18\n        Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.\n        Example 2:\n        Input: root = [1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":922,"row":{"number":1316,"difficulty":2,"question":"class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        \"\"\"\n        Return the number of distinct non-empty substrings of text that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).\n        Example 1:\n        Input: text = \"abcabcabc\"\n        Output: 3\n        Explanation: The 3 substrings are \"abcabc\", \"bcabca\" and \"cabcab\".\n        Example 2:\n        Input: text = \"leetcodeleetcode\"\n        Output: 2\n        Explanation: The 2 substrings are \"ee\" and \"leetcodeleetcode\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":923,"row":{"number":1144,"difficulty":1,"question":"class Solution:\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.\n        An array A is a zigzag array if either:\n            Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ...\n            OR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ...\n        Return the minimum number of moves to transform the given array nums into a zigzag array.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: 2\n        Explanation: We can decrease 2 to 0 or 3 to 1.\n        Example 2:\n        Input: nums = [9,6,1,6,2]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":924,"row":{"number":1145,"difficulty":1,"question":"class Solution:\n    def btreeGameWinningMove(self, root: Optional[TreeNode], n: int, x: int) -> bool:\n        \"\"\"\n        Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n.\n        Initially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue.\n        Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\n        If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\n        You are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false.\n        Example 1:\n        Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\n        Output: true\n        Explanation: The second player can choose the node with value 2.\n        Example 2:\n        Input: root = [1,2,3], n = 3, x = 1\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":925,"row":{"number":1146,"difficulty":1,"question":"class SnapshotArray:\n    def __init__(self, length: int):\n    def set(self, index: int, val: int) -> None:\n    def snap(self) -> int:\n    def get(self, index: int, snap_id: int) -> int:\n        \"\"\"\n        Implement a SnapshotArray that supports the following interface:\n            SnapshotArray(int length) initializes an array-like data structure with the given length. Initially, each element equals 0.\n            void set(index, val) sets the element at the given index to be equal to val.\n            int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.\n            int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id\n        Example 1:\n        Input: [\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\"]\n        [[3],[0,5],[],[0,6],[0,0]]\n        Output: [null,null,0,null,5]\n        Explanation: \n        SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\n        snapshotArr.set(0,5);  // Set array[0] = 5\n        snapshotArr.snap();  // Take a snapshot, return snap_id = 0\n        snapshotArr.set(0,6);\n        snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":926,"row":{"number":1143,"difficulty":1,"question":"class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        \"\"\"\n        Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\n        A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n            For example, \"ace\" is a subsequence of \"abcde\".\n        A common subsequence of two strings is a subsequence that is common to both strings.\n        Example 1:\n        Input: text1 = \"abcde\", text2 = \"ace\" \n        Output: 3  \n        Explanation: The longest common subsequence is \"ace\" and its length is 3.\n        Example 2:\n        Input: text1 = \"abc\", text2 = \"abc\"\n        Output: 3\n        Explanation: The longest common subsequence is \"abc\" and its length is 3.\n        Example 3:\n        Input: text1 = \"abc\", text2 = \"def\"\n        Output: 0\n        Explanation: There is no such common subsequence, so the result is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":927,"row":{"number":1147,"difficulty":2,"question":"class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        \"\"\"\n        You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that:\n            subtexti is a non-empty string.\n            The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + ... + subtextk == text).\n            subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 <= i <= k).\n        Return the largest possible value of k.\n        Example 1:\n        Input: text = \"ghiabcdefhelloadamhelloabcdefghi\"\n        Output: 7\n        Explanation: We can split the string on \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\".\n        Example 2:\n        Input: text = \"merchant\"\n        Output: 1\n        Explanation: We can split the string on \"(merchant)\".\n        Example 3:\n        Input: text = \"antaprezatepzapreanta\"\n        Output: 11\n        Explanation: We can split the string on \"(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":928,"row":{"number":1328,"difficulty":1,"question":"class Solution:\n    def breakPalindrome(self, palindrome: str) -> str:\n        \"\"\"\n        Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\n        Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.\n        A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, \"abcc\" is lexicographically smaller than \"abcd\" because the first position they differ is at the fourth character, and 'c' is smaller than 'd'.\n        Example 1:\n        Input: palindrome = \"abccba\"\n        Output: \"aaccba\"\n        Explanation: There are many ways to make \"abccba\" not a palindrome, such as \"zbccba\", \"aaccba\", and \"abacba\".\n        Of all the ways, \"aaccba\" is the lexicographically smallest.\n        Example 2:\n        Input: palindrome = \"a\"\n        Output: \"\"\n        Explanation: There is no way to replace a single character to make \"a\" not a palindrome, so return an empty string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":929,"row":{"number":1329,"difficulty":1,"question":"class Solution:\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2].\n        Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.\n        Example 1:\n        Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]\n        Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]\n        Example 2:\n        Input: mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]\n        Output: [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":930,"row":{"number":1302,"difficulty":1,"question":"class Solution:\n    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the sum of values of its deepest leaves.\n        Example 1:\n        Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n        Output: 15\n        Example 2:\n        Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n        Output: 19\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":931,"row":{"number":1330,"difficulty":2,"question":"class Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1.\n        You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.\n        Find maximum possible value of the final array.\n        Example 1:\n        Input: nums = [2,3,1,5,4]\n        Output: 10\n        Explanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.\n        Example 2:\n        Input: nums = [2,4,9,24,2,1,10]\n        Output: 68\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":932,"row":{"number":1331,"difficulty":0,"question":"class Solution:\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\n        \"\"\"\n        Given an array of integers arr, replace each element with its rank.\n        The rank represents how large the element is. The rank has the following rules:\n            Rank is an integer starting from 1.\n            The larger the element, the larger the rank. If two elements are equal, their rank must be the same.\n            Rank should be as small as possible.\n        Example 1:\n        Input: arr = [40,10,20,30]\n        Output: [4,1,2,3]\n        Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.\n        Example 2:\n        Input: arr = [100,100,100]\n        Output: [1,1,1]\n        Explanation: Same elements share the same rank.\n        Example 3:\n        Input: arr = [37,12,28,9,100,56,80,5,12]\n        Output: [5,3,4,2,8,6,7,1,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":933,"row":{"number":1632,"difficulty":2,"question":"class Solution:\n    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].\n        The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:\n            The rank is an integer starting from 1.\n            If two elements p and q are in the same row or column, then:\n                If p < q then rank(p) < rank(q)\n                If p == q then rank(p) == rank(q)\n                If p > q then rank(p) > rank(q)\n            The rank should be as small as possible.\n        The test cases are generated so that answer is unique under the given rules.\n        Example 1:\n        Input: matrix = [[1,2],[3,4]]\n        Output: [[1,2],[2,3]]\n        Explanation:\n        The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.\n        The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.\n        The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.\n        The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.\n        Example 2:\n        Input: matrix = [[7,7],[7,7]]\n        Output: [[1,1],[1,1]]\n        Example 3:\n        Input: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\n        Output: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":934,"row":{"number":1154,"difficulty":0,"question":"class Solution:\n    def dayOfYear(self, date: str) -> int:\n        \"\"\"\n        Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.\n        Example 1:\n        Input: date = \"2019-01-09\"\n        Output: 9\n        Explanation: Given date is the 9th day of the year in 2019.\n        Example 2:\n        Input: date = \"2019-02-10\"\n        Output: 41\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":935,"row":{"number":1156,"difficulty":1,"question":"class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        \"\"\"\n        You are given a string text. You can swap two of the characters in the text.\n        Return the length of the longest substring with repeated characters.\n        Example 1:\n        Input: text = \"ababa\"\n        Output: 3\n        Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is \"aaa\" with length 3.\n        Example 2:\n        Input: text = \"aaabaaa\"\n        Output: 6\n        Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring \"aaaaaa\" with length 6.\n        Example 3:\n        Input: text = \"aaaaa\"\n        Output: 5\n        Explanation: No need to swap, longest repeated character substring is \"aaaaa\" with length is 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":936,"row":{"number":1157,"difficulty":2,"question":"class MajorityChecker:\n    def __init__(self, arr: List[int]):\n    def query(self, left: int, right: int, threshold: int) -> int:\n        \"\"\"\n        Design a data structure that efficiently finds the majority element of a given subarray.\n        The majority element of a subarray is an element that occurs threshold times or more in the subarray.\n        Implementing the MajorityChecker class:\n            MajorityChecker(int[] arr) Initializes the instance of the class with the given array arr.\n            int query(int left, int right, int threshold) returns the element in the subarray arr[left...right] that occurs at least threshold times, or -1 if no such element exists.\n        Example 1:\n        Input\n        [\"MajorityChecker\", \"query\", \"query\", \"query\"]\n        [[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]\n        Output\n        [null, 1, -1, 2]\n        Explanation\n        MajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]);\n        majorityChecker.query(0, 5, 4); // return 1\n        majorityChecker.query(0, 3, 3); // return -1\n        majorityChecker.query(2, 3, 2); // return 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":937,"row":{"number":1155,"difficulty":1,"question":"class Solution:\n    def numRollsToTarget(self, n: int, k: int, target: int) -> int:\n        \"\"\"\n        You have n dice, and each die has k faces numbered from 1 to k.\n        Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 1, k = 6, target = 3\n        Output: 1\n        Explanation: You throw one die with 6 faces.\n        There is only one way to get a sum of 3.\n        Example 2:\n        Input: n = 2, k = 6, target = 7\n        Output: 6\n        Explanation: You throw two dice, each with 6 faces.\n        There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.\n        Example 3:\n        Input: n = 30, k = 30, target = 500\n        Output: 222616187\n        Explanation: The answer must be returned modulo 109 + 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":938,"row":{"number":1935,"difficulty":0,"question":"class Solution:\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\n        \"\"\"\n        There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.\n        Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.\n        Example 1:\n        Input: text = \"hello world\", brokenLetters = \"ad\"\n        Output: 1\n        Explanation: We cannot type \"world\" because the 'd' key is broken.\n        Example 2:\n        Input: text = \"leet code\", brokenLetters = \"lt\"\n        Output: 1\n        Explanation: We cannot type \"leet\" because the 'l' and 't' keys are broken.\n        Example 3:\n        Input: text = \"leet code\", brokenLetters = \"e\"\n        Output: 0\n        Explanation: We cannot type either word because the 'e' key is broken.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":939,"row":{"number":1171,"difficulty":1,"question":"class Solution:\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.\r\n        After doing so, return the head of the final linked list.  You may return any such answer.\r\n        (Note that in the examples below, all sequences are serializations of ListNode objects.)\n        Example 1:\n        Input: head = [1,2,-3,3,1]\n        Output: [3,1]\n        Note: The answer [1,2,1] would also be accepted.\n        Example 2:\n        Input: head = [1,2,3,-3,4]\n        Output: [1,2,4]\n        Example 3:\n        Input: head = [1,2,3,-3,-2]\n        Output: [1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":940,"row":{"number":1172,"difficulty":2,"question":"class DinnerPlates:\n    def __init__(self, capacity: int):\n    def push(self, val: int) -> None:\n    def pop(self) -> int:\n    def popAtStack(self, index: int) -> int:\n        \"\"\"\n        You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.\n        Implement the DinnerPlates class:\n            DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity.\n            void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity.\n            int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty.\n            int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty.\n        Example 1:\n        Input\n        [\"DinnerPlates\", \"push\", \"push\", \"push\", \"push\", \"push\", \"popAtStack\", \"push\", \"push\", \"popAtStack\", \"popAtStack\", \"pop\", \"pop\", \"pop\", \"pop\", \"pop\"]\n        [[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []]\n        Output\n        [null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1]\n        Explanation: \n        DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2\n        D.push(1);\n        D.push(2);\n        D.push(3);\n        D.push(4);\n        D.push(5);         // The stacks are now:  2  4\n                                                   1  3  5\n                                                   ﹈ ﹈ ﹈\n        D.popAtStack(0);   // Returns 2.  The stacks are now:     4\n                                                               1  3  5\n                                                               ﹈ ﹈ ﹈\n        D.push(20);        // The stacks are now: 20  4\n                                                   1  3  5\n                                                   ﹈ ﹈ ﹈\n        D.push(21);        // The stacks are now: 20  4 21\n                                                   1  3  5\n                                                   ﹈ ﹈ ﹈\n        D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21\n                                                                1  3  5\n                                                                ﹈ ﹈ ﹈\n        D.popAtStack(2);   // Returns 21.  The stacks are now:     4\n                                                                1  3  5\n                                                                ﹈ ﹈ ﹈ \n        D.pop()            // Returns 5.  The stacks are now:      4\n                                                                1  3 \n                                                                ﹈ ﹈  \n        D.pop()            // Returns 4.  The stacks are now:   1  3 \n                                                                ﹈ ﹈   \n        D.pop()            // Returns 3.  The stacks are now:   1 \n                                                                ﹈   \n        D.pop()            // Returns 1.  There are no stacks.\n        D.pop()            // Returns -1.  There are still no stacks.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":941,"row":{"number":1169,"difficulty":1,"question":"class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \"\"\"\n        A transaction is possibly invalid if:\n            the amount exceeds $1000, or;\n            if it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n        You are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\n        Return a list of transactions that are possibly invalid. You may return the answer in any order.\n        Example 1:\n        Input: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n        Output: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n        Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\n        Example 2:\n        Input: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n        Output: [\"alice,50,1200,mtv\"]\n        Example 3:\n        Input: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n        Output: [\"bob,50,1200,mtv\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":942,"row":{"number":1170,"difficulty":1,"question":"class Solution:\n    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\n        \"\"\"\n        Let the function f(s) be the frequency of the lexicographically smallest character in a non-empty string s. For example, if s = \"dcce\" then f(s) = 2 because the lexicographically smallest character is 'c', which has a frequency of 2.\n        You are given an array of strings words and another array of query strings queries. For each query queries[i], count the number of words in words such that f(queries[i]) < f(W) for each W in words.\n        Return an integer array answer, where each answer[i] is the answer to the ith query.\n        Example 1:\n        Input: queries = [\"cbd\"], words = [\"zaaaz\"]\n        Output: [1]\n        Explanation: On the first query we have f(\"cbd\") = 1, f(\"zaaaz\") = 3 so f(\"cbd\") < f(\"zaaaz\").\n        Example 2:\n        Input: queries = [\"bbb\",\"cc\"], words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        Output: [1,2]\n        Explanation: On the first query only f(\"bbb\") < f(\"aaaa\"). On the second query both f(\"aaa\") and f(\"aaaa\") are both > f(\"cc\").\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":943,"row":{"number":1360,"difficulty":0,"question":"class Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        \"\"\"\n        Write a program to count the number of days between two dates.\n        The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.\n        Example 1:\n        Input: date1 = \"2019-06-29\", date2 = \"2019-06-30\"\n        Output: 1\n        Example 2:\n        Input: date1 = \"2020-01-15\", date2 = \"2019-12-31\"\n        Output: 15\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":944,"row":{"number":1361,"difficulty":1,"question":"class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \"\"\"\n        You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.\n        If node i has no left child then leftChild[i] will equal -1, similarly for the right child.\n        Note that the nodes have no values and that we only use the node numbers in this problem.\n        Example 1:\n        Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\n        Output: true\n        Example 2:\n        Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\n        Output: false\n        Example 3:\n        Input: n = 2, leftChild = [1,0], rightChild = [-1,-1]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":945,"row":{"number":1362,"difficulty":1,"question":"class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        \"\"\"\n        Given an integer num, find the closest two integers in absolute difference whose product equals num + 1 or num + 2.\n        Return the two integers in any order.\n        Example 1:\n        Input: num = 8\n        Output: [3,3]\n        Explanation: For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 = 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen.\n        Example 2:\n        Input: num = 123\n        Output: [5,25]\n        Example 3:\n        Input: num = 999\n        Output: [40,25]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":946,"row":{"number":1363,"difficulty":2,"question":"class Solution:\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\n        \"\"\"\n        Given an array of digits digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order. If there is no answer return an empty string.\n        Since the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros.\n        Example 1:\n        Input: digits = [8,1,9]\n        Output: \"981\"\n        Example 2:\n        Input: digits = [8,6,7,1,0]\n        Output: \"8760\"\n        Example 3:\n        Input: digits = [1]\n        Output: \"\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":947,"row":{"number":1175,"difficulty":0,"question":"class Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        \"\"\"\n        Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n        (Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)\n        Since the answer may be large, return the answer modulo 10^9 + 7.\n        Example 1:\n        Input: n = 5\n        Output: 12\n        Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.\n        Example 2:\n        Input: n = 100\n        Output: 682289015\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":948,"row":{"number":1177,"difficulty":1,"question":"class Solution:\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        \"\"\"\n        You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter.\n        If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.\n        Return a boolean array answer where answer[i] is the result of the ith query queries[i].\n        Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = \"aaa\", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s.\n        Example :\n        Input: s = \"abcda\", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]\n        Output: [true,false,false,true,true]\n        Explanation:\n        queries[0]: substring = \"d\", is palidrome.\n        queries[1]: substring = \"bc\", is not palidrome.\n        queries[2]: substring = \"abcd\", is not palidrome after replacing only 1 character.\n        queries[3]: substring = \"abcd\", could be changed to \"abba\" which is palidrome. Also this can be changed to \"baab\" first rearrange it \"bacd\" then replace \"cd\" with \"ab\".\n        queries[4]: substring = \"abcda\", could be changed to \"abcba\" which is palidrome.\n        Example 2:\n        Input: s = \"lyb\", queries = [[0,1,0],[2,2,1]]\n        Output: [false,true]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":949,"row":{"number":1178,"difficulty":2,"question":"class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        \"\"\"\n        With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:\n            word contains the first letter of puzzle.\n            For each letter in word, that letter is in puzzle.\n                For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\", while\n                invalid words are \"beefed\" (does not include 'a') and \"based\" (includes 's' which is not in the puzzle).\n        Return an array answer, where answer[i] is the number of words in the given word list words that is valid with respect to the puzzle puzzles[i].\n        Example 1:\n        Input: words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]\n        Output: [1,1,3,2,4,0]\n        Explanation: \n        1 valid word for \"aboveyz\" : \"aaaa\" \n        1 valid word for \"abrodyz\" : \"aaaa\"\n        3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\"\n        2 valid words for \"absoryz\" : \"aaaa\", \"asas\"\n        4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\"\n        There are no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'.\n        Example 2:\n        Input: words = [\"apple\",\"pleas\",\"please\"], puzzles = [\"aelwxyz\",\"aelpxyz\",\"aelpsxy\",\"saelpxy\",\"xaelpsy\"]\n        Output: [0,1,3,2,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":950,"row":{"number":1507,"difficulty":0,"question":"class Solution:\n    def reformatDate(self, date: str) -> str:\n        \"\"\"\n        Given a date string in the form Day Month Year, where:\n            Day is in the set {\"1st\", \"2nd\", \"3rd\", \"4th\", ..., \"30th\", \"31st\"}.\n            Month is in the set {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"}.\n            Year is in the range [1900, 2100].\n        Convert the date string to the format YYYY-MM-DD, where:\n            YYYY denotes the 4 digit year.\n            MM denotes the 2 digit month.\n            DD denotes the 2 digit day.\n        Example 1:\n        Input: date = \"20th Oct 2052\"\n        Output: \"2052-10-20\"\n        Example 2:\n        Input: date = \"6th Jun 1933\"\n        Output: \"1933-06-06\"\n        Example 3:\n        Input: date = \"26th May 1960\"\n        Output: \"1960-05-26\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":951,"row":{"number":1390,"difficulty":1,"question":"class Solution:\n    def sumFourDivisors(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0.\n        Example 1:\n        Input: nums = [21,4,7]\n        Output: 32\n        Explanation: \n        21 has 4 divisors: 1, 3, 7, 21\n        4 has 3 divisors: 1, 2, 4\n        7 has 2 divisors: 1, 7\n        The answer is the sum of divisors of 21 only.\n        Example 2:\n        Input: nums = [21,21]\n        Output: 64\n        Example 3:\n        Input: nums = [1,2,3,4,5]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":952,"row":{"number":1382,"difficulty":1,"question":"class Solution:\n    def balanceBST(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.\n        A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.\n        Example 1:\n        Input: root = [1,null,2,null,3,null,4,null,null]\n        Output: [2,1,3,null,null,null,4]\n        Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct.\n        Example 2:\n        Input: root = [2,1,3]\n        Output: [2,1,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":953,"row":{"number":1425,"difficulty":2,"question":"class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\n        A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.\n        Example 1:\n        Input: nums = [10,2,-10,5,20], k = 2\n        Output: 37\n        Explanation: The subsequence is [10, 2, 5, 20].\n        Example 2:\n        Input: nums = [-1,-2,-3], k = 1\n        Output: -1\n        Explanation: The subsequence must be non-empty, so we choose the largest number.\n        Example 3:\n        Input: nums = [10,-2,-10,-5,20], k = 2\n        Output: 23\n        Explanation: The subsequence is [10, -2, -5, 20].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":954,"row":{"number":1184,"difficulty":0,"question":"class Solution:\n    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:\n        \"\"\"\n        A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.\r\n        The bus goes along both directions i.e. clockwise and counterclockwise.\r\n        Return the shortest distance between the given start and destination stops.\r\n        Example 1:\r\n        Input: distance = [1,2,3,4], start = 0, destination = 1\r\n        Output: 1\r\n        Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.\r\n        Example 2:\r\n        Input: distance = [1,2,3,4], start = 0, destination = 2\r\n        Output: 3\r\n        Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.\r\n        Example 3:\r\n        Input: distance = [1,2,3,4], start = 0, destination = 3\r\n        Output: 4\r\n        Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":955,"row":{"number":1186,"difficulty":1,"question":"class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible.\n        Note that the subarray needs to be non-empty after deleting one element.\n        Example 1:\n        Input: arr = [1,-2,0,3]\n        Output: 4\n        Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.\n        Example 2:\n        Input: arr = [1,-2,-2,3]\n        Output: 3\n        Explanation: We just choose [3] and it's the maximum sum.\n        Example 3:\n        Input: arr = [-1,-1,-1,-1]\n        Output: -1\n        Explanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":956,"row":{"number":1185,"difficulty":0,"question":"class Solution:\n    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n        \"\"\"\n        Given a date, return the corresponding day of the week for that date.\n        The input is given as three integers representing the day, month and year respectively.\n        Return the answer as one of the following values {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}.\n        Example 1:\n        Input: day = 31, month = 8, year = 2019\n        Output: \"Saturday\"\n        Example 2:\n        Input: day = 18, month = 7, year = 1999\n        Output: \"Sunday\"\n        Example 3:\n        Input: day = 15, month = 8, year = 1993\n        Output: \"Sunday\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":957,"row":{"number":1187,"difficulty":2,"question":"class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        \"\"\"\n        Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.\r\n        In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].\r\n        If there is no way to make arr1 strictly increasing, return -1.\r\n        Example 1:\r\n        Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\r\n        Output: 1\r\n        Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].\r\n        Example 2:\r\n        Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\r\n        Output: 2\r\n        Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].\r\n        Example 3:\r\n        Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\r\n        Output: -1\r\n        Explanation: You can't make arr1 strictly increasing.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":958,"row":{"number":1550,"difficulty":0,"question":"class Solution:\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\n        \"\"\"\n        Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.\n        Example 1:\n        Input: arr = [2,6,4,1]\n        Output: false\n        Explanation: There are no three consecutive odds.\n        Example 2:\n        Input: arr = [1,2,34,3,4,5,7,23,12]\n        Output: true\n        Explanation: [5,7,23] are three consecutive odds.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":959,"row":{"number":2080,"difficulty":1,"question":"class RangeFreqQuery:\n    def __init__(self, arr: List[int]):\n    def query(self, left: int, right: int, value: int) -> int:\n        \"\"\"\n        Design a data structure to find the frequency of a given value in a given subarray.\n        The frequency of a value in a subarray is the number of occurrences of that value in the subarray.\n        Implement the RangeFreqQuery class:\n            RangeFreqQuery(int[] arr) Constructs an instance of the class with the given 0-indexed integer array arr.\n            int query(int left, int right, int value) Returns the frequency of value in the subarray arr[left...right].\n        A subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).\n        Example 1:\n        Input\n        [\"RangeFreqQuery\", \"query\", \"query\"]\n        [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]\n        Output\n        [null, 1, 2]\n        Explanation\n        RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);\n        rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4]\n        rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":960,"row":{"number":1954,"difficulty":1,"question":"class Solution:\n    def minimumPerimeter(self, neededApples: int) -> int:\n        \"\"\"\n        In a garden represented as an infinite 2D grid, there is an apple tree planted at every integer coordinate. The apple tree planted at an integer coordinate (i, j) has |i| + |j| apples growing on it.\n        You will buy an axis-aligned square plot of land that is centered at (0, 0).\n        Given an integer neededApples, return the minimum perimeter of a plot such that at least neededApples apples are inside or on the perimeter of that plot.\n        The value of |x| is defined as:\n            x if x >= 0\n            -x if x < 0\n        Example 1:\n        Input: neededApples = 1\n        Output: 8\n        Explanation: A square plot of side length 1 does not contain any apples.\n        However, a square plot of side length 2 has 12 apples inside (as depicted in the image above).\n        The perimeter is 2 * 4 = 8.\n        Example 2:\n        Input: neededApples = 13\n        Output: 16\n        Example 3:\n        Input: neededApples = 1000000000\n        Output: 5040\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":961,"row":{"number":1483,"difficulty":2,"question":"class TreeAncestor:\n    def __init__(self, n: int, parent: List[int]):\n    def getKthAncestor(self, node: int, k: int) -> int:\n        \"\"\"\n        You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\n        The kth ancestor of a tree node is the kth node in the path from that node to the root node.\n        Implement the TreeAncestor class:\n            TreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\n            int getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.\n        Example 1:\n        Input\n        [\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n        [[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\n        Output\n        [null, 1, 0, -1]\n        Explanation\n        TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\n        treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\n        treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\n        treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":962,"row":{"number":1189,"difficulty":0,"question":"class Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n        \"\"\"\n        Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\n        You can use each character in text at most once. Return the maximum number of instances that can be formed.\n        Example 1:\n        Input: text = \"nlaebolko\"\n        Output: 1\n        Example 2:\n        Input: text = \"loonbalxballpoon\"\n        Output: 2\n        Example 3:\n        Input: text = \"leetcode\"\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":963,"row":{"number":1190,"difficulty":1,"question":"class Solution:\n    def reverseParentheses(self, s: str) -> str:\n        \"\"\"\n        You are given a string s that consists of lower case English letters and brackets.\n        Reverse the strings in each pair of matching parentheses, starting from the innermost one.\n        Your result should not contain any brackets.\n        Example 1:\n        Input: s = \"(abcd)\"\n        Output: \"dcba\"\n        Example 2:\n        Input: s = \"(u(love)i)\"\n        Output: \"iloveu\"\n        Explanation: The substring \"love\" is reversed first, then the whole string is reversed.\n        Example 3:\n        Input: s = \"(ed(et(oc))el)\"\n        Output: \"leetcode\"\n        Explanation: First, we reverse the substring \"oc\", then \"etco\", and finally, the whole string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":964,"row":{"number":1191,"difficulty":1,"question":"class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array arr and an integer k, modify the array by repeating it k times.\n        For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].\n        Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.\n        As the answer can be very large, return the answer modulo 109 + 7.\n        Example 1:\n        Input: arr = [1,2], k = 3\n        Output: 9\n        Example 2:\n        Input: arr = [1,-2,1], k = 5\n        Output: 2\n        Example 3:\n        Input: arr = [-1,-2], k = 7\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":965,"row":{"number":1192,"difficulty":2,"question":"class Solution:\n    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.\n        A critical connection is a connection that, if removed, will make some servers unable to reach some other server.\n        Return all critical connections in the network in any order.\n        Example 1:\n        Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n        Output: [[1,3]]\n        Explanation: [[3,1]] is also accepted.\n        Example 2:\n        Input: n = 2, connections = [[0,1]]\n        Output: [[0,1]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":966,"row":{"number":1957,"difficulty":0,"question":"class Solution:\n    def makeFancyString(self, s: str) -> str:\n        \"\"\"\n        A fancy string is a string where no three consecutive characters are equal.\n        Given a string s, delete the minimum possible number of characters from s to make it fancy.\n        Return the final string after the deletion. It can be shown that the answer will always be unique.\n        Example 1:\n        Input: s = \"leeetcode\"\n        Output: \"leetcode\"\n        Explanation:\n        Remove an 'e' from the first group of 'e's to create \"leetcode\".\n        No three consecutive characters are equal, so return \"leetcode\".\n        Example 2:\n        Input: s = \"aaabaaaa\"\n        Output: \"aabaa\"\n        Explanation:\n        Remove an 'a' from the first group of 'a's to create \"aabaaaa\".\n        Remove two 'a's from the second group of 'a's to create \"aabaa\".\n        No three consecutive characters are equal, so return \"aabaa\".\n        Example 3:\n        Input: s = \"aab\"\n        Output: \"aab\"\n        Explanation: No three consecutive characters are equal, so return \"aab\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":967,"row":{"number":2139,"difficulty":1,"question":"class Solution:\n    def minMoves(self, target: int, maxDoubles: int) -> int:\n        \"\"\"\n        You are playing a game with integers. You start with the integer 1 and you want to reach the integer target.\n        In one move, you can either:\n            Increment the current integer by one (i.e., x = x + 1).\n            Double the current integer (i.e., x = 2 * x).\n        You can use the increment operation any number of times, however, you can only use the double operation at most maxDoubles times.\n        Given the two integers target and maxDoubles, return the minimum number of moves needed to reach target starting with 1.\n        Example 1:\n        Input: target = 5, maxDoubles = 0\n        Output: 4\n        Explanation: Keep incrementing by 1 until you reach target.\n        Example 2:\n        Input: target = 19, maxDoubles = 2\n        Output: 7\n        Explanation: Initially, x = 1\n        Increment 3 times so x = 4\n        Double once so x = 8\n        Increment once so x = 9\n        Double again so x = 18\n        Increment once so x = 19\n        Example 3:\n        Input: target = 10, maxDoubles = 4\n        Output: 4\n        Explanation: Initially, x = 1\n        Increment once so x = 2\n        Double once so x = 4\n        Increment once so x = 5\n        Double again so x = 10\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":968,"row":{"number":1405,"difficulty":1,"question":"class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        \"\"\"\n        A string s is called happy if it satisfies the following conditions:\n            s only contains the letters 'a', 'b', and 'c'.\n            s does not contain any of \"aaa\", \"bbb\", or \"ccc\" as a substring.\n            s contains at most a occurrences of the letter 'a'.\n            s contains at most b occurrences of the letter 'b'.\n            s contains at most c occurrences of the letter 'c'.\n        Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string \"\".\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: a = 1, b = 1, c = 7\n        Output: \"ccaccbcc\"\n        Explanation: \"ccbccacc\" would also be a correct answer.\n        Example 2:\n        Input: a = 7, b = 1, c = 0\n        Output: \"aabaa\"\n        Explanation: It is the only correct answer in this case.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":969,"row":{"number":1944,"difficulty":2,"question":"class Solution:\n    def canSeePersonsCount(self, heights: List[int]) -> List[int]:\n        \"\"\"\n        There are n people standing in a queue, and they numbered from 0 to n - 1 in left to right order. You are given an array heights of distinct integers where heights[i] represents the height of the ith person.\n        A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the ith person can see the jth person if i < j and min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]).\n        Return an array answer of length n where answer[i] is the number of people the ith person can see to their right in the queue.\n        Example 1:\n        Input: heights = [10,6,8,5,11,9]\n        Output: [3,1,2,1,1,0]\n        Explanation:\n        Person 0 can see person 1, 2, and 4.\n        Person 1 can see person 2.\n        Person 2 can see person 3 and 4.\n        Person 3 can see person 4.\n        Person 4 can see person 5.\n        Person 5 can see no one since nobody is to the right of them.\n        Example 2:\n        Input: heights = [5,1,2,3,10]\n        Output: [4,1,1,1,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":970,"row":{"number":1200,"difficulty":0,"question":"class Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.\n        Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows\n            a, b are from arr\n            a < b\n            b - a equals to the minimum absolute difference of any two elements in arr\n        Example 1:\n        Input: arr = [4,2,1,3]\n        Output: [[1,2],[2,3],[3,4]]\n        Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.\n        Example 2:\n        Input: arr = [1,3,6,10,15]\n        Output: [[1,3]]\n        Example 3:\n        Input: arr = [3,8,-10,23,19,-4,-14,27]\n        Output: [[-14,-10],[19,23],[23,27]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":971,"row":{"number":1201,"difficulty":1,"question":"class Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        \"\"\"\n        An ugly number is a positive integer that is divisible by a, b, or c.\n        Given four integers n, a, b, and c, return the nth ugly number.\n        Example 1:\n        Input: n = 3, a = 2, b = 3, c = 5\n        Output: 4\n        Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\n        Example 2:\n        Input: n = 4, a = 2, b = 3, c = 4\n        Output: 6\n        Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\n        Example 3:\n        Input: n = 5, a = 2, b = 11, c = 13\n        Output: 10\n        Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":972,"row":{"number":1202,"difficulty":1,"question":"class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \"\"\"\n        You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.\n        You can swap the characters at any pair of indices in the given pairs any number of times.\n        Return the lexicographically smallest string that s can be changed to after using the swaps.\n        Example 1:\n        Input: s = \"dcab\", pairs = [[0,3],[1,2]]\n        Output: \"bacd\"\n        Explaination: \n        Swap s[0] and s[3], s = \"bcad\"\n        Swap s[1] and s[2], s = \"bacd\"\n        Example 2:\n        Input: s = \"dcab\", pairs = [[0,3],[1,2],[0,2]]\n        Output: \"abcd\"\n        Explaination: \n        Swap s[0] and s[3], s = \"bcad\"\n        Swap s[0] and s[2], s = \"acbd\"\n        Swap s[1] and s[2], s = \"abcd\"\n        Example 3:\n        Input: s = \"cba\", pairs = [[0,1],[1,2]]\n        Output: \"abc\"\n        Explaination: \n        Swap s[0] and s[1], s = \"bca\"\n        Swap s[1] and s[2], s = \"bac\"\n        Swap s[0] and s[1], s = \"abc\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":973,"row":{"number":1203,"difficulty":2,"question":"class Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        \"\"\"\n        There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n        Return a sorted list of the items such that:\n            The items that belong to the same group are next to each other in the sorted list.\n            There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).\n        Return any solution if there is more than one solution and return an empty list if there is no solution.\n        Example 1:\n        Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n        Output: [6,3,4,1,5,2,0,7]\n        Example 2:\n        Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n        Output: []\n        Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":974,"row":{"number":2079,"difficulty":1,"question":"class Solution:\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\n        \"\"\"\n        You want to water n plants in your garden with a watering can. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i. There is a river at x = -1 that you can refill your watering can at.\n        Each plant needs a specific amount of water. You will water the plants in the following way:\n            Water the plants in order from left to right.\n            After watering the current plant, if you do not have enough water to completely water the next plant, return to the river to fully refill the watering can.\n            You cannot refill the watering can early.\n        You are initially at the river (i.e., x = -1). It takes one step to move one unit on the x-axis.\n        Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and an integer capacity representing the watering can capacity, return the number of steps needed to water all the plants.\n        Example 1:\n        Input: plants = [2,2,3,3], capacity = 5\n        Output: 14\n        Explanation: Start at the river with a full watering can:\n        - Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.\n        - Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.\n        - Since you cannot completely water plant 2, walk back to the river to refill (2 steps).\n        - Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.\n        - Since you cannot completely water plant 3, walk back to the river to refill (3 steps).\n        - Walk to plant 3 (4 steps) and water it.\n        Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.\n        Example 2:\n        Input: plants = [1,1,1,4,2,3], capacity = 4\n        Output: 30\n        Explanation: Start at the river with a full watering can:\n        - Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).\n        - Water plant 3 (4 steps). Return to river (4 steps).\n        - Water plant 4 (5 steps). Return to river (5 steps).\n        - Water plant 5 (6 steps).\n        Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.\n        Example 3:\n        Input: plants = [7,7,7,7,7,7,7], capacity = 8\n        Output: 49\n        Explanation: You have to refill before watering each plant.\n        Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":975,"row":{"number":1895,"difficulty":1,"question":"class Solution:\n    def largestMagicSquare(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        A k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square.\n        Given an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.\n        Example 1:\n        Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\n        Output: 3\n        Explanation: The largest magic square has a size of 3.\n        Every row sum, column sum, and diagonal sum of this magic square is equal to 12.\n        - Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12\n        - Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12\n        - Diagonal sums: 5+4+3 = 6+4+2 = 12\n        Example 2:\n        Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":976,"row":{"number":2201,"difficulty":1,"question":"class Solution:\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\n        \"\"\"\n        There is an n x n 0-indexed grid with some artifacts buried in it. You are given the integer n and a 0-indexed 2D integer array artifacts describing the positions of the rectangular artifacts where artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried in the subgrid where:\n            (r1i, c1i) is the coordinate of the top-left cell of the ith artifact and\n            (r2i, c2i) is the coordinate of the bottom-right cell of the ith artifact.\n        You will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.\n        Given a 0-indexed 2D integer array dig where dig[i] = [ri, ci] indicates that you will excavate the cell (ri, ci), return the number of artifacts that you can extract.\n        The test cases are generated such that:\n            No two artifacts overlap.\n            Each artifact only covers at most 4 cells.\n            The entries of dig are unique.\n        Example 1:\n        Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\n        Output: 1\n        Explanation: \n        The different colors represent different artifacts. Excavated cells are labeled with a 'D' in the grid.\n        There is 1 artifact that can be extracted, namely the red artifact.\n        The blue artifact has one part in cell (1,1) which remains uncovered, so we cannot extract it.\n        Thus, we return 1.\n        Example 2:\n        Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\n        Output: 2\n        Explanation: Both the red and blue artifacts have all parts uncovered (labeled with a 'D') and can be extracted, so we return 2. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":977,"row":{"number":1916,"difficulty":2,"question":"class Solution:\r\n    def waysToBuildRooms(self, prevRoom: List[int]) -> int:\n        \"\"\"\n        You are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. You are given the expansion plan as a 0-indexed integer array of length n, prevRoom, where prevRoom[i] indicates that you must build room prevRoom[i] before building room i, and these two rooms must be connected directly. Room 0 is already built, so prevRoom[0] = -1. The expansion plan is given such that once all the rooms are built, every room will be reachable from room 0.\r\n        You can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected. You can choose to build any room as long as its previous room is already built.\r\n        Return the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo 109 + 7.\r\n        Example 1:\r\n        Input: prevRoom = [-1,0,1]\r\n        Output: 1\r\n        Explanation: There is only one way to build the additional rooms: 0 → 1 → 2\r\n        Example 2:\r\n        Input: prevRoom = [-1,0,0,1,2]\r\n        Output: 6\r\n        Explanation:\r\n        The 6 ways are:\r\n        0 → 1 → 3 → 2 → 4\r\n        0 → 2 → 4 → 1 → 3\r\n        0 → 1 → 2 → 3 → 4\r\n        0 → 1 → 2 → 4 → 3\r\n        0 → 2 → 1 → 3 → 4\r\n        0 → 2 → 1 → 4 → 3\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":978,"row":{"number":1195,"difficulty":1,"question":"class FizzBuzz:\n    def __init__(self, n: int):\n        self.n = n\n    def fizz(self, printFizz: 'Callable[[], None]') -> None:\n    def buzz(self, printBuzz: 'Callable[[], None]') -> None:\n    def fizzbuzz(self, printFizzBuzz: 'Callable[[], None]') -> None:\n    def number(self, printNumber: 'Callable[[int], None]') -> None:\n        \"\"\"\n        You have the four functions:\n            printFizz that prints the word \"fizz\" to the console,\n            printBuzz that prints the word \"buzz\" to the console,\n            printFizzBuzz that prints the word \"fizzbuzz\" to the console, and\n            printNumber that prints a given integer to the console.\n        You are given an instance of the class FizzBuzz that has four functions: fizz, buzz, fizzbuzz and number. The same instance of FizzBuzz will be passed to four different threads:\n            Thread A: calls fizz() that should output the word \"fizz\".\n            Thread B: calls buzz() that should output the word \"buzz\".\n            Thread C: calls fizzbuzz() that should output the word \"fizzbuzz\".\n            Thread D: calls number() that should only output the integers.\n        Modify the given class to output the series [1, 2, \"fizz\", 4, \"buzz\", ...] where the ith token (1-indexed) of the series is:\n            \"fizzbuzz\" if i is divisible by 3 and 5,\n            \"fizz\" if i is divisible by 3 and not 5,\n            \"buzz\" if i is divisible by 5 and not 3, or\n            i if i is not divisible by 3 or 5.\n        Implement the FizzBuzz class:\n            FizzBuzz(int n) Initializes the object with the number n that represents the length of the sequence that should be printed.\n            void fizz(printFizz) Calls printFizz to output \"fizz\".\n            void buzz(printBuzz) Calls printBuzz to output \"buzz\".\n            void fizzbuzz(printFizzBuzz) Calls printFizzBuzz to output \"fizzbuzz\".\n            void number(printNumber) Calls printnumber to output the numbers.\n        Example 1:\n        Input: n = 15\n        Output: [1,2,\"fizz\",4,\"buzz\",\"fizz\",7,8,\"fizz\",\"buzz\",11,\"fizz\",13,14,\"fizzbuzz\"]\n        Example 2:\n        Input: n = 5\n        Output: [1,2,\"fizz\",4,\"buzz\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":979,"row":{"number":1207,"difficulty":0,"question":"class Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        \"\"\"\n        Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.\n        Example 1:\n        Input: arr = [1,2,2,1,1,3]\n        Output: true\n        Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.\n        Example 2:\n        Input: arr = [1,2]\n        Output: false\n        Example 3:\n        Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":980,"row":{"number":1209,"difficulty":1,"question":"class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        \"\"\"\n        You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.\n        We repeatedly make k duplicate removals on s until we no longer can.\n        Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.\n        Example 1:\n        Input: s = \"abcd\", k = 2\n        Output: \"abcd\"\n        Explanation: There's nothing to delete.\n        Example 2:\n        Input: s = \"deeedbbcccbdaa\", k = 3\n        Output: \"aa\"\n        Explanation: \n        First delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\n        Then delete \"bbb\", get \"dddaa\"\n        Finally delete \"ddd\", get \"aa\"\n        Example 3:\n        Input: s = \"pbbcggttciiippooaais\", k = 2\n        Output: \"ps\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":981,"row":{"number":1208,"difficulty":1,"question":"class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        \"\"\"\n        You are given two strings s and t of the same length and an integer maxCost.\n        You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).\n        Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.\n        Example 1:\n        Input: s = \"abcd\", t = \"bcdf\", maxCost = 3\n        Output: 3\n        Explanation: \"abc\" of s can change to \"bcd\".\n        That costs 3, so the maximum length is 3.\n        Example 2:\n        Input: s = \"abcd\", t = \"cdef\", maxCost = 3\n        Output: 1\n        Explanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.\n        Example 3:\n        Input: s = \"abcd\", t = \"acde\", maxCost = 0\n        Output: 1\n        Explanation: You cannot make any change, so the maximum length is 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":982,"row":{"number":1210,"difficulty":2,"question":"class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\n        In one move the snake can:\n            Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n            Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n            Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n            Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from (r, c) and (r+1, c) to (r, c) and (r, c+1).\n        Return the minimum number of moves to reach the target.\n        If there is no way to reach the target, return -1.\n        Example 1:\n        Input: grid = [[0,0,0,0,0,1],\n                       [1,1,0,0,1,0],\n                       [0,0,0,0,1,1],\n                       [0,0,1,0,1,0],\n                       [0,1,1,0,0,0],\n                       [0,1,1,0,0,0]]\n        Output: 11\n        Explanation:\n        One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\n        Example 2:\n        Input: grid = [[0,0,1,1,1,1],\n                       [0,0,0,0,1,1],\n                       [1,1,0,0,0,1],\n                       [1,1,1,0,0,1],\n                       [1,1,1,0,0,1],\n                       [1,1,1,0,0,0]]\n        Output: 9\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":983,"row":{"number":1706,"difficulty":1,"question":"class Solution:\n    def findBall(self, grid: List[List[int]]) -> List[int]:\n        \"\"\"\n        You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.\n        Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n            A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.\n            A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.\n        We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a \"V\" shaped pattern between two boards or if a board redirects the ball into either wall of the box.\n        Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box.\n        Example 1:\n        Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n        Output: [1,-1,-1,-1,-1]\n        Explanation: This example is shown in the photo.\n        Ball b0 is dropped at column 0 and falls out of the box at column 1.\n        Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\n        Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\n        Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\n        Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n        Example 2:\n        Input: grid = [[-1]]\n        Output: [-1]\n        Explanation: The ball gets stuck against the left wall.\n        Example 3:\n        Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n        Output: [0,1,2,3,4,-1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":984,"row":{"number":1514,"difficulty":1,"question":"class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        \"\"\"\n        You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].\n        Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.\n        If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.\n        Example 1:\n        Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\n        Output: 0.25000\n        Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n        Example 2:\n        Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\n        Output: 0.30000\n        Example 3:\n        Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\n        Output: 0.00000\n        Explanation: There is no path between 0 and 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":985,"row":{"number":1862,"difficulty":2,"question":"class Solution:\n    def sumOfFlooredPairs(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the sum of floor(nums[i] / nums[j]) for all pairs of indices 0 <= i, j < nums.length in the array. Since the answer may be too large, return it modulo 109 + 7.\n        The floor() function returns the integer part of the division.\n        Example 1:\n        Input: nums = [2,5,9]\n        Output: 10\n        Explanation:\n        floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0\n        floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1\n        floor(5 / 2) = 2\n        floor(9 / 2) = 4\n        floor(9 / 5) = 1\n        We calculate the floor of the division for every pair of indices in the array then sum them up.\n        Example 2:\n        Input: nums = [7,7,7,7,7,7,7]\n        Output: 49\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":986,"row":{"number":1217,"difficulty":0,"question":"class Solution:\n    def minCostToMoveChips(self, position: List[int]) -> int:\n        \"\"\"\n        We have n chips, where the position of the ith chip is position[i].\n        We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:\n            position[i] + 2 or position[i] - 2 with cost = 0.\n            position[i] + 1 or position[i] - 1 with cost = 1.\n        Return the minimum cost needed to move all the chips to the same position.\n        Example 1:\n        Input: position = [1,2,3]\n        Output: 1\n        Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.\n        Second step: Move the chip at position 2 to position 1 with cost = 1.\n        Total cost is 1.\n        Example 2:\n        Input: position = [2,2,2,3,3]\n        Output: 2\n        Explanation: We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n        Example 3:\n        Input: position = [1,1000000000]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":987,"row":{"number":1218,"difficulty":1,"question":"class Solution:\n    def longestSubsequence(self, arr: List[int], difference: int) -> int:\n        \"\"\"\n        Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.\n        A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: arr = [1,2,3,4], difference = 1\n        Output: 4\n        Explanation: The longest arithmetic subsequence is [1,2,3,4].\n        Example 2:\n        Input: arr = [1,3,5,7], difference = 1\n        Output: 1\n        Explanation: The longest arithmetic subsequence is any single element.\n        Example 3:\n        Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2\n        Output: 4\n        Explanation: The longest arithmetic subsequence is [7,5,3,1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":988,"row":{"number":1219,"difficulty":1,"question":"class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\n        Return the maximum amount of gold you can collect under the conditions:\n            Every time you are located in a cell you will collect all the gold in that cell.\n            From your position, you can walk one step to the left, right, up, or down.\n            You can't visit the same cell more than once.\n            Never visit a cell with 0 gold.\n            You can start and stop collecting gold from any position in the grid that has some gold.\n        Example 1:\n        Input: grid = [[0,6,0],[5,8,7],[0,9,0]]\n        Output: 24\n        Explanation:\n        [[0,6,0],\n         [5,8,7],\n         [0,9,0]]\n        Path to get the maximum gold, 9 -> 8 -> 7.\n        Example 2:\n        Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\n        Output: 28\n        Explanation:\n        [[1,0,7],\n         [2,0,6],\n         [3,4,5],\n         [0,3,0],\n         [9,0,20]]\n        Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":989,"row":{"number":1220,"difficulty":2,"question":"class Solution:\n    def countVowelPermutation(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, your task is to count how many strings of length n can be formed under the following rules:\n            Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')\n            Each vowel 'a' may only be followed by an 'e'.\n            Each vowel 'e' may only be followed by an 'a' or an 'i'.\n            Each vowel 'i' may not be followed by another 'i'.\n            Each vowel 'o' may only be followed by an 'i' or a 'u'.\n            Each vowel 'u' may only be followed by an 'a'.\n        Since the answer may be too large, return it modulo 10^9 + 7.\n        Example 1:\n        Input: n = 1\n        Output: 5\n        Explanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n        Example 2:\n        Input: n = 2\n        Output: 10\n        Explanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n        Example 3: \n        Input: n = 5\n        Output: 68\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":990,"row":{"number":2191,"difficulty":1,"question":"class Solution:\n    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system.\n        The mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9.\n        You are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements.\n        Notes:\n            Elements with the same mapped values should appear in the same relative order as in the input.\n            The elements of nums should only be sorted based on their mapped values and not be replaced by them.\n        Example 1:\n        Input: mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]\n        Output: [338,38,991]\n        Explanation: \n        Map the number 991 as follows:\n        1. mapping[9] = 6, so all occurrences of the digit 9 will become 6.\n        2. mapping[1] = 9, so all occurrences of the digit 1 will become 9.\n        Therefore, the mapped value of 991 is 669.\n        338 maps to 007, or 7 after removing the leading zeros.\n        38 maps to 07, which is also 7 after removing leading zeros.\n        Since 338 and 38 share the same mapped value, they should remain in the same relative order, so 338 comes before 38.\n        Thus, the sorted array is [338,38,991].\n        Example 2:\n        Input: mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]\n        Output: [123,456,789]\n        Explanation: 789 maps to 789, 456 maps to 456, and 123 maps to 123. Thus, the sorted array is [123,456,789].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":991,"row":{"number":2310,"difficulty":1,"question":"class Solution:\n    def minimumNumbers(self, num: int, k: int) -> int:\n        \"\"\"\n        Given two integers num and k, consider a set of positive integers with the following properties:\n            The units digit of each integer is k.\n            The sum of the integers is num.\n        Return the minimum possible size of such a set, or -1 if no such set exists.\n        Note:\n            The set can contain multiple instances of the same integer, and the sum of an empty set is considered 0.\n            The units digit of a number is the rightmost digit of the number.\n        Example 1:\n        Input: num = 58, k = 9\n        Output: 2\n        Explanation:\n        One valid set is [9,49], as the sum is 58 and each integer has a units digit of 9.\n        Another valid set is [19,39].\n        It can be shown that 2 is the minimum possible size of a valid set.\n        Example 2:\n        Input: num = 37, k = 2\n        Output: -1\n        Explanation: It is not possible to obtain a sum of 37 using only integers that have a units digit of 2.\n        Example 3:\n        Input: num = 0, k = 7\n        Output: 0\n        Explanation: The sum of an empty set is considered 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":992,"row":{"number":2226,"difficulty":1,"question":"class Solution:\n    def maximumCandies(self, candies: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.\n        You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.\n        Return the maximum number of candies each child can get.\n        Example 1:\n        Input: candies = [5,8,6], k = 3\n        Output: 5\n        Explanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n        Example 2:\n        Input: candies = [2,5], k = 11\n        Output: 0\n        Explanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":993,"row":{"number":1960,"difficulty":2,"question":"class Solution:\n    def maxProduct(self, s: str) -> int:\n        \"\"\"\n        You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized.\n        More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive.\n        Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings.\n        A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\n        Example 1:\n        Input: s = \"ababbb\"\n        Output: 9\n        Explanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n        Example 2:\n        Input: s = \"zaaaxbbby\"\n        Output: 9\n        Explanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":994,"row":{"number":1206,"difficulty":2,"question":"class Skiplist:\n    def __init__(self):\n    def search(self, target: int) -> bool:\n    def add(self, num: int) -> None:\n    def erase(self, num: int) -> bool:\n        \"\"\"\n        Design a Skiplist without using any built-in libraries.\n        A skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.\n        For example, we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way:\n        Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons\n        You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n).\n        See more about Skiplist: https://en.wikipedia.org/wiki/Skip_list\n        Implement the Skiplist class:\n            Skiplist() Initializes the object of the skiplist.\n            bool search(int target) Returns true if the integer target exists in the Skiplist or false otherwise.\n            void add(int num) Inserts the value num into the SkipList.\n            bool erase(int num) Removes the value num from the Skiplist and returns true. If num does not exist in the Skiplist, do nothing and return false. If there exist multiple num values, removing any one of them is fine.\n        Note that duplicates may exist in the Skiplist, your code needs to handle this situation.\n        Example 1:\n        Input\n        [\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"]\n        [[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\n        Output\n        [null, null, null, null, false, null, true, false, true, false]\n        Explanation\n        Skiplist skiplist = new Skiplist();\n        skiplist.add(1);\n        skiplist.add(2);\n        skiplist.add(3);\n        skiplist.search(0); // return False\n        skiplist.add(4);\n        skiplist.search(1); // return True\n        skiplist.erase(0);  // return False, 0 is not in skiplist.\n        skiplist.erase(1);  // return True\n        skiplist.search(1); // return False, 1 has already been erased.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":995,"row":{"number":1226,"difficulty":1,"question":"class DiningPhilosophers:\n    def wantsToEat(self,\n                   philosopher: int,\n                   pickLeftFork: 'Callable[[], None]',\n                   pickRightFork: 'Callable[[], None]',\n                   eat: 'Callable[[], None]',\n                   putLeftFork: 'Callable[[], None]',\n                   putRightFork: 'Callable[[], None]') -> None:\n        \"\"\"\n        Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers.\n        Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks.\n        Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite supply and an infinite demand are assumed.\n        Design a discipline of behaviour (a concurrent algorithm) such that no philosopher will starve; i.e., each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think.\n        The problem statement and the image above are taken from wikipedia.org\n        The philosophers' ids are numbered from 0 to 4 in a clockwise order. Implement the function void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) where:\n            philosopher is the id of the philosopher who wants to eat.\n            pickLeftFork and pickRightFork are functions you can call to pick the corresponding forks of that philosopher.\n            eat is a function you can call to let the philosopher eat once he has picked both forks.\n            putLeftFork and putRightFork are functions you can call to put down the corresponding forks of that philosopher.\n            The philosophers are assumed to be thinking as long as they are not asking to eat (the function is not being called with their number).\n        Five threads, each representing a philosopher, will simultaneously use one object of your class to simulate the process. The function may be called for the same philosopher more than once, even before the last call ends.\n        Example 1:\n        Input: n = 1\n        Output: [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]\n        Explanation:\n        n is the number of times each philosopher will call the function.\n        The output array describes the calls you made to the functions controlling the forks and the eat function, its format is:\n        output[i] = [a, b, c] (three integers)\n        - a is the id of a philosopher.\n        - b specifies the fork: {1 : left, 2 : right}.\n        - c specifies the operation: {1 : pick, 2 : put, 3 : eat}.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":996,"row":{"number":1221,"difficulty":0,"question":"class Solution:\n    def balancedStringSplit(self, s: str) -> int:\n        \"\"\"\n        Balanced strings are those that have an equal quantity of 'L' and 'R' characters.\n        Given a balanced string s, split it into some number of substrings such that:\n            Each substring is balanced.\n        Return the maximum number of balanced strings you can obtain.\n        Example 1:\n        Input: s = \"RLRRLLRLRL\"\n        Output: 4\n        Explanation: s can be split into \"RL\", \"RRLL\", \"RL\", \"RL\", each substring contains same number of 'L' and 'R'.\n        Example 2:\n        Input: s = \"RLRRRLLRLL\"\n        Output: 2\n        Explanation: s can be split into \"RL\", \"RRRLLRLL\", each substring contains same number of 'L' and 'R'.\n        Note that s cannot be split into \"RL\", \"RR\", \"RL\", \"LR\", \"LL\", because the 2nd and 5th substrings are not balanced.\n        Example 3:\n        Input: s = \"LLLLRRRR\"\n        Output: 1\n        Explanation: s can be split into \"LLLLRRRR\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":997,"row":{"number":1222,"difficulty":1,"question":"class Solution:\n    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:\n        \"\"\"\n        On a 0-indexed 8 x 8 chessboard, there can be multiple black queens ad one white king.\n        You are given a 2D integer array queens where queens[i] = [xQueeni, yQueeni] represents the position of the ith black queen on the chessboard. You are also given an integer array king of length 2 where king = [xKing, yKing] represents the position of the white king.\n        Return the coordinates of the black queens that can directly attack the king. You may return the answer in any order.\n        Example 1:\n        Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]\n        Output: [[0,1],[1,0],[3,3]]\n        Explanation: The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).\n        Example 2:\n        Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]\n        Output: [[2,2],[3,4],[4,4]]\n        Explanation: The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":998,"row":{"number":1223,"difficulty":2,"question":"class Solution:\n    def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        \"\"\"\n        A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] (1-indexed) consecutive times.\n        Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 109 + 7.\n        Two sequences are considered different if at least one element differs from each other.\n        Example 1:\n        Input: n = 2, rollMax = [1,1,2,2,2,3]\n        Output: 34\n        Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n        Example 2:\n        Input: n = 2, rollMax = [1,1,1,1,1,1]\n        Output: 30\n        Example 3:\n        Input: n = 3, rollMax = [1,1,1,2,2,3]\n        Output: 181\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":999,"row":{"number":1224,"difficulty":2,"question":"class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums of positive integers, return the longest possible length of an array prefix of nums, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.\n        If after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).\n        Example 1:\n        Input: nums = [2,2,1,1,5,3,3,5]\n        Output: 7\n        Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4] = 5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.\n        Example 2:\n        Input: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]\n        Output: 13\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}