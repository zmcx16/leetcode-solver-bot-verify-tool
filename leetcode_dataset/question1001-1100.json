{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1000,"row":{"number":2202,"difficulty":1,"question":"class Solution:\n    def maximumTop(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums representing the contents of a pile, where nums[0] is the topmost element of the pile.\n        In one move, you can perform either of the following:\n            If the pile is not empty, remove the topmost element of the pile.\n            If there are one or more removed elements, add any one of them back onto the pile. This element becomes the new topmost element.\n        You are also given an integer k, which denotes the total number of moves to be made.\n        Return the maximum value of the topmost element of the pile possible after exactly k moves. In case it is not possible to obtain a non-empty pile after k moves, return -1.\n        Example 1:\n        Input: nums = [5,2,2,4,0,6], k = 4\n        Output: 5\n        Explanation:\n        One of the ways we can end with 5 at the top of the pile after 4 moves is as follows:\n        - Step 1: Remove the topmost element = 5. The pile becomes [2,2,4,0,6].\n        - Step 2: Remove the topmost element = 2. The pile becomes [2,4,0,6].\n        - Step 3: Remove the topmost element = 2. The pile becomes [4,0,6].\n        - Step 4: Add 5 back onto the pile. The pile becomes [5,4,0,6].\n        Note that this is not the only way to end with 5 at the top of the pile. It can be shown that 5 is the largest answer possible after 4 moves.\n        Example 2:\n        Input: nums = [2], k = 1\n        Output: -1\n        Explanation: \n        In the first move, our only option is to pop the topmost element of the pile.\n        Since it is not possible to obtain a non-empty pile after one move, we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1001,"row":{"number":2321,"difficulty":2,"question":"class Solution:\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two 0-indexed integer arrays nums1 and nums2, both of length n.\n        You can choose two integers left and right where 0 <= left <= right < n and swap the subarray nums1[left...right] with the subarray nums2[left...right].\n            For example, if nums1 = [1,2,3,4,5] and nums2 = [11,12,13,14,15] and you choose left = 1 and right = 2, nums1 becomes [1,12,13,4,5] and nums2 becomes [11,2,3,14,15].\n        You may choose to apply the mentioned operation once or not do anything.\n        The score of the arrays is the maximum of sum(nums1) and sum(nums2), where sum(arr) is the sum of all the elements in the array arr.\n        Return the maximum possible score.\n        A subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).\n        Example 1:\n        Input: nums1 = [60,60,60], nums2 = [10,90,10]\n        Output: 210\n        Explanation: Choosing left = 1 and right = 1, we have nums1 = [60,90,60] and nums2 = [10,60,10].\n        The score is max(sum(nums1), sum(nums2)) = max(210, 80) = 210.\n        Example 2:\n        Input: nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]\n        Output: 220\n        Explanation: Choosing left = 3, right = 4, we have nums1 = [20,40,20,40,20] and nums2 = [50,20,50,70,30].\n        The score is max(sum(nums1), sum(nums2)) = max(140, 220) = 220.\n        Example 3:\n        Input: nums1 = [7,11,13], nums2 = [1,1,1]\n        Output: 31\n        Explanation: We choose not to swap any subarray.\n        The score is max(sum(nums1), sum(nums2)) = max(31, 3) = 31.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1002,"row":{"number":1232,"difficulty":0,"question":"class Solution:\r\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\n        \"\"\"\n        You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.\r\n        Example 1:\r\n        Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\r\n        Output: true\r\n        Example 2:\r\n        Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]\r\n        Output: false\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1003,"row":{"number":1233,"difficulty":1,"question":"class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \"\"\"\n        Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order.\n        If a folder[i] is located within another folder[j], it is called a sub-folder of it.\n        The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters.\n            For example, \"/leetcode\" and \"/leetcode/problems\" are valid paths while an empty string and \"/\" are not.\n        Example 1:\n        Input: folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        Output: [\"/a\",\"/c/d\",\"/c/f\"]\n        Explanation: Folders \"/a/b\" is a subfolder of \"/a\" and \"/c/d/e\" is inside of folder \"/c/d\" in our filesystem.\n        Example 2:\n        Input: folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"]\n        Output: [\"/a\"]\n        Explanation: Folders \"/a/b/c\" and \"/a/b/d\" will be removed because they are subfolders of \"/a\".\n        Example 3:\n        Input: folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\n        Output: [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1004,"row":{"number":1234,"difficulty":1,"question":"class Solution:\n    def balancedString(self, s: str) -> int:\n        \"\"\"\n        You are given a string s of length n containing only four kinds of characters: 'Q', 'W', 'E', and 'R'.\n        A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string.\n        Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. If s is already balanced, return 0.\n        Example 1:\n        Input: s = \"QWER\"\n        Output: 0\n        Explanation: s is already balanced.\n        Example 2:\n        Input: s = \"QQWE\"\n        Output: 1\n        Explanation: We need to replace a 'Q' to 'R', so that \"RQWE\" (or \"QRWE\") is balanced.\n        Example 3:\n        Input: s = \"QQQW\"\n        Output: 2\n        Explanation: We can replace the first \"QQ\" to \"ER\". \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1005,"row":{"number":1235,"difficulty":2,"question":"class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \"\"\"\n        We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\n        You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n        If you choose a job that ends at time X you will be able to start another job that starts at time X.\n        Example 1:\n        Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n        Output: 120\n        Explanation: The subset chosen is the first and fourth job. \n        Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n        Example 2:\n        Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n        Output: 150\n        Explanation: The subset chosen is the first, fourth and fifth job. \n        Profit obtained 150 = 20 + 70 + 60.\n        Example 3:\n        Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n        Output: 6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1006,"row":{"number":2273,"difficulty":0,"question":"class Solution:\n    def removeAnagrams(self, words: List[str]) -> List[str]:\n        \"\"\"\n        You are given a 0-indexed string array words, where words[i] consists of lowercase English letters.\n        In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions.\n        Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, \"dacb\" is an anagram of \"abdc\".\n        Example 1:\n        Input: words = [\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]\n        Output: [\"abba\",\"cd\"]\n        Explanation:\n        One of the ways we can obtain the resultant array is by using the following operations:\n        - Since words[2] = \"bbaa\" and words[1] = \"baba\" are anagrams, we choose index 2 and delete words[2].\n          Now words = [\"abba\",\"baba\",\"cd\",\"cd\"].\n        - Since words[1] = \"baba\" and words[0] = \"abba\" are anagrams, we choose index 1 and delete words[1].\n          Now words = [\"abba\",\"cd\",\"cd\"].\n        - Since words[2] = \"cd\" and words[1] = \"cd\" are anagrams, we choose index 2 and delete words[2].\n          Now words = [\"abba\",\"cd\"].\n        We can no longer perform any operations, so [\"abba\",\"cd\"] is the final answer.\n        Example 2:\n        Input: words = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n        Output: [\"a\",\"b\",\"c\",\"d\",\"e\"]\n        Explanation:\n        No two adjacent strings in words are anagrams of each other, so no operations are performed.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1007,"row":{"number":2225,"difficulty":1,"question":"class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\n        Return a list answer of size 2 where:\n            answer[0] is a list of all players that have not lost any matches.\n            answer[1] is a list of all players that have lost exactly one match.\n        The values in the two lists should be returned in increasing order.\n        Note:\n            You should only consider the players that have played at least one match.\n            The testcases will be generated such that no two matches will have the same outcome.\n        Example 1:\n        Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\n        Output: [[1,2,10],[4,5,7,8]]\n        Explanation:\n        Players 1, 2, and 10 have not lost any matches.\n        Players 4, 5, 7, and 8 each have lost one match.\n        Players 3, 6, and 9 each have lost two matches.\n        Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].\n        Example 2:\n        Input: matches = [[2,3],[1,3],[5,4],[6,4]]\n        Output: [[1,2,5,6],[]]\n        Explanation:\n        Players 1, 2, 5, and 6 have not lost any matches.\n        Players 3 and 4 each have lost two matches.\n        Thus, answer[0] = [1,2,5,6] and answer[1] = [].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1008,"row":{"number":2216,"difficulty":1,"question":"class Solution:\n    def minDeletion(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. The array nums is beautiful if:\n            nums.length is even.\n            nums[i] != nums[i + 1] for all i % 2 == 0.\n        Note that an empty array is considered beautiful.\n        You can delete any number of elements from nums. When you delete an element, all the elements to the right of the deleted element will be shifted one unit to the left to fill the gap created and all the elements to the left of the deleted element will remain unchanged.\n        Return the minimum number of elements to delete from nums to make it beautiful.\n        Example 1:\n        Input: nums = [1,1,2,3,5]\n        Output: 1\n        Explanation: You can delete either nums[0] or nums[1] to make nums = [1,2,3,5] which is beautiful. It can be proven you need at least 1 deletion to make nums beautiful.\n        Example 2:\n        Input: nums = [1,1,2,2,3,3]\n        Output: 2\n        Explanation: You can delete nums[0] and nums[5] to make nums = [1,2,2,3] which is beautiful. It can be proven you need at least 2 deletions to make nums beautiful.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1009,"row":{"number":2193,"difficulty":2,"question":"class Solution:\n    def minMovesToMakePalindrome(self, s: str) -> int:\n        \"\"\"\n        You are given a string s consisting only of lowercase English letters.\n        In one move, you can select any two adjacent characters of s and swap them.\n        Return the minimum number of moves needed to make s a palindrome.\n        Note that the input will be generated such that s can always be converted to a palindrome.\n        Example 1:\n        Input: s = \"aabb\"\n        Output: 2\n        Explanation:\n        We can obtain two palindromes from s, \"abba\" and \"baab\". \n        - We can obtain \"abba\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"abba\".\n        - We can obtain \"baab\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"baab\".\n        Thus, the minimum number of moves needed to make s a palindrome is 2.\n        Example 2:\n        Input: s = \"letelt\"\n        Output: 2\n        Explanation:\n        One of the palindromes we can obtain from s in 2 moves is \"lettel\".\n        One of the ways we can obtain it is \"letelt\" -> \"letetl\" -> \"lettel\".\n        Other palindromes such as \"tleelt\" can also be obtained in 2 moves.\n        It can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1010,"row":{"number":1237,"difficulty":1,"question":"\n        \"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       def f(self, x, y):\n        Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order.\n        While the exact formula is hidden, the function is monotonically increasing, i.e.:\n            f(x, y) < f(x + 1, y)\n            f(x, y) < f(x, y + 1)\n        The function interface is defined like this:\n        interface CustomFunction {\n        public:\n          // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.\n          int f(int x, int y);\n        };\n        We will judge your solution as follows:\n            The judge has a list of 9 hidden implementations of CustomFunction, along with a way to generate an answer key of all valid pairs for a specific z.\n            The judge will receive two inputs: a function_id (to determine which implementation to test your code with), and the target z.\n            The judge will call your findSolution and compare your results with the answer key.\n            If your results match the answer key, your solution will be Accepted.\n        Example 1:\n        Input: function_id = 1, z = 5\n        Output: [[1,4],[2,3],[3,2],[4,1]]\n        Explanation: The hidden formula for function_id = 1 is f(x, y) = x + y.\n        The following positive integer values of x and y make f(x, y) equal to 5:\n        x=1, y=4 -> f(1, 4) = 1 + 4 = 5.\n        x=2, y=3 -> f(2, 3) = 2 + 3 = 5.\n        x=3, y=2 -> f(3, 2) = 3 + 2 = 5.\n        x=4, y=1 -> f(4, 1) = 4 + 1 = 5.\n        Example 2:\n        Input: function_id = 2, z = 5\n        Output: [[1,5],[5,1]]\n        Explanation: The hidden formula for function_id = 2 is f(x, y) = x * y.\n        The following positive integer values of x and y make f(x, y) equal to 5:\n        x=1, y=5 -> f(1, 5) = 1 * 5 = 5.\n        x=5, y=1 -> f(5, 1) = 5 * 1 = 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1011,"row":{"number":1238,"difficulty":1,"question":"class Solution:\r\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        \"\"\"\n        Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that :\r\n            p[0] = start\r\n            p[i] and p[i+1] differ by only one bit in their binary representation.\r\n            p[0] and p[2^n -1] must also differ by only one bit in their binary representation.\r\n        Example 1:\r\n        Input: n = 2, start = 3\r\n        Output: [3,2,0,1]\r\n        Explanation: The binary representation of the permutation is (11,10,00,01). \r\n        All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]\r\n        Example 2:\r\n        Input: n = 3, start = 2\r\n        Output: [2,6,7,5,4,0,1,3]\r\n        Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011).\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1012,"row":{"number":1239,"difficulty":1,"question":"class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \"\"\"\n        You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.\n        Return the maximum possible length of s.\n        A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: arr = [\"un\",\"iq\",\"ue\"]\n        Output: 4\n        Explanation: All the valid concatenations are:\n        - \"\"\n        - \"un\"\n        - \"iq\"\n        - \"ue\"\n        - \"uniq\" (\"un\" + \"iq\")\n        - \"ique\" (\"iq\" + \"ue\")\n        Maximum length is 4.\n        Example 2:\n        Input: arr = [\"cha\",\"r\",\"act\",\"ers\"]\n        Output: 6\n        Explanation: Possible longest valid concatenations are \"chaers\" (\"cha\" + \"ers\") and \"acters\" (\"act\" + \"ers\").\n        Example 3:\n        Input: arr = [\"abcdefghijklmnopqrstuvwxyz\"]\n        Output: 26\n        Explanation: The only string in arr has all 26 characters.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1013,"row":{"number":1240,"difficulty":2,"question":"class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        \"\"\"\n        Given a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle.\n        Example 1:\n        Input: n = 2, m = 3\n        Output: 3\n        Explanation: 3 squares are necessary to cover the rectangle.\n        2 (squares of 1x1)\n        1 (square of 2x2)\n        Example 2:\n        Input: n = 5, m = 8\n        Output: 5\n        Example 3:\n        Input: n = 11, m = 13\n        Output: 6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1014,"row":{"number":1227,"difficulty":1,"question":"class Solution:\n    def nthPersonGetsNthSeat(self, n: int) -> float:\n        \"\"\"\n        n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:\n            Take their own seat if it is still available, and\n            Pick other seats randomly when they find their seat occupied\n        Return the probability that the nth person gets his own seat.\n        Example 1:\n        Input: n = 1\n        Output: 1.00000\n        Explanation: The first person can only get the first seat.\n        Example 2:\n        Input: n = 2\n        Output: 0.50000\n        Explanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1015,"row":{"number":2309,"difficulty":0,"question":"class Solution:\n    def greatestLetter(self, s: str) -> str:\n        \"\"\"\n        Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string.\n        An English letter b is greater than another letter a if b appears after a in the English alphabet.\n        Example 1:\n        Input: s = \"lEeTcOdE\"\n        Output: \"E\"\n        Explanation:\n        The letter 'E' is the only letter to appear in both lower and upper case.\n        Example 2:\n        Input: s = \"arRAzFif\"\n        Output: \"R\"\n        Explanation:\n        The letter 'R' is the greatest letter to appear in both lower and upper case.\n        Note that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'.\n        Example 3:\n        Input: s = \"AbCdEfGhIjK\"\n        Output: \"\"\n        Explanation:\n        There is no letter that appears in both lower and upper case.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1016,"row":{"number":1726,"difficulty":1,"question":"class Solution:\n    def tupleSameProduct(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.\n        Example 1:\n        Input: nums = [2,3,4,6]\n        Output: 8\n        Explanation: There are 8 valid tuples:\n        (2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)\n        (3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)\n        Example 2:\n        Input: nums = [1,2,4,5,10]\n        Output: 16\n        Explanation: There are 16 valid tuples:\n        (1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)\n        (2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)\n        (2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)\n        (4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1017,"row":{"number":1691,"difficulty":2,"question":"class Solution:\n    def maxHeight(self, cuboids: List[List[int]]) -> int:\n        \"\"\"\n        Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.\n        You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.\n        Return the maximum height of the stacked cuboids.\n        Example 1:\n        Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]\n        Output: 190\n        Explanation:\n        Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.\n        Cuboid 0 is placed next with the 45x20 side facing down with height 50.\n        Cuboid 2 is placed next with the 23x12 side facing down with height 45.\n        The total height is 95 + 50 + 45 = 190.\n        Example 2:\n        Input: cuboids = [[38,25,45],[76,35,3]]\n        Output: 76\n        Explanation:\n        You can't place any of the cuboids on the other.\n        We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.\n        Example 3:\n        Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]\n        Output: 102\n        Explanation:\n        After rearranging the cuboids, you can see that all cuboids have the same dimension.\n        You can place the 11x7 side down on all cuboids so their heights are 17.\n        The maximum height of stacked cuboids is 6 * 17 = 102.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1018,"row":{"number":1247,"difficulty":1,"question":"class Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        \"\"\"\n        You are given two strings s1 and s2 of equal length consisting of letters \"x\" and \"y\" only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].\n        Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.\n        Example 1:\n        Input: s1 = \"xx\", s2 = \"yy\"\n        Output: 1\n        Explanation: Swap s1[0] and s2[1], s1 = \"yx\", s2 = \"yx\".\n        Example 2:\n        Input: s1 = \"xy\", s2 = \"yx\"\n        Output: 2\n        Explanation: Swap s1[0] and s2[0], s1 = \"yy\", s2 = \"xx\".\n        Swap s1[0] and s2[1], s1 = \"xy\", s2 = \"xy\".\n        Note that you cannot swap s1[0] and s1[1] to make s1 equal to \"yx\", cause we can only swap chars in different strings.\n        Example 3:\n        Input: s1 = \"xx\", s2 = \"xy\"\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1019,"row":{"number":1248,"difficulty":1,"question":"class Solution:\r\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\r\n        Return the number of nice sub-arrays.\r\n        Example 1:\r\n        Input: nums = [1,1,2,1,1], k = 3\r\n        Output: 2\r\n        Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].\r\n        Example 2:\r\n        Input: nums = [2,4,6], k = 1\r\n        Output: 0\r\n        Explanation: There is no odd numbers in the array.\r\n        Example 3:\r\n        Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\r\n        Output: 16\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1020,"row":{"number":1249,"difficulty":1,"question":"class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \"\"\"\n        Given a string s of '(' , ')' and lowercase English characters.\n        Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\n        Formally, a parentheses string is valid if and only if:\n            It is the empty string, contains only lowercase characters, or\n            It can be written as AB (A concatenated with B), where A and B are valid strings, or\n            It can be written as (A), where A is a valid string.\n        Example 1:\n        Input: s = \"lee(t(c)o)de)\"\n        Output: \"lee(t(c)o)de\"\n        Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n        Example 2:\n        Input: s = \"a)b(c)d\"\n        Output: \"ab(c)d\"\n        Example 3:\n        Input: s = \"))((\"\n        Output: \"\"\n        Explanation: An empty string is also valid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1021,"row":{"number":1250,"difficulty":2,"question":"class Solution:\n    def isGoodArray(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given an array nums of positive integers. Your task is to select some subset of nums, multiply each element by an integer and add all these numbers. The array is said to be good if you can obtain a sum of 1 from the array by any possible subset and multiplicand.\n        Return True if the array is good otherwise return False.\n        Example 1:\n        Input: nums = [12,5,7,23]\n        Output: true\n        Explanation: Pick numbers 5 and 7.\n        5*3 + 7*(-2) = 1\n        Example 2:\n        Input: nums = [29,6,10]\n        Output: true\n        Explanation: Pick numbers 29, 6 and 10.\n        29*1 + 6*(-3) + 10*(-1) = 1\n        Example 3:\n        Input: nums = [3,6]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1022,"row":{"number":2217,"difficulty":1,"question":"class Solution:\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\n        \"\"\"\n        Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists.\n        A palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.\n        Example 1:\n        Input: queries = [1,2,3,4,5,90], intLength = 3\n        Output: [101,111,121,131,141,999]\n        Explanation:\n        The first few palindromes of length 3 are:\n        101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\n        The 90th palindrome of length 3 is 999.\n        Example 2:\n        Input: queries = [2,4,6], intLength = 4\n        Output: [1111,1331,1551]\n        Explanation:\n        The first six palindromes of length 4 are:\n        1001, 1111, 1221, 1331, 1441, and 1551.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1023,"row":{"number":2312,"difficulty":2,"question":"class Solution:\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\n        \"\"\"\n        You are given two integers m and n that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array prices, where prices[i] = [hi, wi, pricei] indicates you can sell a rectangular piece of wood of height hi and width wi for pricei dollars.\n        To cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to prices. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you cannot rotate a piece to swap its height and width.\n        Return the maximum money you can earn after cutting an m x n piece of wood.\n        Note that you can cut the piece of wood as many times as you want.\n        Example 1:\n        Input: m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]\n        Output: 19\n        Explanation: The diagram above shows a possible scenario. It consists of:\n        - 2 pieces of wood shaped 2 x 2, selling for a price of 2 * 7 = 14.\n        - 1 piece of wood shaped 2 x 1, selling for a price of 1 * 3 = 3.\n        - 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\n        This obtains a total of 14 + 3 + 2 = 19 money earned.\n        It can be shown that 19 is the maximum amount of money that can be earned.\n        Example 2:\n        Input: m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]\n        Output: 32\n        Explanation: The diagram above shows a possible scenario. It consists of:\n        - 3 pieces of wood shaped 3 x 2, selling for a price of 3 * 10 = 30.\n        - 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\n        This obtains a total of 30 + 2 = 32 money earned.\n        It can be shown that 32 is the maximum amount of money that can be earned.\n        Notice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1024,"row":{"number":1252,"difficulty":0,"question":"class Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        \"\"\"\n        There is an m x n matrix that is initialized to all 0's. There is also a 2D array indices where each indices[i] = [ri, ci] represents a 0-indexed location to perform some increment operations on the matrix.\n        For each location indices[i], do both of the following:\n            Increment all the cells on row ri.\n            Increment all the cells on column ci.\n        Given m, n, and indices, return the number of odd-valued cells in the matrix after applying the increment to all locations in indices.\n        Example 1:\n        Input: m = 2, n = 3, indices = [[0,1],[1,1]]\n        Output: 6\n        Explanation: Initial matrix = [[0,0,0],[0,0,0]].\n        After applying first increment it becomes [[1,2,1],[0,1,0]].\n        The final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.\n        Example 2:\n        Input: m = 2, n = 2, indices = [[1,1],[0,0]]\n        Output: 0\n        Explanation: Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1025,"row":{"number":1253,"difficulty":1,"question":"class Solution:\n    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given the following details of a matrix with n columns and 2 rows :\n            The matrix is a binary matrix, which means each element in the matrix can be 0 or 1.\n            The sum of elements of the 0-th(upper) row is given as upper.\n            The sum of elements of the 1-st(lower) row is given as lower.\n            The sum of elements in the i-th column(0-indexed) is colsum[i], where colsum is given as an integer array with length n.\n        Your task is to reconstruct the matrix with upper, lower and colsum.\n        Return it as a 2-D integer array.\n        If there are more than one valid solution, any of them will be accepted.\n        If no valid solution exists, return an empty 2-D array.\n        Example 1:\n        Input: upper = 2, lower = 1, colsum = [1,1,1]\n        Output: [[1,1,0],[0,0,1]]\n        Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers.\n        Example 2:\n        Input: upper = 2, lower = 3, colsum = [2,2,1,1]\n        Output: []\n        Example 3:\n        Input: upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]\n        Output: [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1026,"row":{"number":1254,"difficulty":1,"question":"class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.\n        Return the number of closed islands.\n        Example 1:\n        Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\n        Output: 2\n        Explanation: \n        Islands in gray are closed because they are completely surrounded by water (group of 1s).\n        Example 2:\n        Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]\n        Output: 1\n        Example 3:\n        Input: grid = [[1,1,1,1,1,1,1],\n                       [1,0,0,0,0,0,1],\n                       [1,0,1,1,1,0,1],\n                       [1,0,1,0,1,0,1],\n                       [1,0,1,1,1,0,1],\n                       [1,0,0,0,0,0,1],\n                       [1,1,1,1,1,1,1]]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1027,"row":{"number":1255,"difficulty":2,"question":"class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        \"\"\"\n        Given a list of words, list of  single letters (might be repeating) and score of every character.\n        Return the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).\n        It is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.\n        Example 1:\n        Input: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\n        Output: 23\n        Explanation:\n        Score  a=1, c=9, d=5, g=3, o=2\n        Given letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23.\n        Words \"dad\" and \"dog\" only get a score of 21.\n        Example 2:\n        Input: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\n        Output: 27\n        Explanation:\n        Score  a=4, b=4, c=4, x=5, z=10\n        Given letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27.\n        Word \"xxxz\" only get a score of 25.\n        Example 3:\n        Input: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\n        Output: 0\n        Explanation:\n        Letter \"e\" can only be used once.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1028,"row":{"number":2303,"difficulty":0,"question":"class Solution:\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\n        \"\"\"\n        You are given a 0-indexed 2D integer array brackets where brackets[i] = [upperi, percenti] means that the ith tax bracket has an upper bound of upperi and is taxed at a rate of percenti. The brackets are sorted by upper bound (i.e. upperi-1 < upperi for 0 < i < brackets.length).\n        Tax is calculated as follows:\n            The first upper0 dollars earned are taxed at a rate of percent0.\n            The next upper1 - upper0 dollars earned are taxed at a rate of percent1.\n            The next upper2 - upper1 dollars earned are taxed at a rate of percent2.\n            And so on.\n        You are given an integer income representing the amount of money you earned. Return the amount of money that you have to pay in taxes. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: brackets = [[3,50],[7,10],[12,25]], income = 10\n        Output: 2.65000\n        Explanation:\n        Based on your income, you have 3 dollars in the 1st tax bracket, 4 dollars in the 2nd tax bracket, and 3 dollars in the 3rd tax bracket.\n        The tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.\n        In total, you pay $3 * 50% + $4 * 10% + $3 * 25% = $2.65 in taxes.\n        Example 2:\n        Input: brackets = [[1,0],[4,25],[5,50]], income = 2\n        Output: 0.25000\n        Explanation:\n        Based on your income, you have 1 dollar in the 1st tax bracket and 1 dollar in the 2nd tax bracket.\n        The tax rate for the two tax brackets is 0% and 25%, respectively.\n        In total, you pay $1 * 0% + $1 * 25% = $0.25 in taxes.\n        Example 3:\n        Input: brackets = [[2,50]], income = 0\n        Output: 0.00000\n        Explanation:\n        You have no income to tax, so you have to pay a total of $0 in taxes.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1029,"row":{"number":1260,"difficulty":0,"question":"class Solution:\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        \"\"\"\n        Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.\n        In one shift operation:\n            Element at grid[i][j] moves to grid[i][j + 1].\n            Element at grid[i][n - 1] moves to grid[i + 1][0].\n            Element at grid[m - 1][n - 1] moves to grid[0][0].\n        Return the 2D grid after applying shift operation k times.\n        Example 1:\n        Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n        Output: [[9,1,2],[3,4,5],[6,7,8]]\n        Example 2:\n        Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\n        Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n        Example 3:\n        Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9\n        Output: [[1,2,3],[4,5,6],[7,8,9]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1030,"row":{"number":1261,"difficulty":1,"question":"class FindElements:\n    def __init__(self, root: Optional[TreeNode]):\n    def find(self, target: int) -> bool:\n        \"\"\"\n        Given a binary tree with the following rules:\n            root.val == 0\n            If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\n            If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n        Now the binary tree is contaminated, which means all treeNode.val have been changed to -1.\n        Implement the FindElements class:\n            FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.\n            bool find(int target) Returns true if the target value exists in the recovered binary tree.\n        Example 1:\n        Input\n        [\"FindElements\",\"find\",\"find\"]\n        [[[-1,null,-1]],[1],[2]]\n        Output\n        [null,false,true]\n        Explanation\n        FindElements findElements = new FindElements([-1,null,-1]); \n        findElements.find(1); // return False \n        findElements.find(2); // return True \n        Example 2:\n        Input\n        [\"FindElements\",\"find\",\"find\",\"find\"]\n        [[[-1,-1,-1,-1,-1]],[1],[3],[5]]\n        Output\n        [null,true,true,false]\n        Explanation\n        FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\n        findElements.find(1); // return True\n        findElements.find(3); // return True\n        findElements.find(5); // return False\n        Example 3:\n        Input\n        [\"FindElements\",\"find\",\"find\",\"find\",\"find\"]\n        [[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\n        Output\n        [null,true,false,false,true]\n        Explanation\n        FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\n        findElements.find(2); // return True\n        findElements.find(3); // return False\n        findElements.find(4); // return False\n        findElements.find(5); // return True\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1031,"row":{"number":1262,"difficulty":1,"question":"class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the maximum possible sum of elements of the array such that it is divisible by three.\n        Example 1:\n        Input: nums = [3,6,5,1,8]\n        Output: 18\n        Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).\n        Example 2:\n        Input: nums = [4]\n        Output: 0\n        Explanation: Since 4 is not divisible by 3, do not pick any number.\n        Example 3:\n        Input: nums = [1,2,3,4,4]\n        Output: 12\n        Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1032,"row":{"number":1263,"difficulty":2,"question":"class Solution:\n    def minPushBox(self, grid: List[List[str]]) -> int:\n        \"\"\"\n        A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.\n        The game is represented by an m x n grid of characters grid where each element is a wall, floor, or box.\n        Your task is to move the box 'B' to the target position 'T' under the following rules:\n            The character 'S' represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell).\n            The character '.' represents the floor which means a free cell to walk.\n            The character '#' represents the wall which means an obstacle (impossible to walk there).\n            There is only one box 'B' and one target cell 'T' in the grid.\n            The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.\n            The player cannot walk through the box.\n        Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.\n        Example 1:\n        Input: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n                       [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n                       [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n                       [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n                       [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n                       [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n        Output: 3\n        Explanation: We return only the number of times the box is pushed.\n        Example 2:\n        Input: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n                       [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n                       [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n                       [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n                       [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n                       [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n        Output: -1\n        Example 3:\n        Input: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n                       [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n                       [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n                       [\"#\",\".\",\".\",\".\",\".\",\"#\"],\n                       [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n                       [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n        Output: 5\n        Explanation: push the box down, left, left, up and up.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1033,"row":{"number":2215,"difficulty":0,"question":"class Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\n            answer[0] is a list of all distinct integers in nums1 which are not present in nums2.\n            answer[1] is a list of all distinct integers in nums2 which are not present in nums1.\n        Note that the integers in the lists may be returned in any order.\n        Example 1:\n        Input: nums1 = [1,2,3], nums2 = [2,4,6]\n        Output: [[1,3],[4,6]]\n        Explanation:\n        For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\n        For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].\n        Example 2:\n        Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]\n        Output: [[3],[]]\n        Explanation:\n        For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\n        Every integer in nums2 is present in nums1. Therefore, answer[1] = [].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1034,"row":{"number":2218,"difficulty":2,"question":"class Solution:\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\n        \"\"\"\n        There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations.\n        In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.\n        Given a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.\n        Example 1:\n        Input: piles = [[1,100,3],[7,8,9]], k = 2\n        Output: 101\n        Explanation:\n        The above diagram shows the different ways we can choose k coins.\n        The maximum total we can obtain is 101.\n        Example 2:\n        Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\n        Output: 706\n        Explanation:\n        The maximum total can be obtained if we choose all coins from the last pile.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1035,"row":{"number":2304,"difficulty":1,"question":"class Solution:\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 0-indexed m x n integer matrix grid consisting of distinct integers from 0 to m * n - 1. You can move in this matrix from a cell to any other cell in the next row. That is, if you are in cell (x, y) such that x < m - 1, you can move to any of the cells (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1). Note that it is not possible to move from cells in the last row.\n        Each possible move has a cost given by a 0-indexed 2D array moveCost of size (m * n) x n, where moveCost[i][j] is the cost of moving from a cell with value i to a cell in column j of the next row. The cost of moving from cells in the last row of grid can be ignored.\n        The cost of a path in grid is the sum of all values of cells visited plus the sum of costs of all the moves made. Return the minimum cost of a path that starts from any cell in the first row and ends at any cell in the last row.\n        Example 1:\n        Input: grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n        Output: 17\n        Explanation: The path with the minimum possible cost is the path 5 -> 0 -> 1.\n        - The sum of the values of cells visited is 5 + 0 + 1 = 6.\n        - The cost of moving from 5 to 0 is 3.\n        - The cost of moving from 0 to 1 is 8.\n        So the total cost of the path is 6 + 3 + 8 = 17.\n        Example 2:\n        Input: grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]\n        Output: 6\n        Explanation: The path with the minimum possible cost is the path 2 -> 3.\n        - The sum of the values of cells visited is 2 + 3 = 5.\n        - The cost of moving from 2 to 3 is 1.\n        So the total cost of this path is 5 + 1 = 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1036,"row":{"number":1266,"difficulty":0,"question":"class Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        \"\"\"\n        On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.\n        You can move according to these rules:\n            In 1 second, you can either:\n                move vertically by one unit,\n                move horizontally by one unit, or\n                move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).\n            You have to visit the points in the same order as they appear in the array.\n            You are allowed to pass through points that appear later in the order, but these do not count as visits.\n        Example 1:\n        Input: points = [[1,1],[3,4],[-1,0]]\n        Output: 7\n        Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   \n        Time from [1,1] to [3,4] = 3 seconds \n        Time from [3,4] to [-1,0] = 4 seconds\n        Total time = 7 seconds\n        Example 2:\n        Input: points = [[3,2],[-2,2]]\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1037,"row":{"number":1267,"difficulty":1,"question":"class Solution:\n    def countServers(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.\n        Return the number of servers that communicate with any other server.\n        Example 1:\n        Input: grid = [[1,0],[0,1]]\n        Output: 0\n        Explanation: No servers can communicate with others.\n        Example 2:\n        Input: grid = [[1,0],[1,1]]\n        Output: 3\n        Explanation: All three servers can communicate with at least one other server.\n        Example 3:\n        Input: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]\n        Output: 4\n        Explanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1038,"row":{"number":1268,"difficulty":1,"question":"class Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        \"\"\"\n        You are given an array of strings products and a string searchWord.\n        Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.\n        Return a list of lists of the suggested products after each character of searchWord is typed.\n        Example 1:\n        Input: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\n        Output: [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]\n        Explanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"].\n        After typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"].\n        After typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"].\n        Example 2:\n        Input: products = [\"havana\"], searchWord = \"havana\"\n        Output: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n        Explanation: The only word \"havana\" will be always suggested while typing the search word.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1039,"row":{"number":1269,"difficulty":2,"question":"class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \"\"\"\n        You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).\n        Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: steps = 3, arrLen = 2\n        Output: 4\n        Explanation: There are 4 differents ways to stay at index 0 after 3 steps.\n        Right, Left, Stay\n        Stay, Right, Left\n        Right, Stay, Left\n        Stay, Stay, Stay\n        Example 2:\n        Input: steps = 2, arrLen = 4\n        Output: 2\n        Explanation: There are 2 differents ways to stay at index 0 after 2 steps\n        Right, Left\n        Stay, Stay\n        Example 3:\n        Input: steps = 4, arrLen = 2\n        Output: 8\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1040,"row":{"number":1275,"difficulty":0,"question":"class Solution:\n    def tictactoe(self, moves: List[List[int]]) -> str:\n        \"\"\"\n        Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:\n            Players take turns placing characters into empty squares ' '.\n            The first player A always places 'X' characters, while the second player B always places 'O' characters.\n            'X' and 'O' characters are always placed into empty squares, never on filled ones.\n            The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n            The game also ends if all squares are non-empty.\n            No more moves can be played if the game is over.\n        Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return \"Draw\". If there are still movements to play return \"Pending\".\n        You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.\n        Example 1:\n        Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\n        Output: \"A\"\n        Explanation: A wins, they always play first.\n        Example 2:\n        Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\n        Output: \"B\"\n        Explanation: B wins.\n        Example 3:\n        Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\n        Output: \"Draw\"\n        Explanation: The game ends in a draw since there are no moves to make.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1041,"row":{"number":1276,"difficulty":1,"question":"class Solution:\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\n        \"\"\"\n        Given two integers tomatoSlices and cheeseSlices. The ingredients of different burgers are as follows:\n            Jumbo Burger: 4 tomato slices and 1 cheese slice.\n            Small Burger: 2 Tomato slices and 1 cheese slice.\n        Return [total_jumbo, total_small] so that the number of remaining tomatoSlices equal to 0 and the number of remaining cheeseSlices equal to 0. If it is not possible to make the remaining tomatoSlices and cheeseSlices equal to 0 return [].\n        Example 1:\n        Input: tomatoSlices = 16, cheeseSlices = 7\n        Output: [1,6]\n        Explantion: To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese.\n        There will be no remaining ingredients.\n        Example 2:\n        Input: tomatoSlices = 17, cheeseSlices = 4\n        Output: []\n        Explantion: There will be no way to use all ingredients to make small and jumbo burgers.\n        Example 3:\n        Input: tomatoSlices = 4, cheeseSlices = 17\n        Output: []\n        Explantion: Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1042,"row":{"number":1277,"difficulty":1,"question":"class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        \"\"\"\n        Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.\n        Example 1:\n        Input: matrix =\n        [\n          [0,1,1,1],\n          [1,1,1,1],\n          [0,1,1,1]\n        ]\n        Output: 15\n        Explanation: \n        There are 10 squares of side 1.\n        There are 4 squares of side 2.\n        There is  1 square of side 3.\n        Total number of squares = 10 + 4 + 1 = 15.\n        Example 2:\n        Input: matrix = \n        [\n          [1,0,1],\n          [1,1,0],\n          [1,1,0]\n        ]\n        Output: 7\n        Explanation: \n        There are 6 squares of side 1.  \n        There is 1 square of side 2. \n        Total number of squares = 6 + 1 = 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1043,"row":{"number":1278,"difficulty":2,"question":"class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \"\"\"\n        You are given a string s containing lowercase letters and an integer k. You need to :\n            First, change some characters of s to other lowercase English letters.\n            Then divide s into k non-empty disjoint substrings such that each substring is a palindrome.\n        Return the minimal number of characters that you need to change to divide the string.\n        Example 1:\n        Input: s = \"abc\", k = 2\n        Output: 1\n        Explanation: You can split the string into \"ab\" and \"c\", and change 1 character in \"ab\" to make it palindrome.\n        Example 2:\n        Input: s = \"aabbc\", k = 3\n        Output: 0\n        Explanation: You can split the string into \"aa\", \"bb\" and \"c\", all of them are palindrome.\n        Example 3:\n        Input: s = \"leetcode\", k = 8\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1044,"row":{"number":1281,"difficulty":0,"question":"class Solution:\n    def subtractProductAndSum(self, n: int) -> int:\n        \"\"\"\n        Given an integer number n, return the difference between the product of its digits and the sum of its digits.\n        Example 1:\n        Input: n = 234\n        Output: 15 \n        Explanation: \n        Product of digits = 2 * 3 * 4 = 24 \n        Sum of digits = 2 + 3 + 4 = 9 \n        Result = 24 - 9 = 15\n        Example 2:\n        Input: n = 4421\n        Output: 21\n        Explanation: \n        Product of digits = 4 * 4 * 2 * 1 = 32 \n        Sum of digits = 4 + 4 + 2 + 1 = 11 \n        Result = 32 - 11 = 21\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1045,"row":{"number":1282,"difficulty":1,"question":"class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        \"\"\"\n        There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.\n        You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.\n        Return a list of groups such that each person i is in a group of size groupSizes[i].\n        Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.\n        Example 1:\n        Input: groupSizes = [3,3,3,3,3,1,3]\n        Output: [[5],[0,1,2],[3,4,6]]\n        Explanation: \n        The first group is [5]. The size is 1, and groupSizes[5] = 1.\n        The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.\n        The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.\n        Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].\n        Example 2:\n        Input: groupSizes = [2,1,3,3,3,2]\n        Output: [[1],[0,5],[2,3,4]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1046,"row":{"number":1283,"difficulty":1,"question":"class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \"\"\"\n        Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\n        Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).\n        The test cases are generated so that there will be an answer.\n        Example 1:\n        Input: nums = [1,2,5,9], threshold = 6\n        Output: 5\n        Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \n        If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \n        Example 2:\n        Input: nums = [44,22,33,11,1], threshold = 5\n        Output: 44\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1047,"row":{"number":1284,"difficulty":2,"question":"class Solution:\n    def minFlips(self, mat: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighbors if they share one edge.\n        Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot.\n        A binary matrix is a matrix with all cells equal to 0 or 1 only.\n        A zero matrix is a matrix with all cells equal to 0.\n        Example 1:\n        Input: mat = [[0,0],[0,1]]\n        Output: 3\n        Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n        Example 2:\n        Input: mat = [[0]]\n        Output: 0\n        Explanation: Given matrix is a zero matrix. We do not need to change it.\n        Example 3:\n        Input: mat = [[1,0,0],[1,0,0]]\n        Output: -1\n        Explanation: Given matrix cannot be a zero matrix.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1048,"row":{"number":1290,"difficulty":0,"question":"class Solution:\n    def getDecimalValue(self, head: ListNode) -> int:\n        \"\"\"\n        Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.\n        Return the decimal value of the number in the linked list.\n        The most significant bit is at the head of the linked list.\n        Example 1:\n        Input: head = [1,0,1]\n        Output: 5\n        Explanation: (101) in base 2 = (5) in base 10\n        Example 2:\n        Input: head = [0]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1049,"row":{"number":1292,"difficulty":1,"question":"class Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\n        \"\"\"\n        Given a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.\n        Example 1:\n        Input: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\n        Output: 2\n        Explanation: The maximum side length of square with sum less than 4 is 2 as shown.\n        Example 2:\n        Input: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1050,"row":{"number":1293,"difficulty":2,"question":"class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        \"\"\"\n        You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step.\n        Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.\n        Example 1:\n        Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n        Output: 6\n        Explanation: \n        The shortest path without eliminating any obstacle is 10.\n        The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).\n        Example 2:\n        Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n        Output: -1\n        Explanation: We need to eliminate at least two obstacles to find such a walk.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1051,"row":{"number":2305,"difficulty":1,"question":"class Solution:\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array cookies, where cookies[i] denotes the number of cookies in the ith bag. You are also given an integer k that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.\n        The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n        Return the minimum unfairness of all distributions.\n        Example 1:\n        Input: cookies = [8,15,10,20,8], k = 2\n        Output: 31\n        Explanation: One optimal distribution is [8,15,8] and [10,20]\n        - The 1st child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.\n        - The 2nd child receives [10,20] which has a total of 10 + 20 = 30 cookies.\n        The unfairness of the distribution is max(31,30) = 31.\n        It can be shown that there is no distribution with an unfairness less than 31.\n        Example 2:\n        Input: cookies = [6,1,3,2,2,4,1,2], k = 3\n        Output: 7\n        Explanation: One optimal distribution is [6,1], [3,2,2], and [4,1,2]\n        - The 1st child receives [6,1] which has a total of 6 + 1 = 7 cookies.\n        - The 2nd child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.\n        - The 3rd child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.\n        The unfairness of the distribution is max(7,7,7) = 7.\n        It can be shown that there is no distribution with an unfairness less than 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1052,"row":{"number":1295,"difficulty":0,"question":"class Solution:\n    def findNumbers(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums of integers, return how many of them contain an even number of digits.\n        Example 1:\n        Input: nums = [12,345,2,6,7896]\n        Output: 2\n        Explanation: \n        12 contains 2 digits (even number of digits). \n        345 contains 3 digits (odd number of digits). \n        2 contains 1 digit (odd number of digits). \n        6 contains 1 digit (odd number of digits). \n        7896 contains 4 digits (even number of digits). \n        Therefore only 12 and 7896 contain an even number of digits.\n        Example 2:\n        Input: nums = [555,901,482,1771]\n        Output: 1 \n        Explanation: \n        Only 1771 contains an even number of digits.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1053,"row":{"number":1296,"difficulty":1,"question":"class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        \"\"\"\n        Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.\n        Return true if it is possible. Otherwise, return false.\n        Example 1:\n        Input: nums = [1,2,3,3,4,4,5,6], k = 4\n        Output: true\n        Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6].\n        Example 2:\n        Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\n        Output: true\n        Explanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].\n        Example 3:\n        Input: nums = [1,2,3,4], k = 3\n        Output: false\n        Explanation: Each array should be divided in subarrays of size 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1054,"row":{"number":1297,"difficulty":1,"question":"class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        \"\"\"\n        Given a string s, return the maximum number of ocurrences of any substring under the following rules:\n            The number of unique characters in the substring must be less than or equal to maxLetters.\n            The substring size must be between minSize and maxSize inclusive.\n        Example 1:\n        Input: s = \"aababcaab\", maxLetters = 2, minSize = 3, maxSize = 4\n        Output: 2\n        Explanation: Substring \"aab\" has 2 ocurrences in the original string.\n        It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).\n        Example 2:\n        Input: s = \"aaaa\", maxLetters = 1, minSize = 3, maxSize = 3\n        Output: 2\n        Explanation: Substring \"aaa\" occur 2 times in the string. It can overlap.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1055,"row":{"number":1298,"difficulty":2,"question":"class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        \"\"\"\n        You have n boxes labeled from 0 to n - 1. You are given four arrays: status, candies, keys, and containedBoxes where:\n            status[i] is 1 if the ith box is open and 0 if the ith box is closed,\n            candies[i] is the number of candies in the ith box,\n            keys[i] is a list of the labels of the boxes you can open after opening the ith box.\n            containedBoxes[i] is a list of the boxes you found inside the ith box.\n        You are given an integer array initialBoxes that contains the labels of the boxes you initially have. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.\n        Return the maximum number of candies you can get following the rules above.\n        Example 1:\n        Input: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]\n        Output: 16\n        Explanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.\n        Box 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.\n        In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.\n        Total number of candies collected = 7 + 4 + 5 = 16 candy.\n        Example 2:\n        Input: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]\n        Output: 6\n        Explanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys.\n        The total number of candies will be 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1056,"row":{"number":1304,"difficulty":0,"question":"class Solution:\n    def sumZero(self, n: int) -> List[int]:\n        \"\"\"\n        Given an integer n, return any array containing n unique integers such that they add up to 0.\n        Example 1:\n        Input: n = 5\n        Output: [-7,-1,1,3,4]\n        Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].\n        Example 2:\n        Input: n = 3\n        Output: [-1,0,1]\n        Example 3:\n        Input: n = 1\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1057,"row":{"number":1305,"difficulty":1,"question":"class Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        \"\"\"\n        Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.\n        Example 1:\n        Input: root1 = [2,1,4], root2 = [1,0,3]\n        Output: [0,1,1,2,3,4]\n        Example 2:\n        Input: root1 = [1,null,8], root2 = [8,1]\n        Output: [1,1,8,8]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1058,"row":{"number":1306,"difficulty":1,"question":"class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \"\"\"\n        Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.\n        Notice that you can not jump outside of the array at any time.\n        Example 1:\n        Input: arr = [4,2,3,0,3,1,2], start = 5\n        Output: true\n        Explanation: \n        All possible ways to reach at index 3 with value 0 are: \n        index 5 -> index 4 -> index 1 -> index 3 \n        index 5 -> index 6 -> index 4 -> index 1 -> index 3 \n        Example 2:\n        Input: arr = [4,2,3,0,3,1,2], start = 0\n        Output: true \n        Explanation: \n        One possible way to reach at index 3 with value 0 is: \n        index 0 -> index 4 -> index 1 -> index 3\n        Example 3:\n        Input: arr = [3,0,2,1,2], start = 2\n        Output: false\n        Explanation: There is no way to reach at index 1 with value 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1059,"row":{"number":1307,"difficulty":2,"question":"class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        \"\"\"\n        Given an equation, represented by words on the left side and the result on the right side.\n        You need to check if the equation is solvable under the following rules:\n            Each character is decoded as one digit (0 - 9).\n            No two characters can map to the same digit.\n            Each words[i] and result are decoded as one number without leading zeros.\n            Sum of numbers on the left side (words) will equal to the number on the right side (result).\n        Return true if the equation is solvable, otherwise return false.\n        Example 1:\n        Input: words = [\"SEND\",\"MORE\"], result = \"MONEY\"\n        Output: true\n        Explanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'\n        Such that: \"SEND\" + \"MORE\" = \"MONEY\" ,  9567 + 1085 = 10652\n        Example 2:\n        Input: words = [\"SIX\",\"SEVEN\",\"SEVEN\"], result = \"TWENTY\"\n        Output: true\n        Explanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4\n        Such that: \"SIX\" + \"SEVEN\" + \"SEVEN\" = \"TWENTY\" ,  650 + 68782 + 68782 = 138214\n        Example 3:\n        Input: words = [\"LEET\",\"CODE\"], result = \"POINT\"\n        Output: false\n        Explanation: There is no possible mapping to satisfy the equation, so we return false.\n        Note that two different characters cannot map to the same digit.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1060,"row":{"number":2269,"difficulty":0,"question":"class Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        \"\"\"\n        The k-beauty of an integer num is defined as the number of substrings of num when it is read as a string that meet the following conditions:\n            It has a length of k.\n            It is a divisor of num.\n        Given integers num and k, return the k-beauty of num.\n        Note:\n            Leading zeros are allowed.\n            0 is not a divisor of any value.\n        A substring is a contiguous sequence of characters in a string.\n        Example 1:\n        Input: num = 240, k = 2\n        Output: 2\n        Explanation: The following are the substrings of num of length k:\n        - \"24\" from \"240\": 24 is a divisor of 240.\n        - \"40\" from \"240\": 40 is a divisor of 240.\n        Therefore, the k-beauty is 2.\n        Example 2:\n        Input: num = 430043, k = 2\n        Output: 2\n        Explanation: The following are the substrings of num of length k:\n        - \"43\" from \"430043\": 43 is a divisor of 430043.\n        - \"30\" from \"430043\": 30 is not a divisor of 430043.\n        - \"00\" from \"430043\": 0 is not a divisor of 430043.\n        - \"04\" from \"430043\": 4 is not a divisor of 430043.\n        - \"43\" from \"430043\": 43 is a divisor of 430043.\n        Therefore, the k-beauty is 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1061,"row":{"number":2192,"difficulty":1,"question":"class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\n        You are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\n        Return a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\n        A node u is an ancestor of another node v if u can reach v via a set of edges.\n        Example 1:\n        Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\n        Output: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\n        Explanation:\n        The above diagram represents the input graph.\n        - Nodes 0, 1, and 2 do not have any ancestors.\n        - Node 3 has two ancestors 0 and 1.\n        - Node 4 has two ancestors 0 and 2.\n        - Node 5 has three ancestors 0, 1, and 3.\n        - Node 6 has five ancestors 0, 1, 2, 3, and 4.\n        - Node 7 has four ancestors 0, 1, 2, and 3.\n        Example 2:\n        Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Output: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\n        Explanation:\n        The above diagram represents the input graph.\n        - Node 0 does not have any ancestor.\n        - Node 1 has one ancestor 0.\n        - Node 2 has two ancestors 0 and 1.\n        - Node 3 has three ancestors 0, 1, and 2.\n        - Node 4 has four ancestors 0, 1, 2, and 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1062,"row":{"number":2227,"difficulty":2,"question":"class Encrypter:\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\n    def encrypt(self, word1: str) -> str:\n    def decrypt(self, word2: str) -> int:\n        \"\"\"\n        You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.\n        A string is encrypted with the following process:\n            For each character c in the string, we find the index i satisfying keys[i] == c in keys.\n            Replace c with values[i] in the string.\n        Note that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string \"\" is returned.\n        A string is decrypted with the following process:\n            For each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.\n            Replace s with keys[i] in the string.\n        Implement the Encrypter class:\n            Encrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.\n            String encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.\n            int decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\n        Example 1:\n        Input\n        [\"Encrypter\", \"encrypt\", \"decrypt\"]\n        [[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\n        Output\n        [null, \"eizfeiam\", 2]\n        Explanation\n        Encrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\n        encrypter.encrypt(\"abcd\"); // return \"eizfeiam\". \n                                   // 'a' maps to \"ei\", 'b' maps to \"zf\", 'c' maps to \"ei\", and 'd' maps to \"am\".\n        encrypter.decrypt(\"eizfeiam\"); // return 2. \n                                      // \"ei\" can map to 'a' or 'c', \"zf\" maps to 'b', and \"am\" maps to 'd'. \n                                      // Thus, the possible strings after decryption are \"abad\", \"cbad\", \"abcd\", and \"cbcd\". \n                                      // 2 of those strings, \"abad\" and \"abcd\", appear in dictionary, so the answer is 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1063,"row":{"number":1309,"difficulty":0,"question":"class Solution:\n    def freqAlphabets(self, s: str) -> str:\n        \"\"\"\n        You are given a string s formed by digits and '#'. We want to map s to English lowercase characters as follows:\n            Characters ('a' to 'i') are represented by ('1' to '9') respectively.\n            Characters ('j' to 'z') are represented by ('10#' to '26#') respectively.\n        Return the string formed after mapping.\n        The test cases are generated so that a unique mapping will always exist.\n        Example 1:\n        Input: s = \"10#11#12\"\n        Output: \"jkab\"\n        Explanation: \"j\" -> \"10#\" , \"k\" -> \"11#\" , \"a\" -> \"1\" , \"b\" -> \"2\".\n        Example 2:\n        Input: s = \"1326#\"\n        Output: \"acz\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1064,"row":{"number":1310,"difficulty":1,"question":"class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti].\n        For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ).\n        Return an array answer where answer[i] is the answer to the ith query.\n        Example 1:\n        Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n        Output: [2,7,14,8] \n        Explanation: \n        The binary representation of the elements in the array are:\n        1 = 0001 \n        3 = 0011 \n        4 = 0100 \n        8 = 1000 \n        The XOR values for queries are:\n        [0,1] = 1 xor 3 = 2 \n        [1,2] = 3 xor 4 = 7 \n        [0,3] = 1 xor 3 xor 4 xor 8 = 14 \n        [3,3] = 8\n        Example 2:\n        Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n        Output: [8,0,4,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1065,"row":{"number":1311,"difficulty":1,"question":"class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \"\"\"\n        There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i.\n        Level 1 of videos are all watched videos by your friends, level 2 of videos are all watched videos by the friends of your friends and so on. In general, the level k of videos are all watched videos by people with the shortest path exactly equal to k with you. Given your id and the level of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest. \n        Example 1:\n        Input: watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n        Output: [\"B\",\"C\"] \n        Explanation: \n        You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):\n        Person with id = 1 -> watchedVideos = [\"C\"] \n        Person with id = 2 -> watchedVideos = [\"B\",\"C\"] \n        The frequencies of watchedVideos by your friends are: \n        B -> 1 \n        C -> 2\n        Example 2:\n        Input: watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n        Output: [\"D\"]\n        Explanation: \n        You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1066,"row":{"number":1312,"difficulty":2,"question":"class Solution:\n    def minInsertions(self, s: str) -> int:\n        \"\"\"\n        Given a string s. In one step you can insert any character at any index of the string.\n        Return the minimum number of steps to make s palindrome.\n        A Palindrome String is one that reads the same backward as well as forward.\n        Example 1:\n        Input: s = \"zzazz\"\n        Output: 0\n        Explanation: The string \"zzazz\" is already palindrome we do not need any insertions.\n        Example 2:\n        Input: s = \"mbadm\"\n        Output: 2\n        Explanation: String can be \"mbdadbm\" or \"mdbabdm\".\n        Example 3:\n        Input: s = \"leetcode\"\n        Output: 5\n        Explanation: Inserting 5 characters the string becomes \"leetcodocteel\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1067,"row":{"number":1317,"difficulty":0,"question":"class Solution:\n    def getNoZeroIntegers(self, n: int) -> List[int]:\n        \"\"\"\n        No-Zero integer is a positive integer that does not contain any 0 in its decimal representation.\n        Given an integer n, return a list of two integers [a, b] where:\n            a and b are No-Zero integers.\n            a + b = n\n        The test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.\n        Example 1:\n        Input: n = 2\n        Output: [1,1]\n        Explanation: Let a = 1 and b = 1.\n        Both a and b are no-zero integers, and a + b = 2 = n.\n        Example 2:\n        Input: n = 11\n        Output: [2,9]\n        Explanation: Let a = 2 and b = 9.\n        Both a and b are no-zero integers, and a + b = 9 = n.\n        Note that there are other valid answers as [8, 3] that can be accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1068,"row":{"number":1318,"difficulty":1,"question":"class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        \"\"\"\n        Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).\r\n        Flip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.\r\n        Example 1:\r\n        Input: a = 2, b = 6, c = 5\r\n        Output: 3\r\n        Explanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)\r\n        Example 2:\r\n        Input: a = 4, b = 2, c = 7\r\n        Output: 1\r\n        Example 3:\r\n        Input: a = 1, b = 2, c = 3\r\n        Output: 0\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1069,"row":{"number":1319,"difficulty":1,"question":"class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        \"\"\"\n        There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network.\n        You are given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\n        Return the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1.\n        Example 1:\n        Input: n = 4, connections = [[0,1],[0,2],[1,2]]\n        Output: 1\n        Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.\n        Example 2:\n        Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n        Output: 2\n        Example 3:\n        Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\n        Output: -1\n        Explanation: There are not enough cables.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1070,"row":{"number":1320,"difficulty":2,"question":"class Solution:\n    def minimumDistance(self, word: str) -> int:\n        \"\"\"\n        You have a keyboard layout as shown above in the X-Y plane, where each English uppercase letter is located at some coordinate.\n            For example, the letter 'A' is located at coordinate (0, 0), the letter 'B' is located at coordinate (0, 1), the letter 'P' is located at coordinate (2, 3) and the letter 'Z' is located at coordinate (4, 1).\n        Given the string word, return the minimum total distance to type such string using only two fingers.\n        The distance between coordinates (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|.\n        Note that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.\n        Example 1:\n        Input: word = \"CAKE\"\n        Output: 3\n        Explanation: Using two fingers, one optimal way to type \"CAKE\" is: \n        Finger 1 on letter 'C' -> cost = 0 \n        Finger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 \n        Finger 2 on letter 'K' -> cost = 0 \n        Finger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 \n        Total distance = 3\n        Example 2:\n        Input: word = \"HAPPY\"\n        Output: 6\n        Explanation: Using two fingers, one optimal way to type \"HAPPY\" is:\n        Finger 1 on letter 'H' -> cost = 0\n        Finger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2\n        Finger 2 on letter 'P' -> cost = 0\n        Finger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0\n        Finger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4\n        Total distance = 6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1071,"row":{"number":1342,"difficulty":0,"question":"class Solution:\n    def numberOfSteps(self, num: int) -> int:\n        \"\"\"\n        Given an integer num, return the number of steps to reduce it to zero.\n        In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n        Example 1:\n        Input: num = 14\n        Output: 6\n        Explanation: \n        Step 1) 14 is even; divide by 2 and obtain 7. \n        Step 2) 7 is odd; subtract 1 and obtain 6.\n        Step 3) 6 is even; divide by 2 and obtain 3. \n        Step 4) 3 is odd; subtract 1 and obtain 2. \n        Step 5) 2 is even; divide by 2 and obtain 1. \n        Step 6) 1 is odd; subtract 1 and obtain 0.\n        Example 2:\n        Input: num = 8\n        Output: 4\n        Explanation: \n        Step 1) 8 is even; divide by 2 and obtain 4. \n        Step 2) 4 is even; divide by 2 and obtain 2. \n        Step 3) 2 is even; divide by 2 and obtain 1. \n        Step 4) 1 is odd; subtract 1 and obtain 0.\n        Example 3:\n        Input: num = 123\n        Output: 12\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1072,"row":{"number":1343,"difficulty":1,"question":"class Solution:\n    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\n        \"\"\"\n        Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.\n        Example 1:\n        Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n        Output: 3\n        Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).\n        Example 2:\n        Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n        Output: 6\n        Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1073,"row":{"number":1344,"difficulty":1,"question":"class Solution:\n    def angleClock(self, hour: int, minutes: int) -> float:\n        \"\"\"\n        Given two numbers, hour and minutes, return the smaller angle (in degrees) formed between the hour and the minute hand.\n        Answers within 10-5 of the actual value will be accepted as correct.\n        Example 1:\n        Input: hour = 12, minutes = 30\n        Output: 165\n        Example 2:\n        Input: hour = 3, minutes = 30\n        Output: 75\n        Example 3:\n        Input: hour = 3, minutes = 15\n        Output: 7.5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1074,"row":{"number":1345,"difficulty":2,"question":"class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array of integers arr, you are initially positioned at the first index of the array.\n        In one step you can jump from index i to index:\n            i + 1 where: i + 1 < arr.length.\n            i - 1 where: i - 1 >= 0.\n            j where: arr[i] == arr[j] and i != j.\n        Return the minimum number of steps to reach the last index of the array.\n        Notice that you can not jump outside of the array at any time.\n        Example 1:\n        Input: arr = [100,-23,-23,404,100,23,23,23,3,404]\n        Output: 3\n        Explanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.\n        Example 2:\n        Input: arr = [7]\n        Output: 0\n        Explanation: Start index is the last index. You do not need to jump.\n        Example 3:\n        Input: arr = [7,6,9,6,9,6,9,7]\n        Output: 1\n        Explanation: You can jump directly from index 0 to index 7 which is last index of the array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1075,"row":{"number":1323,"difficulty":0,"question":"class Solution:\n    def maximum69Number (self, num: int) -> int:\n        \"\"\"\n        You are given a positive integer num consisting only of digits 6 and 9.\n        Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\n        Example 1:\n        Input: num = 9669\n        Output: 9969\n        Explanation: \n        Changing the first digit results in 6669.\n        Changing the second digit results in 9969.\n        Changing the third digit results in 9699.\n        Changing the fourth digit results in 9666.\n        The maximum number is 9969.\n        Example 2:\n        Input: num = 9996\n        Output: 9999\n        Explanation: Changing the last digit 6 to 9 results in the maximum number.\n        Example 3:\n        Input: num = 9999\n        Output: 9999\n        Explanation: It is better not to apply any change.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1076,"row":{"number":1324,"difficulty":1,"question":"class Solution:\n    def printVertically(self, s: str) -> List[str]:\n        \"\"\"\n        Given a string s. Return all the words vertically in the same order in which they appear in s.\r\n        Words are returned as a list of strings, complete with spaces when is necessary. (Trailing spaces are not allowed).\r\n        Each word would be put on only one column and that in one column there will be only one word.\r\n        Example 1:\r\n        Input: s = \"HOW ARE YOU\"\r\n        Output: [\"HAY\",\"ORO\",\"WEU\"]\r\n        Explanation: Each word is printed vertically. \r\n         \"HAY\"\r\n         \"ORO\"\r\n         \"WEU\"\r\n        Example 2:\r\n        Input: s = \"TO BE OR NOT TO BE\"\r\n        Output: [\"TBONTB\",\"OEROOE\",\"   T\"]\r\n        Explanation: Trailing spaces is not allowed. \r\n        \"TBONTB\"\r\n        \"OEROOE\"\r\n        \"   T\"\r\n        Example 3:\r\n        Input: s = \"CONTEST IS COMING\"\r\n        Output: [\"CIC\",\"OSO\",\"N M\",\"T I\",\"E N\",\"S G\",\"T\"]\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1077,"row":{"number":1325,"difficulty":1,"question":"class Solution:\n    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:\n        \"\"\"\n        Given a binary tree root and an integer target, delete all the leaf nodes with value target.\n        Note that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).\n        Example 1:\n        Input: root = [1,2,3,2,null,2,4], target = 2\n        Output: [1,null,3,null,4]\n        Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). \n        After removing, new nodes become leaf nodes with value (target = 2) (Picture in center).\n        Example 2:\n        Input: root = [1,3,3,3,2], target = 3\n        Output: [1,3,null,null,2]\n        Example 3:\n        Input: root = [1,2,null,2,null,2], target = 2\n        Output: [1]\n        Explanation: Leaf nodes in green with value (target = 2) are removed at each step.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1078,"row":{"number":1326,"difficulty":2,"question":"class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \"\"\"\n        There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).\n        There are n + 1 taps located at points [0, 1, ..., n] in the garden.\n        Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.\n        Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.\n        Example 1:\n        Input: n = 5, ranges = [3,4,1,1,0,0]\n        Output: 1\n        Explanation: The tap at point 0 can cover the interval [-3,3]\n        The tap at point 1 can cover the interval [-3,5]\n        The tap at point 2 can cover the interval [1,3]\n        The tap at point 3 can cover the interval [2,4]\n        The tap at point 4 can cover the interval [4,4]\n        The tap at point 5 can cover the interval [5,5]\n        Opening Only the second tap will water the whole garden [0,5]\n        Example 2:\n        Input: n = 3, ranges = [0,0,0,0]\n        Output: -1\n        Explanation: Even if you activate all the four taps you cannot water the whole garden.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1079,"row":{"number":1332,"difficulty":0,"question":"class Solution:\n    def removePalindromeSub(self, s: str) -> int:\n        \"\"\"\n        You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.\n        Return the minimum number of steps to make the given string empty.\n        A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.\n        A string is called palindrome if is one that reads the same backward as well as forward.\n        Example 1:\n        Input: s = \"ababa\"\n        Output: 1\n        Explanation: s is already a palindrome, so its entirety can be removed in a single step.\n        Example 2:\n        Input: s = \"abb\"\n        Output: 2\n        Explanation: \"abb\" -> \"bb\" -> \"\". \n        Remove palindromic subsequence \"a\" then \"bb\".\n        Example 3:\n        Input: s = \"baabb\"\n        Output: 2\n        Explanation: \"baabb\" -> \"b\" -> \"\". \n        Remove palindromic subsequence \"baab\" then \"b\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1080,"row":{"number":1333,"difficulty":1,"question":"class Solution:\n    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\n        \"\"\"\n        Given the array restaurants where  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\n        The veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true) or false (meaning you can include any restaurant). In addition, you have the filters maxPrice and maxDistance which are the maximum value for price and distance of restaurants you should consider respectively.\n        Return the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.\n        Example 1:\n        Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\n        Output: [3,1,5] \n        Explanation: \n        The restaurants are:\n        Restaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\n        Restaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\n        Restaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\n        Restaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\n        Restaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \n        After filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). \n        Example 2:\n        Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\n        Output: [4,3,2,1,5]\n        Explanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.\n        Example 3:\n        Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\n        Output: [4,5]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1081,"row":{"number":1334,"difficulty":1,"question":"class Solution:\n    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n        \"\"\"\n        There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.\n        Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.\n        Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.\n        Example 1:\n        Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\n        Output: 3\n        Explanation: The figure above describes the graph. \n        The neighboring cities at a distanceThreshold = 4 for each city are:\n        City 0 -> [City 1, City 2] \n        City 1 -> [City 0, City 2, City 3] \n        City 2 -> [City 0, City 1, City 3] \n        City 3 -> [City 1, City 2] \n        Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n        Example 2:\n        Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\n        Output: 0\n        Explanation: The figure above describes the graph. \n        The neighboring cities at a distanceThreshold = 2 for each city are:\n        City 0 -> [City 1] \n        City 1 -> [City 0, City 4] \n        City 2 -> [City 3, City 4] \n        City 3 -> [City 2, City 4]\n        City 4 -> [City 1, City 2, City 3] \n        The city 0 has 1 neighboring city at a distanceThreshold = 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1082,"row":{"number":1335,"difficulty":2,"question":"class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        \"\"\"\n        You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i).\n        You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day.\n        You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].\n        Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.\n        Example 1:\n        Input: jobDifficulty = [6,5,4,3,2,1], d = 2\n        Output: 7\n        Explanation: First day you can finish the first 5 jobs, total difficulty = 6.\n        Second day you can finish the last job, total difficulty = 1.\n        The difficulty of the schedule = 6 + 1 = 7 \n        Example 2:\n        Input: jobDifficulty = [9,9,9], d = 4\n        Output: -1\n        Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n        Example 3:\n        Input: jobDifficulty = [1,1,1], d = 3\n        Output: 3\n        Explanation: The schedule is one job per day. total difficulty will be 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1083,"row":{"number":1356,"difficulty":0,"question":"class Solution:\n    def sortByBits(self, arr: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.\n        Return the array after sorting it.\n        Example 1:\n        Input: arr = [0,1,2,3,4,5,6,7,8]\n        Output: [0,1,2,4,8,3,5,6,7]\n        Explantion: [0] is the only integer with 0 bits.\n        [1,2,4,8] all have 1 bit.\n        [3,5,6] have 2 bits.\n        [7] has 3 bits.\n        The sorted array by bits is [0,1,2,4,8,3,5,6,7]\n        Example 2:\n        Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]\n        Output: [1,2,4,8,16,32,64,128,256,512,1024]\n        Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1084,"row":{"number":1357,"difficulty":1,"question":"class Cashier:\n    def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):\n    def getBill(self, product: List[int], amount: List[int]) -> float:\n        \"\"\"\n        There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\n        When a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\n        The supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\n        Implement the Cashier class:\n            Cashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\n            double getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.\n        Example 1:\n        Input\n        [\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n        [[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\n        Output\n        [null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\n        Explanation\n        Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\n        cashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n                                                             // bill = 1 * 100 + 2 * 200 = 500.\n        cashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n                                                             // bill = 10 * 300 + 10 * 100 = 4000.\n        cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n                                                             // Original bill = 1600\n                                                             // Actual bill = 1600 * ((100 - 50) / 100) = 800.\n        cashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\n        cashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\n        cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n                                                             // Original bill = 14700, but with\n                                                             // Actual bill = 14700 * ((100 - 50) / 100) = 7350.\n        cashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  6th customer, no discount.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1085,"row":{"number":1358,"difficulty":1,"question":"class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting only of characters a, b and c.\n        Return the number of substrings containing at least one occurrence of all these characters a, b and c.\n        Example 1:\n        Input: s = \"abcabc\"\n        Output: 10\n        Explanation: The substrings containing at least one occurrence of the characters a, b and c are \"abc\", \"abca\", \"abcab\", \"abcabc\", \"bca\", \"bcab\", \"bcabc\", \"cab\", \"cabc\" and \"abc\" (again). \n        Example 2:\n        Input: s = \"aaacb\"\n        Output: 3\n        Explanation: The substrings containing at least one occurrence of the characters a, b and c are \"aaacb\", \"aacb\" and \"acb\". \n        Example 3:\n        Input: s = \"abc\"\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1086,"row":{"number":1359,"difficulty":2,"question":"class Solution:\n    def countOrders(self, n: int) -> int:\n        \"\"\"\n        Given n orders, each order consist in pickup and delivery services. \n        Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). \n        Since the answer may be too large, return it modulo 10^9 + 7.\n        Example 1:\n        Input: n = 1\n        Output: 1\n        Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n        Example 2:\n        Input: n = 2\n        Output: 6\n        Explanation: All possible orders: \n        (P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\n        This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n        Example 3:\n        Input: n = 3\n        Output: 90\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1087,"row":{"number":1337,"difficulty":0,"question":"class Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        \"\"\"\n        You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.\n        A row i is weaker than a row j if one of the following is true:\n            The number of soldiers in row i is less than the number of soldiers in row j.\n            Both rows have the same number of soldiers and i < j.\n        Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.\n        Example 1:\n        Input: mat = \n        [[1,1,0,0,0],\n         [1,1,1,1,0],\n         [1,0,0,0,0],\n         [1,1,0,0,0],\n         [1,1,1,1,1]], \n        k = 3\n        Output: [2,0,3]\n        Explanation: \n        The number of soldiers in each row is: \n        - Row 0: 2 \n        - Row 1: 4 \n        - Row 2: 1 \n        - Row 3: 2 \n        - Row 4: 5 \n        The rows ordered from weakest to strongest are [2,0,3,1,4].\n        Example 2:\n        Input: mat = \n        [[1,0,0,0],\n         [1,1,1,1],\n         [1,0,0,0],\n         [1,0,0,0]], \n        k = 2\n        Output: [0,2]\n        Explanation: \n        The number of soldiers in each row is: \n        - Row 0: 1 \n        - Row 1: 4 \n        - Row 2: 1 \n        - Row 3: 1 \n        The rows ordered from weakest to strongest are [0,2,3,1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1088,"row":{"number":1338,"difficulty":1,"question":"class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \"\"\"\n        You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.\n        Return the minimum size of the set so that at least half of the integers of the array are removed.\n        Example 1:\n        Input: arr = [3,3,3,3,5,5,5,2,2,7]\n        Output: 2\n        Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).\n        Possible sets of size 2 are {3,5},{3,2},{5,2}.\n        Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array.\n        Example 2:\n        Input: arr = [7,7,7,7,7,7]\n        Output: 1\n        Explanation: The only possible set you can choose is {7}. This will make the new array empty.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1089,"row":{"number":1339,"difficulty":1,"question":"class Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\n        Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\n        Note that you need to maximize the answer before taking the mod and not after taking it.\n        Example 1:\n        Input: root = [1,2,3,4,5,6]\n        Output: 110\n        Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n        Example 2:\n        Input: root = [1,null,2,3,4,null,null,5,6]\n        Output: 90\n        Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1090,"row":{"number":1340,"difficulty":2,"question":"class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \"\"\"\n        Given an array of integers arr and an integer d. In one step you can jump from index i to index:\n            i + x where: i + x < arr.length and  0 < x <= d.\n            i - x where: i - x >= 0 and  0 < x <= d.\n        In addition, you can only jump from index i to index j if arr[i] > arr[j] and arr[i] > arr[k] for all indices k between i and j (More formally min(i, j) < k < max(i, j)).\n        You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.\n        Notice that you can not jump outside of the array at any time.\n        Example 1:\n        Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\n        Output: 4\n        Explanation: You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\n        Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\n        Similarly You cannot jump from index 3 to index 2 or index 1.\n        Example 2:\n        Input: arr = [3,3,3,3,3], d = 3\n        Output: 1\n        Explanation: You can start at any index. You always cannot jump to any index.\n        Example 3:\n        Input: arr = [7,6,5,4,3,2,1], d = 1\n        Output: 7\n        Explanation: Start at index 0. You can visit all the indicies. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1091,"row":{"number":1346,"difficulty":0,"question":"class Solution:\n    def checkIfExist(self, arr: List[int]) -> bool:\n        \"\"\"\n        Given an array arr of integers, check if there exist two indices i and j such that :\n            i != j\n            0 <= i, j < arr.length\n            arr[i] == 2 * arr[j]\n        Example 1:\n        Input: arr = [10,2,5,3]\n        Output: true\n        Explanation: For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]\n        Example 2:\n        Input: arr = [3,1,7,11]\n        Output: false\n        Explanation: There is no i and j that satisfy the conditions.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1092,"row":{"number":1347,"difficulty":1,"question":"class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \"\"\"\n        You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.\n        Return the minimum number of steps to make t an anagram of s.\n        An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.\n        Example 1:\n        Input: s = \"bab\", t = \"aba\"\n        Output: 1\n        Explanation: Replace the first 'a' in t with b, t = \"bba\" which is anagram of s.\n        Example 2:\n        Input: s = \"leetcode\", t = \"practice\"\n        Output: 5\n        Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.\n        Example 3:\n        Input: s = \"anagram\", t = \"mangaar\"\n        Output: 0\n        Explanation: \"anagram\" and \"mangaar\" are anagrams. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1093,"row":{"number":1348,"difficulty":1,"question":"class TweetCounts:\n    def __init__(self):\n    def recordTweet(self, tweetName: str, time: int) -> None:\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \"\"\"\n        A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. These periods can be partitioned into smaller time chunks based on a certain frequency (every minute, hour, or day).\n        For example, the period [10, 10000] (in seconds) would be partitioned into the following time chunks with these frequencies:\n            Every minute (60-second chunks): [10,69], [70,129], [130,189], ..., [9970,10000]\n            Every hour (3600-second chunks): [10,3609], [3610,7209], [7210,10000]\n            Every day (86400-second chunks): [10,10000]\n        Notice that the last chunk may be shorter than the specified frequency's chunk size and will always end with the end time of the period (10000 in the above example).\n        Design and implement an API to help the company with their analysis.\n        Implement the TweetCounts class:\n            TweetCounts() Initializes the TweetCounts object.\n            void recordTweet(String tweetName, int time) Stores the tweetName at the recorded time (in seconds).\n            List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) Returns a list of integers representing the number of tweets with tweetName in each time chunk for the given period of time [startTime, endTime] (in seconds) and frequency freq.\n                freq is one of \"minute\", \"hour\", or \"day\" representing a frequency of every minute, hour, or day respectively.\n        Example:\n        Input\n        [\"TweetCounts\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"getTweetCountsPerFrequency\",\"getTweetCountsPerFrequency\",\"recordTweet\",\"getTweetCountsPerFrequency\"]\n        [[],[\"tweet3\",0],[\"tweet3\",60],[\"tweet3\",10],[\"minute\",\"tweet3\",0,59],[\"minute\",\"tweet3\",0,60],[\"tweet3\",120],[\"hour\",\"tweet3\",0,210]]\n        Output\n        [null,null,null,null,[2],[2,1],null,[4]]\n        Explanation\n        TweetCounts tweetCounts = new TweetCounts();\n        tweetCounts.recordTweet(\"tweet3\", 0);                              // New tweet \"tweet3\" at time 0\n        tweetCounts.recordTweet(\"tweet3\", 60);                             // New tweet \"tweet3\" at time 60\n        tweetCounts.recordTweet(\"tweet3\", 10);                             // New tweet \"tweet3\" at time 10\n        tweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 59); // return [2]; chunk [0,59] had 2 tweets\n        tweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet\n        tweetCounts.recordTweet(\"tweet3\", 120);                            // New tweet \"tweet3\" at time 120\n        tweetCounts.getTweetCountsPerFrequency(\"hour\", \"tweet3\", 0, 210);  // return [4]; chunk [0,210] had 4 tweets\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1094,"row":{"number":1349,"difficulty":2,"question":"class Solution:\n    def maxStudents(self, seats: List[List[str]]) -> int:\n        \"\"\"\n        Given a m * n matrix seats  that represent seats distributions in a classroom. If a seat is broken, it is denoted by '#' character otherwise it is denoted by a '.' character.\n        Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the maximum number of students that can take the exam together without any cheating being possible..\n        Students must be placed in seats in good condition.\n        Example 1:\n        Input: seats = [[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n                        [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\n                        [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]\n        Output: 4\n        Explanation: Teacher can place 4 students in available seats so they don't cheat on the exam. \n        Example 2:\n        Input: seats = [[\".\",\"#\"],\n                        [\"#\",\"#\"],\n                        [\"#\",\".\"],\n                        [\"#\",\"#\"],\n                        [\".\",\"#\"]]\n        Output: 3\n        Explanation: Place all students in available seats. \n        Example 3:\n        Input: seats = [[\"#\",\".\",\".\",\".\",\"#\"],\n                        [\".\",\"#\",\".\",\"#\",\".\"],\n                        [\".\",\".\",\"#\",\".\",\".\"],\n                        [\".\",\"#\",\".\",\"#\",\".\"],\n                        [\"#\",\".\",\".\",\".\",\"#\"]]\n        Output: 10\n        Explanation: Place students in available seats in column 1, 3 and 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1095,"row":{"number":1370,"difficulty":0,"question":"class Solution:\n    def sortString(self, s: str) -> str:\n        \"\"\"\n        You are given a string s. Reorder the string using the following algorithm:\n            Pick the smallest character from s and append it to the result.\n            Pick the smallest character from s which is greater than the last appended character to the result and append it.\n            Repeat step 2 until you cannot pick more characters.\n            Pick the largest character from s and append it to the result.\n            Pick the largest character from s which is smaller than the last appended character to the result and append it.\n            Repeat step 5 until you cannot pick more characters.\n            Repeat the steps from 1 to 6 until you pick all characters from s.\n        In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n        Return the result string after sorting s with this algorithm.\n        Example 1:\n        Input: s = \"aaaabbbbcccc\"\n        Output: \"abccbaabccba\"\n        Explanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\n        After steps 4, 5 and 6 of the first iteration, result = \"abccba\"\n        First iteration is done. Now s = \"aabbcc\" and we go back to step 1\n        After steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\n        After steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"\n        Example 2:\n        Input: s = \"rat\"\n        Output: \"art\"\n        Explanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1096,"row":{"number":1371,"difficulty":1,"question":"class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times.\n        Example 1:\n        Input: s = \"eleetminicoworoep\"\n        Output: 13\n        Explanation: The longest substring is \"leetminicowor\" which contains two each of the vowels: e, i and o and zero of the vowels: a and u.\n        Example 2:\n        Input: s = \"leetcodeisgreat\"\n        Output: 5\n        Explanation: The longest substring is \"leetc\" which contains two e's.\n        Example 3:\n        Input: s = \"bcbcbc\"\n        Output: 6\n        Explanation: In this case, the given string \"bcbcbc\" is the longest because all vowels: a, e, i, o and u appear zero times.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1097,"row":{"number":1372,"difficulty":1,"question":"class Solution:\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        You are given the root of a binary tree.\n        A ZigZag path for a binary tree is defined as follow:\n            Choose any node in the binary tree and a direction (right or left).\n            If the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n            Change the direction from right to left or from left to right.\n            Repeat the second and third steps until you can't move in the tree.\n        Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n        Return the longest ZigZag path contained in that tree.\n        Example 1:\n        Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\n        Output: 3\n        Explanation: Longest ZigZag path in blue nodes (right -> left -> right).\n        Example 2:\n        Input: root = [1,1,1,null,1,null,null,1,1,null,1]\n        Output: 4\n        Explanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).\n        Example 3:\n        Input: root = [1]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1098,"row":{"number":1373,"difficulty":2,"question":"class Solution:\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).\n        Assume a BST is defined as follows:\n            The left subtree of a node contains only nodes with keys less than the node's key.\n            The right subtree of a node contains only nodes with keys greater than the node's key.\n            Both the left and right subtrees must also be binary search trees.\n        Example 1:\n        Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n        Output: 20\n        Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.\n        Example 2:\n        Input: root = [4,3,null,1,2]\n        Output: 2\n        Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.\n        Example 3:\n        Input: root = [-4,-2,-5]\n        Output: 0\n        Explanation: All values are negatives. Return an empty BST.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1099,"row":{"number":1351,"difficulty":0,"question":"class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.\n        Example 1:\n        Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\n        Output: 8\n        Explanation: There are 8 negatives number in the matrix.\n        Example 2:\n        Input: grid = [[3,2],[1,0]]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}