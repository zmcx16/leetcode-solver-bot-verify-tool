{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":800,"row":{"number":989,"difficulty":0,"question":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \"\"\"\n        The array-form of an integer num is an array representing its digits in left to right order.\n            For example, for num = 1321, the array form is [1,3,2,1].\n        Given num, the array-form of an integer, and an integer k, return the array-form of the integer num + k.\n        Example 1:\n        Input: num = [1,2,0,0], k = 34\n        Output: [1,2,3,4]\n        Explanation: 1200 + 34 = 1234\n        Example 2:\n        Input: num = [2,7,4], k = 181\n        Output: [4,5,5]\n        Explanation: 274 + 181 = 455\n        Example 3:\n        Input: num = [2,1,5], k = 806\n        Output: [1,0,2,1]\n        Explanation: 215 + 806 = 1021\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":801,"row":{"number":990,"difficulty":1,"question":"class Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        \"\"\"\n        You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\n        Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\n        Example 1:\n        Input: equations = [\"a==b\",\"b!=a\"]\n        Output: false\n        Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\n        There is no way to assign the variables to satisfy both equations.\n        Example 2:\n        Input: equations = [\"b==a\",\"a==b\"]\n        Output: true\n        Explanation: We could assign a = 1 and b = 1 to satisfy both equations.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":802,"row":{"number":991,"difficulty":1,"question":"class Solution:\n    def brokenCalc(self, startValue: int, target: int) -> int:\n        \"\"\"\n        There is a broken calculator that has the integer startValue on its display initially. In one operation, you can:\n            multiply the number on display by 2, or\n            subtract 1 from the number on display.\n        Given two integers startValue and target, return the minimum number of operations needed to display target on the calculator.\n        Example 1:\n        Input: startValue = 2, target = 3\n        Output: 2\n        Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}.\n        Example 2:\n        Input: startValue = 5, target = 8\n        Output: 2\n        Explanation: Use decrement and then double {5 -> 4 -> 8}.\n        Example 3:\n        Input: startValue = 3, target = 10\n        Output: 3\n        Explanation: Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":803,"row":{"number":992,"difficulty":2,"question":"class Solution:\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the number of good subarrays of nums.\n        A good array is an array where the number of different integers in that array is exactly k.\n            For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.\n        A subarray is a contiguous part of an array.\n        Example 1:\n        Input: nums = [1,2,1,2,3], k = 2\n        Output: 7\n        Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]\n        Example 2:\n        Input: nums = [1,2,1,3,4], k = 3\n        Output: 3\n        Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":804,"row":{"number":993,"difficulty":0,"question":"class Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        \"\"\"\n        Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise.\n        Two nodes of a binary tree are cousins if they have the same depth with different parents.\n        Note that in a binary tree, the root node is at the depth 0, and children of each depth k node are at the depth k + 1.\n        Example 1:\n        Input: root = [1,2,3,4], x = 4, y = 3\n        Output: false\n        Example 2:\n        Input: root = [1,2,3,null,4,null,5], x = 5, y = 4\n        Output: true\n        Example 3:\n        Input: root = [1,2,3,null,4], x = 2, y = 3\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":805,"row":{"number":994,"difficulty":1,"question":"class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n grid where each cell can have one of three values:\n            0 representing an empty cell,\n            1 representing a fresh orange, or\n            2 representing a rotten orange.\n        Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n        Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\n        Example 1:\n        Input: grid = [[2,1,1],[1,1,0],[0,1,1]]\n        Output: 4\n        Example 2:\n        Input: grid = [[2,1,1],[0,1,1],[1,0,1]]\n        Output: -1\n        Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n        Example 3:\n        Input: grid = [[0,2]]\n        Output: 0\n        Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":806,"row":{"number":995,"difficulty":2,"question":"class Solution:\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given a binary array nums and an integer k.\n        A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\n        Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\n        A subarray is a contiguous part of an array.\n        Example 1:\n        Input: nums = [0,1,0], k = 1\n        Output: 2\n        Explanation: Flip nums[0], then flip nums[2].\n        Example 2:\n        Input: nums = [1,1,0], k = 2\n        Output: -1\n        Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\n        Example 3:\n        Input: nums = [0,0,0,1,0,1,1,0], k = 3\n        Output: 3\n        Explanation: \n        Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\n        Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\n        Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":807,"row":{"number":996,"difficulty":2,"question":"class Solution:\n    def numSquarefulPerms(self, nums: List[int]) -> int:\n        \"\"\"\n        An array is squareful if the sum of every pair of adjacent elements is a perfect square.\n        Given an integer array nums, return the number of permutations of nums that are squareful.\n        Two permutations perm1 and perm2 are different if there is some index i such that perm1[i] != perm2[i].\n        Example 1:\n        Input: nums = [1,17,8]\n        Output: 2\n        Explanation: [1,8,17] and [17,8,1] are the valid permutations.\n        Example 2:\n        Input: nums = [2,2,2]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":808,"row":{"number":997,"difficulty":0,"question":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        \"\"\"\n        In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\n        If the town judge exists, then:\n            The town judge trusts nobody.\n            Everybody (except for the town judge) trusts the town judge.\n            There is exactly one person that satisfies properties 1 and 2.\n        You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\n        Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.\n        Example 1:\n        Input: n = 2, trust = [[1,2]]\n        Output: 2\n        Example 2:\n        Input: n = 3, trust = [[1,3],[2,3]]\n        Output: 3\n        Example 3:\n        Input: n = 3, trust = [[1,3],[2,3],[3,1]]\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":809,"row":{"number":998,"difficulty":1,"question":"class Solution:\n    def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        \"\"\"\n        A maximum tree is a tree where every node has a value greater than any other value in its subtree.\n        You are given the root of a maximum binary tree and an integer val.\n        Just as in the previous problem, the given tree was constructed from a list a (root = Construct(a)) recursively with the following Construct(a) routine:\n            If a is empty, return null.\n            Otherwise, let a[i] be the largest element of a. Create a root node with the value a[i].\n            The left child of root will be Construct([a[0], a[1], ..., a[i - 1]]).\n            The right child of root will be Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]).\n            Return root.\n        Note that we were not given a directly, only a root node root = Construct(a).\n        Suppose b is a copy of a with the value val appended to it. It is guaranteed that b has unique values.\n        Return Construct(b).\n        Example 1:\n        Input: root = [4,1,3,null,null,2], val = 5\n        Output: [5,4,null,1,3,null,null,2]\n        Explanation: a = [1,4,2,3], b = [1,4,2,3,5]\n        Example 2:\n        Input: root = [5,2,4,null,1], val = 3\n        Output: [5,2,4,null,1,null,3]\n        Explanation: a = [2,1,5,4], b = [2,1,5,4,3]\n        Example 3:\n        Input: root = [5,2,3,null,1], val = 4\n        Output: [5,2,4,null,1,3]\n        Explanation: a = [2,1,5,3], b = [2,1,5,3,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":810,"row":{"number":999,"difficulty":0,"question":"class Solution:\n    def numRookCaptures(self, board: List[List[str]]) -> int:\n        \"\"\"\n        On an 8 x 8 chessboard, there is exactly one white rook 'R' and some number of white bishops 'B', black pawns 'p', and empty squares '.'.\n        When the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered attacking a pawn if the rook can capture the pawn on the rook's turn. The number of available captures for the white rook is the number of pawns that the rook is attacking.\n        Return the number of available captures for the white rook.\n        Example 1:\n        Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n        Output: 3\n        Explanation: In this example, the rook is attacking all the pawns.\n        Example 2:\n        Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n        Output: 0\n        Explanation: The bishops are blocking the rook from attacking any of the pawns.\n        Example 3:\n        Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n        Output: 3\n        Explanation: The rook is attacking the pawns at positions b5, d6, and f5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":811,"row":{"number":1000,"difficulty":2,"question":"class Solution:\n    def mergeStones(self, stones: List[int], k: int) -> int:\n        \"\"\"\n        There are n piles of stones arranged in a row. The ith pile has stones[i] stones.\n        A move consists of merging exactly k consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these k piles.\n        Return the minimum cost to merge all piles of stones into one pile. If it is impossible, return -1.\n        Example 1:\n        Input: stones = [3,2,4,1], k = 2\n        Output: 20\n        Explanation: We start with [3, 2, 4, 1].\n        We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].\n        We merge [4, 1] for a cost of 5, and we are left with [5, 5].\n        We merge [5, 5] for a cost of 10, and we are left with [10].\n        The total cost was 20, and this is the minimum possible.\n        Example 2:\n        Input: stones = [3,2,4,1], k = 3\n        Output: -1\n        Explanation: After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n        Example 3:\n        Input: stones = [3,5,1,2,6], k = 3\n        Output: 25\n        Explanation: We start with [3, 5, 1, 2, 6].\n        We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].\n        We merge [3, 8, 6] for a cost of 17, and we are left with [17].\n        The total cost was 25, and this is the minimum possible.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":812,"row":{"number":1001,"difficulty":2,"question":"class Solution:\n    def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        There is a 2D grid of size n x n where each cell of this grid has a lamp that is initially turned off.\n        You are given a 2D array of lamp positions lamps, where lamps[i] = [rowi, coli] indicates that the lamp at grid[rowi][coli] is turned on. Even if the same lamp is listed more than once, it is turned on.\n        When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.\n        You are also given another 2D array queries, where queries[j] = [rowj, colj]. For the jth query, determine whether grid[rowj][colj] is illuminated or not. After answering the jth query, turn off the lamp at grid[rowj][colj] and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with grid[rowj][colj].\n        Return an array of integers ans, where ans[j] should be 1 if the cell in the jth query was illuminated, or 0 if the lamp was not.\n        Example 1:\n        Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]\n        Output: [1,0]\n        Explanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4].\n        The 0th query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square.\n        The 1st query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle.\n        Example 2:\n        Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]\n        Output: [1,1]\n        Example 3:\n        Input: n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]\n        Output: [1,1,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":813,"row":{"number":1002,"difficulty":0,"question":"class Solution:\n    def commonChars(self, words: List[str]) -> List[str]:\n        \"\"\"\n        Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\n        Example 1:\n        Input: words = [\"bella\",\"label\",\"roller\"]\n        Output: [\"e\",\"l\",\"l\"]\n        Example 2:\n        Input: words = [\"cool\",\"lock\",\"cook\"]\n        Output: [\"c\",\"o\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":814,"row":{"number":1003,"difficulty":1,"question":"class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s, determine if it is valid.\n        A string s is valid if, starting with an empty string t = \"\", you can transform t into s after performing the following operation any number of times:\n            Insert string \"abc\" into any position in t. More formally, t becomes tleft + \"abc\" + tright, where t == tleft + tright. Note that tleft and tright may be empty.\n        Return true if s is a valid string, otherwise, return false.\n        Example 1:\n        Input: s = \"aabcbc\"\n        Output: true\n        Explanation:\n        \"\" -> \"abc\" -> \"aabcbc\"\n        Thus, \"aabcbc\" is valid.\n        Example 2:\n        Input: s = \"abcabcababcc\"\n        Output: true\n        Explanation:\n        \"\" -> \"abc\" -> \"abcabc\" -> \"abcabcabc\" -> \"abcabcababcc\"\n        Thus, \"abcabcababcc\" is valid.\n        Example 3:\n        Input: s = \"abccba\"\n        Output: false\n        Explanation: It is impossible to get \"abccba\" using the operation.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":815,"row":{"number":1004,"difficulty":1,"question":"class Solution:\n    def longestOnes(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.\n        Example 1:\n        Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n        Output: 6\n        Explanation: [1,1,1,0,0,1,1,1,1,1,1]\n        Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n        Example 2:\n        Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n        Output: 10\n        Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\n        Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":816,"row":{"number":1005,"difficulty":0,"question":"class Solution:\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, modify the array in the following way:\n            choose an index i and replace nums[i] with -nums[i].\n        You should apply this process exactly k times. You may choose the same index i multiple times.\n        Return the largest possible sum of the array after modifying it in this way.\n        Example 1:\n        Input: nums = [4,2,3], k = 1\n        Output: 5\n        Explanation: Choose index 1 and nums becomes [4,-2,3].\n        Example 2:\n        Input: nums = [3,-1,0,2], k = 3\n        Output: 6\n        Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].\n        Example 3:\n        Input: nums = [2,-3,-1,5,-4], k = 2\n        Output: 13\n        Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":817,"row":{"number":1006,"difficulty":1,"question":"class Solution:\n    def clumsy(self, n: int) -> int:\n        \"\"\"\n        The factorial of a positive integer n is the product of all positive integers less than or equal to n.\n            For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.\n        We make a clumsy factorial using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply '*', divide '/', add '+', and subtract '-' in this order.\n            For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.\n        However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.\n        Additionally, the division that we use is floor division such that 10 * 9 / 8 = 90 / 8 = 11.\n        Given an integer n, return the clumsy factorial of n.\n        Example 1:\n        Input: n = 4\n        Output: 7\n        Explanation: 7 = 4 * 3 / 2 + 1\n        Example 2:\n        Input: n = 10\n        Output: 12\n        Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":818,"row":{"number":1007,"difficulty":1,"question":"class Solution:\n    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\n        \"\"\"\n        In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n        We may rotate the ith domino, so that tops[i] and bottoms[i] swap values.\n        Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.\n        If it cannot be done, return -1.\n        Example 1:\n        Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\n        Output: 2\n        Explanation: \n        The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\n        If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n        Example 2:\n        Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\n        Output: -1\n        Explanation: \n        In this case, it is not possible to rotate the dominoes to make one row of values equal.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":819,"row":{"number":1008,"difficulty":1,"question":"class Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\n        \"\"\"\n        Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.\n        It is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.\n        A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.\n        A preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.\n        Example 1:\n        Input: preorder = [8,5,1,7,10,12]\n        Output: [8,5,10,1,7,null,12]\n        Example 2:\n        Input: preorder = [1,3]\n        Output: [1,null,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":820,"row":{"number":1009,"difficulty":0,"question":"class Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        \"\"\"\n        The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n            For example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n        Given an integer n, return its complement.\n        Example 1:\n        Input: n = 5\n        Output: 2\n        Explanation: 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10.\n        Example 2:\n        Input: n = 7\n        Output: 0\n        Explanation: 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10.\n        Example 3:\n        Input: n = 10\n        Output: 5\n        Explanation: 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":821,"row":{"number":1010,"difficulty":1,"question":"class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        \"\"\"\n        You are given a list of songs where the ith song has a duration of time[i] seconds.\n        Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.\n        Example 1:\n        Input: time = [30,20,150,100,40]\n        Output: 3\n        Explanation: Three pairs have a total duration divisible by 60:\n        (time[0] = 30, time[2] = 150): total duration 180\n        (time[1] = 20, time[3] = 100): total duration 120\n        (time[1] = 20, time[4] = 40): total duration 60\n        Example 2:\n        Input: time = [60,60,60]\n        Output: 3\n        Explanation: All three pairs have a total duration of 120, which is divisible by 60.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":822,"row":{"number":1011,"difficulty":1,"question":"class Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        \"\"\"\n        A conveyor belt has packages that must be shipped from one port to another within days days.\n        The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\n        Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.\n        Example 1:\n        Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5\n        Output: 15\n        Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n        1st day: 1, 2, 3, 4, 5\n        2nd day: 6, 7\n        3rd day: 8\n        4th day: 9\n        5th day: 10\n        Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\n        Example 2:\n        Input: weights = [3,2,2,4,1,4], days = 3\n        Output: 6\n        Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n        1st day: 3, 2\n        2nd day: 2, 4\n        3rd day: 1, 4\n        Example 3:\n        Input: weights = [1,2,3,1,1], days = 4\n        Output: 3\n        Explanation:\n        1st day: 1\n        2nd day: 2\n        3rd day: 3\n        4th day: 1, 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":823,"row":{"number":1012,"difficulty":2,"question":"class Solution:\n    def numDupDigitsAtMostN(self, n: int) -> int:\n        \"\"\"\n        Given an integer n, return the number of positive integers in the range [1, n] that have at least one repeated digit.\n        Example 1:\n        Input: n = 20\n        Output: 1\n        Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\n        Example 2:\n        Input: n = 100\n        Output: 10\n        Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n        Example 3:\n        Input: n = 1000\n        Output: 262\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":824,"row":{"number":1061,"difficulty":1,"question":"class Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        \"\"\"\n        You are given two strings of the same length s1 and s2 and a string baseStr.\n        We say s1[i] and s2[i] are equivalent characters.\n            For example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n        Equivalent characters follow the usual rules of any equivalence relation:\n            Reflexivity: 'a' == 'a'.\n            Symmetry: 'a' == 'b' implies 'b' == 'a'.\n            Transitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n        For example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\n        Return the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n        Example 1:\n        Input: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\n        Output: \"makkek\"\n        Explanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\n        The characters in each group are equivalent and sorted in lexicographical order.\n        So the answer is \"makkek\".\n        Example 2:\n        Input: s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\n        Output: \"hdld\"\n        Explanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\n        So only the second letter 'o' in baseStr is changed to 'd', the answer is \"hdld\".\n        Example 3:\n        Input: s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\n        Output: \"aauaaaaada\"\n        Explanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is \"aauaaaaada\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":825,"row":{"number":1013,"difficulty":0,"question":"class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        \"\"\"\n        Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\n        Formally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])\n        Example 1:\n        Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\n        Output: true\n        Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n        Example 2:\n        Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\n        Output: false\n        Example 3:\n        Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\n        Output: true\n        Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":826,"row":{"number":1014,"difficulty":1,"question":"class Solution:\n    def maxScoreSightseeingPair(self, values: List[int]) -> int:\n        \"\"\"\n        You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.\n        The score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.\n        Return the maximum score of a pair of sightseeing spots.\n        Example 1:\n        Input: values = [8,1,5,2,6]\n        Output: 11\n        Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11\n        Example 2:\n        Input: values = [1,2]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":827,"row":{"number":1015,"difficulty":1,"question":"class Solution:\n    def smallestRepunitDivByK(self, k: int) -> int:\n        \"\"\"\n        Given a positive integer k, you need to find the length of the smallest positive integer n such that n is divisible by k, and n only contains the digit 1.\n        Return the length of n. If there is no such n, return -1.\n        Note: n may not fit in a 64-bit signed integer.\n        Example 1:\n        Input: k = 1\n        Output: 1\n        Explanation: The smallest answer is n = 1, which has length 1.\n        Example 2:\n        Input: k = 2\n        Output: -1\n        Explanation: There is no such positive integer n divisible by 2.\n        Example 3:\n        Input: k = 3\n        Output: 3\n        Explanation: The smallest answer is n = 111, which has length 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":828,"row":{"number":1016,"difficulty":1,"question":"class Solution:\n    def queryString(self, s: str, n: int) -> bool:\n        \"\"\"\n        Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"0110\", n = 3\n        Output: true\n        Example 2:\n        Input: s = \"0110\", n = 4\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":829,"row":{"number":1017,"difficulty":1,"question":"class Solution:\n    def baseNeg2(self, n: int) -> str:\n        \"\"\"\n        Given an integer n, return a binary string representing its representation in base -2.\n        Note that the returned string should not have leading zeros unless the string is \"0\".\n        Example 1:\n        Input: n = 2\n        Output: \"110\"\n        Explantion: (-2)2 + (-2)1 = 2\n        Example 2:\n        Input: n = 3\n        Output: \"111\"\n        Explantion: (-2)2 + (-2)1 + (-2)0 = 3\n        Example 3:\n        Input: n = 4\n        Output: \"100\"\n        Explantion: (-2)2 = 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":830,"row":{"number":1018,"difficulty":0,"question":"class Solution:\n    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:\n        \"\"\"\n        You are given a binary array nums (0-indexed).\n        We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit).\n            For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.\n        Return an array of booleans answer where answer[i] is true if xi is divisible by 5.\n        Example 1:\n        Input: nums = [0,1,1]\n        Output: [true,false,false]\n        Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.\n        Only the first number is divisible by 5, so answer[0] is true.\n        Example 2:\n        Input: nums = [1,1,1]\n        Output: [false,false,false]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":831,"row":{"number":1019,"difficulty":1,"question":"class Solution:\n    def nextLargerNodes(self, head: Optional[ListNode]) -> List[int]:\n        \"\"\"\n        You are given the head of a linked list with n nodes.\n        For each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.\n        Return an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.\n        Example 1:\n        Input: head = [2,1,5]\n        Output: [5,5,0]\n        Example 2:\n        Input: head = [2,7,4,3,5]\n        Output: [7,0,5,5,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":832,"row":{"number":1020,"difficulty":1,"question":"class Solution:\n    def numEnclaves(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.\n        A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.\n        Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.\n        Example 1:\n        Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n        Output: 3\n        Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n        Example 2:\n        Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n        Output: 0\n        Explanation: All 1s are either on the boundary or can reach the boundary.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":833,"row":{"number":1021,"difficulty":0,"question":"class Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        \"\"\"\n        A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n            For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n        A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\n        Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\n        Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n        Example 1:\n        Input: s = \"(()())(())\"\n        Output: \"()()()\"\n        Explanation: \n        The input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\n        After removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".\n        Example 2:\n        Input: s = \"(()())(())(()(()))\"\n        Output: \"()()()()(())\"\n        Explanation: \n        The input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\n        After removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".\n        Example 3:\n        Input: s = \"()()\"\n        Output: \"\"\n        Explanation: \n        The input string is \"()()\", with primitive decomposition \"()\" + \"()\".\n        After removing outer parentheses of each part, this is \"\" + \"\" = \"\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":834,"row":{"number":1022,"difficulty":0,"question":"class Solution:\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.\n            For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.\n        For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.\n        The test cases are generated so that the answer fits in a 32-bits integer.\n        Example 1:\n        Input: root = [1,0,1,0,1,0,1]\n        Output: 22\n        Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n        Example 2:\n        Input: root = [0]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":835,"row":{"number":1023,"difficulty":1,"question":"class Solution:\n    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\n        \"\"\"\n        Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise.\n        A query word queries[i] matches pattern if you can insert lowercase English letters pattern so that it equals the query. You may insert each character at any position and you may not insert any characters.\n        Example 1:\n        Input: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FB\"\n        Output: [true,false,true,true,false]\n        Explanation: \"FooBar\" can be generated like this \"F\" + \"oo\" + \"B\" + \"ar\".\n        \"FootBall\" can be generated like this \"F\" + \"oot\" + \"B\" + \"all\".\n        \"FrameBuffer\" can be generated like this \"F\" + \"rame\" + \"B\" + \"uffer\".\n        Example 2:\n        Input: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBa\"\n        Output: [true,false,true,false,false]\n        Explanation: \"FooBar\" can be generated like this \"Fo\" + \"o\" + \"Ba\" + \"r\".\n        \"FootBall\" can be generated like this \"Fo\" + \"ot\" + \"Ba\" + \"ll\".\n        Example 3:\n        Input: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBaT\"\n        Output: [false,true,false,false,false]\n        Explanation: \"FooBarTest\" can be generated like this \"Fo\" + \"o\" + \"Ba\" + \"r\" + \"T\" + \"est\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":836,"row":{"number":1024,"difficulty":1,"question":"class Solution:\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\n        \"\"\"\n        You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths.\n        Each video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi.\n        We can cut these clips into segments freely.\n            For example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].\n        Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.\n        Example 1:\n        Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\n        Output: 3\n        Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.\n        Then, we can reconstruct the sporting event as follows:\n        We cut [1,9] into segments [1,2] + [2,8] + [8,9].\n        Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].\n        Example 2:\n        Input: clips = [[0,1],[1,2]], time = 5\n        Output: -1\n        Explanation: We cannot cover [0,5] with only [0,1] and [1,2].\n        Example 3:\n        Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9\n        Output: 3\n        Explanation: We can take clips [0,4], [4,7], and [6,9].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":837,"row":{"number":1025,"difficulty":0,"question":"class Solution:\n    def divisorGame(self, n: int) -> bool:\n        \"\"\"\n        Alice and Bob take turns playing a game, with Alice starting first.\n        Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of:\n            Choosing any x with 0 < x < n and n % x == 0.\n            Replacing the number n on the chalkboard with n - x.\n        Also, if a player cannot make a move, they lose the game.\n        Return true if and only if Alice wins the game, assuming both players play optimally.\n        Example 1:\n        Input: n = 2\n        Output: true\n        Explanation: Alice chooses 1, and Bob has no more moves.\n        Example 2:\n        Input: n = 3\n        Output: false\n        Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":838,"row":{"number":1027,"difficulty":1,"question":"class Solution:\n    def longestArithSeqLength(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array nums of integers, return the length of the longest arithmetic subsequence in nums.\n        Note that:\n            A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n            A sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 <= i < seq.length - 1).\n        Example 1:\n        Input: nums = [3,6,9,12]\n        Output: 4\n        Explanation:  The whole array is an arithmetic sequence with steps of length = 3.\n        Example 2:\n        Input: nums = [9,4,7,2,10]\n        Output: 3\n        Explanation:  The longest arithmetic subsequence is [4,7,10].\n        Example 3:\n        Input: nums = [20,1,15,3,10,5,8]\n        Output: 4\n        Explanation:  The longest arithmetic subsequence is [20,15,10,5].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":839,"row":{"number":1026,"difficulty":1,"question":"class Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\n        A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.\n        Example 1:\n        Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]\n        Output: 7\n        Explanation: We have various ancestor-node differences, some of which are given below :\n        |8 - 3| = 5\n        |3 - 7| = 4\n        |8 - 1| = 7\n        |10 - 13| = 3\n        Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.\n        Example 2:\n        Input: root = [1,null,2,null,0,3]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":840,"row":{"number":1028,"difficulty":2,"question":"class Solution:\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\n        \"\"\"\n        We run a preorder depth-first search (DFS) on the root of a binary tree.\n        At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  If the depth of a node is D, the depth of its immediate child is D + 1.  The depth of the root node is 0.\n        If a node has only one child, that child is guaranteed to be the left child.\n        Given the output traversal of this traversal, recover the tree and return its root.\n        Example 1:\n        Input: traversal = \"1-2--3--4-5--6--7\"\n        Output: [1,2,5,3,4,6,7]\n        Example 2:\n        Input: traversal = \"1-2--3---4-5--6---7\"\n        Output: [1,2,5,3,null,6,null,4,null,7]\n        Example 3:\n        Input: traversal = \"1-401--349---90--88\"\n        Output: [1,401,null,349,88,90]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":841,"row":{"number":1030,"difficulty":0,"question":"class Solution:\n    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]:\n        \"\"\"\n        You are given four integers row, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter).\n        Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition.\n        The distance between two cells (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|.\n        Example 1:\n        Input: rows = 1, cols = 2, rCenter = 0, cCenter = 0\n        Output: [[0,0],[0,1]]\n        Explanation: The distances from (0, 0) to other cells are: [0,1]\n        Example 2:\n        Input: rows = 2, cols = 2, rCenter = 0, cCenter = 1\n        Output: [[0,1],[0,0],[1,1],[1,0]]\n        Explanation: The distances from (0, 1) to other cells are: [0,1,1,2]\n        The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.\n        Example 3:\n        Input: rows = 2, cols = 3, rCenter = 1, cCenter = 2\n        Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]\n        Explanation: The distances from (1, 2) to other cells are: [0,1,1,2,2,3]\n        There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":842,"row":{"number":1029,"difficulty":1,"question":"class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        \"\"\"\n        A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti], the cost of flying the ith person to city a is aCosti, and the cost of flying the ith person to city b is bCosti.\n        Return the minimum cost to fly every person to a city such that exactly n people arrive in each city.\n        Example 1:\n        Input: costs = [[10,20],[30,200],[400,50],[30,20]]\n        Output: 110\n        Explanation: \n        The first person goes to city A for a cost of 10.\n        The second person goes to city A for a cost of 30.\n        The third person goes to city B for a cost of 50.\n        The fourth person goes to city B for a cost of 20.\n        The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.\n        Example 2:\n        Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]\n        Output: 1859\n        Example 3:\n        Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]\n        Output: 3086\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":843,"row":{"number":1031,"difficulty":1,"question":"class Solution:\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\n        \"\"\"\n        Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.\n        The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.\n        A subarray is a contiguous part of an array.\n        Example 1:\n        Input: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2\n        Output: 20\n        Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.\n        Example 2:\n        Input: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2\n        Output: 29\n        Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.\n        Example 3:\n        Input: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3\n        Output: 31\n        Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [0,3,8] with length 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":844,"row":{"number":1032,"difficulty":2,"question":"class StreamChecker:\n    def __init__(self, words: List[str]):\n    def query(self, letter: str) -> bool:\n        \"\"\"\n        Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words.\n        For example, if words = [\"abc\", \"xyz\"] and the stream added the four characters (one by one) 'a', 'x', 'y', and 'z', your algorithm should detect that the suffix \"xyz\" of the characters \"axyz\" matches \"xyz\" from words.\n        Implement the StreamChecker class:\n            StreamChecker(String[] words) Initializes the object with the strings array words.\n            boolean query(char letter) Accepts a new character from the stream and returns true if any non-empty suffix from the stream forms a word that is in words.\n        Example 1:\n        Input\n        [\"StreamChecker\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\"]\n        [[[\"cd\", \"f\", \"kl\"]], [\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [\"f\"], [\"g\"], [\"h\"], [\"i\"], [\"j\"], [\"k\"], [\"l\"]]\n        Output\n        [null, false, false, false, true, false, true, false, false, false, false, false, true]\n        Explanation\n        StreamChecker streamChecker = new StreamChecker([\"cd\", \"f\", \"kl\"]);\n        streamChecker.query(\"a\"); // return False\n        streamChecker.query(\"b\"); // return False\n        streamChecker.query(\"c\"); // return False\n        streamChecker.query(\"d\"); // return True, because 'cd' is in the wordlist\n        streamChecker.query(\"e\"); // return False\n        streamChecker.query(\"f\"); // return True, because 'f' is in the wordlist\n        streamChecker.query(\"g\"); // return False\n        streamChecker.query(\"h\"); // return False\n        streamChecker.query(\"i\"); // return False\n        streamChecker.query(\"j\"); // return False\n        streamChecker.query(\"k\"); // return False\n        streamChecker.query(\"l\"); // return True, because 'kl' is in the wordlist\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":845,"row":{"number":1033,"difficulty":1,"question":"class Solution:\n    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:\n        \"\"\"\n        There are three stones in different positions on the X-axis. You are given three integers a, b, and c, the positions of the stones.\n        In one move, you pick up a stone at an endpoint (i.e., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. Formally, let's say the stones are currently at positions x, y, and z with x < y < z. You pick up the stone at either position x or position z, and move that stone to an integer position k, with x < k < z and k != y.\n        The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n        Return an integer array answer of length 2 where:\n            answer[0] is the minimum number of moves you can play, and\n            answer[1] is the maximum number of moves you can play.\n        Example 1:\n        Input: a = 1, b = 2, c = 5\n        Output: [1,2]\n        Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.\n        Example 2:\n        Input: a = 4, b = 3, c = 2\n        Output: [0,0]\n        Explanation: We cannot make any moves.\n        Example 3:\n        Input: a = 3, b = 5, c = 1\n        Output: [1,2]\n        Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":846,"row":{"number":1034,"difficulty":1,"question":"class Solution:\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\n        \"\"\"\n        You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.\n        Two squares belong to the same connected component if they have the same color and are next to each other in any of the 4 directions.\n        The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\n        You should color the border of the connected component that contains the square grid[row][col] with color.\n        Return the final grid.\n        Example 1:\n        Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n        Output: [[3,3],[3,2]]\n        Example 2:\n        Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n        Output: [[1,3,3],[2,3,3]]\n        Example 3:\n        Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n        Output: [[2,2,2],[2,1,2],[2,2,2]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":847,"row":{"number":1035,"difficulty":1,"question":"class Solution:\n    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines.\n        We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that:\n            nums1[i] == nums2[j], and\n            the line we draw does not intersect any other connecting (non-horizontal) line.\n        Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n        Return the maximum number of connecting lines we can draw in this way.\n        Example 1:\n        Input: nums1 = [1,4,2], nums2 = [1,2,4]\n        Output: 2\n        Explanation: We can draw 2 uncrossed lines as in the diagram.\n        We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.\n        Example 2:\n        Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n        Output: 3\n        Example 3:\n        Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":848,"row":{"number":1036,"difficulty":2,"question":"class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \"\"\"\n        There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y).\n        We start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. There is also an array of blocked squares, where each blocked[i] = [xi, yi] represents a blocked square with coordinates (xi, yi).\n        Each move, we can walk one square north, east, south, or west if the square is not in the array of blocked squares. We are also not allowed to walk outside of the grid.\n        Return true if and only if it is possible to reach the target square from the source square through a sequence of valid moves.\n        Example 1:\n        Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]\n        Output: false\n        Explanation: The target square is inaccessible starting from the source square because we cannot move.\n        We cannot move north or east because those squares are blocked.\n        We cannot move south or west because we cannot go outside of the grid.\n        Example 2:\n        Input: blocked = [], source = [0,0], target = [999999,999999]\n        Output: true\n        Explanation: Because there are no blocked cells, it is possible to reach the target square.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":849,"row":{"number":1039,"difficulty":1,"question":"class Solution:\n    def minScoreTriangulation(self, values: List[int]) -> int:\n        \"\"\"\n        You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\n        You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\n        Return the smallest possible total score that you can achieve with some triangulation of the polygon.\n        Example 1:\n        Input: values = [1,2,3]\n        Output: 6\n        Explanation: The polygon is already triangulated, and the score of the only triangle is 6.\n        Example 2:\n        Input: values = [3,7,4,5]\n        Output: 144\n        Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\n        The minimum score is 144.\n        Example 3:\n        Input: values = [1,3,1,4,1,5]\n        Output: 13\n        Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":850,"row":{"number":1160,"difficulty":0,"question":"class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        \"\"\"\n        You are given an array of strings words and a string chars.\n        A string is good if it can be formed by characters from chars (each character can only be used once).\n        Return the sum of lengths of all good strings in words.\n        Example 1:\n        Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\n        Output: 6\n        Explanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\n        Example 2:\n        Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\n        Output: 10\n        Explanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":851,"row":{"number":1040,"difficulty":1,"question":"class Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int]:\n        \"\"\"\n        There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\n        Call a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n            In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n        The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n        Return an integer array answer of length 2 where:\n            answer[0] is the minimum number of moves you can play, and\n            answer[1] is the maximum number of moves you can play.\n        Example 1:\n        Input: stones = [7,4,9]\n        Output: [1,2]\n        Explanation: We can move 4 -> 8 for one move to finish the game.\n        Or, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.\n        Example 2:\n        Input: stones = [6,5,4,3,10]\n        Output: [2,3]\n        Explanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\n        Or, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\n        Notice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":852,"row":{"number":1038,"difficulty":1,"question":"class Solution:\n    def bstToGst(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\n        As a reminder, a binary search tree is a tree that satisfies these constraints:\n            The left subtree of a node contains only nodes with keys less than the node's key.\n            The right subtree of a node contains only nodes with keys greater than the node's key.\n            Both the left and right subtrees must also be binary search trees.\n        Example 1:\n        Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n        Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n        Example 2:\n        Input: root = [0,null,1]\n        Output: [1,null,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":853,"row":{"number":1037,"difficulty":0,"question":"class Solution:\n    def isBoomerang(self, points: List[List[int]]) -> bool:\n        \"\"\"\n        Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.\n        A boomerang is a set of three points that are all distinct and not in a straight line.\n        Example 1:\n        Input: points = [[1,1],[2,3],[3,2]]\n        Output: true\n        Example 2:\n        Input: points = [[1,1],[2,2],[3,3]]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":854,"row":{"number":1161,"difficulty":1,"question":"class Solution:\n    def maxLevelSum(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.\n        Return the smallest level x such that the sum of all the values of nodes at level x is maximal.\n        Example 1:\n        Input: root = [1,7,0,7,-8,null,null]\n        Output: 2\n        Explanation: \n        Level 1 sum = 1.\n        Level 2 sum = 7 + 0 = 7.\n        Level 3 sum = 7 + -8 = -1.\n        So we return the level with the maximum sum which is level 2.\n        Example 2:\n        Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":855,"row":{"number":1162,"difficulty":1,"question":"class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return -1.\n        The distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.\n        Example 1:\n        Input: grid = [[1,0,1],[0,0,0],[1,0,1]]\n        Output: 2\n        Explanation: The cell (1, 1) is as far as possible from all the land with distance 2.\n        Example 2:\n        Input: grid = [[1,0,0],[0,0,0],[0,0,0]]\n        Output: 4\n        Explanation: The cell (2, 2) is as far as possible from all the land with distance 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":856,"row":{"number":1041,"difficulty":1,"question":"class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        \"\"\"\n        On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:\n            The north direction is the positive direction of the y-axis.\n            The south direction is the negative direction of the y-axis.\n            The east direction is the positive direction of the x-axis.\n            The west direction is the negative direction of the x-axis.\n        The robot can receive one of three instructions:\n            \"G\": go straight 1 unit.\n            \"L\": turn 90 degrees to the left (i.e., anti-clockwise direction).\n            \"R\": turn 90 degrees to the right (i.e., clockwise direction).\n        The robot performs the instructions given in order, and repeats them forever.\n        Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n        Example 1:\n        Input: instructions = \"GGLLGG\"\n        Output: true\n        Explanation: The robot is initially at (0, 0) facing the north direction.\n        \"G\": move one step. Position: (0, 1). Direction: North.\n        \"G\": move one step. Position: (0, 2). Direction: North.\n        \"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.\n        \"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.\n        \"G\": move one step. Position: (0, 1). Direction: South.\n        \"G\": move one step. Position: (0, 0). Direction: South.\n        Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (0, 2) --> (0, 1) --> (0, 0).\n        Based on that, we return true.\n        Example 2:\n        Input: instructions = \"GG\"\n        Output: false\n        Explanation: The robot is initially at (0, 0) facing the north direction.\n        \"G\": move one step. Position: (0, 1). Direction: North.\n        \"G\": move one step. Position: (0, 2). Direction: North.\n        Repeating the instructions, keeps advancing in the north direction and does not go into cycles.\n        Based on that, we return false.\n        Example 3:\n        Input: instructions = \"GL\"\n        Output: true\n        Explanation: The robot is initially at (0, 0) facing the north direction.\n        \"G\": move one step. Position: (0, 1). Direction: North.\n        \"L\": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.\n        \"G\": move one step. Position: (-1, 1). Direction: West.\n        \"L\": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.\n        \"G\": move one step. Position: (-1, 0). Direction: South.\n        \"L\": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.\n        \"G\": move one step. Position: (0, 0). Direction: East.\n        \"L\": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.\n        Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (-1, 1) --> (-1, 0) --> (0, 0).\n        Based on that, we return true.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":857,"row":{"number":1042,"difficulty":1,"question":"class Solution:\n    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:\n        \"\"\"\n        You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers.\n        All gardens have at most 3 paths coming into or leaving it.\n        Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.\n        Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)th garden. The flower types are denoted 1, 2, 3, or 4. It is guaranteed an answer exists.\n        Example 1:\n        Input: n = 3, paths = [[1,2],[2,3],[3,1]]\n        Output: [1,2,3]\n        Explanation:\n        Gardens 1 and 2 have different types.\n        Gardens 2 and 3 have different types.\n        Gardens 3 and 1 have different types.\n        Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1].\n        Example 2:\n        Input: n = 4, paths = [[1,2],[3,4]]\n        Output: [1,2,1,2]\n        Example 3:\n        Input: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]\n        Output: [1,2,3,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":858,"row":{"number":1043,"difficulty":1,"question":"class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\n        Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.\n        Example 1:\n        Input: arr = [1,15,7,9,2,5,10], k = 3\n        Output: 84\n        Explanation: arr becomes [15,15,15,9,10,10,10]\n        Example 2:\n        Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\n        Output: 83\n        Example 3:\n        Input: arr = [1], k = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":859,"row":{"number":1044,"difficulty":2,"question":"class Solution:\n    def longestDupSubstring(self, s: str) -> str:\n        \"\"\"\n        Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.\n        Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is \"\".\n        Example 1:\n        Input: s = \"banana\"\n        Output: \"ana\"\n        Example 2:\n        Input: s = \"abcd\"\n        Output: \"\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":860,"row":{"number":1046,"difficulty":0,"question":"class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        \"\"\"\n        You are given an array of integers stones where stones[i] is the weight of the ith stone.\n        We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\n            If x == y, both stones are destroyed, and\n            If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n        At the end of the game, there is at most one stone left.\n        Return the weight of the last remaining stone. If there are no stones left, return 0.\n        Example 1:\n        Input: stones = [2,7,4,1,8,1]\n        Output: 1\n        Explanation: \n        We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\n        we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\n        we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\n        we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\n        Example 2:\n        Input: stones = [1]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":861,"row":{"number":1047,"difficulty":0,"question":"class Solution:\n    def removeDuplicates(self, s: str) -> str:\n        \"\"\"\n        You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\n        We repeatedly make duplicate removals on s until we no longer can.\n        Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.\n        Example 1:\n        Input: s = \"abbaca\"\n        Output: \"ca\"\n        Explanation: \n        For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".\n        Example 2:\n        Input: s = \"azxxzy\"\n        Output: \"ay\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":862,"row":{"number":1048,"difficulty":1,"question":"class Solution:\n    def longestStrChain(self, words: List[str]) -> int:\n        \"\"\"\n        You are given an array of words where each word consists of lowercase English letters.\n        wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.\n            For example, \"abc\" is a predecessor of \"abac\", while \"cba\" is not a predecessor of \"bcad\".\n        A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.\n        Return the length of the longest possible word chain with words chosen from the given list of words.\n        Example 1:\n        Input: words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\n        Output: 4\n        Explanation: One of the longest word chains is [\"a\",\"ba\",\"bda\",\"bdca\"].\n        Example 2:\n        Input: words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\n        Output: 5\n        Explanation: All the words can be put in a word chain [\"xb\", \"xbc\", \"cxbc\", \"pcxbc\", \"pcxbcf\"].\n        Example 3:\n        Input: words = [\"abcd\",\"dbqca\"]\n        Output: 1\n        Explanation: The trivial word chain [\"abcd\"] is one of the longest word chains.\n        [\"abcd\",\"dbqca\"] is not a valid word chain because the ordering of the letters is changed.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":863,"row":{"number":1049,"difficulty":1,"question":"class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        \"\"\"\n        You are given an array of integers stones where stones[i] is the weight of the ith stone.\n        We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is:\n            If x == y, both stones are destroyed, and\n            If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n        At the end of the game, there is at most one stone left.\n        Return the smallest possible weight of the left stone. If there are no stones left, return 0.\n        Example 1:\n        Input: stones = [2,7,4,1,8,1]\n        Output: 1\n        Explanation:\n        We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,\n        we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,\n        we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,\n        we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.\n        Example 2:\n        Input: stones = [31,26,33,21,40]\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":864,"row":{"number":1163,"difficulty":2,"question":"class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the last substring of s in lexicographical order.\n        Example 1:\n        Input: s = \"abab\"\n        Output: \"bab\"\n        Explanation: The substrings are [\"a\", \"ab\", \"aba\", \"abab\", \"b\", \"ba\", \"bab\"]. The lexicographically maximum substring is \"bab\".\n        Example 2:\n        Input: s = \"leetcode\"\n        Output: \"tcode\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":865,"row":{"number":1051,"difficulty":0,"question":"class Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n        \"\"\"\n        A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.\n        You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).\n        Return the number of indices where heights[i] != expected[i].\n        Example 1:\n        Input: heights = [1,1,4,2,1,3]\n        Output: 3\n        Explanation: \n        heights:  [1,1,4,2,1,3]\n        expected: [1,1,1,2,3,4]\n        Indices 2, 4, and 5 do not match.\n        Example 2:\n        Input: heights = [5,1,2,3,4]\n        Output: 5\n        Explanation:\n        heights:  [5,1,2,3,4]\n        expected: [1,2,3,4,5]\n        All indices do not match.\n        Example 3:\n        Input: heights = [1,2,3,4,5]\n        Output: 0\n        Explanation:\n        heights:  [1,2,3,4,5]\n        expected: [1,2,3,4,5]\n        All indices match.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":866,"row":{"number":1052,"difficulty":1,"question":"class Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\n        \"\"\"\n        There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.\n        On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.\n        When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\n        The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.\n        Return the maximum number of customers that can be satisfied throughout the day.\n        Example 1:\n        Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\n        Output: 16\n        Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \n        The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n        Example 2:\n        Input: customers = [1], grumpy = [0], minutes = 1\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":867,"row":{"number":1053,"difficulty":1,"question":"class Solution:\n    def prevPermOpt1(self, arr: List[int]) -> List[int]:\n        \"\"\"\n        Given an array of positive integers arr (not necessarily distinct), return the lexicographically largest permutation that is smaller than arr, that can be made with exactly one swap. If it cannot be done, then return the same array.\n        Note that a swap exchanges the positions of two numbers arr[i] and arr[j]\n        Example 1:\n        Input: arr = [3,2,1]\n        Output: [3,1,2]\n        Explanation: Swapping 2 and 1.\n        Example 2:\n        Input: arr = [1,1,5]\n        Output: [1,1,5]\n        Explanation: This is already the smallest permutation.\n        Example 3:\n        Input: arr = [1,9,4,6,7]\n        Output: [1,7,4,6,9]\n        Explanation: Swapping 9 and 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":868,"row":{"number":1054,"difficulty":1,"question":"class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        \"\"\"\n        In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].\n        Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.\n        Example 1:\n        Input: barcodes = [1,1,1,2,2,2]\n        Output: [2,1,2,1,2,1]\n        Example 2:\n        Input: barcodes = [1,1,1,1,2,2,3,3]\n        Output: [1,3,1,3,1,2,1,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":869,"row":{"number":1074,"difficulty":2,"question":"class Solution:\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\n        \"\"\"\n        Given a matrix and a target, return the number of non-empty submatrices that sum to target.\n        A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.\n        Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.\n        Example 1:\n        Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n        Output: 4\n        Explanation: The four 1x1 submatrices that only contain 0.\n        Example 2:\n        Input: matrix = [[1,-1],[-1,1]], target = 0\n        Output: 5\n        Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n        Example 3:\n        Input: matrix = [[904]], target = 0\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":870,"row":{"number":1071,"difficulty":0,"question":"class Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        \"\"\"\n        For two strings s and t, we say \"t divides s\" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times).\n        Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.\n        Example 1:\n        Input: str1 = \"ABCABC\", str2 = \"ABC\"\n        Output: \"ABC\"\n        Example 2:\n        Input: str1 = \"ABABAB\", str2 = \"ABAB\"\n        Output: \"AB\"\n        Example 3:\n        Input: str1 = \"LEET\", str2 = \"CODE\"\n        Output: \"\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":871,"row":{"number":1072,"difficulty":1,"question":"class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n binary matrix matrix.\n        You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa).\n        Return the maximum number of rows that have all values equal after some number of flips.\n        Example 1:\n        Input: matrix = [[0,1],[1,1]]\n        Output: 1\n        Explanation: After flipping no values, 1 row has all values equal.\n        Example 2:\n        Input: matrix = [[0,1],[1,0]]\n        Output: 2\n        Explanation: After flipping values in the first column, both rows have equal values.\n        Example 3:\n        Input: matrix = [[0,0,0],[0,0,1],[1,1,0]]\n        Output: 2\n        Explanation: After flipping values in the first two columns, the last two rows have equal values.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":872,"row":{"number":1073,"difficulty":1,"question":"class Solution:\n    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        \"\"\"\n        Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\n        Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array, format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.\n        Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.\n        Example 1:\n        Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]\n        Output: [1,0,0,0,0]\n        Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.\n        Example 2:\n        Input: arr1 = [0], arr2 = [0]\n        Output: [0]\n        Example 3:\n        Input: arr1 = [0], arr2 = [1]\n        Output: [1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":873,"row":{"number":1078,"difficulty":0,"question":"class Solution:\n    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:\n        \"\"\"\n        Given two strings first and second, consider occurrences in some text of the form \"first second third\", where second comes immediately after first, and third comes immediately after second.\n        Return an array of all the words third for each occurrence of \"first second third\".\n        Example 1:\n        Input: text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n        Output: [\"girl\",\"student\"]\n        Example 2:\n        Input: text = \"we will we will rock you\", first = \"we\", second = \"will\"\n        Output: [\"we\",\"rock\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":874,"row":{"number":1080,"difficulty":1,"question":"class Solution:\n    def sufficientSubset(self, root: Optional[TreeNode], limit: int) -> Optional[TreeNode]:\n        \"\"\"\n        Given the root of a binary tree and an integer limit, delete all insufficient nodes in the tree simultaneously, and return the root of the resulting binary tree.\n        A node is insufficient if every root to leaf path intersecting this node has a sum strictly less than limit.\n        A leaf is a node with no children.\n        Example 1:\n        Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1\n        Output: [1,2,3,4,null,null,7,8,9,null,14]\n        Example 2:\n        Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22\n        Output: [5,4,8,11,null,17,4,7,null,null,null,5]\n        Example 3:\n        Input: root = [1,2,-3,-5,null,4,null], limit = -1\n        Output: [1,null,-3,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":875,"row":{"number":1081,"difficulty":1,"question":"class Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.\n        Example 1:\n        Input: s = \"bcabc\"\n        Output: \"abc\"\n        Example 2:\n        Input: s = \"cbacdcbc\"\n        Output: \"acdb\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":876,"row":{"number":1079,"difficulty":1,"question":"class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        \"\"\"\n        You have n  tiles, where each tile has one letter tiles[i] printed on it.\n        Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.\n        Example 1:\n        Input: tiles = \"AAB\"\n        Output: 8\n        Explanation: The possible sequences are \"A\", \"B\", \"AA\", \"AB\", \"BA\", \"AAB\", \"ABA\", \"BAA\".\n        Example 2:\n        Input: tiles = \"AAABBC\"\n        Output: 188\n        Example 3:\n        Input: tiles = \"V\"\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":877,"row":{"number":1089,"difficulty":0,"question":"class Solution:\n    def duplicateZeros(self, arr: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify arr in-place instead.\n        Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.\n        Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.\n        Example 1:\n        Input: arr = [1,0,2,3,0,4,5,0]\n        Output: [1,0,0,2,3,0,0,4]\n        Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n        Example 2:\n        Input: arr = [1,2,3]\n        Output: [1,2,3]\n        Explanation: After calling your function, the input array is modified to: [1,2,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":878,"row":{"number":1090,"difficulty":1,"question":"class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\n        \"\"\"\n        There is a set of n items. You are given two integer arrays values and labels where the value and the label of the ith element are values[i] and labels[i] respectively. You are also given two integers numWanted and useLimit.\n        Choose a subset s of the n elements such that:\n            The size of the subset s is less than or equal to numWanted.\n            There are at most useLimit items with the same label in s.\n        The score of a subset is the sum of the values in the subset.\n        Return the maximum score of a subset s.\n        Example 1:\n        Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1\n        Output: 9\n        Explanation: The subset chosen is the first, third, and fifth items.\n        Example 2:\n        Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2\n        Output: 12\n        Explanation: The subset chosen is the first, second, and third items.\n        Example 3:\n        Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1\n        Output: 16\n        Explanation: The subset chosen is the first and fourth items.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":879,"row":{"number":1092,"difficulty":2,"question":"class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        \"\"\"\n        Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them.\n        A string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s.\n        Example 1:\n        Input: str1 = \"abac\", str2 = \"cab\"\n        Output: \"cabac\"\n        Explanation: \n        str1 = \"abac\" is a subsequence of \"cabac\" because we can delete the first \"c\".\n        str2 = \"cab\" is a subsequence of \"cabac\" because we can delete the last \"ac\".\n        The answer provided is the shortest such string that satisfies these properties.\n        Example 2:\n        Input: str1 = \"aaaaaaaa\", str2 = \"aaaaaaaa\"\n        Output: \"aaaaaaaa\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":880,"row":{"number":1091,"difficulty":1,"question":"class Solution:\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\n        A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\n            All the visited cells of the path are 0.\n            All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\n        The length of a clear path is the number of visited cells of this path.\n        Example 1:\n        Input: grid = [[0,1],[1,0]]\n        Output: 2\n        Example 2:\n        Input: grid = [[0,0,0],[1,1,0],[1,1,0]]\n        Output: 4\n        Example 3:\n        Input: grid = [[1,0,0],[1,1,0],[1,1,0]]\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":881,"row":{"number":1093,"difficulty":1,"question":"class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        \"\"\"\n        You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it is represented by an array count where count[k] is the number of times that k appears in the sample.\n        Calculate the following statistics:\n            minimum: The minimum element in the sample.\n            maximum: The maximum element in the sample.\n            mean: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.\n            median:\n                If the sample has an odd number of elements, then the median is the middle element once the sample is sorted.\n                If the sample has an even number of elements, then the median is the average of the two middle elements once the sample is sorted.\n            mode: The number that appears the most in the sample. It is guaranteed to be unique.\n        Return the statistics of the sample as an array of floating-point numbers [minimum, maximum, mean, median, mode]. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        Output: [1.00000,3.00000,2.37500,2.50000,3.00000]\n        Explanation: The sample represented by count is [1,2,2,2,3,3,3,3].\n        The minimum and maximum are 1 and 3 respectively.\n        The mean is (1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375.\n        Since the size of the sample is even, the median is the average of the two middle elements 2 and 3, which is 2.5.\n        The mode is 3 as it appears the most in the sample.\n        Example 2:\n        Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        Output: [1.00000,4.00000,2.18182,2.00000,1.00000]\n        Explanation: The sample represented by count is [1,1,1,1,2,2,2,3,3,4,4].\n        The minimum and maximum are 1 and 4 respectively.\n        The mean is (1+1+1+1+2+2+2+3+3+4+4) / 11 = 24 / 11 = 2.18181818... (for display purposes, the output shows the rounded number 2.18182).\n        Since the size of the sample is odd, the median is the middle element 2.\n        The mode is 1 as it appears the most in the sample.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":882,"row":{"number":1094,"difficulty":1,"question":"class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        \"\"\"\n        There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).\n        You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location.\n        Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.\n        Example 1:\n        Input: trips = [[2,1,5],[3,3,7]], capacity = 4\n        Output: false\n        Example 2:\n        Input: trips = [[2,1,5],[3,3,7]], capacity = 5\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":883,"row":{"number":1095,"difficulty":2,"question":"        \"\"\"\n        (This problem is an interactive problem.)\n        You may recall that an array arr is a mountain array if and only if:\n            arr.length >= 3\n            There exists some i with 0 < i < arr.length - 1 such that:\n                arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n                arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n        Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1.\n        You cannot access the mountain array directly. You may only access the array using a MountainArray interface:\n            MountainArray.get(k) returns the element of the array at index k (0-indexed).\n            MountainArray.length() returns the length of the array.\n        Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.\n        Example 1:\n        Input: array = [1,2,3,4,5,3,1], target = 3\n        Output: 2\n        Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.\n        Example 2:\n        Input: array = [0,1,2,4,2,1], target = 3\n        Output: -1\n        Explanation: 3 does not exist in the array, so we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":884,"row":{"number":1117,"difficulty":1,"question":"class H2O:\n    def __init__(self):\n        pass\n    def hydrogen(self, releaseHydrogen: 'Callable[[], None]') -> None:\n        releaseHydrogen()\n    def oxygen(self, releaseOxygen: 'Callable[[], None]') -> None:\n        releaseOxygen()\n        \"\"\"\n        There are two kinds of threads: oxygen and hydrogen. Your goal is to group these threads to form water molecules.\n        There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.\n        In other words:\n            If an oxygen thread arrives at the barrier when no hydrogen threads are present, it must wait for two hydrogen threads.\n            If a hydrogen thread arrives at the barrier when no other threads are present, it must wait for an oxygen thread and another hydrogen thread.\n        We do not have to worry about matching the threads up explicitly; the threads do not necessarily know which other threads they are paired up with. The key is that threads pass the barriers in complete sets; thus, if we examine the sequence of threads that bind and divide them into groups of three, each group should contain one oxygen and two hydrogen threads.\n        Write synchronization code for oxygen and hydrogen molecules that enforces these constraints.\n        Example 1:\n        Input: water = \"HOH\"\n        Output: \"HHO\"\n        Explanation: \"HOH\" and \"OHH\" are also valid answers.\n        Example 2:\n        Input: water = \"OOHHHH\"\n        Output: \"HHOHHO\"\n        Explanation: \"HOHHHO\", \"OHHHHO\", \"HHOHOH\", \"HOHHOH\", \"OHHHOH\", \"HHOOHH\", \"HOHOHH\" and \"OHHOHH\" are also valid answers.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":885,"row":{"number":1115,"difficulty":1,"question":"class FooBar:\n    def __init__(self, n):\n        self.n = n\n    def foo(self, printFoo: 'Callable[[], None]') -> None:\n        for i in range(self.n):\n            printFoo()\n    def bar(self, printBar: 'Callable[[], None]') -> None:\n        for i in range(self.n):\n            printBar()\n        \"\"\"\n        Suppose you are given the following code:\n        class FooBar {\n          public void foo() {\n            for (int i = 0; i < n; i++) {\n              print(\"foo\");\n            }\n          }\n          public void bar() {\n            for (int i = 0; i < n; i++) {\n              print(\"bar\");\n            }\n          }\n        }\n        The same instance of FooBar will be passed to two different threads:\n            thread A will call foo(), while\n            thread B will call bar().\n        Modify the given program to output \"foobar\" n times.\n        Example 1:\n        Input: n = 1\n        Output: \"foobar\"\n        Explanation: There are two threads being fired asynchronously. One of them calls foo(), while the other calls bar().\n        \"foobar\" is being output 1 time.\n        Example 2:\n        Input: n = 2\n        Output: \"foobarfoobar\"\n        Explanation: \"foobar\" is being output 2 times.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":886,"row":{"number":1096,"difficulty":2,"question":"class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        \"\"\"\n        Under the grammar given below, strings can represent a set of lowercase words. Let R(expr) denote the set of words the expression represents.\n        The grammar can best be understood through simple examples:\n            Single letters represent a singleton set containing that word.\n                R(\"a\") = {\"a\"}\n                R(\"w\") = {\"w\"}\n            When we take a comma-delimited list of two or more expressions, we take the union of possibilities.\n                R(\"{a,b,c}\") = {\"a\",\"b\",\"c\"}\n                R(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains each word at most once)\n            When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.\n                R(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"}\n                R(\"a{b,c}{d,e}f{g,h}\") = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"}\n        Formally, the three rules for our grammar:\n            For every lowercase letter x, we have R(x) = {x}.\n            For expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) ∪ R(e2) ∪ ...\n            For expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) × R(e2)}, where + denotes concatenation, and × denotes the cartesian product.\n        Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.\n        Example 1:\n        Input: expression = \"{a,b}{c,{d,e}}\"\n        Output: [\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]\n        Example 2:\n        Input: expression = \"{{a,z},a{b,c},{ab,z}}\"\n        Output: [\"a\",\"ab\",\"ac\",\"z\"]\n        Explanation: Each distinct word is written only once in the final answer.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":887,"row":{"number":1104,"difficulty":1,"question":"class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        \"\"\"\n        In an infinite binary tree where every node has two children, the nodes are labelled in row order.\n        In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n        Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.\n        Example 1:\n        Input: label = 14\n        Output: [1,3,4,14]\n        Example 2:\n        Input: label = 26\n        Output: [1,2,6,10,26]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":888,"row":{"number":1103,"difficulty":0,"question":"class Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        \"\"\"\n        We distribute some number of candies, to a row of n = num_people people in the following way:\n        We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.\n        Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.\n        This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\n        Return an array (of length num_people and sum candies) that represents the final distribution of candies.\n        Example 1:\n        Input: candies = 7, num_people = 4\n        Output: [1,2,3,1]\n        Explanation:\n        On the first turn, ans[0] += 1, and the array is [1,0,0,0].\n        On the second turn, ans[1] += 2, and the array is [1,2,0,0].\n        On the third turn, ans[2] += 3, and the array is [1,2,3,0].\n        On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].\n        Example 2:\n        Input: candies = 10, num_people = 3\n        Output: [5,2,3]\n        Explanation: \n        On the first turn, ans[0] += 1, and the array is [1,0,0].\n        On the second turn, ans[1] += 2, and the array is [1,2,0].\n        On the third turn, ans[2] += 3, and the array is [1,2,3].\n        On the fourth turn, ans[0] += 4, and the final array is [5,2,3].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":889,"row":{"number":1105,"difficulty":1,"question":"class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:\n        \"\"\"\n        You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.\n        We want to place these books in order onto bookcase shelves that have a total width shelfWidth.\n        We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n        Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n            For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n        Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.\n        Example 1:\n        Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4\n        Output: 6\n        Explanation:\n        The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\n        Notice that book number 2 does not have to be on the first shelf.\n        Example 2:\n        Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":890,"row":{"number":1106,"difficulty":2,"question":"class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        \"\"\"\n        A boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes:\n            't' that evaluates to true.\n            'f' that evaluates to false.\n            '!(subExpr)' that evaluates to the logical NOT of the inner expression subExpr.\n            '&(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical AND of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n            '|(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical OR of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n        Given a string expression that represents a boolean expression, return the evaluation of that expression.\n        It is guaranteed that the given expression is valid and follows the given rules.\n        Example 1:\n        Input: expression = \"&(|(f))\"\n        Output: false\n        Explanation: \n        First, evaluate |(f) --> f. The expression is now \"&(f)\".\n        Then, evaluate &(f) --> f. The expression is now \"f\".\n        Finally, return false.\n        Example 2:\n        Input: expression = \"|(f,f,f,t)\"\n        Output: true\n        Explanation: The evaluation of (false OR false OR false OR true) is true.\n        Example 3:\n        Input: expression = \"!(&(f,t))\"\n        Output: true\n        Explanation: \n        First, evaluate &(f,t) --> (false AND true) --> false --> f. The expression is now \"!(f)\".\n        Then, evaluate !(f) --> NOT false --> true. We return true.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":891,"row":{"number":1114,"difficulty":0,"question":"class Foo:\n    def __init__(self):\n        pass\n    def first(self, printFirst: 'Callable[[], None]') -> None:\n        printFirst()\n    def second(self, printSecond: 'Callable[[], None]') -> None:\n        printSecond()\n    def third(self, printThird: 'Callable[[], None]') -> None:\n        printThird()\n        \"\"\"\n        Suppose we have a class:\n        public class Foo {\n          public void first() { print(\"first\"); }\n          public void second() { print(\"second\"); }\n          public void third() { print(\"third\"); }\n        }\n        The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().\n        Note:\n        We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests' comprehensiveness.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: \"firstsecondthird\"\n        Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). \"firstsecondthird\" is the correct output.\n        Example 2:\n        Input: nums = [1,3,2]\n        Output: \"firstsecondthird\"\n        Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":892,"row":{"number":1108,"difficulty":0,"question":"class Solution:\n    def defangIPaddr(self, address: str) -> str:\n        \"\"\"\n        Given a valid (IPv4) IP address, return a defanged version of that IP address.\r\n        A defanged IP address replaces every period \".\" with \"[.]\".\r\n        Example 1:\r\n        Input: address = \"1.1.1.1\"\r\n        Output: \"1[.]1[.]1[.]1\"\r\n        Example 2:\r\n        Input: address = \"255.100.50.0\"\r\n        Output: \"255[.]100[.]50[.]0\"\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":893,"row":{"number":1109,"difficulty":1,"question":"class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        \"\"\"\n        There are n flights that are labeled from 1 to n.\n        You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\n        Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.\n        Example 1:\n        Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n        Output: [10,55,45,25,25]\n        Explanation:\n        Flight labels:        1   2   3   4   5\n        Booking 1 reserved:  10  10\n        Booking 2 reserved:      20  20\n        Booking 3 reserved:      25  25  25  25\n        Total seats:         10  55  45  25  25\n        Hence, answer = [10,55,45,25,25]\n        Example 2:\n        Input: bookings = [[1,2,10],[2,2,15]], n = 2\n        Output: [10,25]\n        Explanation:\n        Flight labels:        1   2\n        Booking 1 reserved:  10  10\n        Booking 2 reserved:      15\n        Total seats:         10  25\n        Hence, answer = [10,25]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":894,"row":{"number":1110,"difficulty":1,"question":"class Solution:\n    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:\n        \"\"\"\n        Given the root of a binary tree, each node in the tree has a distinct value.\n        After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).\n        Return the roots of the trees in the remaining forest. You may return the result in any order.\n        Example 1:\n        Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]\n        Output: [[1,2,null,4],[6],[7]]\n        Example 2:\n        Input: root = [1,2,4,null,3], to_delete = [3]\n        Output: [[1,2,4]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":895,"row":{"number":1111,"difficulty":1,"question":"class Solution:\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\n        \"\"\"\n        A string is a valid parentheses string (denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and:\r\n            It is the empty string, or\r\n            It can be written as AB (A concatenated with B), where A and B are VPS's, or\r\n            It can be written as (A), where A is a VPS.\r\n        We can similarly define the nesting depth depth(S) of any VPS S as follows:\r\n            depth(\"\") = 0\r\n            depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's\r\n            depth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.\r\n        For example,  \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's.\r\n        Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS's (and A.length + B.length = seq.length).\r\n        Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.\r\n        Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.\r\n        Example 1:\n        Input: seq = \"(()())\"\n        Output: [0,1,1,1,1,0]\n        Example 2:\n        Input: seq = \"()(())()\"\n        Output: [0,0,0,1,1,0,1,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":896,"row":{"number":1619,"difficulty":0,"question":"class Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        \"\"\"\n        Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.\n        Answers within 10-5 of the actual answer will be considered accepted.\n        Example 1:\n        Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n        Output: 2.00000\n        Explanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.\n        Example 2:\n        Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n        Output: 4.00000\n        Example 3:\n        Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n        Output: 4.77778\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":897,"row":{"number":1286,"difficulty":1,"question":"class CombinationIterator:\n    def __init__(self, characters: str, combinationLength: int):\n    def next(self) -> str:\n    def hasNext(self) -> bool:\n        \"\"\"\n        Design the CombinationIterator class:\n            CombinationIterator(string characters, int combinationLength) Initializes the object with a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments.\n            next() Returns the next combination of length combinationLength in lexicographical order.\n            hasNext() Returns true if and only if there exists a next combination.\n        Example 1:\n        Input\n        [\"CombinationIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n        [[\"abc\", 2], [], [], [], [], [], []]\n        Output\n        [null, \"ab\", true, \"ac\", true, \"bc\", false]\n        Explanation\n        CombinationIterator itr = new CombinationIterator(\"abc\", 2);\n        itr.next();    // return \"ab\"\n        itr.hasNext(); // return True\n        itr.next();    // return \"ac\"\n        itr.hasNext(); // return True\n        itr.next();    // return \"bc\"\n        itr.hasNext(); // return False\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":898,"row":{"number":1291,"difficulty":1,"question":"class Solution:\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\n        \"\"\"\n        An integer has sequential digits if and only if each digit in the number is one more than the previous digit.\n        Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.\n        Example 1:\n        Input: low = 100, high = 300\n        Output: [123,234]\n        Example 2:\n        Input: low = 1000, high = 13000\n        Output: [1234,2345,3456,4567,5678,6789,12345]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":899,"row":{"number":1116,"difficulty":1,"question":"class ZeroEvenOdd:\n    def __init__(self, n):\n        self.n = n\n    def zero(self, printNumber: 'Callable[[int], None]') -> None:\n    def even(self, printNumber: 'Callable[[int], None]') -> None:\n    def odd(self, printNumber: 'Callable[[int], None]') -> None:\n        \"\"\"\n        You have a function printNumber that can be called with an integer parameter and prints it to the console.\n            For example, calling printNumber(7) prints 7 to the console.\n        You are given an instance of the class ZeroEvenOdd that has three functions: zero, even, and odd. The same instance of ZeroEvenOdd will be passed to three different threads:\n            Thread A: calls zero() that should only output 0's.\n            Thread B: calls even() that should only output even numbers.\n            Thread C: calls odd() that should only output odd numbers.\n        Modify the given class to output the series \"010203040506...\" where the length of the series must be 2n.\n        Implement the ZeroEvenOdd class:\n            ZeroEvenOdd(int n) Initializes the object with the number n that represents the numbers that should be printed.\n            void zero(printNumber) Calls printNumber to output one zero.\n            void even(printNumber) Calls printNumber to output one even number.\n            void odd(printNumber) Calls printNumber to output one odd number.\n        Example 1:\n        Input: n = 2\n        Output: \"0102\"\n        Explanation: There are three threads being fired asynchronously.\n        One of them calls zero(), the other calls even(), and the last one calls odd().\n        \"0102\" is the correct output.\n        Example 2:\n        Input: n = 5\n        Output: \"0102030405\"\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}