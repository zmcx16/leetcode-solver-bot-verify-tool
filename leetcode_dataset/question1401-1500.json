{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1400,"row":{"number":1773,"difficulty":0,"question":"class Solution:\n    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:\n        \"\"\"\n        You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.\n        The ith item is said to match the rule if one of the following is true:\n            ruleKey == \"type\" and ruleValue == typei.\n            ruleKey == \"color\" and ruleValue == colori.\n            ruleKey == \"name\" and ruleValue == namei.\n        Return the number of items that match the given rule.\n        Example 1:\n        Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"\n        Output: 1\n        Explanation: There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"].\n        Example 2:\n        Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"\n        Output: 2\n        Explanation: There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1401,"row":{"number":1774,"difficulty":1,"question":"class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        \"\"\"\n        You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n            There must be exactly one ice cream base.\n            You can add one or more types of topping or have no toppings at all.\n            There are at most two of each type of topping.\n        You are given three inputs:\n            baseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\n            toppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\n            target, an integer representing your target price for dessert.\n        You want to make a dessert with a total cost as close to target as possible.\n        Return the closest possible cost of the dessert to target. If there are multiple, return the lower one.\n        Example 1:\n        Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\n        Output: 10\n        Explanation: Consider the following combination (all 0-indexed):\n        - Choose base 1: cost 7\n        - Take 1 of topping 0: cost 1 x 3 = 3\n        - Take 0 of topping 1: cost 0 x 4 = 0\n        Total: 7 + 3 + 0 = 10.\n        Example 2:\n        Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n        Output: 17\n        Explanation: Consider the following combination (all 0-indexed):\n        - Choose base 1: cost 3\n        - Take 1 of topping 0: cost 1 x 4 = 4\n        - Take 2 of topping 1: cost 2 x 5 = 10\n        - Take 0 of topping 2: cost 0 x 100 = 0\n        Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.\n        Example 3:\n        Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\n        Output: 8\n        Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1402,"row":{"number":1775,"difficulty":1,"question":"class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two arrays of integers nums1 and nums2, possibly of different lengths. The values in the arrays are between 1 and 6, inclusive.\n        In one operation, you can change any integer's value in any of the arrays to any value between 1 and 6, inclusive.\n        Return the minimum number of operations required to make the sum of values in nums1 equal to the sum of values in nums2. Return -1​​​​​ if it is not possible to make the sum of the two arrays equal.\n        Example 1:\n        Input: nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]\n        Output: 3\n        Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.\n        - Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2].\n        - Change nums1[5] to 1. nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2].\n        - Change nums1[2] to 2. nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2].\n        Example 2:\n        Input: nums1 = [1,1,1,1,1,1,1], nums2 = [6]\n        Output: -1\n        Explanation: There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal.\n        Example 3:\n        Input: nums1 = [6,6], nums2 = [1]\n        Output: 3\n        Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. \n        - Change nums1[0] to 2. nums1 = [2,6], nums2 = [1].\n        - Change nums1[1] to 2. nums1 = [2,2], nums2 = [1].\n        - Change nums2[0] to 4. nums1 = [2,2], nums2 = [4].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1403,"row":{"number":1776,"difficulty":2,"question":"class Solution:\n    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:\n        \"\"\"\n        There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents:\n            positioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni < positioni+1.\n            speedi is the initial speed of the ith car in meters per second.\n        For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet.\n        Return an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car. Answers within 10-5 of the actual answers are accepted.\n        Example 1:\n        Input: cars = [[1,2],[2,1],[4,3],[7,2]]\n        Output: [1.00000,-1.00000,3.00000,-1.00000]\n        Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.\n        Example 2:\n        Input: cars = [[3,4],[5,4],[6,3],[9,1]]\n        Output: [2.00000,1.00000,1.50000,-1.00000]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1404,"row":{"number":1796,"difficulty":0,"question":"class Solution:\n    def secondHighest(self, s: str) -> int:\n        \"\"\"\n        Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.\n        An alphanumeric string is a string consisting of lowercase English letters and digits.\n        Example 1:\n        Input: s = \"dfa12321afd\"\n        Output: 2\n        Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.\n        Example 2:\n        Input: s = \"abc1111\"\n        Output: -1\n        Explanation: The digits that appear in s are [1]. There is no second largest digit. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1405,"row":{"number":1797,"difficulty":1,"question":"class AuthenticationManager:\n    def __init__(self, timeToLive: int):\n    def generate(self, tokenId: str, currentTime: int) -> None:\n    def renew(self, tokenId: str, currentTime: int) -> None:\n    def countUnexpiredTokens(self, currentTime: int) -> int:\n        \"\"\"\n        There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.\n        Implement the AuthenticationManager class:\n            AuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.\n            generate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.\n            renew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.\n            countUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.\n        Note that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.\n        Example 1:\n        Input\n        [\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"]\n        [[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\n        Output\n        [null, null, null, 1, null, null, null, 0]\n        Explanation\n        AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.\n        authenticationManager.renew(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens.\n        authenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2.\n        authenticationManager.countUnexpiredTokens(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1.\n        authenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7.\n        authenticationManager.renew(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.\n        authenticationManager.renew(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.\n        authenticationManager.countUnexpiredTokens(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1406,"row":{"number":1799,"difficulty":2,"question":"class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.\n        In the ith operation (1-indexed), you will:\n            Choose two elements, x and y.\n            Receive a score of i * gcd(x, y).\n            Remove x and y from nums.\n        Return the maximum score you can receive after performing n operations.\n        The function gcd(x, y) is the greatest common divisor of x and y.\n        Example 1:\n        Input: nums = [1,2]\n        Output: 1\n        Explanation: The optimal choice of operations is:\n        (1 * gcd(1, 2)) = 1\n        Example 2:\n        Input: nums = [3,4,6,8]\n        Output: 11\n        Explanation: The optimal choice of operations is:\n        (1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11\n        Example 3:\n        Input: nums = [1,2,3,4,5,6]\n        Output: 14\n        Explanation: The optimal choice of operations is:\n        (1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1407,"row":{"number":1803,"difficulty":2,"question":"class Solution:\n    def countPairs(self, nums: List[int], low: int, high: int) -> int:\n        \"\"\"\n        Given a (0-indexed) integer array nums and two integers low and high, return the number of nice pairs.\r\n        A nice pair is a pair (i, j) where 0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high.\r\n        Example 1:\r\n        Input: nums = [1,4,2,7], low = 2, high = 6\r\n        Output: 6\r\n        Explanation: All nice pairs (i, j) are as follows:\r\n            - (0, 1): nums[0] XOR nums[1] = 5 \r\n            - (0, 2): nums[0] XOR nums[2] = 3\r\n            - (0, 3): nums[0] XOR nums[3] = 6\r\n            - (1, 2): nums[1] XOR nums[2] = 6\r\n            - (1, 3): nums[1] XOR nums[3] = 3\r\n            - (2, 3): nums[2] XOR nums[3] = 5\r\n        Example 2:\r\n        Input: nums = [9,8,4,2,1], low = 5, high = 14\r\n        Output: 8\r\n        Explanation: All nice pairs (i, j) are as follows:\r\n        ​​​​​    - (0, 2): nums[0] XOR nums[2] = 13\r\n            - (0, 3): nums[0] XOR nums[3] = 11\r\n            - (0, 4): nums[0] XOR nums[4] = 8\r\n            - (1, 2): nums[1] XOR nums[2] = 12\r\n            - (1, 3): nums[1] XOR nums[3] = 10\r\n            - (1, 4): nums[1] XOR nums[4] = 9\r\n            - (2, 3): nums[2] XOR nums[3] = 6\r\n            - (2, 4): nums[2] XOR nums[4] = 5\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1408,"row":{"number":1784,"difficulty":0,"question":"class Solution:\n    def checkOnesSegment(self, s: str) -> bool:\n        \"\"\"\n        Given a binary string s ​​​​​without leading zeros, return true​​​ if s contains at most one contiguous segment of ones. Otherwise, return false.\n        Example 1:\n        Input: s = \"1001\"\n        Output: false\n        Explanation: The ones do not form a contiguous segment.\n        Example 2:\n        Input: s = \"110\"\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1409,"row":{"number":1785,"difficulty":1,"question":"class Solution:\n    def minElements(self, nums: List[int], limit: int, goal: int) -> int:\n        \"\"\"\n        You are given an integer array nums and two integers limit and goal. The array nums has an interesting property that abs(nums[i]) <= limit.\n        Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i]) <= limit.\n        Note that abs(x) equals x if x >= 0, and -x otherwise.\n        Example 1:\n        Input: nums = [1,-1,1], limit = 3, goal = -4\n        Output: 2\n        Explanation: You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4.\n        Example 2:\n        Input: nums = [1,-10,9,1], limit = 100, goal = 0\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1410,"row":{"number":1786,"difficulty":1,"question":"class Solution:\n    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n        \"\"\"\n        There is an undirected weighted connected graph. You are given a positive integer n which denotes that the graph has n nodes labeled from 1 to n, and an array edges where each edges[i] = [ui, vi, weighti] denotes that there is an edge between nodes ui and vi with weight equal to weighti.\n        A path from node start to node end is a sequence of nodes [z0, z1, z2, ..., zk] such that z0 = start and zk = end and there is an edge between zi and zi+1 where 0 <= i <= k-1.\n        The distance of a path is the sum of the weights on the edges of the path. Let distanceToLastNode(x) denote the shortest distance of a path between node n and node x. A restricted path is a path that also satisfies that distanceToLastNode(zi) > distanceToLastNode(zi+1) where 0 <= i <= k-1.\n        Return the number of restricted paths from node 1 to node n. Since that number may be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]\n        Output: 3\n        Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The three restricted paths are:\n        1) 1 --> 2 --> 5\n        2) 1 --> 2 --> 3 --> 5\n        3) 1 --> 3 --> 5\n        Example 2:\n        Input: n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]\n        Output: 1\n        Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The only restricted path is 1 --> 3 --> 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1411,"row":{"number":1787,"difficulty":2,"question":"class Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an array nums​​​ and an integer k​​​​​. The XOR of a segment [left, right] where left <= right is the XOR of all the elements with indices between left and right, inclusive: nums[left] XOR nums[left+1] XOR ... XOR nums[right].\n        Return the minimum number of elements to change in the array such that the XOR of all segments of size k​​​​​​ is equal to zero.\n        Example 1:\n        Input: nums = [1,2,0,3,0], k = 1\n        Output: 3\n        Explanation: Modify the array from [1,2,0,3,0] to from [0,0,0,0,0].\n        Example 2:\n        Input: nums = [3,4,5,2,1,7,3,4,7], k = 3\n        Output: 3\n        Explanation: Modify the array from [3,4,5,2,1,7,3,4,7] to [3,4,7,3,4,7,3,4,7].\n        Example 3:\n        Input: nums = [1,2,4,1,2,5,1,2,6], k = 3\n        Output: 3\n        Explanation: Modify the array from [1,2,4,1,2,5,1,2,6] to [1,2,3,1,2,3,1,2,3].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1412,"row":{"number":1790,"difficulty":0,"question":"class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        \"\"\"\n        You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\n        Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.\n        Example 1:\n        Input: s1 = \"bank\", s2 = \"kanb\"\n        Output: true\n        Explanation: For example, swap the first character with the last character of s2 to make \"bank\".\n        Example 2:\n        Input: s1 = \"attack\", s2 = \"defend\"\n        Output: false\n        Explanation: It is impossible to make them equal with one string swap.\n        Example 3:\n        Input: s1 = \"kelb\", s2 = \"kelb\"\n        Output: true\n        Explanation: The two strings are already equal, so no string swap operation is required.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1413,"row":{"number":1791,"difficulty":0,"question":"class Solution:\n    def findCenter(self, edges: List[List[int]]) -> int:\n        \"\"\"\n        There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\n        You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.\n        Example 1:\n        Input: edges = [[1,2],[2,3],[4,2]]\n        Output: 2\n        Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.\n        Example 2:\n        Input: edges = [[1,2],[5,1],[1,3],[1,4]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1414,"row":{"number":1792,"difficulty":1,"question":"class Solution:\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\n        \"\"\"\n        There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.\n        You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.\n        The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.\n        Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2\n        Output: 0.78333\n        Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.\n        Example 2:\n        Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4\n        Output: 0.53485\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1415,"row":{"number":1793,"difficulty":2,"question":"class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an array of integers nums (0-indexed) and an integer k.\n        The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.\n        Return the maximum possible score of a good subarray.\n        Example 1:\n        Input: nums = [1,4,3,7,4,5], k = 3\n        Output: 15\n        Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. \n        Example 2:\n        Input: nums = [5,5,4,5,4,1,1,1], k = 0\n        Output: 20\n        Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1416,"row":{"number":1812,"difficulty":0,"question":"class Solution:\n    def squareIsWhite(self, coordinates: str) -> bool:\n        \"\"\"\n        You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\n        Return true if the square is white, and false if the square is black.\n        The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.\n        Example 1:\n        Input: coordinates = \"a1\"\n        Output: false\n        Explanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false.\n        Example 2:\n        Input: coordinates = \"h3\"\n        Output: true\n        Explanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true.\n        Example 3:\n        Input: coordinates = \"c7\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1417,"row":{"number":1813,"difficulty":1,"question":"class Solution:\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\n        \"\"\"\n        A sentence is a list of words that are separated by a single space with no leading or trailing spaces. For example, \"Hello World\", \"HELLO\", \"hello world hello world\" are all sentences. Words consist of only uppercase and lowercase English letters.\n        Two sentences sentence1 and sentence2 are similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences such that the two sentences become equal. For example, sentence1 = \"Hello my name is Jane\" and sentence2 = \"Hello Jane\" can be made equal by inserting \"my name is\" between \"Hello\" and \"Jane\" in sentence2.\n        Given two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.\n        Example 1:\n        Input: sentence1 = \"My name is Haley\", sentence2 = \"My Haley\"\n        Output: true\n        Explanation: sentence2 can be turned to sentence1 by inserting \"name is\" between \"My\" and \"Haley\".\n        Example 2:\n        Input: sentence1 = \"of\", sentence2 = \"A lot of words\"\n        Output: false\n        Explanation: No single sentence can be inserted inside one of the sentences to make it equal to the other.\n        Example 3:\n        Input: sentence1 = \"Eating right now\", sentence2 = \"Eating\"\n        Output: true\n        Explanation: sentence2 can be turned to sentence1 by inserting \"right now\" at the end of the sentence.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1418,"row":{"number":1815,"difficulty":2,"question":"class Solution:\n    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:\n        \"\"\"\n        There is a donuts shop that bakes donuts in batches of batchSize. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. You are given an integer batchSize and an integer array groups, where groups[i] denotes that there is a group of groups[i] customers that will visit the shop. Each customer will get exactly one donut.\n        When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.\n        You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups.\n        Example 1:\n        Input: batchSize = 3, groups = [1,2,3,4,5,6]\n        Output: 4\n        Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd, 4th, and 6th groups will be happy.\n        Example 2:\n        Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1419,"row":{"number":1814,"difficulty":1,"question":"class Solution:\n    def countNicePairs(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:\n            0 <= i < j < nums.length\n            nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])\n        Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: nums = [42,11,1,97]\n        Output: 2\n        Explanation: The two pairs are:\n         - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.\n         - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.\n        Example 2:\n        Input: nums = [13,10,35,24,76]\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1420,"row":{"number":1800,"difficulty":0,"question":"class Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n        A subarray is defined as a contiguous sequence of numbers in an array.\n        A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l <= i < r, numsi  < numsi+1. Note that a subarray of size 1 is ascending.\n        Example 1:\n        Input: nums = [10,20,30,5,10,50]\n        Output: 65\n        Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.\n        Example 2:\n        Input: nums = [10,20,30,40,50]\n        Output: 150\n        Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.\n        Example 3:\n        Input: nums = [12,17,15,13,10,11,12]\n        Output: 33\n        Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1421,"row":{"number":1801,"difficulty":1,"question":"class Solution:\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D integer array orders, where each orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have been placed of type orderTypei at the price pricei. The orderTypei is:\r\n            0 if it is a batch of buy orders, or\r\n            1 if it is a batch of sell orders.\r\n        Note that orders[i] represents a batch of amounti independent orders with the same price and order type. All orders represented by orders[i] will be placed before all orders represented by orders[i+1] for all valid i.\r\n        There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:\r\n            If the order is a buy order, you look at the sell order with the smallest price in the backlog. If that sell order's price is smaller than or equal to the current buy order's price, they will match and be executed, and that sell order will be removed from the backlog. Else, the buy order is added to the backlog.\r\n            Vice versa, if the order is a sell order, you look at the buy order with the largest price in the backlog. If that buy order's price is larger than or equal to the current sell order's price, they will match and be executed, and that buy order will be removed from the backlog. Else, the sell order is added to the backlog.\r\n        Return the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo 109 + 7.\r\n        Example 1:\r\n        Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]\r\n        Output: 6\r\n        Explanation: Here is what happens with the orders:\r\n        - 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.\r\n        - 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.\r\n        - 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.\r\n        - 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.\r\n        Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.\r\n        Example 2:\r\n        Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\r\n        Output: 999999984\r\n        Explanation: Here is what happens with the orders:\r\n        - 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.\r\n        - 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.\r\n        - 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.\r\n        - 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.\r\n        Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1422,"row":{"number":1802,"difficulty":1,"question":"class Solution:\n    def maxValue(self, n: int, index: int, maxSum: int) -> int:\n        \"\"\"\n        You are given three positive integers: n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:\n            nums.length == n\n            nums[i] is a positive integer where 0 <= i < n.\n            abs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.\n            The sum of all the elements of nums does not exceed maxSum.\n            nums[index] is maximized.\n        Return nums[index] of the constructed array.\n        Note that abs(x) equals x if x >= 0, and -x otherwise.\n        Example 1:\n        Input: n = 4, index = 2,  maxSum = 6\n        Output: 2\n        Explanation: nums = [1,2,2,1] is one array that satisfies all the conditions.\n        There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].\n        Example 2:\n        Input: n = 6, index = 1,  maxSum = 10\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1423,"row":{"number":1798,"difficulty":1,"question":"class Solution:\n    def getMaximumConsecutive(self, coins: List[int]) -> int:\n        \"\"\"\n        You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x.\n        Return the maximum number of consecutive integer values that you can make with your coins starting from and including 0.\n        Note that you may have multiple coins of the same value.\n        Example 1:\n        Input: coins = [1,3]\n        Output: 2\n        Explanation: You can make the following values:\n        - 0: take []\n        - 1: take [1]\n        You can make 2 consecutive integer values starting from 0.\n        Example 2:\n        Input: coins = [1,1,1,4]\n        Output: 8\n        Explanation: You can make the following values:\n        - 0: take []\n        - 1: take [1]\n        - 2: take [1,1]\n        - 3: take [1,1,1]\n        - 4: take [4]\n        - 5: take [4,1]\n        - 6: take [4,1,1]\n        - 7: take [4,1,1,1]\n        You can make 8 consecutive integer values starting from 0.\n        Example 3:\n        Input: nums = [1,4,10,3,1]\n        Output: 20\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1424,"row":{"number":1805,"difficulty":0,"question":"class Solution:\n    def numDifferentIntegers(self, word: str) -> int:\n        \"\"\"\n        You are given a string word that consists of digits and lowercase English letters.\n        You will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123  34 8  34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\".\n        Return the number of different integers after performing the replacement operations on word.\n        Two integers are considered different if their decimal representations without any leading zeros are different.\n        Example 1:\n        Input: word = \"a123bc34d8ef34\"\n        Output: 3\n        Explanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once.\n        Example 2:\n        Input: word = \"leet1234code234\"\n        Output: 2\n        Example 3:\n        Input: word = \"a1b01c001\"\n        Output: 1\n        Explanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because\n        the leading zeros are ignored when comparing their decimal values.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1425,"row":{"number":1807,"difficulty":1,"question":"class Solution:\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\n        \"\"\"\n        You are given a string s that contains some bracket pairs, with each pair containing a non-empty key.\n            For example, in the string \"(name)is(age)yearsold\", there are two bracket pairs that contain the keys \"name\" and \"age\".\n        You know the values of a wide range of keys. This is represented by a 2D string array knowledge where each knowledge[i] = [keyi, valuei] indicates that key keyi has a value of valuei.\n        You are tasked to evaluate all of the bracket pairs. When you evaluate a bracket pair that contains some key keyi, you will:\n            Replace keyi and the bracket pair with the key's corresponding valuei.\n            If you do not know the value of the key, you will replace keyi and the bracket pair with a question mark \"?\" (without the quotation marks).\n        Each key will appear at most once in your knowledge. There will not be any nested brackets in s.\n        Return the resulting string after evaluating all of the bracket pairs.\n        Example 1:\n        Input: s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]]\n        Output: \"bobistwoyearsold\"\n        Explanation:\n        The key \"name\" has a value of \"bob\", so replace \"(name)\" with \"bob\".\n        The key \"age\" has a value of \"two\", so replace \"(age)\" with \"two\".\n        Example 2:\n        Input: s = \"hi(name)\", knowledge = [[\"a\",\"b\"]]\n        Output: \"hi?\"\n        Explanation: As you do not know the value of the key \"name\", replace \"(name)\" with \"?\".\n        Example 3:\n        Input: s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]]\n        Output: \"yesyesyesaaa\"\n        Explanation: The same key can appear multiple times.\n        The key \"a\" has a value of \"yes\", so replace all occurrences of \"(a)\" with \"yes\".\n        Notice that the \"a\"s not in a bracket pair are not evaluated.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1426,"row":{"number":1806,"difficulty":1,"question":"class Solution:\n    def reinitializePermutation(self, n: int) -> int:\n        \"\"\"\n        You are given an even integer n​​​​​​. You initially have a permutation perm of size n​​ where perm[i] == i​ (0-indexed)​​​​.\n        In one operation, you will create a new array arr, and for each i:\n            If i % 2 == 0, then arr[i] = perm[i / 2].\n            If i % 2 == 1, then arr[i] = perm[n / 2 + (i - 1) / 2].\n        You will then assign arr​​​​ to perm.\n        Return the minimum non-zero number of operations you need to perform on perm to return the permutation to its initial value.\n        Example 1:\n        Input: n = 2\n        Output: 1\n        Explanation: perm = [0,1] initially.\n        After the 1st operation, perm = [0,1]\n        So it takes only 1 operation.\n        Example 2:\n        Input: n = 4\n        Output: 2\n        Explanation: perm = [0,1,2,3] initially.\n        After the 1st operation, perm = [0,2,1,3]\n        After the 2nd operation, perm = [0,1,2,3]\n        So it takes only 2 operations.\n        Example 3:\n        Input: n = 6\n        Output: 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1427,"row":{"number":1808,"difficulty":2,"question":"class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        \"\"\"\n        You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\r\n          The number of prime factors of n (not necessarily distinct) is at most primeFactors.\r\n          The number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\r\n        Return the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\r\n        Note that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.\r\n        Example 1:\r\n        Input: primeFactors = 5\r\n        Output: 6\r\n        Explanation: 200 is a valid value of n.\r\n        It has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\n        There is not other value of n that has at most 5 prime factors and more nice divisors.\r\n        Example 2:\r\n        Input: primeFactors = 8\r\n        Output: 18\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1428,"row":{"number":1827,"difficulty":0,"question":"class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.\r\n            For example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].\r\n        Return the minimum number of operations needed to make nums strictly increasing.\r\n        An array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.\r\n        Example 1:\r\n        Input: nums = [1,1,1]\r\n        Output: 3\r\n        Explanation: You can do the following operations:\r\n        1) Increment nums[2], so nums becomes [1,1,2].\r\n        2) Increment nums[1], so nums becomes [1,2,2].\r\n        3) Increment nums[2], so nums becomes [1,2,3].\r\n        Example 2:\r\n        Input: nums = [1,5,2,4,1]\r\n        Output: 14\r\n        Example 3:\r\n        Input: nums = [8]\r\n        Output: 0\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1429,"row":{"number":1828,"difficulty":1,"question":"class Solution:\n    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.\n        You are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.\n        For each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.\n        Return an array answer, where answer[j] is the answer to the jth query.\n        Example 1:\n        Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\n        Output: [3,2,2]\n        Explanation: The points and circles are shown above.\n        queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.\n        Example 2:\n        Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\n        Output: [2,3,2,4]\n        Explanation: The points and circles are shown above.\n        queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1430,"row":{"number":1829,"difficulty":1,"question":"class Solution:\n    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:\n        \"\"\"\n        You are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times:\n            Find a non-negative integer k < 2maximumBit such that nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to the ith query.\n            Remove the last element from the current array nums.\n        Return an array answer, where answer[i] is the answer to the ith query.\n        Example 1:\n        Input: nums = [0,1,1,3], maximumBit = 2\n        Output: [0,3,2,3]\n        Explanation: The queries are answered as follows:\n        1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n        2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n        3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.\n        4th query: nums = [0], k = 3 since 0 XOR 3 = 3.\n        Example 2:\n        Input: nums = [2,3,4,7], maximumBit = 3\n        Output: [5,2,6,5]\n        Explanation: The queries are answered as follows:\n        1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n        2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n        3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.\n        4th query: nums = [2], k = 5 since 2 XOR 5 = 7.\n        Example 3:\n        Input: nums = [0,1,2,2,5,7], maximumBit = 3\n        Output: [4,3,6,4,6,7]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1431,"row":{"number":1830,"difficulty":2,"question":"class Solution:\n    def makeStringSorted(self, s: str) -> int:\n        \"\"\"\n        You are given a string s (0-indexed)​​​​​​. You are asked to perform the following operation on s​​​​​​ until you get a sorted string:\n            Find the largest index i such that 1 <= i < s.length and s[i] < s[i - 1].\n            Find the largest index j such that i <= j < s.length and s[k] < s[i - 1] for all the possible values of k in the range [i, j] inclusive.\n            Swap the two characters at indices i - 1​​​​ and j​​​​​.\n            Reverse the suffix starting at index i​​​​​​.\n        Return the number of operations needed to make the string sorted. Since the answer can be too large, return it modulo 109 + 7.\n        Example 1:\n        Input: s = \"cba\"\n        Output: 5\n        Explanation: The simulation goes as follows:\n        Operation 1: i=2, j=2. Swap s[1] and s[2] to get s=\"cab\", then reverse the suffix starting at 2. Now, s=\"cab\".\n        Operation 2: i=1, j=2. Swap s[0] and s[2] to get s=\"bac\", then reverse the suffix starting at 1. Now, s=\"bca\".\n        Operation 3: i=2, j=2. Swap s[1] and s[2] to get s=\"bac\", then reverse the suffix starting at 2. Now, s=\"bac\".\n        Operation 4: i=1, j=1. Swap s[0] and s[1] to get s=\"abc\", then reverse the suffix starting at 1. Now, s=\"acb\".\n        Operation 5: i=2, j=2. Swap s[1] and s[2] to get s=\"abc\", then reverse the suffix starting at 2. Now, s=\"abc\".\n        Example 2:\n        Input: s = \"aabaa\"\n        Output: 2\n        Explanation: The simulation goes as follows:\n        Operation 1: i=3, j=4. Swap s[2] and s[4] to get s=\"aaaab\", then reverse the substring starting at 3. Now, s=\"aaaba\".\n        Operation 2: i=4, j=4. Swap s[3] and s[4] to get s=\"aaaab\", then reverse the substring starting at 4. Now, s=\"aaaab\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1432,"row":{"number":1816,"difficulty":0,"question":"class Solution:\n    def truncateSentence(self, s: str, k: int) -> str:\n        \"\"\"\n        A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).\n            For example, \"Hello World\", \"HELLO\", and \"hello world hello world\" are all sentences.\n        You are given a sentence s​​​​​​ and an integer k​​​​​​. You want to truncate s​​​​​​ such that it contains only the first k​​​​​​ words. Return s​​​​​​ after truncating it.\n        Example 1:\n        Input: s = \"Hello how are you Contestant\", k = 4\n        Output: \"Hello how are you\"\n        Explanation:\n        The words in s are [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"].\n        The first 4 words are [\"Hello\", \"how\", \"are\", \"you\"].\n        Hence, you should return \"Hello how are you\".\n        Example 2:\n        Input: s = \"What is the solution to this problem\", k = 4\n        Output: \"What is the solution\"\n        Explanation:\n        The words in s are [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"].\n        The first 4 words are [\"What\", \"is\", \"the\", \"solution\"].\n        Hence, you should return \"What is the solution\".\n        Example 3:\n        Input: s = \"chopper is not a tanuki\", k = 5\n        Output: \"chopper is not a tanuki\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1433,"row":{"number":1817,"difficulty":1,"question":"class Solution:\n    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:\n        \"\"\"\n        You are given the logs for users' actions on LeetCode, and an integer k. The logs are represented by a 2D integer array logs where each logs[i] = [IDi, timei] indicates that the user with IDi performed an action at the minute timei.\n        Multiple users can perform actions simultaneously, and a single user can perform multiple actions in the same minute.\n        The user active minutes (UAM) for a given user is defined as the number of unique minutes in which the user performed an action on LeetCode. A minute can only be counted once, even if multiple actions occur during it.\n        You are to calculate a 1-indexed array answer of size k such that, for each j (1 <= j <= k), answer[j] is the number of users whose UAM equals j.\n        Return the array answer as described above.\n        Example 1:\n        Input: logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5\n        Output: [0,2,0,0,0]\n        Explanation:\n        The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).\n        The user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\n        Since both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0.\n        Example 2:\n        Input: logs = [[1,1],[2,2],[2,3]], k = 4\n        Output: [1,1,0,0]\n        Explanation:\n        The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.\n        The user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\n        There is one user with a UAM of 1 and one with a UAM of 2.\n        Hence, answer[1] = 1, answer[2] = 1, and the remaining values are 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1434,"row":{"number":1818,"difficulty":1,"question":"class Solution:\n    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two positive integer arrays nums1 and nums2, both of length n.\n        The absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 <= i < n (0-indexed).\n        You can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference.\n        Return the minimum absolute sum difference after replacing at most one element in the array nums1. Since the answer may be large, return it modulo 109 + 7.\n        |x| is defined as:\n            x if x >= 0, or\n            -x if x < 0.\n        Example 1:\n        Input: nums1 = [1,7,5], nums2 = [2,3,5]\n        Output: 3\n        Explanation: There are two possible optimal solutions:\n        - Replace the second element with the first: [1,7,5] => [1,1,5], or\n        - Replace the second element with the third: [1,7,5] => [1,5,5].\n        Both will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3.\n        Example 2:\n        Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]\n        Output: 0\n        Explanation: nums1 is equal to nums2 so no replacement is needed. This will result in an \n        absolute sum difference of 0.\n        Example 3:\n        Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]\n        Output: 20\n        Explanation: Replace the first element with the second: [1,10,4,4,2,7] => [10,10,4,4,2,7].\n        This yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1435,"row":{"number":1819,"difficulty":2,"question":"class Solution:\n    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums that consists of positive integers.\n        The GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly.\n            For example, the GCD of the sequence [4,6,16] is 2.\n        A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n            For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n        Return the number of different GCDs among all non-empty subsequences of nums.\n        Example 1:\n        Input: nums = [6,10,3]\n        Output: 5\n        Explanation: The figure shows all the non-empty subsequences and their GCDs.\n        The different GCDs are 6, 10, 3, 2, and 1.\n        Example 2:\n        Input: nums = [5,15,40,5,6]\n        Output: 7\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1436,"row":{"number":1822,"difficulty":0,"question":"class Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        \"\"\"\n        There is a function signFunc(x) that returns:\n            1 if x is positive.\n            -1 if x is negative.\n            0 if x is equal to 0.\n        You are given an integer array nums. Let product be the product of all values in the array nums.\n        Return signFunc(product).\n        Example 1:\n        Input: nums = [-1,-2,-3,-4,3,2,1]\n        Output: 1\n        Explanation: The product of all values in the array is 144, and signFunc(144) = 1\n        Example 2:\n        Input: nums = [1,5,0,2,-3]\n        Output: 0\n        Explanation: The product of all values in the array is 0, and signFunc(0) = 0\n        Example 3:\n        Input: nums = [-1,1,-1,1,-1]\n        Output: -1\n        Explanation: The product of all values in the array is -1, and signFunc(-1) = -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1437,"row":{"number":1823,"difficulty":1,"question":"class Solution:\n    def findTheWinner(self, n: int, k: int) -> int:\n        \"\"\"\n        There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\n        The rules of the game are as follows:\n            Start at the 1st friend.\n            Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\n            The last friend you counted leaves the circle and loses the game.\n            If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\n            Else, the last friend in the circle wins the game.\n        Given the number of friends, n, and an integer k, return the winner of the game.\n        Example 1:\n        Input: n = 5, k = 2\n        Output: 3\n        Explanation: Here are the steps of the game:\n        1) Start at friend 1.\n        2) Count 2 friends clockwise, which are friends 1 and 2.\n        3) Friend 2 leaves the circle. Next start is friend 3.\n        4) Count 2 friends clockwise, which are friends 3 and 4.\n        5) Friend 4 leaves the circle. Next start is friend 5.\n        6) Count 2 friends clockwise, which are friends 5 and 1.\n        7) Friend 1 leaves the circle. Next start is friend 3.\n        8) Count 2 friends clockwise, which are friends 3 and 5.\n        9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.\n        Example 2:\n        Input: n = 6, k = 5\n        Output: 1\n        Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1438,"row":{"number":1824,"difficulty":1,"question":"class Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        \"\"\"\n        There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way.\n        You are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.\n            For example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.\n        The frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.\n            For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n        Return the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.\n        Note: There will be no obstacles on points 0 and n.\n        Example 1:\n        Input: obstacles = [0,1,2,3,0]\n        Output: 2 \n        Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\n        Note that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n        Example 2:\n        Input: obstacles = [0,1,1,3,3,0]\n        Output: 0\n        Explanation: There are no obstacles on lane 2. No side jumps are required.\n        Example 3:\n        Input: obstacles = [0,2,1,0,3,0]\n        Output: 2\n        Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1439,"row":{"number":1825,"difficulty":2,"question":"class MKAverage:\n    def __init__(self, m: int, k: int):\n    def addElement(self, num: int) -> None:\n    def calculateMKAverage(self) -> int:\n        \"\"\"\n        You are given two integers, m and k, and a stream of integers. You are tasked to implement a data structure that calculates the MKAverage for the stream.\n        The MKAverage can be calculated using these steps:\n            If the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\n            Remove the smallest k elements and the largest k elements from the container.\n            Calculate the average value for the rest of the elements rounded down to the nearest integer.\n        Implement the MKAverage class:\n            MKAverage(int m, int k) Initializes the MKAverage object with an empty stream and the two integers m and k.\n            void addElement(int num) Inserts a new element num into the stream.\n            int calculateMKAverage() Calculates and returns the MKAverage for the current stream rounded down to the nearest integer.\n        Example 1:\n        Input\n        [\"MKAverage\", \"addElement\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"addElement\", \"addElement\", \"calculateMKAverage\"]\n        [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]\n        Output\n        [null, null, null, -1, null, 3, null, null, null, 5]\n        Explanation\n        MKAverage obj = new MKAverage(3, 1); \n        obj.addElement(3);        // current elements are [3]\n        obj.addElement(1);        // current elements are [3,1]\n        obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist.\n        obj.addElement(10);       // current elements are [3,1,10]\n        obj.calculateMKAverage(); // The last 3 elements are [3,1,10].\n                                  // After removing smallest and largest 1 element the container will be [3].\n                                  // The average of [3] equals 3/1 = 3, return 3\n        obj.addElement(5);        // current elements are [3,1,10,5]\n        obj.addElement(5);        // current elements are [3,1,10,5,5]\n        obj.addElement(5);        // current elements are [3,1,10,5,5,5]\n        obj.calculateMKAverage(); // The last 3 elements are [5,5,5].\n                                  // After removing smallest and largest 1 element the container will be [5].\n                                  // The average of [5] equals 5/1 = 5, return 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1440,"row":{"number":1844,"difficulty":0,"question":"class Solution:\n    def replaceDigits(self, s: str) -> str:\n        \"\"\"\n        You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices.\n        There is a function shift(c, x), where c is a character and x is a digit, that returns the xth character after c.\n            For example, shift('a', 5) = 'f' and shift('x', 0) = 'x'.\n        For every odd index i, you want to replace the digit s[i] with shift(s[i-1], s[i]).\n        Return s after replacing all digits. It is guaranteed that shift(s[i-1], s[i]) will never exceed 'z'.\n        Example 1:\n        Input: s = \"a1c1e1\"\n        Output: \"abcdef\"\n        Explanation: The digits are replaced as follows:\n        - s[1] -> shift('a',1) = 'b'\n        - s[3] -> shift('c',1) = 'd'\n        - s[5] -> shift('e',1) = 'f'\n        Example 2:\n        Input: s = \"a1b2c3d4e\"\n        Output: \"abbdcfdhe\"\n        Explanation: The digits are replaced as follows:\n        - s[1] -> shift('a',1) = 'b'\n        - s[3] -> shift('b',2) = 'd'\n        - s[5] -> shift('c',3) = 'f'\n        - s[7] -> shift('d',4) = 'h'\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1441,"row":{"number":1845,"difficulty":1,"question":"class SeatManager:\n    def __init__(self, n: int):\n    def reserve(self) -> int:\n    def unreserve(self, seatNumber: int) -> None:\n        \"\"\"\n        Design a system that manages the reservation state of n seats that are numbered from 1 to n.\n        Implement the SeatManager class:\n            SeatManager(int n) Initializes a SeatManager object that will manage n seats numbered from 1 to n. All seats are initially available.\n            int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and returns its number.\n            void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.\n        Example 1:\n        Input\n        [\"SeatManager\", \"reserve\", \"reserve\", \"unreserve\", \"reserve\", \"reserve\", \"reserve\", \"reserve\", \"unreserve\"]\n        [[5], [], [], [2], [], [], [], [], [5]]\n        Output\n        [null, 1, 2, null, 2, 3, 4, 5, null]\n        Explanation\n        SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.\n        seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.\n        seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.\n        seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].\n        seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.\n        seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.\n        seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.\n        seatManager.reserve();    // The only available seat is seat 5, so return 5.\n        seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1442,"row":{"number":1846,"difficulty":1,"question":"class Solution:\n    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:\n        \"\"\"\n        You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:\n            The value of the first element in arr must be 1.\n            The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.\n        There are 2 types of operations that you can perform any number of times:\n            Decrease the value of any element of arr to a smaller positive integer.\n            Rearrange the elements of arr to be in any order.\n        Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.\n        Example 1:\n        Input: arr = [2,2,1,2,1]\n        Output: 2\n        Explanation: \n        We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].\n        The largest element in arr is 2.\n        Example 2:\n        Input: arr = [100,1,1000]\n        Output: 3\n        Explanation: \n        One possible way to satisfy the conditions is by doing the following:\n        1. Rearrange arr so it becomes [1,100,1000].\n        2. Decrease the value of the second element to 2.\n        3. Decrease the value of the third element to 3.\n        Now arr = [1,2,3], which satisfies the conditions.\n        The largest element in arr is 3.\n        Example 3:\n        Input: arr = [1,2,3,4,5]\n        Output: 5\n        Explanation: The array already satisfies the conditions, and the largest element is 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1443,"row":{"number":1847,"difficulty":2,"question":"class Solution:\n    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        There is a hotel with n rooms. The rooms are represented by a 2D integer array rooms where rooms[i] = [roomIdi, sizei] denotes that there is a room with room number roomIdi and size equal to sizei. Each roomIdi is guaranteed to be unique.\n        You are also given k queries in a 2D array queries where queries[j] = [preferredj, minSizej]. The answer to the jth query is the room number id of a room such that:\n            The room has a size of at least minSizej, and\n            abs(id - preferredj) is minimized, where abs(x) is the absolute value of x.\n        If there is a tie in the absolute difference, then use the room with the smallest such id. If there is no such room, the answer is -1.\n        Return an array answer of length k where answer[j] contains the answer to the jth query.\n        Example 1:\n        Input: rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]\n        Output: [3,-1,3]\n        Explanation: The answers to the queries are as follows:\n        Query = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.\n        Query = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.\n        Query = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.\n        Example 2:\n        Input: rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]\n        Output: [2,1,3]\n        Explanation: The answers to the queries are as follows:\n        Query = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.\n        Query = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.\n        Query = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1444,"row":{"number":1832,"difficulty":0,"question":"class Solution:\n    def checkIfPangram(self, sentence: str) -> bool:\n        \"\"\"\n        A pangram is a sentence where every letter of the English alphabet appears at least once.\n        Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.\n        Example 1:\n        Input: sentence = \"thequickbrownfoxjumpsoverthelazydog\"\n        Output: true\n        Explanation: sentence contains at least one of every letter of the English alphabet.\n        Example 2:\n        Input: sentence = \"leetcode\"\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1445,"row":{"number":1833,"difficulty":1,"question":"class Solution:\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\n        \"\"\"\n        It is a sweltering summer day, and a boy wants to buy some ice cream bars.\n        At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. \n        Note: The boy can buy the ice cream bars in any order.\n        Return the maximum number of ice cream bars the boy can buy with coins coins.\n        You must solve the problem by counting sort.\n        Example 1:\n        Input: costs = [1,3,2,4,1], coins = 7\n        Output: 4\n        Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.\n        Example 2:\n        Input: costs = [10,6,8,7,7,8], coins = 5\n        Output: 0\n        Explanation: The boy cannot afford any of the ice cream bars.\n        Example 3:\n        Input: costs = [1,6,3,1,2,5], coins = 20\n        Output: 6\n        Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1446,"row":{"number":1834,"difficulty":1,"question":"class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given n​​​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.\n        You have a single-threaded CPU that can process at most one task at a time and will act in the following way:\n            If the CPU is idle and there are no available tasks to process, the CPU remains idle.\n            If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.\n            Once a task is started, the CPU will process the entire task without stopping.\n            The CPU can finish a task then start a new one instantly.\n        Return the order in which the CPU will process the tasks.\n        Example 1:\n        Input: tasks = [[1,2],[2,4],[3,2],[4,1]]\n        Output: [0,2,3,1]\n        Explanation: The events go as follows: \n        - At time = 1, task 0 is available to process. Available tasks = {0}.\n        - Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n        - At time = 2, task 1 is available to process. Available tasks = {1}.\n        - At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n        - Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n        - At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n        - At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n        - At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n        - At time = 10, the CPU finishes task 1 and becomes idle.\n        Example 2:\n        Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\n        Output: [4,3,2,0,1]\n        Explanation: The events go as follows:\n        - At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n        - Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n        - At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n        - At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n        - At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n        - At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n        - At time = 40, the CPU finishes task 1 and becomes idle.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1447,"row":{"number":1835,"difficulty":2,"question":"class Solution:\n    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:\n        \"\"\"\n        The XOR sum of a list is the bitwise XOR of all its elements. If the list only contains one element, then its XOR sum will be equal to this element.\n            For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 4 = 4, and the XOR sum of [3] is equal to 3.\n        You are given two 0-indexed arrays arr1 and arr2 that consist only of non-negative integers.\n        Consider the list containing the result of arr1[i] AND arr2[j] (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 0 <= j < arr2.length.\n        Return the XOR sum of the aforementioned list.\n        Example 1:\n        Input: arr1 = [1,2,3], arr2 = [6,5]\n        Output: 0\n        Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1].\n        The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.\n        Example 2:\n        Input: arr1 = [12], arr2 = [4]\n        Output: 4\n        Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1448,"row":{"number":1837,"difficulty":0,"question":"class Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        \"\"\"\n        Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.\n        After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.\n        Example 1:\n        Input: n = 34, k = 6\n        Output: 9\n        Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.\n        Example 2:\n        Input: n = 10, k = 10\n        Output: 1\n        Explanation: n is already in base 10. 1 + 0 = 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1449,"row":{"number":1838,"difficulty":1,"question":"class Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        The frequency of an element is the number of times it occurs in an array.\n        You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.\n        Return the maximum possible frequency of an element after performing at most k operations.\n        Example 1:\n        Input: nums = [1,2,4], k = 5\n        Output: 3\n        Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].\n        4 has a frequency of 3.\n        Example 2:\n        Input: nums = [1,4,8,13], k = 5\n        Output: 2\n        Explanation: There are multiple optimal solutions:\n        - Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n        - Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n        - Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n        Example 3:\n        Input: nums = [3,9,6], k = 2\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1450,"row":{"number":1839,"difficulty":1,"question":"class Solution:\n    def longestBeautifulSubstring(self, word: str) -> int:\n        \"\"\"\n        A string is considered beautiful if it satisfies the following conditions:\n            Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it.\n            The letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.).\n        For example, strings \"aeiou\" and \"aaaaaaeiiiioou\" are considered beautiful, but \"uaeio\", \"aeoiu\", and \"aaaeeeooo\" are not beautiful.\n        Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0.\n        A substring is a contiguous sequence of characters in a string.\n        Example 1:\n        Input: word = \"aeiaaioaaaaeiiiiouuuooaauuaeiu\"\n        Output: 13\n        Explanation: The longest beautiful substring in word is \"aaaaeiiiiouuu\" of length 13.\n        Example 2:\n        Input: word = \"aeeeiiiioooauuuaeiou\"\n        Output: 5\n        Explanation: The longest beautiful substring in word is \"aeiou\" of length 5.\n        Example 3:\n        Input: word = \"a\"\n        Output: 0\n        Explanation: There is no beautiful substring, so return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1451,"row":{"number":1840,"difficulty":2,"question":"class Solution:\n    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:\n        \"\"\"\n        You want to build n new buildings in a city. The new buildings will be built in a line and are labeled from 1 to n.\n        However, there are city restrictions on the heights of the new buildings:\n            The height of each building must be a non-negative integer.\n            The height of the first building must be 0.\n            The height difference between any two adjacent buildings cannot exceed 1.\n        Additionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array restrictions where restrictions[i] = [idi, maxHeighti] indicates that building idi must have a height less than or equal to maxHeighti.\n        It is guaranteed that each building will appear at most once in restrictions, and building 1 will not be in restrictions.\n        Return the maximum possible height of the tallest building.\n        Example 1:\n        Input: n = 5, restrictions = [[2,1],[4,1]]\n        Output: 2\n        Explanation: The green area in the image indicates the maximum allowed height for each building.\n        We can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2.\n        Example 2:\n        Input: n = 6, restrictions = []\n        Output: 5\n        Explanation: The green area in the image indicates the maximum allowed height for each building.\n        We can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5.\n        Example 3:\n        Input: n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]\n        Output: 5\n        Explanation: The green area in the image indicates the maximum allowed height for each building.\n        We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1452,"row":{"number":1859,"difficulty":0,"question":"class Solution:\n    def sortSentence(self, s: str) -> str:\n        \"\"\"\n        A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.\r\n        A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence.\r\n            For example, the sentence \"This is a sentence\" can be shuffled as \"sentence4 a3 is2 This1\" or \"is2 sentence4 This1 a3\".\r\n        Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.\r\n        Example 1:\r\n        Input: s = \"is2 sentence4 This1 a3\"\r\n        Output: \"This is a sentence\"\r\n        Explanation: Sort the words in s to their original positions \"This1 is2 a3 sentence4\", then remove the numbers.\r\n        Example 2:\r\n        Input: s = \"Myself2 Me1 I4 and3\"\r\n        Output: \"Me Myself and I\"\r\n        Explanation: Sort the words in s to their original positions \"Me1 Myself2 and3 I4\", then remove the numbers.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1453,"row":{"number":1860,"difficulty":1,"question":"class Solution:\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\n        \"\"\"\n        You are given two integers memory1 and memory2 representing the available memory in bits on two memory sticks. There is currently a faulty program running that consumes an increasing amount of memory every second.\n        At the ith second (starting from 1), i bits of memory are allocated to the stick with more available memory (or from the first memory stick if both have the same available memory). If neither stick has at least i bits of available memory, the program crashes.\n        Return an array containing [crashTime, memory1crash, memory2crash], where crashTime is the time (in seconds) when the program crashed and memory1crash and memory2crash are the available bits of memory in the first and second sticks respectively.\n        Example 1:\n        Input: memory1 = 2, memory2 = 2\n        Output: [3,1,0]\n        Explanation: The memory is allocated as follows:\n        - At the 1st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory.\n        - At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory.\n        - At the 3rd second, the program crashes. The sticks have 1 and 0 bits available respectively.\n        Example 2:\n        Input: memory1 = 8, memory2 = 11\n        Output: [6,0,4]\n        Explanation: The memory is allocated as follows:\n        - At the 1st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory.\n        - At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory.\n        - At the 3rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory.\n        - At the 4th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory.\n        - At the 5th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory.\n        - At the 6th second, the program crashes. The sticks have 0 and 4 bits available respectively.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1454,"row":{"number":1861,"difficulty":1,"question":"class Solution:\n    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:\n        \"\"\"\n        You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\r\n            A stone '#'\r\n            A stationary obstacle '*'\r\n            Empty '.'\r\n        The box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\r\n        It is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\r\n        Return an n x m matrix representing the box after the rotation described above.\r\n        Example 1:\r\n        Input: box = [[\"#\",\".\",\"#\"]]\r\n        Output: [[\".\"],\r\n                 [\"#\"],\r\n                 [\"#\"]]\r\n        Example 2:\r\n        Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n                      [\"#\",\"#\",\"*\",\".\"]]\r\n        Output: [[\"#\",\".\"],\r\n                 [\"#\",\"#\"],\r\n                 [\"*\",\"*\"],\r\n                 [\".\",\".\"]]\r\n        Example 3:\r\n        Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n                      [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n                      [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\n        Output: [[\".\",\"#\",\"#\"],\r\n                 [\".\",\"#\",\"#\"],\r\n                 [\"#\",\"#\",\"*\"],\r\n                 [\"#\",\"*\",\".\"],\r\n                 [\"#\",\".\",\"*\"],\r\n                 [\"#\",\".\",\".\"]]\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1455,"row":{"number":1848,"difficulty":0,"question":"class Solution:\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\n        \"\"\"\n        Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x.\n        Return abs(i - start).\n        It is guaranteed that target exists in nums.\n        Example 1:\n        Input: nums = [1,2,3,4,5], target = 5, start = 3\n        Output: 1\n        Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.\n        Example 2:\n        Input: nums = [1], target = 1, start = 0\n        Output: 0\n        Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.\n        Example 3:\n        Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\n        Output: 0\n        Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1456,"row":{"number":1849,"difficulty":1,"question":"class Solution:\n    def splitString(self, s: str) -> bool:\n        \"\"\"\n        You are given a string s that consists of only digits.\n        Check if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order and the difference between numerical values of every two adjacent substrings is equal to 1.\n            For example, the string s = \"0090089\" can be split into [\"0090\", \"089\"] with numerical values [90,89]. The values are in descending order and adjacent values differ by 1, so this way is valid.\n            Another example, the string s = \"001\" can be split into [\"0\", \"01\"], [\"00\", \"1\"], or [\"0\", \"0\", \"1\"]. However all the ways are invalid because they have numerical values [0,1], [0,1], and [0,0,1] respectively, all of which are not in descending order.\n        Return true if it is possible to split s​​​​​​ as described above, or false otherwise.\n        A substring is a contiguous sequence of characters in a string.\n        Example 1:\n        Input: s = \"1234\"\n        Output: false\n        Explanation: There is no valid way to split s.\n        Example 2:\n        Input: s = \"050043\"\n        Output: true\n        Explanation: s can be split into [\"05\", \"004\", \"3\"] with numerical values [5,4,3].\n        The values are in descending order with adjacent values differing by 1.\n        Example 3:\n        Input: s = \"9080701\"\n        Output: false\n        Explanation: There is no valid way to split s.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1457,"row":{"number":1851,"difficulty":2,"question":"class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\n        You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\n        Return an array containing the answers to the queries.\n        Example 1:\n        Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\n        Output: [3,3,1,4]\n        Explanation: The queries are processed as follows:\n        - Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n        - Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n        - Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n        - Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\n        Example 2:\n        Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\n        Output: [2,-1,4,6]\n        Explanation: The queries are processed as follows:\n        - Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n        - Query = 19: None of the intervals contain 19. The answer is -1.\n        - Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n        - Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1458,"row":{"number":1850,"difficulty":1,"question":"class Solution:\n    def getMinSwaps(self, num: str, k: int) -> int:\n        \"\"\"\n        You are given a string num, representing a large integer, and an integer k.\n        We call some integer wonderful if it is a permutation of the digits in num and is greater in value than num. There can be many wonderful integers. However, we only care about the smallest-valued ones.\n            For example, when num = \"5489355142\":\n                The 1st smallest wonderful integer is \"5489355214\".\n                The 2nd smallest wonderful integer is \"5489355241\".\n                The 3rd smallest wonderful integer is \"5489355412\".\n                The 4th smallest wonderful integer is \"5489355421\".\n        Return the minimum number of adjacent digit swaps that needs to be applied to num to reach the kth smallest wonderful integer.\n        The tests are generated in such a way that kth smallest wonderful integer exists.\n        Example 1:\n        Input: num = \"5489355142\", k = 4\n        Output: 2\n        Explanation: The 4th smallest wonderful number is \"5489355421\". To get this number:\n        - Swap index 7 with index 8: \"5489355142\" -> \"5489355412\"\n        - Swap index 8 with index 9: \"5489355412\" -> \"5489355421\"\n        Example 2:\n        Input: num = \"11112\", k = 4\n        Output: 4\n        Explanation: The 4th smallest wonderful number is \"21111\". To get this number:\n        - Swap index 3 with index 4: \"11112\" -> \"11121\"\n        - Swap index 2 with index 3: \"11121\" -> \"11211\"\n        - Swap index 1 with index 2: \"11211\" -> \"12111\"\n        - Swap index 0 with index 1: \"12111\" -> \"21111\"\n        Example 3:\n        Input: num = \"00123\", k = 1\n        Output: 1\n        Explanation: The 1st smallest wonderful number is \"00132\". To get this number:\n        - Swap index 3 with index 4: \"00123\" -> \"00132\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1459,"row":{"number":1854,"difficulty":0,"question":"class Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person.\n        The population of some year x is the number of people alive during that year. The ith person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die.\n        Return the earliest year with the maximum population.\n        Example 1:\n        Input: logs = [[1993,1999],[2000,2010]]\n        Output: 1993\n        Explanation: The maximum population is 1, and 1993 is the earliest year with this population.\n        Example 2:\n        Input: logs = [[1950,1961],[1960,1971],[1970,1981]]\n        Output: 1960\n        Explanation: \n        The maximum population is 2, and it had happened in years 1960 and 1970.\n        The earlier year between them is 1960.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1460,"row":{"number":1855,"difficulty":1,"question":"class Solution:\n    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two non-increasing 0-indexed integer arrays nums1​​​​​​ and nums2​​​​​​.\n        A pair of indices (i, j), where 0 <= i < nums1.length and 0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j]. The distance of the pair is j - i​​​​.\n        Return the maximum distance of any valid pair (i, j). If there are no valid pairs, return 0.\n        An array arr is non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.\n        Example 1:\n        Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]\n        Output: 2\n        Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).\n        The maximum distance is 2 with pair (2,4).\n        Example 2:\n        Input: nums1 = [2,2,2], nums2 = [10,10,1]\n        Output: 1\n        Explanation: The valid pairs are (0,0), (0,1), and (1,1).\n        The maximum distance is 1 with pair (0,1).\n        Example 3:\n        Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]\n        Output: 2\n        Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).\n        The maximum distance is 2 with pair (2,4).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1461,"row":{"number":1856,"difficulty":1,"question":"class Solution:\n    def maxSumMinProduct(self, nums: List[int]) -> int:\n        \"\"\"\n        The min-product of an array is equal to the minimum value in the array multiplied by the array's sum.\n            For example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20.\n        Given an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 109 + 7.\n        Note that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.\n        A subarray is a contiguous part of an array.\n        Example 1:\n        Input: nums = [1,2,3,2]\n        Output: 14\n        Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).\n        2 * (2+3+2) = 2 * 7 = 14.\n        Example 2:\n        Input: nums = [2,3,3,1,2]\n        Output: 18\n        Explanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).\n        3 * (3+3) = 3 * 6 = 18.\n        Example 3:\n        Input: nums = [3,1,5,6,4,2]\n        Output: 60\n        Explanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).\n        4 * (5+6+4) = 4 * 15 = 60.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1462,"row":{"number":1857,"difficulty":2,"question":"class Solution:\r\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        \"\"\"\n        There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1.\r\n        You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj.\r\n        A valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path.\r\n        Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.\r\n        Example 1:\r\n        Input: colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\r\n        Output: 3\r\n        Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image).\r\n        Example 2:\r\n        Input: colors = \"a\", edges = [[0,0]]\r\n        Output: -1\r\n        Explanation: There is a cycle from 0 to 0.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1463,"row":{"number":1876,"difficulty":0,"question":"class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        \"\"\"\n        A string is good if there are no repeated characters.\n        Given a string s​​​​​, return the number of good substrings of length three in s​​​​​​.\n        Note that if there are multiple occurrences of the same substring, every occurrence should be counted.\n        A substring is a contiguous sequence of characters in a string.\n        Example 1:\n        Input: s = \"xyzzaz\"\n        Output: 1\n        Explanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \n        The only good substring of length 3 is \"xyz\".\n        Example 2:\n        Input: s = \"aababcabc\"\n        Output: 4\n        Explanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\n        The good substrings are \"abc\", \"bca\", \"cab\", and \"abc\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1464,"row":{"number":1877,"difficulty":1,"question":"class Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        \"\"\"\n        The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\r\n            For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.\r\n        Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:\r\n            Each element of nums is in exactly one pair, and\r\n            The maximum pair sum is minimized.\r\n        Return the minimized maximum pair sum after optimally pairing up the elements.\r\n        Example 1:\r\n        Input: nums = [3,5,2,3]\r\n        Output: 7\r\n        Explanation: The elements can be paired up into pairs (3,3) and (5,2).\r\n        The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\r\n        Example 2:\r\n        Input: nums = [3,5,4,2,4,6]\r\n        Output: 8\r\n        Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\n        The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1465,"row":{"number":1879,"difficulty":2,"question":"class Solution:\n    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two integer arrays nums1 and nums2 of length n.\n        The XOR sum of the two integer arrays is (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed).\n            For example, the XOR sum of [1,2,3] and [3,2,1] is equal to (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4.\n        Rearrange the elements of nums2 such that the resulting XOR sum is minimized.\n        Return the XOR sum after the rearrangement.\n        Example 1:\n        Input: nums1 = [1,2], nums2 = [2,3]\n        Output: 2\n        Explanation: Rearrange nums2 so that it becomes [3,2].\n        The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.\n        Example 2:\n        Input: nums1 = [1,0,3], nums2 = [5,3,4]\n        Output: 8\n        Explanation: Rearrange nums2 so that it becomes [5,4,3]. \n        The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1466,"row":{"number":1878,"difficulty":1,"question":"class Solution:\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an m x n integer matrix grid​​​.\n        A rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid​​​. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each rhombus sum:\n        Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.\n        Return the biggest three distinct rhombus sums in the grid in descending order. If there are less than three distinct values, return all of them.\n        Example 1:\n        Input: grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]\n        Output: [228,216,211]\n        Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n        - Blue: 20 + 3 + 200 + 5 = 228\n        - Red: 200 + 2 + 10 + 4 = 216\n        - Green: 5 + 200 + 4 + 2 = 211\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [20,9,8]\n        Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n        - Blue: 4 + 2 + 6 + 8 = 20\n        - Red: 9 (area 0 rhombus in the bottom right corner)\n        - Green: 8 (area 0 rhombus in the bottom middle)\n        Example 3:\n        Input: grid = [[7,7,7]]\n        Output: [7]\n        Explanation: All three possible rhombus sums are the same, so return [7].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1467,"row":{"number":1863,"difficulty":0,"question":"class Solution:\n    def subsetXORSum(self, nums: List[int]) -> int:\n        \"\"\"\n        The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.\n            For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.\n        Given an array nums, return the sum of all XOR totals for every subset of nums. \n        Note: Subsets with the same elements should be counted multiple times.\n        An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.\n        Example 1:\n        Input: nums = [1,3]\n        Output: 6\n        Explanation: The 4 subsets of [1,3] are:\n        - The empty subset has an XOR total of 0.\n        - [1] has an XOR total of 1.\n        - [3] has an XOR total of 3.\n        - [1,3] has an XOR total of 1 XOR 3 = 2.\n        0 + 1 + 3 + 2 = 6\n        Example 2:\n        Input: nums = [5,1,6]\n        Output: 28\n        Explanation: The 8 subsets of [5,1,6] are:\n        - The empty subset has an XOR total of 0.\n        - [5] has an XOR total of 5.\n        - [1] has an XOR total of 1.\n        - [6] has an XOR total of 6.\n        - [5,1] has an XOR total of 5 XOR 1 = 4.\n        - [5,6] has an XOR total of 5 XOR 6 = 3.\n        - [1,6] has an XOR total of 1 XOR 6 = 7.\n        - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\n        0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n        Example 3:\n        Input: nums = [3,4,5,6,7,8]\n        Output: 480\n        Explanation: The sum of all XOR totals for every subset is 480.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1468,"row":{"number":1864,"difficulty":1,"question":"class Solution:\n    def minSwaps(self, s: str) -> int:\n        \"\"\"\n        Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible.\n        The string is called alternating if no two adjacent characters are equal. For example, the strings \"010\" and \"1010\" are alternating, while the string \"0100\" is not.\n        Any two characters may be swapped, even if they are not adjacent.\n        Example 1:\n        Input: s = \"111000\"\n        Output: 1\n        Explanation: Swap positions 1 and 4: \"111000\" -> \"101010\"\n        The string is now alternating.\n        Example 2:\n        Input: s = \"010\"\n        Output: 0\n        Explanation: The string is already alternating, no swaps are needed.\n        Example 3:\n        Input: s = \"1110\"\n        Output: -1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1469,"row":{"number":1865,"difficulty":1,"question":"class FindSumPairs:\n    def __init__(self, nums1: List[int], nums2: List[int]):\n    def add(self, index: int, val: int) -> None:\n    def count(self, tot: int) -> int:\n        \"\"\"\n        You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types:\n            Add a positive integer to an element of a given index in the array nums2.\n            Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 <= i < nums1.length and 0 <= j < nums2.length).\n        Implement the FindSumPairs class:\n            FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object with two integer arrays nums1 and nums2.\n            void add(int index, int val) Adds val to nums2[index], i.e., apply nums2[index] += val.\n            int count(int tot) Returns the number of pairs (i, j) such that nums1[i] + nums2[j] == tot.\n        Example 1:\n        Input\n        [\"FindSumPairs\", \"count\", \"add\", \"count\", \"count\", \"add\", \"add\", \"count\"]\n        [[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]\n        Output\n        [null, 8, null, 2, 1, null, null, 11]\n        Explanation\n        FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);\n        findSumPairs.count(7);  // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4\n        findSumPairs.add(3, 2); // now nums2 = [1,4,5,4,5,4]\n        findSumPairs.count(8);  // return 2; pairs (5,2), (5,4) make 3 + 5\n        findSumPairs.count(4);  // return 1; pair (5,0) makes 3 + 1\n        findSumPairs.add(0, 1); // now nums2 = [2,4,5,4,5,4]\n        findSumPairs.add(1, 1); // now nums2 = [2,5,5,4,5,4]\n        findSumPairs.count(7);  // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1470,"row":{"number":1866,"difficulty":2,"question":"class Solution:\n    def rearrangeSticks(self, n: int, k: int) -> int:\n        \"\"\"\n        There are n uniquely-sized sticks whose lengths are integers from 1 to n. You want to arrange the sticks such that exactly k sticks are visible from the left. A stick is visible from the left if there are no longer sticks to the left of it.\n            For example, if the sticks are arranged [1,3,2,5,4], then the sticks with lengths 1, 3, and 5 are visible from the left.\n        Given n and k, return the number of such arrangements. Since the answer may be large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 3, k = 2\n        Output: 3\n        Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible.\n        The visible sticks are underlined.\n        Example 2:\n        Input: n = 5, k = 5\n        Output: 1\n        Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible.\n        The visible sticks are underlined.\n        Example 3:\n        Input: n = 20, k = 11\n        Output: 647427950\n        Explanation: There are 647427950 (mod 109 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1471,"row":{"number":1869,"difficulty":0,"question":"class Solution:\n    def checkZeroOnes(self, s: str) -> bool:\n        \"\"\"\n        Given a binary string s, return true if the longest contiguous segment of 1's is strictly longer than the longest contiguous segment of 0's in s, or return false otherwise.\n            For example, in s = \"110100010\" the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3.\n        Note that if there are no 0's, then the longest continuous segment of 0's is considered to have a length 0. The same applies if there is no 1's.\n        Example 1:\n        Input: s = \"1101\"\n        Output: true\n        Explanation:\n        The longest contiguous segment of 1s has length 2: \"1101\"\n        The longest contiguous segment of 0s has length 1: \"1101\"\n        The segment of 1s is longer, so return true.\n        Example 2:\n        Input: s = \"111000\"\n        Output: false\n        Explanation:\n        The longest contiguous segment of 1s has length 3: \"111000\"\n        The longest contiguous segment of 0s has length 3: \"111000\"\n        The segment of 1s is not longer, so return false.\n        Example 3:\n        Input: s = \"110100010\"\n        Output: false\n        Explanation:\n        The longest contiguous segment of 1s has length 2: \"110100010\"\n        The longest contiguous segment of 0s has length 3: \"110100010\"\n        The segment of 1s is not longer, so return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1472,"row":{"number":1870,"difficulty":1,"question":"class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        \"\"\"\n        You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\n        Each train can only depart at an integer hour, so you may need to wait in between each train ride.\n            For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n        Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\n        Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.\n        Example 1:\n        Input: dist = [1,3,2], hour = 6\n        Output: 1\n        Explanation: At speed 1:\n        - The first train ride takes 1/1 = 1 hour.\n        - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n        - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n        - You will arrive at exactly the 6 hour mark.\n        Example 2:\n        Input: dist = [1,3,2], hour = 2.7\n        Output: 3\n        Explanation: At speed 3:\n        - The first train ride takes 1/3 = 0.33333 hours.\n        - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n        - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n        - You will arrive at the 2.66667 hour mark.\n        Example 3:\n        Input: dist = [1,3,2], hour = 1.9\n        Output: -1\n        Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1473,"row":{"number":1871,"difficulty":1,"question":"class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        \"\"\"\n        You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. You can move from index i to index j if the following conditions are fulfilled:\n            i + minJump <= j <= min(i + maxJump, s.length - 1), and\n            s[j] == '0'.\n        Return true if you can reach index s.length - 1 in s, or false otherwise.\n        Example 1:\n        Input: s = \"011010\", minJump = 2, maxJump = 3\n        Output: true\n        Explanation:\n        In the first step, move from index 0 to index 3. \n        In the second step, move from index 3 to index 5.\n        Example 2:\n        Input: s = \"01101110\", minJump = 2, maxJump = 3\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1474,"row":{"number":1872,"difficulty":2,"question":"class Solution:\n    def stoneGameVIII(self, stones: List[int]) -> int:\n        \"\"\"\n        Alice and Bob take turns playing a game, with Alice starting first.\r\n        There are n stones arranged in a row. On each player's turn, while the number of stones is more than one, they will do the following:\r\n            Choose an integer x > 1, and remove the leftmost x stones from the row.\r\n            Add the sum of the removed stones' values to the player's score.\r\n            Place a new stone, whose value is equal to that sum, on the left side of the row.\r\n        The game stops when only one stone is left in the row.\r\n        The score difference between Alice and Bob is (Alice's score - Bob's score). Alice's goal is to maximize the score difference, and Bob's goal is the minimize the score difference.\r\n        Given an integer array stones of length n where stones[i] represents the value of the ith stone from the left, return the score difference between Alice and Bob if they both play optimally.\r\n        Example 1:\r\n        Input: stones = [-1,2,-3,4,-5]\r\n        Output: 5\r\n        Explanation:\r\n        - Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of\r\n          value 2 on the left. stones = [2,-5].\r\n        - Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on\r\n          the left. stones = [-3].\r\n        The difference between their scores is 2 - (-3) = 5.\r\n        Example 2:\r\n        Input: stones = [7,-6,5,10,5,-2,-6]\r\n        Output: 13\r\n        Explanation:\r\n        - Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a\r\n          stone of value 13 on the left. stones = [13].\r\n        The difference between their scores is 13 - 0 = 13.\r\n        Example 3:\r\n        Input: stones = [-10,-12]\r\n        Output: -22\r\n        Explanation:\r\n        - Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her\r\n          score and places a stone of value -22 on the left. stones = [-22].\r\n        The difference between their scores is (-22) - 0 = -22.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1475,"row":{"number":1893,"difficulty":0,"question":"class Solution:\n    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:\n        \"\"\"\n        You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.\n        Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.\n        An integer x is covered by an interval ranges[i] = [starti, endi] if starti <= x <= endi.\n        Example 1:\n        Input: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n        Output: true\n        Explanation: Every integer between 2 and 5 is covered:\n        - 2 is covered by the first range.\n        - 3 and 4 are covered by the second range.\n        - 5 is covered by the third range.\n        Example 2:\n        Input: ranges = [[1,10],[10,20]], left = 21, right = 21\n        Output: false\n        Explanation: 21 is not covered by any range.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1476,"row":{"number":1894,"difficulty":1,"question":"class Solution:\n    def chalkReplacer(self, chalk: List[int], k: int) -> int:\n        \"\"\"\n        There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.\n        You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.\n        Return the index of the student that will replace the chalk pieces.\n        Example 1:\n        Input: chalk = [5,1,5], k = 22\n        Output: 0\n        Explanation: The students go in turns as follows:\n        - Student number 0 uses 5 chalk, so k = 17.\n        - Student number 1 uses 1 chalk, so k = 16.\n        - Student number 2 uses 5 chalk, so k = 11.\n        - Student number 0 uses 5 chalk, so k = 6.\n        - Student number 1 uses 1 chalk, so k = 5.\n        - Student number 2 uses 5 chalk, so k = 0.\n        Student number 0 does not have enough chalk, so they will have to replace it.\n        Example 2:\n        Input: chalk = [3,4,1,2], k = 25\n        Output: 1\n        Explanation: The students go in turns as follows:\n        - Student number 0 uses 3 chalk so k = 22.\n        - Student number 1 uses 4 chalk so k = 18.\n        - Student number 2 uses 1 chalk so k = 17.\n        - Student number 3 uses 2 chalk so k = 15.\n        - Student number 0 uses 3 chalk so k = 12.\n        - Student number 1 uses 4 chalk so k = 8.\n        - Student number 2 uses 1 chalk so k = 7.\n        - Student number 3 uses 2 chalk so k = 5.\n        - Student number 0 uses 3 chalk so k = 2.\n        Student number 1 does not have enough chalk, so they will have to replace it.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1477,"row":{"number":1896,"difficulty":2,"question":"class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n        \"\"\"\n        You are given a valid boolean expression as a string expression consisting of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR operator),'(', and ')'.\n            For example, \"()1|1\" and \"(1)&()\" are not valid while \"1\", \"(((1))|(0))\", and \"1|(0&(1))\" are valid expressions.\n        Return the minimum cost to change the final value of the expression.\n            For example, if expression = \"1|1|(0&0)&1\", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1. We want to apply operations so that the new expression evaluates to 0.\n        The cost of changing the final value of an expression is the number of operations performed on the expression. The types of operations are described as follows:\n            Turn a '1' into a '0'.\n            Turn a '0' into a '1'.\n            Turn a '&' into a '|'.\n            Turn a '|' into a '&'.\n        Note: '&' does not take precedence over '|' in the order of calculation. Evaluate parentheses first, then in left-to-right order.\n        Example 1:\n        Input: expression = \"1&(0|1)\"\n        Output: 1\n        Explanation: We can turn \"1&(0|1)\" into \"1&(0&1)\" by changing the '|' to a '&' using 1 operation.\n        The new expression evaluates to 0. \n        Example 2:\n        Input: expression = \"(0&0)&(0&0&0)\"\n        Output: 3\n        Explanation: We can turn \"(0&0)&(0&0&0)\" into \"(0|1)|(0&0&0)\" using 3 operations.\n        The new expression evaluates to 1.\n        Example 3:\n        Input: expression = \"(0|(1|0&1))\"\n        Output: 1\n        Explanation: We can turn \"(0|(1|0&1))\" into \"(0|(0|0&1))\" using 1 operation.\n        The new expression evaluates to 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1478,"row":{"number":1880,"difficulty":0,"question":"class Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        \"\"\"\n        The letter value of a letter is its position in the alphabet starting from 0 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, etc.).\n        The numerical value of some string of lowercase English letters s is the concatenation of the letter values of each letter in s, which is then converted into an integer.\n            For example, if s = \"acb\", we concatenate each letter's letter value, resulting in \"021\". After converting it, we get 21.\n        You are given three strings firstWord, secondWord, and targetWord, each consisting of lowercase English letters 'a' through 'j' inclusive.\n        Return true if the summation of the numerical values of firstWord and secondWord equals the numerical value of targetWord, or false otherwise.\n        Example 1:\n        Input: firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"\n        Output: true\n        Explanation:\n        The numerical value of firstWord is \"acb\" -> \"021\" -> 21.\n        The numerical value of secondWord is \"cba\" -> \"210\" -> 210.\n        The numerical value of targetWord is \"cdb\" -> \"231\" -> 231.\n        We return true because 21 + 210 == 231.\n        Example 2:\n        Input: firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"\n        Output: false\n        Explanation: \n        The numerical value of firstWord is \"aaa\" -> \"000\" -> 0.\n        The numerical value of secondWord is \"a\" -> \"0\" -> 0.\n        The numerical value of targetWord is \"aab\" -> \"001\" -> 1.\n        We return false because 0 + 0 != 1.\n        Example 3:\n        Input: firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"\n        Output: true\n        Explanation: \n        The numerical value of firstWord is \"aaa\" -> \"000\" -> 0.\n        The numerical value of secondWord is \"a\" -> \"0\" -> 0.\n        The numerical value of targetWord is \"aaaa\" -> \"0000\" -> 0.\n        We return true because 0 + 0 == 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1479,"row":{"number":1881,"difficulty":1,"question":"class Solution:\n    def maxValue(self, n: str, x: int) -> str:\n        \"\"\"\n        You are given a very large integer n, represented as a string,​​​​​​ and an integer digit x. The digits in n and the digit x are in the inclusive range [1, 9], and n may represent a negative number.\n        You want to maximize n's numerical value by inserting x anywhere in the decimal representation of n​​​​​​. You cannot insert x to the left of the negative sign.\n            For example, if n = 73 and x = 6, it would be best to insert it between 7 and 3, making n = 763.\n            If n = -55 and x = 2, it would be best to insert it before the first 5, making n = -255.\n        Return a string representing the maximum value of n​​​​​​ after the insertion.\n        Example 1:\n        Input: n = \"99\", x = 9\n        Output: \"999\"\n        Explanation: The result is the same regardless of where you insert 9.\n        Example 2:\n        Input: n = \"-13\", x = 2\n        Output: \"-123\"\n        Explanation: You can make n one of {-213, -123, -132}, and the largest of those three is -123.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1480,"row":{"number":1882,"difficulty":1,"question":"class Solution:\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\n        \"\"\"\n        You are given two 0-indexed integer arrays servers and tasks of lengths n​​​​​​ and m​​​​​​ respectively. servers[i] is the weight of the i​​​​​​th​​​​ server, and tasks[j] is the time needed to process the j​​​​​​th​​​​ task in seconds.\n        Tasks are assigned to the servers using a task queue. Initially, all servers are free, and the queue is empty.\n        At second j, the jth task is inserted into the queue (starting with the 0th task being inserted at second 0). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the smallest weight, and in case of a tie, it is assigned to a free server with the smallest index.\n        If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\n        A server that is assigned task j at second t will be free again at second t + tasks[j].\n        Build an array ans​​​​ of length m, where ans[j] is the index of the server the j​​​​​​th task will be assigned to.\n        Return the array ans​​​​.\n        Example 1:\n        Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]\n        Output: [2,2,0,2,1,2]\n        Explanation: Events in chronological order go as follows:\n        - At second 0, task 0 is added and processed using server 2 until second 1.\n        - At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.\n        - At second 2, task 2 is added and processed using server 0 until second 5.\n        - At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.\n        - At second 4, task 4 is added and processed using server 1 until second 5.\n        - At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.\n        Example 2:\n        Input: servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]\n        Output: [1,4,1,4,1,3,2]\n        Explanation: Events in chronological order go as follows: \n        - At second 0, task 0 is added and processed using server 1 until second 2.\n        - At second 1, task 1 is added and processed using server 4 until second 2.\n        - At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. \n        - At second 3, task 3 is added and processed using server 4 until second 7.\n        - At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. \n        - At second 5, task 5 is added and processed using server 3 until second 7.\n        - At second 6, task 6 is added and processed using server 2 until second 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1481,"row":{"number":1883,"difficulty":2,"question":"class Solution:\n    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:\n        \"\"\"\n        You are given an integer hoursBefore, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through n roads. The road lengths are given as an integer array dist of length n, where dist[i] describes the length of the ith road in kilometers. In addition, you are given an integer speed, which is the speed (in km/h) you will travel at.\n        After you travel road i, you must rest and wait for the next integer hour before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting.\n            For example, if traveling a road takes 1.4 hours, you must wait until the 2 hour mark before traveling the next road. If traveling a road takes exactly 2 hours, you do not need to wait.\n        However, you are allowed to skip some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks.\n            For example, suppose traveling the first road takes 1.4 hours and traveling the second road takes 0.6 hours. Skipping the rest after the first road will mean you finish traveling the second road right at the 2 hour mark, letting you start traveling the third road immediately.\n        Return the minimum number of skips required to arrive at the meeting on time, or -1 if it is impossible.\n        Example 1:\n        Input: dist = [1,3,2], speed = 4, hoursBefore = 2\n        Output: 1\n        Explanation:\n        Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.\n        You can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.\n        Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.\n        Example 2:\n        Input: dist = [7,3,5,5], speed = 2, hoursBefore = 10\n        Output: 2\n        Explanation:\n        Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.\n        You can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.\n        Example 3:\n        Input: dist = [7,3,5,5], speed = 1, hoursBefore = 10\n        Output: -1\n        Explanation: It is impossible to arrive at the meeting on time even if you skip all the rests.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1482,"row":{"number":1886,"difficulty":0,"question":"class Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        \"\"\"\n        Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.\n        Example 1:\n        Input: mat = [[0,1],[1,0]], target = [[1,0],[0,1]]\n        Output: true\n        Explanation: We can rotate mat 90 degrees clockwise to make mat equal target.\n        Example 2:\n        Input: mat = [[0,1],[1,1]], target = [[1,0],[0,1]]\n        Output: false\n        Explanation: It is impossible to make mat equal to target by rotating mat.\n        Example 3:\n        Input: mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]\n        Output: true\n        Explanation: We can rotate mat 90 degrees clockwise two times to make mat equal target.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1483,"row":{"number":1887,"difficulty":1,"question":"class Solution:\n    def reductionOperations(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:\n            Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.\n            Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.\n            Reduce nums[i] to nextLargest.\n        Return the number of operations to make all elements in nums equal.\n        Example 1:\n        Input: nums = [5,1,3]\n        Output: 3\n        Explanation: It takes 3 operations to make all elements in nums equal:\n        1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].\n        2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].\n        3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].\n        Example 2:\n        Input: nums = [1,1,1]\n        Output: 0\n        Explanation: All elements in nums are already equal.\n        Example 3:\n        Input: nums = [1,1,2,2,3]\n        Output: 4\n        Explanation: It takes 4 operations to make all elements in nums equal:\n        1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].\n        2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].\n        3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].\n        4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1484,"row":{"number":1888,"difficulty":1,"question":"class Solution:\n    def minFlips(self, s: str) -> int:\n        \"\"\"\n        You are given a binary string s. You are allowed to perform two types of operations on the string in any sequence:\n            Type-1: Remove the character at the start of the string s and append it to the end of the string.\n            Type-2: Pick any character in s and flip its value, i.e., if its value is '0' it becomes '1' and vice-versa.\n        Return the minimum number of type-2 operations you need to perform such that s becomes alternating.\n        The string is called alternating if no two adjacent characters are equal.\n            For example, the strings \"010\" and \"1010\" are alternating, while the string \"0100\" is not.\n        Example 1:\n        Input: s = \"111000\"\n        Output: 2\n        Explanation: Use the first operation two times to make s = \"100011\".\n        Then, use the second operation on the third and sixth elements to make s = \"101010\".\n        Example 2:\n        Input: s = \"010\"\n        Output: 0\n        Explanation: The string is already alternating.\n        Example 3:\n        Input: s = \"1110\"\n        Output: 1\n        Explanation: Use the second operation on the second element to make s = \"1010\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1485,"row":{"number":1889,"difficulty":2,"question":"class Solution:\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\n        \"\"\"\n        You have n packages that you are trying to place in boxes, one package in each box. There are m suppliers that each produce boxes of different sizes (with infinite supply). A package can be placed in a box if the size of the package is less than or equal to the size of the box.\n        The package sizes are given as an integer array packages, where packages[i] is the size of the ith package. The suppliers are given as a 2D integer array boxes, where boxes[j] is an array of box sizes that the jth supplier produces.\n        You want to choose a single supplier and use boxes from them such that the total wasted space is minimized. For each package in a box, we define the space wasted to be size of the box - size of the package. The total wasted space is the sum of the space wasted in all the boxes.\n            For example, if you have to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes [4,8], you can fit the packages of size-2 and size-3 into two boxes of size-4 and the package with size-5 into a box of size-8. This would result in a waste of (4-2) + (4-3) + (8-5) = 6.\n        Return the minimum total wasted space by choosing the box supplier optimally, or -1 if it is impossible to fit all the packages inside boxes. Since the answer may be large, return it modulo 109 + 7.\n        Example 1:\n        Input: packages = [2,3,5], boxes = [[4,8],[2,8]]\n        Output: 6\n        Explanation: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.\n        The total waste is (4-2) + (4-3) + (8-5) = 6.\n        Example 2:\n        Input: packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]\n        Output: -1\n        Explanation: There is no box that the package of size 5 can fit in.\n        Example 3:\n        Input: packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]\n        Output: 9\n        Explanation: It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.\n        The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1486,"row":{"number":1909,"difficulty":0,"question":"class Solution:\n    def canBeIncreasing(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true.\n        The array nums is strictly increasing if nums[i - 1] < nums[i] for each index (1 <= i < nums.length).\n        Example 1:\n        Input: nums = [1,2,10,5,7]\n        Output: true\n        Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].\n        [1,2,5,7] is strictly increasing, so return true.\n        Example 2:\n        Input: nums = [2,3,1,2]\n        Output: false\n        Explanation:\n        [3,1,2] is the result of removing the element at index 0.\n        [2,1,2] is the result of removing the element at index 1.\n        [2,3,2] is the result of removing the element at index 2.\n        [2,3,1] is the result of removing the element at index 3.\n        No resulting array is strictly increasing, so return false.\n        Example 3:\n        Input: nums = [1,1,1]\n        Output: false\n        Explanation: The result of removing any element is [1,1].\n        [1,1] is not strictly increasing, so return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1487,"row":{"number":1910,"difficulty":1,"question":"class Solution:\n    def removeOccurrences(self, s: str, part: str) -> str:\n        \"\"\"\n        Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:\n            Find the leftmost occurrence of the substring part and remove it from s.\n        Return s after removing all occurrences of part.\n        A substring is a contiguous sequence of characters in a string.\n        Example 1:\n        Input: s = \"daabcbaabcbc\", part = \"abc\"\n        Output: \"dab\"\n        Explanation: The following operations are done:\n        - s = \"daabcbaabcbc\", remove \"abc\" starting at index 2, so s = \"dabaabcbc\".\n        - s = \"dabaabcbc\", remove \"abc\" starting at index 4, so s = \"dababc\".\n        - s = \"dababc\", remove \"abc\" starting at index 3, so s = \"dab\".\n        Now s has no occurrences of \"abc\".\n        Example 2:\n        Input: s = \"axxxxyyyyb\", part = \"xy\"\n        Output: \"ab\"\n        Explanation: The following operations are done:\n        - s = \"axxxxyyyyb\", remove \"xy\" starting at index 4 so s = \"axxxyyyb\".\n        - s = \"axxxyyyb\", remove \"xy\" starting at index 3 so s = \"axxyyb\".\n        - s = \"axxyyb\", remove \"xy\" starting at index 2 so s = \"axyb\".\n        - s = \"axyb\", remove \"xy\" starting at index 1 so s = \"ab\".\n        Now s has no occurrences of \"xy\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1488,"row":{"number":1911,"difficulty":1,"question":"class Solution:\r\n    def maxAlternatingSum(self, nums: List[int]) -> int:\n        \"\"\"\n        The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.\r\n            For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4.\r\n        Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence).\r\n        A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\r\n        Example 1:\r\n        Input: nums = [4,2,5,3]\r\n        Output: 7\r\n        Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.\r\n        Example 2:\r\n        Input: nums = [5,6,7,8]\r\n        Output: 8\r\n        Explanation: It is optimal to choose the subsequence [8] with alternating sum 8.\r\n        Example 3:\r\n        Input: nums = [6,2,1,2,4,5]\r\n        Output: 10\r\n        Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1489,"row":{"number":1912,"difficulty":2,"question":"class MovieRentingSystem:\n    def __init__(self, n: int, entries: List[List[int]]):\n    def search(self, movie: int) -> List[int]:\n    def rent(self, shop: int, movie: int) -> None:\n    def drop(self, shop: int, movie: int) -> None:\n    def report(self) -> List[List[int]]:\n        \"\"\"\n        You have a movie renting company consisting of n shops. You want to implement a renting system that supports searching for, booking, and returning movies. The system should also support generating a report of the currently rented movies.\n        Each movie is given as a 2D integer array entries where entries[i] = [shopi, moviei, pricei] indicates that there is a copy of movie moviei at shop shopi with a rental price of pricei. Each shop carries at most one copy of a movie moviei.\n        The system should support the following functions:\n            Search: Finds the cheapest 5 shops that have an unrented copy of a given movie. The shops should be sorted by price in ascending order, and in case of a tie, the one with the smaller shopi should appear first. If there are less than 5 matching shops, then all of them should be returned. If no shop has an unrented copy, then an empty list should be returned.\n            Rent: Rents an unrented copy of a given movie from a given shop.\n            Drop: Drops off a previously rented copy of a given movie at a given shop.\n            Report: Returns the cheapest 5 rented movies (possibly of the same movie ID) as a 2D list res where res[j] = [shopj, moviej] describes that the jth cheapest rented movie moviej was rented from the shop shopj. The movies in res should be sorted by price in ascending order, and in case of a tie, the one with the smaller shopj should appear first, and if there is still tie, the one with the smaller moviej should appear first. If there are fewer than 5 rented movies, then all of them should be returned. If no movies are currently being rented, then an empty list should be returned.\n        Implement the MovieRentingSystem class:\n            MovieRentingSystem(int n, int[][] entries) Initializes the MovieRentingSystem object with n shops and the movies in entries.\n            List<Integer> search(int movie) Returns a list of shops that have an unrented copy of the given movie as described above.\n            void rent(int shop, int movie) Rents the given movie from the given shop.\n            void drop(int shop, int movie) Drops off a previously rented movie at the given shop.\n            List<List<Integer>> report() Returns a list of cheapest rented movies as described above.\n        Note: The test cases will be generated such that rent will only be called if the shop has an unrented copy of the movie, and drop will only be called if the shop had previously rented out the movie.\n        Example 1:\n        Input\n        [\"MovieRentingSystem\", \"search\", \"rent\", \"rent\", \"report\", \"drop\", \"search\"]\n        [[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]\n        Output\n        [null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]\n        Explanation\n        MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);\n        movieRentingSystem.search(1);  // return [1, 0, 2], Movies of ID 1 are unrented at shops 1, 0, and 2. Shop 1 is cheapest; shop 0 and 2 are the same price, so order by shop number.\n        movieRentingSystem.rent(0, 1); // Rent movie 1 from shop 0. Unrented movies at shop 0 are now [2,3].\n        movieRentingSystem.rent(1, 2); // Rent movie 2 from shop 1. Unrented movies at shop 1 are now [1].\n        movieRentingSystem.report();   // return [[0, 1], [1, 2]]. Movie 1 from shop 0 is cheapest, followed by movie 2 from shop 1.\n        movieRentingSystem.drop(1, 2); // Drop off movie 2 at shop 1. Unrented movies at shop 1 are now [1,2].\n        movieRentingSystem.search(2);  // return [0, 1]. Movies of ID 2 are unrented at shops 0 and 1. Shop 0 is cheapest, followed by shop 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1490,"row":{"number":1897,"difficulty":0,"question":"class Solution:\n    def makeEqual(self, words: List[str]) -> bool:\n        \"\"\"\n        You are given an array of strings words (0-indexed).\n        In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].\n        Return true if you can make every string in words equal using any number of operations, and false otherwise.\n        Example 1:\n        Input: words = [\"abc\",\"aabc\",\"bc\"]\n        Output: true\n        Explanation: Move the first 'a' in words[1] to the front of words[2],\n        to make words[1] = \"abc\" and words[2] = \"abc\".\n        All the strings are now equal to \"abc\", so return true.\n        Example 2:\n        Input: words = [\"ab\",\"a\"]\n        Output: false\n        Explanation: It is impossible to make all the strings equal using the operation.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1491,"row":{"number":1899,"difficulty":1,"question":"class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        \"\"\"\n        A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.\n        To obtain target, you may apply the following operation on triplets any number of times (possibly zero):\n            Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].\n                For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].\n        Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.\n        Example 1:\n        Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]\n        Output: true\n        Explanation: Perform the following operations:\n        - Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],[2,7,5]]\n        The target triplet [2,7,5] is now an element of triplets.\n        Example 2:\n        Input: triplets = [[3,4,5],[4,5,6]], target = [3,2,5]\n        Output: false\n        Explanation: It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets.\n        Example 3:\n        Input: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]\n        Output: true\n        Explanation: Perform the following operations:\n        - Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].\n        - Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]].\n        The target triplet [5,5,5] is now an element of triplets.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1492,"row":{"number":1898,"difficulty":1,"question":"class Solution:\n    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\n        \"\"\"\n        You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).\n        You want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.\n        Return the maximum k you can choose such that p is still a subsequence of s after the removals.\n        A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n        Example 1:\n        Input: s = \"abcacb\", p = \"ab\", removable = [3,1,0]\n        Output: 2\n        Explanation: After removing the characters at indices 3 and 1, \"abcacb\" becomes \"accb\".\n        \"ab\" is a subsequence of \"accb\".\n        If we remove the characters at indices 3, 1, and 0, \"abcacb\" becomes \"ccb\", and \"ab\" is no longer a subsequence.\n        Hence, the maximum k is 2.\n        Example 2:\n        Input: s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]\n        Output: 1\n        Explanation: After removing the character at index 3, \"abcbddddd\" becomes \"abcddddd\".\n        \"abcd\" is a subsequence of \"abcddddd\".\n        Example 3:\n        Input: s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]\n        Output: 0\n        Explanation: If you remove the first index in the array removable, \"abc\" is no longer a subsequence.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1493,"row":{"number":1900,"difficulty":2,"question":"class Solution:\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\n        \"\"\"\n        There is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position (player 1 is the first player in the row, player 2 is the second player in the row, etc.).\n        The tournament consists of multiple rounds (starting from round number 1). In each round, the ith player from the front of the row competes against the ith player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n            For example, if the row consists of players 1, 2, 4, 6, 7\n                Player 1 competes against player 7.\n                Player 2 competes against player 6.\n                Player 4 automatically advances to the next round.\n        After each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order).\n        The players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round.\n        Given the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively.\n        Example 1:\n        Input: n = 11, firstPlayer = 2, secondPlayer = 4\n        Output: [3,4]\n        Explanation:\n        One possible scenario which leads to the earliest round number:\n        First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n        Second round: 2, 3, 4, 5, 6, 11\n        Third round: 2, 3, 4\n        One possible scenario which leads to the latest round number:\n        First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n        Second round: 1, 2, 3, 4, 5, 6\n        Third round: 1, 2, 4\n        Fourth round: 2, 4\n        Example 2:\n        Input: n = 5, firstPlayer = 1, secondPlayer = 5\n        Output: [1,1]\n        Explanation: The players numbered 1 and 5 compete in the first round.\n        There is no way to make them compete in any other round.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1494,"row":{"number":1884,"difficulty":1,"question":"class Solution:\n    def twoEggDrop(self, n: int) -> int:\n        \"\"\"\n        You are given two identical eggs and you have access to a building with n floors labeled from 1 to n.\n        You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.\n        In each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.\n        Return the minimum number of moves that you need to determine with certainty what the value of f is.\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: We can drop the first egg from floor 1 and the second egg from floor 2.\n        If the first egg breaks, we know that f = 0.\n        If the second egg breaks but the first egg didn't, we know that f = 1.\n        Otherwise, if both eggs survive, we know that f = 2.\n        Example 2:\n        Input: n = 100\n        Output: 14\n        Explanation: One optimal strategy is:\n        - Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n        - If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n        - If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\n        Regardless of the outcome, it takes at most 14 drops to determine f.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1495,"row":{"number":1903,"difficulty":0,"question":"class Solution:\n    def largestOddNumber(self, num: str) -> str:\n        \"\"\"\n        You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string \"\" if no odd integer exists.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: num = \"52\"\n        Output: \"5\"\n        Explanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number.\n        Example 2:\n        Input: num = \"4206\"\n        Output: \"\"\n        Explanation: There are no odd numbers in \"4206\".\n        Example 3:\n        Input: num = \"35427\"\n        Output: \"35427\"\n        Explanation: \"35427\" is already an odd number.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1496,"row":{"number":1904,"difficulty":1,"question":"class Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        \"\"\"\n        You are participating in an online chess tournament. There is a chess round that starts every 15 minutes. The first round of the day starts at 00:00, and after every 15 minutes, a new round starts.\n            For example, the second round starts at 00:15, the fourth round starts at 00:45, and the seventh round starts at 01:30.\n        You are given two strings loginTime and logoutTime where:\n            loginTime is the time you will login to the game, and\n            logoutTime is the time you will logout from the game.\n        If logoutTime is earlier than loginTime, this means you have played from loginTime to midnight and from midnight to logoutTime.\n        Return the number of full chess rounds you have played in the tournament.\n        Note: All the given times follow the 24-hour clock. That means the first round of the day starts at 00:00 and the last round of the day starts at 23:45.\n        Example 1:\n        Input: loginTime = \"09:31\", logoutTime = \"10:14\"\n        Output: 1\n        Explanation: You played one full round from 09:45 to 10:00.\n        You did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began.\n        You did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended.\n        Example 2:\n        Input: loginTime = \"21:30\", logoutTime = \"03:00\"\n        Output: 22\n        Explanation: You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00.\n        10 + 12 = 22.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1497,"row":{"number":1906,"difficulty":1,"question":"class Solution:\n    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        The minimum absolute difference of an array a is defined as the minimum value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. If all elements of a are the same, the minimum absolute difference is -1.\n            For example, the minimum absolute difference of the array [5,2,3,7,2] is |2 - 3| = 1. Note that it is not 0 because a[i] and a[j] must be different.\n        You are given an integer array nums and the array queries where queries[i] = [li, ri]. For each query i, compute the minimum absolute difference of the subarray nums[li...ri] containing the elements of nums between the 0-based indices li and ri (inclusive).\n        Return an array ans where ans[i] is the answer to the ith query.\n        A subarray is a contiguous sequence of elements in an array.\n        The value of |x| is defined as:\n            x if x >= 0.\n            -x if x < 0.\n        Example 1:\n        Input: nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]\n        Output: [2,1,4,1]\n        Explanation: The queries are processed as follows:\n        - queries[0] = [0,1]: The subarray is [1,3] and the minimum absolute difference is |1-3| = 2.\n        - queries[1] = [1,2]: The subarray is [3,4] and the minimum absolute difference is |3-4| = 1.\n        - queries[2] = [2,3]: The subarray is [4,8] and the minimum absolute difference is |4-8| = 4.\n        - queries[3] = [0,3]: The subarray is [1,3,4,8] and the minimum absolute difference is |3-4| = 1.\n        Example 2:\n        Input: nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]\n        Output: [-1,1,1,3]\n        Explanation: The queries are processed as follows:\n        - queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the\n          elements are the same.\n        - queries[1] = [0,2]: The subarray is [4,5,2] and the minimum absolute difference is |4-5| = 1.\n        - queries[2] = [0,5]: The subarray is [4,5,2,2,7,10] and the minimum absolute difference is |4-5| = 1.\n        - queries[3] = [3,5]: The subarray is [2,7,10] and the minimum absolute difference is |7-10| = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1498,"row":{"number":1905,"difficulty":1,"question":"class Solution:\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\n        \"\"\"\n        You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.\n        An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.\n        Return the number of islands in grid2 that are considered sub-islands.\n        Example 1:\n        Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n        Output: 3\n        Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\n        The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.\n        Example 2:\n        Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n        Output: 2 \n        Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\n        The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1499,"row":{"number":1925,"difficulty":0,"question":"class Solution:\n    def countTriples(self, n: int) -> int:\n        \"\"\"\n        A square triple (a,b,c) is a triple where a, b, and c are integers and a2 + b2 = c2.\n        Given an integer n, return the number of square triples such that 1 <= a, b, c <= n.\n        Example 1:\n        Input: n = 5\n        Output: 2\n        Explanation: The square triples are (3,4,5) and (4,3,5).\n        Example 2:\n        Input: n = 10\n        Output: 4\n        Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}