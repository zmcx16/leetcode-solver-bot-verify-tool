{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":700,"row":{"number":890,"difficulty":1,"question":"class Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:\n        \"\"\"\n        Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n        A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n        Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.\n        Example 1:\n        Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\n        Output: [\"mee\",\"aqq\"]\n        Explanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n        \"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.\n        Example 2:\n        Input: words = [\"a\",\"b\",\"c\"], pattern = \"a\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":701,"row":{"number":891,"difficulty":2,"question":"class Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        \"\"\"\n        The width of a sequence is the difference between the maximum and minimum elements in the sequence.\n        Given an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.\n        A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n        Example 1:\n        Input: nums = [2,1,3]\n        Output: 6\n        Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\n        The corresponding widths are 0, 0, 0, 1, 1, 2, 2.\n        The sum of these widths is 6.\n        Example 2:\n        Input: nums = [2]\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":702,"row":{"number":892,"difficulty":0,"question":"class Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n grid where you have placed some 1 x 1 x 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of cell (i, j).\n        After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes.\n        Return the total surface area of the resulting shapes.\n        Note: The bottom face of each shape counts toward its surface area.\n        Example 1:\n        Input: grid = [[1,2],[3,4]]\n        Output: 34\n        Example 2:\n        Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: 32\n        Example 3:\n        Input: grid = [[2,2,2],[2,1,2],[2,2,2]]\n        Output: 46\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":703,"row":{"number":893,"difficulty":1,"question":"class Solution:\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\n        \"\"\"\n        You are given an array of strings of the same length words.\n        In one move, you can swap any two even indexed characters or any two odd indexed characters of a string words[i].\n        Two strings words[i] and words[j] are special-equivalent if after any number of moves, words[i] == words[j].\n            For example, words[i] = \"zzxy\" and words[j] = \"xyzz\" are special-equivalent because we may make the moves \"zzxy\" -> \"xzzy\" -> \"xyzz\".\n        A group of special-equivalent strings from words is a non-empty subset of words such that:\n            Every pair of strings in the group are special equivalent, and\n            The group is the largest size possible (i.e., there is not a string words[i] not in the group such that words[i] is special-equivalent to every string in the group).\n        Return the number of groups of special-equivalent strings from words.\n        Example 1:\n        Input: words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\n        Output: 3\n        Explanation: \n        One group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, and none of the other strings is all pairwise special equivalent to these.\n        The other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].\n        Note that in particular, \"zzxy\" is not special equivalent to \"zzyx\".\n        Example 2:\n        Input: words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":704,"row":{"number":894,"difficulty":1,"question":"class Solution:\n    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:\n        \"\"\"\n        Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.\n        Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.\n        A full binary tree is a binary tree where each node has exactly 0 or 2 children.\n        Example 1:\n        Input: n = 7\n        Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n        Example 2:\n        Input: n = 3\n        Output: [[0,0,0]]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":705,"row":{"number":895,"difficulty":2,"question":"class FreqStack:\n    def __init__(self):\n    def push(self, val: int) -> None:\n    def pop(self) -> int:\n        \"\"\"\n        Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n        Implement the FreqStack class:\n            FreqStack() constructs an empty frequency stack.\n            void push(int val) pushes an integer val onto the top of the stack.\n            int pop() removes and returns the most frequent element in the stack.\n                If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n        Example 1:\n        Input\n        [\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n        [[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n        Output\n        [null, null, null, null, null, null, null, 5, 7, 5, 4]\n        Explanation\n        FreqStack freqStack = new FreqStack();\n        freqStack.push(5); // The stack is [5]\n        freqStack.push(7); // The stack is [5,7]\n        freqStack.push(5); // The stack is [5,7,5]\n        freqStack.push(7); // The stack is [5,7,5,7]\n        freqStack.push(4); // The stack is [5,7,5,7,4]\n        freqStack.push(5); // The stack is [5,7,5,7,4,5]\n        freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\n        freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\n        freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\n        freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":706,"row":{"number":896,"difficulty":0,"question":"class Solution:\n    def isMonotonic(self, nums: List[int]) -> bool:\n        \"\"\"\n        An array is monotonic if it is either monotone increasing or monotone decreasing.\n        An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].\n        Given an integer array nums, return true if the given array is monotonic, or false otherwise.\n        Example 1:\n        Input: nums = [1,2,2,3]\n        Output: true\n        Example 2:\n        Input: nums = [6,5,4,4]\n        Output: true\n        Example 3:\n        Input: nums = [1,3,2]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":707,"row":{"number":897,"difficulty":0,"question":"class Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        \"\"\"\n        Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.\n        Example 1:\n        Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n        Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n        Example 2:\n        Input: root = [5,1,7]\n        Output: [1,null,5,null,7]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":708,"row":{"number":898,"difficulty":1,"question":"class Solution:\n    def subarrayBitwiseORs(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an integer array arr, return the number of distinct bitwise ORs of all the non-empty subarrays of arr.\n        The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: arr = [0]\n        Output: 1\n        Explanation: There is only one possible result: 0.\n        Example 2:\n        Input: arr = [1,1,2]\n        Output: 3\n        Explanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].\n        These yield the results 1, 1, 2, 1, 3, 3.\n        There are 3 unique values, so the answer is 3.\n        Example 3:\n        Input: arr = [1,2,4]\n        Output: 6\n        Explanation: The possible results are 1, 2, 3, 4, 6, and 7.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":709,"row":{"number":899,"difficulty":2,"question":"class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n        \"\"\"\n        You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string..\n        Return the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n        Example 1:\n        Input: s = \"cba\", k = 1\n        Output: \"acb\"\n        Explanation: \n        In the first move, we move the 1st character 'c' to the end, obtaining the string \"bac\".\n        In the second move, we move the 1st character 'b' to the end, obtaining the final result \"acb\".\n        Example 2:\n        Input: s = \"baaca\", k = 3\n        Output: \"aaabc\"\n        Explanation: \n        In the first move, we move the 1st character 'b' to the end, obtaining the string \"aacab\".\n        In the second move, we move the 3rd character 'c' to the end, obtaining the final result \"aaabc\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":710,"row":{"number":900,"difficulty":1,"question":"class RLEIterator:\n    def __init__(self, encoding: List[int]):\n    def next(self, n: int) -> int:\n        \"\"\"\n        We can use run-length encoding (i.e., RLE) to encode a sequence of integers. In a run-length encoded array of even length encoding (0-indexed), for all even i, encoding[i] tells us the number of times that the non-negative integer value encoding[i + 1] is repeated in the sequence.\n            For example, the sequence arr = [8,8,8,5,5] can be encoded to be encoding = [3,8,2,5]. encoding = [3,8,0,9,2,5] and encoding = [2,8,1,8,2,5] are also valid RLE of arr.\n        Given a run-length encoded array, design an iterator that iterates through it.\n        Implement the RLEIterator class:\n            RLEIterator(int[] encoded) Initializes the object with the encoded array encoded.\n            int next(int n) Exhausts the next n elements and returns the last element exhausted in this way. If there is no element left to exhaust, return -1 instead.\n        Example 1:\n        Input\n        [\"RLEIterator\", \"next\", \"next\", \"next\", \"next\"]\n        [[[3, 8, 0, 9, 2, 5]], [2], [1], [1], [2]]\n        Output\n        [null, 8, 8, 5, -1]\n        Explanation\n        RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // This maps to the sequence [8,8,8,5,5].\n        rLEIterator.next(2); // exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5].\n        rLEIterator.next(1); // exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5].\n        rLEIterator.next(1); // exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5].\n        rLEIterator.next(2); // exhausts 2 terms, returning -1. This is because the first term exhausted was 5,\n        but the second term did not exist. Since the last term exhausted does not exist, we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":711,"row":{"number":901,"difficulty":1,"question":"class StockSpanner:\n    def __init__(self):\n    def next(self, price: int) -> int:\n        \"\"\"\n        Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.\n        The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.\n            For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.\n            Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.\n        Implement the StockSpanner class:\n            StockSpanner() Initializes the object of the class.\n            int next(int price) Returns the span of the stock's price given that today's price is price.\n        Example 1:\n        Input\n        [\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"]\n        [[], [100], [80], [60], [70], [60], [75], [85]]\n        Output\n        [null, 1, 1, 1, 2, 1, 4, 6]\n        Explanation\n        StockSpanner stockSpanner = new StockSpanner();\n        stockSpanner.next(100); // return 1\n        stockSpanner.next(80);  // return 1\n        stockSpanner.next(60);  // return 1\n        stockSpanner.next(70);  // return 2\n        stockSpanner.next(60);  // return 1\n        stockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.\n        stockSpanner.next(85);  // return 6\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":712,"row":{"number":902,"difficulty":2,"question":"class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        \"\"\"\n        Given an array of digits which is sorted in non-decreasing order. You can write numbers using each digits[i] as many times as we want. For example, if digits = ['1','3','5'], we may write numbers such as '13', '551', and '1351315'.\n        Return the number of positive integers that can be generated that are less than or equal to a given integer n.\n        Example 1:\n        Input: digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\n        Output: 20\n        Explanation: \n        The 20 numbers that can be written are:\n        1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n        Example 2:\n        Input: digits = [\"1\",\"4\",\"9\"], n = 1000000000\n        Output: 29523\n        Explanation: \n        We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n        81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n        2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\n        In total, this is 29523 integers that can be written using the digits array.\n        Example 3:\n        Input: digits = [\"7\"], n = 8\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":713,"row":{"number":903,"difficulty":2,"question":"class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        \"\"\"\n        You are given a string s of length n where s[i] is either:\n            'D' means decreasing, or\n            'I' means increasing.\n        A permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n            If s[i] == 'D', then perm[i] > perm[i + 1], and\n            If s[i] == 'I', then perm[i] < perm[i + 1].\n        Return the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n        Example 1:\n        Input: s = \"DID\"\n        Output: 5\n        Explanation: The 5 valid permutations of (0, 1, 2, 3) are:\n        (1, 0, 3, 2)\n        (2, 0, 3, 1)\n        (2, 1, 3, 0)\n        (3, 0, 2, 1)\n        (3, 1, 2, 0)\n        Example 2:\n        Input: s = \"D\"\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":714,"row":{"number":904,"difficulty":1,"question":"class Solution:\n    def totalFruit(self, fruits: List[int]) -> int:\n        \"\"\"\n        You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.\n        You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\n            You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.\n            Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\n            Once you reach a tree with fruit that cannot fit in your baskets, you must stop.\n        Given the integer array fruits, return the maximum number of fruits you can pick.\n        Example 1:\n        Input: fruits = [1,2,1]\n        Output: 3\n        Explanation: We can pick from all 3 trees.\n        Example 2:\n        Input: fruits = [0,1,2,2]\n        Output: 3\n        Explanation: We can pick from trees [1,2,2].\n        If we had started at the first tree, we would only pick from trees [0,1].\n        Example 3:\n        Input: fruits = [1,2,3,2,2]\n        Output: 4\n        Explanation: We can pick from trees [2,3,2,2].\n        If we had started at the first tree, we would only pick from trees [1,2].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":715,"row":{"number":905,"difficulty":0,"question":"class Solution:\n    def sortArrayByParity(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.\n        Return any array that satisfies this condition.\n        Example 1:\n        Input: nums = [3,1,2,4]\n        Output: [2,4,3,1]\n        Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n        Example 2:\n        Input: nums = [0]\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":716,"row":{"number":906,"difficulty":2,"question":"class Solution:\n    def superpalindromesInRange(self, left: str, right: str) -> int:\n        \"\"\"\n        Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome.\n        Given two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right].\n        Example 1:\n        Input: left = \"4\", right = \"1000\"\n        Output: 4\n        Explanation: 4, 9, 121, and 484 are superpalindromes.\n        Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.\n        Example 2:\n        Input: left = \"1\", right = \"2\"\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":717,"row":{"number":907,"difficulty":1,"question":"class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.\n        Example 1:\n        Input: arr = [3,1,2,4]\n        Output: 17\n        Explanation: \n        Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \n        Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\n        Sum is 17.\n        Example 2:\n        Input: arr = [11,81,94,43,3]\n        Output: 444\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":718,"row":{"number":908,"difficulty":0,"question":"class Solution:\n    def smallestRangeI(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer k.\n        In one operation, you can choose any index i where 0 <= i < nums.length and change nums[i] to nums[i] + x where x is an integer from the range [-k, k]. You can apply this operation at most once for each index i.\n        The score of nums is the difference between the maximum and minimum elements in nums.\n        Return the minimum score of nums after applying the mentioned operation at most once for each index in it.\n        Example 1:\n        Input: nums = [1], k = 0\n        Output: 0\n        Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0.\n        Example 2:\n        Input: nums = [0,10], k = 2\n        Output: 6\n        Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n        Example 3:\n        Input: nums = [1,3,6], k = 3\n        Output: 0\n        Explanation: Change nums to be [4, 4, 4]. The score is max(nums) - min(nums) = 4 - 4 = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":719,"row":{"number":909,"difficulty":1,"question":"class Solution:\n    def snakesAndLadders(self, board: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.\n        You start on square 1 of the board. In each move, starting from square curr, do the following:\n            Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].\n                This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.\n            If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.\n            The game ends when you reach the square n2.\n        A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.\n        Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.\n            For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.\n        Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.\n        Example 1:\n        Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\n        Output: 4\n        Explanation: \n        In the beginning, you start at square 1 (at row 5, column 0).\n        You decide to move to square 2 and must take the ladder to square 15.\n        You then decide to move to square 17 and must take the snake to square 13.\n        You then decide to move to square 14 and must take the ladder to square 35.\n        You then decide to move to square 36, ending the game.\n        This is the lowest possible number of moves to reach the last square, so return 4.\n        Example 2:\n        Input: board = [[-1,-1],[-1,3]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":720,"row":{"number":910,"difficulty":1,"question":"class Solution:\n    def smallestRangeII(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer k.\n        For each index i where 0 <= i < nums.length, change nums[i] to be either nums[i] + k or nums[i] - k.\n        The score of nums is the difference between the maximum and minimum elements in nums.\n        Return the minimum score of nums after changing the values at each index.\n        Example 1:\n        Input: nums = [1], k = 0\n        Output: 0\n        Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0.\n        Example 2:\n        Input: nums = [0,10], k = 2\n        Output: 6\n        Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n        Example 3:\n        Input: nums = [1,3,6], k = 3\n        Output: 3\n        Explanation: Change nums to be [4, 6, 3]. The score is max(nums) - min(nums) = 6 - 3 = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":721,"row":{"number":911,"difficulty":1,"question":"class TopVotedCandidate:\n    def __init__(self, persons: List[int], times: List[int]):\n    def q(self, t: int) -> int:\n        \"\"\"\n        You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\n        For each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\n        Implement the TopVotedCandidate class:\n            TopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\n            int q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.\n        Example 1:\n        Input\n        [\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n        [[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\n        Output\n        [null, 0, 1, 1, 0, 0, 1]\n        Explanation\n        TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\n        topVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\n        topVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\n        topVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\n        topVotedCandidate.q(15); // return 0\n        topVotedCandidate.q(24); // return 0\n        topVotedCandidate.q(8); // return 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":722,"row":{"number":912,"difficulty":1,"question":"class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an array of integers nums, sort the array in ascending order and return it.\n        You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.\n        Example 1:\n        Input: nums = [5,2,3,1]\n        Output: [1,2,3,5]\n        Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).\n        Example 2:\n        Input: nums = [5,1,1,2,0,0]\n        Output: [0,0,1,1,2,5]\n        Explanation: Note that the values of nums are not necessairly unique.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":723,"row":{"number":913,"difficulty":2,"question":"class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        \"\"\"\n        A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\n        The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\n        The mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0.\n        During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1].\n        Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n        Then, the game can end in three ways:\n            If ever the Cat occupies the same node as the Mouse, the Cat wins.\n            If ever the Mouse reaches the Hole, the Mouse wins.\n            If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n        Given a graph, and assuming both players play optimally, return\n            1 if the mouse wins the game,\n            2 if the cat wins the game, or\n            0 if the game is a draw.\n        Example 1:\n        Input: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\n        Output: 0\n        Example 2:\n        Input: graph = [[1,3],[0],[3],[0,2]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":724,"row":{"number":914,"difficulty":0,"question":"class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array deck where deck[i] represents the number written on the ith card.\n        Partition the cards into one or more groups such that:\n            Each group has exactly x cards where x > 1, and\n            All the cards in one group have the same integer written on them.\n        Return true if such partition is possible, or false otherwise.\n        Example 1:\n        Input: deck = [1,2,3,4,4,3,2,1]\n        Output: true\n        Explanation: Possible partition [1,1],[2,2],[3,3],[4,4].\n        Example 2:\n        Input: deck = [1,1,1,2,2,2,3,3]\n        Output: false\n        Explanation: No possible partition.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":725,"row":{"number":915,"difficulty":1,"question":"class Solution:\n    def partitionDisjoint(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, partition it into two (contiguous) subarrays left and right so that:\n            Every element in left is less than or equal to every element in right.\n            left and right are non-empty.\n            left has the smallest possible size.\n        Return the length of left after such a partitioning.\n        Test cases are generated such that partitioning exists.\n        Example 1:\n        Input: nums = [5,0,3,8,6]\n        Output: 3\n        Explanation: left = [5,0,3], right = [8,6]\n        Example 2:\n        Input: nums = [1,1,1,0,6,12]\n        Output: 4\n        Explanation: left = [1,1,1,0], right = [6,12]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":726,"row":{"number":916,"difficulty":1,"question":"class Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        \"\"\"\n        You are given two string arrays words1 and words2.\n        A string b is a subset of string a if every letter in b occurs in a including multiplicity.\n            For example, \"wrr\" is a subset of \"warrior\" but is not a subset of \"world\".\n        A string a from words1 is universal if for every string b in words2, b is a subset of a.\n        Return an array of all the universal strings in words1. You may return the answer in any order.\n        Example 1:\n        Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\n        Output: [\"facebook\",\"google\",\"leetcode\"]\n        Example 2:\n        Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"l\",\"e\"]\n        Output: [\"apple\",\"google\",\"leetcode\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":727,"row":{"number":917,"difficulty":0,"question":"class Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        \"\"\"\n        Given a string s, reverse the string according to the following rules:\n            All the characters that are not English letters remain in the same position.\n            All the English letters (lowercase or uppercase) should be reversed.\n        Return s after reversing it.\n        Example 1:\n        Input: s = \"ab-cd\"\n        Output: \"dc-ba\"\n        Example 2:\n        Input: s = \"a-bC-dEf-ghIj\"\n        Output: \"j-Ih-gfE-dCba\"\n        Example 3:\n        Input: s = \"Test1ng-Leet=code-Q!\"\n        Output: \"Qedo1ct-eeLg=ntse-T!\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":728,"row":{"number":918,"difficulty":1,"question":"class Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        \"\"\"\n        Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\n        A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\n        A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\n        Example 1:\n        Input: nums = [1,-2,3,-2]\n        Output: 3\n        Explanation: Subarray [3] has maximum sum 3.\n        Example 2:\n        Input: nums = [5,-3,5]\n        Output: 10\n        Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\n        Example 3:\n        Input: nums = [-3,-2,-3]\n        Output: -2\n        Explanation: Subarray [-2] has maximum sum -2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":729,"row":{"number":919,"difficulty":1,"question":"class CBTInserter:\n    def __init__(self, root: Optional[TreeNode]):\n    def insert(self, val: int) -> int:\n    def get_root(self) -> Optional[TreeNode]:\n        \"\"\"\n        A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\n        Design an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.\n        Implement the CBTInserter class:\n            CBTInserter(TreeNode root) Initializes the data structure with the root of the complete binary tree.\n            int insert(int v) Inserts a TreeNode into the tree with value Node.val == val so that the tree remains complete, and returns the value of the parent of the inserted TreeNode.\n            TreeNode get_root() Returns the root node of the tree.\n        Example 1:\n        Input\n        [\"CBTInserter\", \"insert\", \"insert\", \"get_root\"]\n        [[[1, 2]], [3], [4], []]\n        Output\n        [null, 1, 2, [1, 2, 3, 4]]\n        Explanation\n        CBTInserter cBTInserter = new CBTInserter([1, 2]);\n        cBTInserter.insert(3);  // return 1\n        cBTInserter.insert(4);  // return 2\n        cBTInserter.get_root(); // return [1, 2, 3, 4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":730,"row":{"number":920,"difficulty":2,"question":"class Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        \"\"\"\n        Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n            Every song is played at least once.\n            A song can only be played again only if k other songs have been played.\n        Given n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 3, goal = 3, k = 1\n        Output: 6\n        Explanation: There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n        Example 2:\n        Input: n = 2, goal = 3, k = 0\n        Output: 6\n        Explanation: There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2].\n        Example 3:\n        Input: n = 2, goal = 3, k = 1\n        Output: 2\n        Explanation: There are 2 possible playlists: [1, 2, 1] and [2, 1, 2].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":731,"row":{"number":921,"difficulty":1,"question":"class Solution:\n    def minAddToMakeValid(self, s: str) -> int:\n        \"\"\"\n        A parentheses string is valid if and only if:\n            It is the empty string,\n            It can be written as AB (A concatenated with B), where A and B are valid strings, or\n            It can be written as (A), where A is a valid string.\n        You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.\n            For example, if s = \"()))\", you can insert an opening parenthesis to be \"(()))\" or a closing parenthesis to be \"())))\".\n        Return the minimum number of moves required to make s valid.\n        Example 1:\n        Input: s = \"())\"\n        Output: 1\n        Example 2:\n        Input: s = \"(((\"\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":732,"row":{"number":922,"difficulty":0,"question":"class Solution:\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an array of integers nums, half of the integers in nums are odd, and the other half are even.\n        Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\n        Return any answer array that satisfies this condition.\n        Example 1:\n        Input: nums = [4,2,5,7]\n        Output: [4,5,2,7]\n        Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n        Example 2:\n        Input: nums = [2,3]\n        Output: [2,3]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":733,"row":{"number":923,"difficulty":1,"question":"class Solution:\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.\n        As the answer can be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: arr = [1,1,2,2,3,3,4,4,5,5], target = 8\n        Output: 20\n        Explanation: \n        Enumerating by the values (arr[i], arr[j], arr[k]):\n        (1, 2, 5) occurs 8 times;\n        (1, 3, 4) occurs 8 times;\n        (2, 2, 4) occurs 2 times;\n        (2, 3, 3) occurs 2 times.\n        Example 2:\n        Input: arr = [1,1,2,2,2,2], target = 5\n        Output: 12\n        Explanation: \n        arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:\n        We choose one 1 from [1,1] in 2 ways,\n        and two 2s from [2,2,2,2] in 6 ways.\n        Example 3:\n        Input: arr = [2,1,3], target = 6\n        Output: 1\n        Explanation: (1, 2, 3) occured one time in the array so we return 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":734,"row":{"number":924,"difficulty":2,"question":"class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        \"\"\"\n        You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\n        Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n        Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.\n        Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n        Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.\n        Example 1:\n        Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\n        Output: 0\n        Example 2:\n        Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\n        Output: 0\n        Example 3:\n        Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":735,"row":{"number":925,"difficulty":0,"question":"class Solution:\n    def isLongPressedName(self, name: str, typed: str) -> bool:\n        \"\"\"\n        Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\n        You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\n        Example 1:\n        Input: name = \"alex\", typed = \"aaleex\"\n        Output: true\n        Explanation: 'a' and 'e' in 'alex' were long pressed.\n        Example 2:\n        Input: name = \"saeed\", typed = \"ssaaedd\"\n        Output: false\n        Explanation: 'e' must have been pressed twice, but it was not in the typed output.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":736,"row":{"number":926,"difficulty":1,"question":"class Solution:\n    def minFlipsMonoIncr(self, s: str) -> int:\n        \"\"\"\n        A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\n        You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\n        Return the minimum number of flips to make s monotone increasing.\n        Example 1:\n        Input: s = \"00110\"\n        Output: 1\n        Explanation: We flip the last digit to get 00111.\n        Example 2:\n        Input: s = \"010110\"\n        Output: 2\n        Explanation: We flip to get 011111, or alternatively 000111.\n        Example 3:\n        Input: s = \"00011000\"\n        Output: 2\n        Explanation: We flip to get 00000000.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":737,"row":{"number":927,"difficulty":2,"question":"class Solution:\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\n        \"\"\"\n        You are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value.\n        If it is possible, return any [i, j] with i + 1 < j, such that:\n            arr[0], arr[1], ..., arr[i] is the first part,\n            arr[i + 1], arr[i + 2], ..., arr[j - 1] is the second part, and\n            arr[j], arr[j + 1], ..., arr[arr.length - 1] is the third part.\n            All three parts have equal binary values.\n        If it is not possible, return [-1, -1].\n        Note that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.\n        Example 1:\n        Input: arr = [1,0,1,0,1]\n        Output: [0,3]\n        Example 2:\n        Input: arr = [1,1,0,1,1]\n        Output: [-1,-1]\n        Example 3:\n        Input: arr = [1,1,0,0,1]\n        Output: [0,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":738,"row":{"number":928,"difficulty":2,"question":"class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        \"\"\"\n        You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\n        Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n        Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.\n        We will remove exactly one node from initial, completely removing it and any connections from this node to any other node.\n        Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n        Example 1:\n        Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\n        Output: 0\n        Example 2:\n        Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\n        Output: 1\n        Example 3:\n        Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":739,"row":{"number":929,"difficulty":0,"question":"class Solution:\n    def numUniqueEmails(self, emails: List[str]) -> int:\n        \"\"\"\n        Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\n            For example, in \"alice@leetcode.com\", \"alice\" is the local name, and \"leetcode.com\" is the domain name.\n        If you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\n            For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\n        If you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\n            For example, \"m.y+name@email.com\" will be forwarded to \"my@email.com\".\n        It is possible to use both of these rules at the same time.\n        Given an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.\n        Example 1:\n        Input: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\n        Output: 2\n        Explanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails.\n        Example 2:\n        Input: emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\n        Output: 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":740,"row":{"number":930,"difficulty":1,"question":"class Solution:\r\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:\n        \"\"\"\n        Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\r\n        A subarray is a contiguous part of the array.\r\n        Example 1:\r\n        Input: nums = [1,0,1,0,1], goal = 2\r\n        Output: 4\r\n        Explanation: The 4 subarrays are bolded and underlined below:\r\n        [1,0,1,0,1]\r\n        [1,0,1,0,1]\r\n        [1,0,1,0,1]\r\n        [1,0,1,0,1]\r\n        Example 2:\r\n        Input: nums = [0,0,0,0,0], goal = 0\r\n        Output: 15\r\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":741,"row":{"number":931,"difficulty":1,"question":"class Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        \"\"\"\n        Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\n        A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\n        Example 1:\n        Input: matrix = [[2,1,3],[6,5,4],[7,8,9]]\n        Output: 13\n        Explanation: There are two falling paths with a minimum sum as shown.\n        Example 2:\n        Input: matrix = [[-19,57],[-40,-5]]\n        Output: -59\n        Explanation: The falling path with a minimum sum is shown.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":742,"row":{"number":932,"difficulty":1,"question":"class Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        \"\"\"\n        An array nums of length n is beautiful if:\n            nums is a permutation of the integers in the range [1, n].\n            For every 0 <= i < j < n, there is no index k with i < k < j where 2 * nums[k] == nums[i] + nums[j].\n        Given the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n.\n        Example 1:\n        Input: n = 4\n        Output: [2,1,4,3]\n        Example 2:\n        Input: n = 5\n        Output: [3,1,2,5,4]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":743,"row":{"number":933,"difficulty":0,"question":"class RecentCounter:\n    def __init__(self):\n    def ping(self, t: int) -> int:\n        \"\"\"\n        You have a RecentCounter class which counts the number of recent requests within a certain time frame.\n        Implement the RecentCounter class:\n            RecentCounter() Initializes the counter with zero recent requests.\n            int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].\n        It is guaranteed that every call to ping uses a strictly larger value of t than the previous call.\n        Example 1:\n        Input\n        [\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\n        [[], [1], [100], [3001], [3002]]\n        Output\n        [null, 1, 2, 3, 3]\n        Explanation\n        RecentCounter recentCounter = new RecentCounter();\n        recentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1\n        recentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2\n        recentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3\n        recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":744,"row":{"number":934,"difficulty":1,"question":"class Solution:\n    def shortestBridge(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\n        An island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\n        You may change 0's to 1's to connect the two islands to form one island.\n        Return the smallest number of 0's you must flip to connect the two islands.\n        Example 1:\n        Input: grid = [[0,1],[1,0]]\n        Output: 1\n        Example 2:\n        Input: grid = [[0,1,0],[0,0,0],[0,0,1]]\n        Output: 2\n        Example 3:\n        Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":745,"row":{"number":935,"difficulty":1,"question":"class Solution:\n    def knightDialer(self, n: int) -> int:\n        \"\"\"\n        The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\n        A chess knight can move as indicated in the chess diagram below:\n        We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).\n        Given an integer n, return how many distinct phone numbers of length n we can dial.\n        You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\n        As the answer may be very large, return the answer modulo 109 + 7.\n        Example 1:\n        Input: n = 1\n        Output: 10\n        Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n        Example 2:\n        Input: n = 2\n        Output: 20\n        Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n        Example 3:\n        Input: n = 3131\n        Output: 136006598\n        Explanation: Please take care of the mod.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":746,"row":{"number":936,"difficulty":2,"question":"class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \"\"\"\n        You are given two strings stamp and target. Initially, there is a string s of length target.length with all s[i] == '?'.\n        In one turn, you can place stamp over s and replace every letter in the s with the corresponding letter from stamp.\n            For example, if stamp = \"abc\" and target = \"abcba\", then s is \"?????\" initially. In one turn you can:\n                place stamp at index 0 of s to obtain \"abc??\",\n                place stamp at index 1 of s to obtain \"?abc?\", or\n                place stamp at index 2 of s to obtain \"??abc\".\n            Note that stamp must be fully contained in the boundaries of s in order to stamp (i.e., you cannot place stamp at index 3 of s).\n        We want to convert s to target using at most 10 * target.length turns.\n        Return an array of the index of the left-most letter being stamped at each turn. If we cannot obtain target from s within 10 * target.length turns, return an empty array.\n        Example 1:\n        Input: stamp = \"abc\", target = \"ababc\"\n        Output: [0,2]\n        Explanation: Initially s = \"?????\".\n        - Place stamp at index 0 to get \"abc??\".\n        - Place stamp at index 2 to get \"ababc\".\n        [1,0,2] would also be accepted as an answer, as well as some other answers.\n        Example 2:\n        Input: stamp = \"abca\", target = \"aabcaca\"\n        Output: [3,0,1]\n        Explanation: Initially s = \"???????\".\n        - Place stamp at index 3 to get \"???abca\".\n        - Place stamp at index 0 to get \"abcabca\".\n        - Place stamp at index 1 to get \"aabcaca\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":747,"row":{"number":937,"difficulty":1,"question":"class Solution:\n    def reorderLogFiles(self, logs: List[str]) -> List[str]:\n        \"\"\"\n        You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.\n        There are two types of logs:\n            Letter-logs: All words (except the identifier) consist of lowercase English letters.\n            Digit-logs: All words (except the identifier) consist of digits.\n        Reorder these logs so that:\n            The letter-logs come before all digit-logs.\n            The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.\n            The digit-logs maintain their relative ordering.\n        Return the final order of the logs.\n        Example 1:\n        Input: logs = [\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\n        Output: [\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\n        Explanation:\n        The letter-log contents are all different, so their ordering is \"art can\", \"art zero\", \"own kit dig\".\n        The digit-logs have a relative order of \"dig1 8 1 5 1\", \"dig2 3 6\".\n        Example 2:\n        Input: logs = [\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"]\n        Output: [\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":748,"row":{"number":938,"difficulty":0,"question":"class Solution:\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\n        \"\"\"\n        Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\n        Example 1:\n        Input: root = [10,5,15,3,7,null,18], low = 7, high = 15\n        Output: 32\n        Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n        Example 2:\n        Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n        Output: 23\n        Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":749,"row":{"number":939,"difficulty":1,"question":"class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \"\"\"\n        You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\n        Return the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0.\n        Example 1:\n        Input: points = [[1,1],[1,3],[3,1],[3,3],[2,2]]\n        Output: 4\n        Example 2:\n        Input: points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\n        Output: 2\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":750,"row":{"number":940,"difficulty":2,"question":"class Solution:\n    def distinctSubseqII(self, s: str) -> int:\n        \"\"\"\n        Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7.\n        A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not.\n        Example 1:\n        Input: s = \"abc\"\n        Output: 7\n        Explanation: The 7 distinct subsequences are \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", and \"abc\".\n        Example 2:\n        Input: s = \"aba\"\n        Output: 6\n        Explanation: The 6 distinct subsequences are \"a\", \"b\", \"ab\", \"aa\", \"ba\", and \"aba\".\n        Example 3:\n        Input: s = \"aaa\"\n        Output: 3\n        Explanation: The 3 distinct subsequences are \"a\", \"aa\" and \"aaa\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":751,"row":{"number":941,"difficulty":0,"question":"class Solution:\n    def validMountainArray(self, arr: List[int]) -> bool:\n        \"\"\"\n        Given an array of integers arr, return true if and only if it is a valid mountain array.\n        Recall that arr is a mountain array if and only if:\n            arr.length >= 3\n            There exists some i with 0 < i < arr.length - 1 such that:\n                arr[0] < arr[1] < ... < arr[i - 1] < arr[i] \n                arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n        Example 1:\n        Input: arr = [2,1]\n        Output: false\n        Example 2:\n        Input: arr = [3,5,5]\n        Output: false\n        Example 3:\n        Input: arr = [0,3,2,1]\n        Output: true\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":752,"row":{"number":942,"difficulty":0,"question":"class Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        \"\"\"\n        A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where:\n            s[i] == 'I' if perm[i] < perm[i + 1], and\n            s[i] == 'D' if perm[i] > perm[i + 1].\n        Given a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them.\n        Example 1:\n        Input: s = \"IDID\"\n        Output: [0,4,1,3,2]\n        Example 2:\n        Input: s = \"III\"\n        Output: [0,1,2,3]\n        Example 3:\n        Input: s = \"DDI\"\n        Output: [3,2,0,1]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":753,"row":{"number":943,"difficulty":2,"question":"class Solution:\n    def shortestSuperstring(self, words: List[str]) -> str:\n        \"\"\"\n        Given an array of strings words, return the smallest string that contains each string in words as a substring. If there are multiple valid strings of the smallest length, return any of them.\n        You may assume that no string in words is a substring of another string in words.\n        Example 1:\n        Input: words = [\"alex\",\"loves\",\"leetcode\"]\n        Output: \"alexlovesleetcode\"\n        Explanation: All permutations of \"alex\",\"loves\",\"leetcode\" would also be accepted.\n        Example 2:\n        Input: words = [\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"]\n        Output: \"gctaagttcatgcatc\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":754,"row":{"number":944,"difficulty":0,"question":"class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        \"\"\"\n        You are given an array of n strings strs, all of the same length.\n        The strings can be arranged such that there is one on each line, making a grid.\n            For example, strs = [\"abc\", \"bce\", \"cae\"] can be arranged as follows:\n        abc\n        bce\n        cae\n        You want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.\n        Return the number of columns that you will delete.\n        Example 1:\n        Input: strs = [\"cba\",\"daf\",\"ghi\"]\n        Output: 1\n        Explanation: The grid looks as follows:\n          cba\n          daf\n          ghi\n        Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.\n        Example 2:\n        Input: strs = [\"a\",\"b\"]\n        Output: 0\n        Explanation: The grid looks as follows:\n          a\n          b\n        Column 0 is the only column and is sorted, so you will not delete any columns.\n        Example 3:\n        Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\n        Output: 3\n        Explanation: The grid looks as follows:\n          zyx\n          wvu\n          tsr\n        All 3 columns are not sorted, so you will delete all 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":755,"row":{"number":945,"difficulty":1,"question":"class Solution:\n    def minIncrementForUnique(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.\n        Return the minimum number of moves to make every value in nums unique.\n        The test cases are generated so that the answer fits in a 32-bit integer.\n        Example 1:\n        Input: nums = [1,2,2]\n        Output: 1\n        Explanation: After 1 move, the array could be [1, 2, 3].\n        Example 2:\n        Input: nums = [3,2,1,2,1,7]\n        Output: 6\n        Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7].\n        It can be shown with 5 or less moves that it is impossible for the array to have all unique values.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":756,"row":{"number":946,"difficulty":1,"question":"class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        \"\"\"\n        Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.\n        Example 1:\n        Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n        Output: true\n        Explanation: We might do the following sequence:\n        push(1), push(2), push(3), push(4),\n        pop() -> 4,\n        push(5),\n        pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n        Example 2:\n        Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n        Output: false\n        Explanation: 1 cannot be popped before 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":757,"row":{"number":947,"difficulty":1,"question":"class Solution:\n    def removeStones(self, stones: List[List[int]]) -> int:\n        \"\"\"\n        On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\n        A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\n        Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\n        Example 1:\n        Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n        Output: 5\n        Explanation: One way to remove 5 stones is as follows:\n        1. Remove stone [2,2] because it shares the same row as [2,1].\n        2. Remove stone [2,1] because it shares the same column as [0,1].\n        3. Remove stone [1,2] because it shares the same row as [1,0].\n        4. Remove stone [1,0] because it shares the same column as [0,0].\n        5. Remove stone [0,1] because it shares the same row as [0,0].\n        Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.\n        Example 2:\n        Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\n        Output: 3\n        Explanation: One way to make 3 moves is as follows:\n        1. Remove stone [2,2] because it shares the same row as [2,0].\n        2. Remove stone [2,0] because it shares the same column as [0,0].\n        3. Remove stone [0,2] because it shares the same row as [0,0].\n        Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.\n        Example 3:\n        Input: stones = [[0,0]]\n        Output: 0\n        Explanation: [0,0] is the only stone on the plane, so you cannot remove it.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":758,"row":{"number":948,"difficulty":1,"question":"class Solution:\n    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\n        \"\"\"\n        You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed).\n        Your goal is to maximize your total score by potentially playing each token in one of two ways:\n            If your current power is at least tokens[i], you may play the ith token face up, losing tokens[i] power and gaining 1 score.\n            If your current score is at least 1, you may play the ith token face down, gaining tokens[i] power and losing 1 score.\n        Each token may be played at most once and in any order. You do not have to play all the tokens.\n        Return the largest possible score you can achieve after playing any number of tokens.\n        Example 1:\n        Input: tokens = [100], power = 50\n        Output: 0\n        Explanation: Playing the only token in the bag is impossible because you either have too little power or too little score.\n        Example 2:\n        Input: tokens = [100,200], power = 150\n        Output: 1\n        Explanation: Play the 0th token (100) face up, your power becomes 50 and score becomes 1.\n        There is no need to play the 1st token since you cannot play it face up to add to your score.\n        Example 3:\n        Input: tokens = [100,200,300,400], power = 200\n        Output: 2\n        Explanation: Play the tokens in this order to get a score of 2:\n        1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1.\n        2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0.\n        3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1.\n        4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":759,"row":{"number":949,"difficulty":1,"question":"class Solution:\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\n        \"\"\"\n        Given an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.\n        24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\n        Return the latest 24-hour time in \"HH:MM\" format. If no valid time can be made, return an empty string.\n        Example 1:\n        Input: arr = [1,2,3,4]\n        Output: \"23:41\"\n        Explanation: The valid 24-hour times are \"12:34\", \"12:43\", \"13:24\", \"13:42\", \"14:23\", \"14:32\", \"21:34\", \"21:43\", \"23:14\", and \"23:41\". Of these times, \"23:41\" is the latest.\n        Example 2:\n        Input: arr = [5,5,5,5]\n        Output: \"\"\n        Explanation: There are no valid 24-hour times as \"55:55\" is not valid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":760,"row":{"number":950,"difficulty":1,"question":"class Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\n        You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\n        You will do the following steps repeatedly until all cards are revealed:\n            Take the top card of the deck, reveal it, and take it out of the deck.\n            If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\n            If there are still unrevealed cards, go back to step 1. Otherwise, stop.\n        Return an ordering of the deck that would reveal the cards in increasing order.\n        Note that the first entry in the answer is considered to be the top of the deck.\n        Example 1:\n        Input: deck = [17,13,11,2,3,5,7]\n        Output: [2,13,3,11,5,17,7]\n        Explanation: \n        We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.\n        After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.\n        We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].\n        We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].\n        We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].\n        We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].\n        We reveal 11, and move 17 to the bottom.  The deck is now [13,17].\n        We reveal 13, and move 17 to the bottom.  The deck is now [17].\n        We reveal 17.\n        Since all the cards revealed are in increasing order, the answer is correct.\n        Example 2:\n        Input: deck = [1,1000]\n        Output: [1,1000]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":761,"row":{"number":951,"difficulty":1,"question":"class Solution:\n    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        \"\"\"\n        For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\n        A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\n        Given the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise.\n        Example 1:\n        Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\n        Output: true\n        Explanation: We flipped at nodes with values 1, 3, and 5.\n        Example 2:\n        Input: root1 = [], root2 = []\n        Output: true\n        Example 3:\n        Input: root1 = [], root2 = [1]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":762,"row":{"number":952,"difficulty":2,"question":"class Solution:\n    def largestComponentSize(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array of unique positive integers nums. Consider the following graph:\n            There are nums.length nodes, labeled nums[0] to nums[nums.length - 1],\n            There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1.\n        Return the size of the largest connected component in the graph.\n        Example 1:\n        Input: nums = [4,6,15,35]\n        Output: 4\n        Example 2:\n        Input: nums = [20,50,9,63]\n        Output: 2\n        Example 3:\n        Input: nums = [2,3,6,7,4,12,21,39]\n        Output: 8\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":763,"row":{"number":953,"difficulty":0,"question":"class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        \"\"\"\n        In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\n        Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.\n        Example 1:\n        Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\n        Output: true\n        Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.\n        Example 2:\n        Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\n        Output: false\n        Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.\n        Example 3:\n        Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\n        Output: false\n        Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":764,"row":{"number":954,"difficulty":1,"question":"class Solution:\n    def canReorderDoubled(self, arr: List[int]) -> bool:\n        \"\"\"\n        Given an integer array of even length arr, return true if it is possible to reorder arr such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 <= i < len(arr) / 2, or false otherwise.\n        Example 1:\n        Input: arr = [3,1,3,6]\n        Output: false\n        Example 2:\n        Input: arr = [2,1,2,6]\n        Output: false\n        Example 3:\n        Input: arr = [4,-2,2,-4]\n        Output: true\n        Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":765,"row":{"number":955,"difficulty":1,"question":"class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        \"\"\"\n        You are given an array of n strings strs, all of the same length.\n        We may choose any deletion indices, and we delete all the characters in those indices for each string.\n        For example, if we have strs = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\", \"vyz\"].\n        Suppose we chose a set of deletion indices answer such that after deletions, the final array has its elements in lexicographic order (i.e., strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]). Return the minimum possible value of answer.length.\n        Example 1:\n        Input: strs = [\"ca\",\"bb\",\"ac\"]\n        Output: 1\n        Explanation: \n        After deleting the first column, strs = [\"a\", \"b\", \"c\"].\n        Now strs is in lexicographic order (ie. strs[0] <= strs[1] <= strs[2]).\n        We require at least 1 deletion since initially strs was not in lexicographic order, so the answer is 1.\n        Example 2:\n        Input: strs = [\"xc\",\"yb\",\"za\"]\n        Output: 0\n        Explanation: \n        strs is already in lexicographic order, so we do not need to delete anything.\n        Note that the rows of strs are not necessarily in lexicographic order:\n        i.e., it is NOT necessarily true that (strs[0][0] <= strs[0][1] <= ...)\n        Example 3:\n        Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\n        Output: 3\n        Explanation: We have to delete every column.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":766,"row":{"number":956,"difficulty":2,"question":"class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        \"\"\"\n        You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\n        You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\n        Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0.\n        Example 1:\n        Input: rods = [1,2,3,6]\n        Output: 6\n        Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n        Example 2:\n        Input: rods = [1,2,3,4,5,6]\n        Output: 10\n        Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n        Example 3:\n        Input: rods = [1,2]\n        Output: 0\n        Explanation: The billboard cannot be supported, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":767,"row":{"number":957,"difficulty":1,"question":"class Solution:\n    def prisonAfterNDays(self, cells: List[int], n: int) -> List[int]:\n        \"\"\"\n        There are 8 prison cells in a row and each cell is either occupied or vacant.\n        Each day, whether the cell is occupied or vacant changes according to the following rules:\n            If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.\n            Otherwise, it becomes vacant.\n        Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.\n        You are given an integer array cells where cells[i] == 1 if the ith cell is occupied and cells[i] == 0 if the ith cell is vacant, and you are given an integer n.\n        Return the state of the prison after n days (i.e., n such changes described above).\n        Example 1:\n        Input: cells = [0,1,0,1,1,0,0,1], n = 7\n        Output: [0,0,1,1,0,0,0,0]\n        Explanation: The following table summarizes the state of the prison on each day:\n        Day 0: [0, 1, 0, 1, 1, 0, 0, 1]\n        Day 1: [0, 1, 1, 0, 0, 0, 0, 0]\n        Day 2: [0, 0, 0, 0, 1, 1, 1, 0]\n        Day 3: [0, 1, 1, 0, 0, 1, 0, 0]\n        Day 4: [0, 0, 0, 0, 0, 1, 0, 0]\n        Day 5: [0, 1, 1, 1, 0, 1, 0, 0]\n        Day 6: [0, 0, 1, 0, 1, 1, 0, 0]\n        Day 7: [0, 0, 1, 1, 0, 0, 0, 0]\n        Example 2:\n        Input: cells = [1,0,0,1,0,0,1,0], n = 1000000000\n        Output: [0,0,1,1,1,1,1,0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":768,"row":{"number":958,"difficulty":1,"question":"class Solution:\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Given the root of a binary tree, determine if it is a complete binary tree.\n        In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n        Example 1:\n        Input: root = [1,2,3,4,5,6]\n        Output: true\n        Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.\n        Example 2:\n        Input: root = [1,2,3,4,5,null,7]\n        Output: false\n        Explanation: The node with value 7 isn't as far left as possible.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":769,"row":{"number":959,"difficulty":1,"question":"class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        \"\"\"\n        An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\\', or blank space ' '. These characters divide the square into contiguous regions.\n        Given the grid grid represented as a string array, return the number of regions.\n        Note that backslash characters are escaped, so a '\\' is represented as '\\\\'.\n        Example 1:\n        Input: grid = [\" /\",\"/ \"]\n        Output: 2\n        Example 2:\n        Input: grid = [\" /\",\"  \"]\n        Output: 1\n        Example 3:\n        Input: grid = [\"/\\\\\",\"\\\\/\"]\n        Output: 5\n        Explanation: Recall that because \\ characters are escaped, \"\\\\/\" refers to \\/, and \"/\\\\\" refers to /\\.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":770,"row":{"number":960,"difficulty":2,"question":"class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        \"\"\"\n        You are given an array of n strings strs, all of the same length.\n        We may choose any deletion indices, and we delete all the characters in those indices for each string.\n        For example, if we have strs = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\", \"vyz\"].\n        Suppose we chose a set of deletion indices answer such that after deletions, the final array has every string (row) in lexicographic order. (i.e., (strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1]), and (strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1]), and so on). Return the minimum possible value of answer.length.\n        Example 1:\n        Input: strs = [\"babca\",\"bbazb\"]\n        Output: 3\n        Explanation: After deleting columns 0, 1, and 4, the final array is strs = [\"bc\", \"az\"].\n        Both these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]).\n        Note that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order.\n        Example 2:\n        Input: strs = [\"edcba\"]\n        Output: 4\n        Explanation: If we delete less than 4 columns, the only row will not be lexicographically sorted.\n        Example 3:\n        Input: strs = [\"ghi\",\"def\",\"abc\"]\n        Output: 0\n        Explanation: All rows are already lexicographically sorted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":771,"row":{"number":961,"difficulty":0,"question":"class Solution:\n    def repeatedNTimes(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums with the following properties:\n            nums.length == 2 * n.\n            nums contains n + 1 unique elements.\n            Exactly one element of nums is repeated n times.\n        Return the element that is repeated n times.\n        Example 1:\n        Input: nums = [1,2,3,3]\n        Output: 3\n        Example 2:\n        Input: nums = [2,1,2,5,3,2]\n        Output: 2\n        Example 3:\n        Input: nums = [5,1,5,2,5,3,5,4]\n        Output: 5\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":772,"row":{"number":962,"difficulty":1,"question":"class Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        \"\"\"\n        A ramp in an integer array nums is a pair (i, j) for which i < j and nums[i] <= nums[j]. The width of such a ramp is j - i.\n        Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.\n        Example 1:\n        Input: nums = [6,0,8,2,1,5]\n        Output: 4\n        Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.\n        Example 2:\n        Input: nums = [9,8,1,0,1,9,4,0,4,1]\n        Output: 7\n        Explanation: The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":773,"row":{"number":963,"difficulty":1,"question":"class Solution:\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\n        \"\"\"\n        You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\n        Return the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the X and Y axes. If there is not any such rectangle, return 0.\n        Answers within 10-5 of the actual answer will be accepted.\n        Example 1:\n        Input: points = [[1,2],[2,1],[1,0],[0,1]]\n        Output: 2.00000\n        Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.\n        Example 2:\n        Input: points = [[0,1],[2,1],[1,1],[1,0],[2,0]]\n        Output: 1.00000\n        Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.\n        Example 3:\n        Input: points = [[0,3],[1,2],[3,1],[1,3],[2,1]]\n        Output: 0\n        Explanation: There is no possible rectangle to form from these points.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":774,"row":{"number":964,"difficulty":2,"question":"class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        \"\"\"\n        Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3.\n        When writing such an expression, we adhere to the following conventions:\n            The division operator (/) returns rational numbers.\n            There are no parentheses placed anywhere.\n            We use the usual order of operations: multiplication and division happen before addition and subtraction.\n            It is not allowed to use the unary negation operator (-). For example, \"x - x\" is a valid expression as it only uses subtraction, but \"-x + x\" is not because it uses negation.\n        We would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used.\n        Example 1:\n        Input: x = 3, target = 19\n        Output: 5\n        Explanation: 3 * 3 + 3 * 3 + 3 / 3.\n        The expression contains 5 operations.\n        Example 2:\n        Input: x = 5, target = 501\n        Output: 8\n        Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.\n        The expression contains 8 operations.\n        Example 3:\n        Input: x = 100, target = 100000000\n        Output: 3\n        Explanation: 100 * 100 * 100 * 100.\n        The expression contains 3 operations.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":775,"row":{"number":965,"difficulty":0,"question":"class Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        A binary tree is uni-valued if every node in the tree has the same value.\n        Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise.\n        Example 1:\n        Input: root = [1,1,1,1,1,null,1]\n        Output: true\n        Example 2:\n        Input: root = [2,2,2,5,2]\n        Output: false\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":776,"row":{"number":966,"difficulty":1,"question":"class Solution:\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\n        \"\"\"\n        Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.\n        For a given query word, the spell checker handles two categories of spelling mistakes:\n            Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.\n                Example: wordlist = [\"yellow\"], query = \"YellOw\": correct = \"yellow\"\n                Example: wordlist = [\"Yellow\"], query = \"yellow\": correct = \"Yellow\"\n                Example: wordlist = [\"yellow\"], query = \"yellow\": correct = \"yellow\"\n            Vowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist.\n                Example: wordlist = [\"YellOw\"], query = \"yollow\": correct = \"YellOw\"\n                Example: wordlist = [\"YellOw\"], query = \"yeellow\": correct = \"\" (no match)\n                Example: wordlist = [\"YellOw\"], query = \"yllw\": correct = \"\" (no match)\n        In addition, the spell checker operates under the following precedence rules:\n            When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\n            When the query matches a word up to capitlization, you should return the first such match in the wordlist.\n            When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\n            If the query has no matches in the wordlist, you should return the empty string.\n        Given some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].\n        Example 1:\n        Input: wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], queries = [\"kite\",\"Kite\",\"KiTe\",\"Hare\",\"HARE\",\"Hear\",\"hear\",\"keti\",\"keet\",\"keto\"]\n        Output: [\"kite\",\"KiTe\",\"KiTe\",\"Hare\",\"hare\",\"\",\"\",\"KiTe\",\"\",\"KiTe\"]\n        Example 2:\n        Input: wordlist = [\"yellow\"], queries = [\"YellOw\"]\n        Output: [\"yellow\"]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":777,"row":{"number":967,"difficulty":1,"question":"class Solution:\n    def numsSameConsecDiff(self, n: int, k: int) -> List[int]:\n        \"\"\"\n        Given two integers n and k, return an array of all the integers of length n where the difference between every two consecutive digits is k. You may return the answer in any order.\n        Note that the integers should not have leading zeros. Integers as 02 and 043 are not allowed.\n        Example 1:\n        Input: n = 3, k = 7\n        Output: [181,292,707,818,929]\n        Explanation: Note that 070 is not a valid number, because it has leading zeroes.\n        Example 2:\n        Input: n = 2, k = 1\n        Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":778,"row":{"number":968,"difficulty":2,"question":"class Solution:\n    def minCameraCover(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\n        Return the minimum number of cameras needed to monitor all nodes of the tree.\n        Example 1:\n        Input: root = [0,0,null,0,0]\n        Output: 1\n        Explanation: One camera is enough to monitor all nodes if placed as shown.\n        Example 2:\n        Input: root = [0,0,null,0,null,0,null,null,0]\n        Output: 2\n        Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":779,"row":{"number":969,"difficulty":1,"question":"class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        \"\"\"\n        Given an array of integers arr, sort the array by performing a series of pancake flips.\n        In one pancake flip we do the following steps:\n            Choose an integer k where 1 <= k <= arr.length.\n            Reverse the sub-array arr[0...k-1] (0-indexed).\n        For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.\n        Return an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.\n        Example 1:\n        Input: arr = [3,2,4,1]\n        Output: [4,2,4,3]\n        Explanation: \n        We perform 4 pancake flips, with k values 4, 2, 4, and 3.\n        Starting state: arr = [3, 2, 4, 1]\n        After 1st flip (k = 4): arr = [1, 4, 2, 3]\n        After 2nd flip (k = 2): arr = [4, 1, 2, 3]\n        After 3rd flip (k = 4): arr = [3, 2, 1, 4]\n        After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.\n        Example 2:\n        Input: arr = [1,2,3]\n        Output: []\n        Explanation: The input is already sorted, so there is no need to flip anything.\n        Note that other answers, such as [3, 3], would also be accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":780,"row":{"number":970,"difficulty":1,"question":"class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        \"\"\"\n        Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\n        An integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\n        You may return the answer in any order. In your answer, each value should occur at most once.\n        Example 1:\n        Input: x = 2, y = 3, bound = 10\n        Output: [2,3,4,5,7,9,10]\n        Explanation:\n        2 = 20 + 30\n        3 = 21 + 30\n        4 = 20 + 31\n        5 = 21 + 31\n        7 = 22 + 31\n        9 = 23 + 30\n        10 = 20 + 32\n        Example 2:\n        Input: x = 3, y = 5, bound = 15\n        Output: [2,4,6,8,10,14]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":781,"row":{"number":971,"difficulty":1,"question":"class Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        \"\"\"\n        You are given the root of a binary tree with n nodes, where each node is uniquely assigned a value from 1 to n. You are also given a sequence of n values voyage, which is the desired pre-order traversal of the binary tree.\n        Any node in the binary tree can be flipped by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n        Flip the smallest number of nodes so that the pre-order traversal of the tree matches voyage.\n        Return a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match voyage, return the list [-1].\n        Example 1:\n        Input: root = [1,2], voyage = [2,1]\n        Output: [-1]\n        Explanation: It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n        Example 2:\n        Input: root = [1,2,3], voyage = [1,3,2]\n        Output: [1]\n        Explanation: Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n        Example 3:\n        Input: root = [1,2,3], voyage = [1,2,3]\n        Output: []\n        Explanation: The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":782,"row":{"number":972,"difficulty":2,"question":"class Solution:\n    def isRationalEqual(self, s: str, t: str) -> bool:\n        \"\"\"\n        Given two strings s and t, each of which represents a non-negative rational number, return true if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\n        A rational number can be represented using up to three parts: <IntegerPart>, <NonRepeatingPart>, and a <RepeatingPart>. The number will be represented in one of the following three ways:\n            <IntegerPart>\n                For example, 12, 0, and 123.\n            <IntegerPart><.><NonRepeatingPart>\n                For example, 0.5, 1., 2.12, and 123.0001.\n            <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>\n                For example, 0.1(6), 1.(9), 123.00(1212).\n        The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:\n            1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66).\n        Example 1:\n        Input: s = \"0.(52)\", t = \"0.5(25)\"\n        Output: true\n        Explanation: Because \"0.(52)\" represents 0.52525252..., and \"0.5(25)\" represents 0.52525252525..... , the strings represent the same number.\n        Example 2:\n        Input: s = \"0.1666(6)\", t = \"0.166(66)\"\n        Output: true\n        Example 3:\n        Input: s = \"0.9(9)\", t = \"1.\"\n        Output: true\n        Explanation: \"0.9(9)\" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]\n        \"1.\" represents the number 1, which is formed correctly: (IntegerPart) = \"1\" and (NonRepeatingPart) = \"\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":783,"row":{"number":509,"difficulty":0,"question":"class Solution:\n    def fib(self, n: int) -> int:\n        \"\"\"\n        The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n        F(0) = 0, F(1) = 1\n        F(n) = F(n - 1) + F(n - 2), for n > 1.\n        Given n, calculate F(n).\n        Example 1:\n        Input: n = 2\n        Output: 1\n        Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\n        Example 2:\n        Input: n = 3\n        Output: 2\n        Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\n        Example 3:\n        Input: n = 4\n        Output: 3\n        Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":784,"row":{"number":973,"difficulty":1,"question":"class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\n        The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).\n        You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\n        Example 1:\n        Input: points = [[1,3],[-2,2]], k = 1\n        Output: [[-2,2]]\n        Explanation:\n        The distance between (1, 3) and the origin is sqrt(10).\n        The distance between (-2, 2) and the origin is sqrt(8).\n        Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\n        We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n        Example 2:\n        Input: points = [[3,3],[5,-1],[-2,4]], k = 2\n        Output: [[3,3],[-2,4]]\n        Explanation: The answer [[-2,4],[3,3]] would also be accepted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":785,"row":{"number":974,"difficulty":1,"question":"class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\n        A subarray is a contiguous part of an array.\n        Example 1:\n        Input: nums = [4,5,0,-2,-3,1], k = 5\n        Output: 7\n        Explanation: There are 7 subarrays with a sum divisible by k = 5:\n        [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n        Example 2:\n        Input: nums = [5], k = 9\n        Output: 0\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":786,"row":{"number":975,"difficulty":2,"question":"class Solution:\n    def oddEvenJumps(self, arr: List[int]) -> int:\n        \"\"\"\n        You are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\n        You may jump forward from index i to index j (with i < j) in the following way:\n            During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that arr[i] <= arr[j] and arr[j] is the smallest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\n            During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index j such that arr[i] >= arr[j] and arr[j] is the largest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\n            It may be the case that for some index i, there are no legal jumps.\n        A starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once).\n        Return the number of good starting indices.\n        Example 1:\n        Input: arr = [10,13,12,14,15]\n        Output: 2\n        Explanation: \n        From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.\n        From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\n        From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\n        From starting index i = 4, we have reached the end already.\n        In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\n        jumps.\n        Example 2:\n        Input: arr = [2,3,1,1,4]\n        Output: 3\n        Explanation: \n        From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\n        During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].\n        During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\n        During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].\n        We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\n        In a similar manner, we can deduce that:\n        From starting index i = 1, we jump to i = 4, so we reach the end.\n        From starting index i = 2, we jump to i = 3, and then we can't jump anymore.\n        From starting index i = 3, we jump to i = 4, so we reach the end.\n        From starting index i = 4, we are already at the end.\n        In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\n        number of jumps.\n        Example 3:\n        Input: arr = [5,1,3,4,2]\n        Output: 3\n        Explanation: We can reach the end from starting indices 1, 2, and 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":787,"row":{"number":976,"difficulty":0,"question":"class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.\n        Example 1:\n        Input: nums = [2,1,2]\n        Output: 5\n        Explanation: You can form a triangle with three side lengths: 1, 2, and 2.\n        Example 2:\n        Input: nums = [1,2,1,10]\n        Output: 0\n        Explanation: \n        You cannot use the side lengths 1, 1, and 2 to form a triangle.\n        You cannot use the side lengths 1, 1, and 10 to form a triangle.\n        You cannot use the side lengths 1, 2, and 10 to form a triangle.\n        As we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":788,"row":{"number":977,"difficulty":0,"question":"class Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n        Example 1:\n        Input: nums = [-4,-1,0,3,10]\n        Output: [0,1,9,16,100]\n        Explanation: After squaring, the array becomes [16,1,0,9,100].\n        After sorting, it becomes [0,1,9,16,100].\n        Example 2:\n        Input: nums = [-7,-3,2,3,11]\n        Output: [4,9,9,49,121]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":789,"row":{"number":978,"difficulty":1,"question":"class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        \"\"\"\n        Given an integer array arr, return the length of a maximum size turbulent subarray of arr.\n        A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\n        More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:\n            For i <= k < j:\n                arr[k] > arr[k + 1] when k is odd, and\n                arr[k] < arr[k + 1] when k is even.\n            Or, for i <= k < j:\n                arr[k] > arr[k + 1] when k is even, and\n                arr[k] < arr[k + 1] when k is odd.\n        Example 1:\n        Input: arr = [9,4,2,10,7,8,8,1,9]\n        Output: 5\n        Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]\n        Example 2:\n        Input: arr = [4,8,12,16]\n        Output: 2\n        Example 3:\n        Input: arr = [100]\n        Output: 1\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":790,"row":{"number":979,"difficulty":1,"question":"class Solution:\n    def distributeCoins(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\n        In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\n        Return the minimum number of moves required to make every node have exactly one coin.\n        Example 1:\n        Input: root = [3,0,0]\n        Output: 2\n        Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.\n        Example 2:\n        Input: root = [0,3,0]\n        Output: 3\n        Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":791,"row":{"number":980,"difficulty":2,"question":"class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid where grid[i][j] could be:\n            1 representing the starting square. There is exactly one starting square.\n            2 representing the ending square. There is exactly one ending square.\n            0 representing empty squares we can walk over.\n            -1 representing obstacles that we cannot walk over.\n        Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n        Example 1:\n        Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\n        Output: 2\n        Explanation: We have the following two paths: \n        1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n        2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n        Example 2:\n        Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\n        Output: 4\n        Explanation: We have the following four paths: \n        1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n        2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n        3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n        4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n        Example 3:\n        Input: grid = [[0,1],[2,0]]\n        Output: 0\n        Explanation: There is no path that walks over every empty square exactly once.\n        Note that the starting and ending square can be anywhere in the grid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":792,"row":{"number":981,"difficulty":1,"question":"class TimeMap:\n    def __init__(self):\n    def set(self, key: str, value: str, timestamp: int) -> None:\n    def get(self, key: str, timestamp: int) -> str:\n        \"\"\"\n        Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\n        Implement the TimeMap class:\n            TimeMap() Initializes the object of the data structure.\n            void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.\n            String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns \"\".\n        Example 1:\n        Input\n        [\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n        [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\n        Output\n        [null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n        Explanation\n        TimeMap timeMap = new TimeMap();\n        timeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\n        timeMap.get(\"foo\", 1);         // return \"bar\"\n        timeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\n        timeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\n        timeMap.get(\"foo\", 4);         // return \"bar2\"\n        timeMap.get(\"foo\", 5);         // return \"bar2\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":793,"row":{"number":982,"difficulty":2,"question":"class Solution:\n    def countTriplets(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the number of AND triples.\n        An AND triple is a triple of indices (i, j, k) such that:\n            0 <= i < nums.length\n            0 <= j < nums.length\n            0 <= k < nums.length\n            nums[i] & nums[j] & nums[k] == 0, where & represents the bitwise-AND operator.\n        Example 1:\n        Input: nums = [2,1,3]\n        Output: 12\n        Explanation: We could choose the following i, j, k triples:\n        (i=0, j=0, k=1) : 2 & 2 & 1\n        (i=0, j=1, k=0) : 2 & 1 & 2\n        (i=0, j=1, k=1) : 2 & 1 & 1\n        (i=0, j=1, k=2) : 2 & 1 & 3\n        (i=0, j=2, k=1) : 2 & 3 & 1\n        (i=1, j=0, k=0) : 1 & 2 & 2\n        (i=1, j=0, k=1) : 1 & 2 & 1\n        (i=1, j=0, k=2) : 1 & 2 & 3\n        (i=1, j=1, k=0) : 1 & 1 & 2\n        (i=1, j=2, k=0) : 1 & 3 & 2\n        (i=2, j=0, k=1) : 3 & 2 & 1\n        (i=2, j=1, k=0) : 3 & 1 & 2\n        Example 2:\n        Input: nums = [0,0,0]\n        Output: 27\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":794,"row":{"number":983,"difficulty":1,"question":"class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        \"\"\"\n        You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\n        Train tickets are sold in three different ways:\n            a 1-day pass is sold for costs[0] dollars,\n            a 7-day pass is sold for costs[1] dollars, and\n            a 30-day pass is sold for costs[2] dollars.\n        The passes allow that many days of consecutive travel.\n            For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n        Return the minimum number of dollars you need to travel every day in the given list of days.\n        Example 1:\n        Input: days = [1,4,6,7,8,20], costs = [2,7,15]\n        Output: 11\n        Explanation: For example, here is one way to buy passes that lets you travel your travel plan:\n        On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\n        On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\n        On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\n        In total, you spent $11 and covered all the days of your travel.\n        Example 2:\n        Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\n        Output: 17\n        Explanation: For example, here is one way to buy passes that lets you travel your travel plan:\n        On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\n        On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\n        In total, you spent $17 and covered all the days of your travel.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":795,"row":{"number":984,"difficulty":1,"question":"class Solution:\n    def strWithout3a3b(self, a: int, b: int) -> str:\n        \"\"\"\n        Given two integers a and b, return any string s such that:\n            s has length a + b and contains exactly a 'a' letters, and exactly b 'b' letters,\n            The substring 'aaa' does not occur in s, and\n            The substring 'bbb' does not occur in s.\n        Example 1:\n        Input: a = 1, b = 2\n        Output: \"abb\"\n        Explanation: \"abb\", \"bab\" and \"bba\" are all correct answers.\n        Example 2:\n        Input: a = 4, b = 1\n        Output: \"aabaa\"\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":796,"row":{"number":985,"difficulty":1,"question":"class Solution:\n    def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given an integer array nums and an array queries where queries[i] = [vali, indexi].\n        For each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums.\n        Return an integer array answer where answer[i] is the answer to the ith query.\n        Example 1:\n        Input: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]\n        Output: [8,6,2,4]\n        Explanation: At the beginning, the array is [1,2,3,4].\n        After adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.\n        After adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.\n        After adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.\n        After adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.\n        Example 2:\n        Input: nums = [1], queries = [[4,0]]\n        Output: [0]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":797,"row":{"number":986,"difficulty":1,"question":"class Solution:\n    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order.\n        Return the intersection of these two interval lists.\n        A closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b.\n        The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].\n        Example 1:\n        Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n        Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n        Example 2:\n        Input: firstList = [[1,3],[5,9]], secondList = []\n        Output: []\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":798,"row":{"number":987,"difficulty":2,"question":"class Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Given the root of a binary tree, calculate the vertical order traversal of the binary tree.\n        For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0).\n        The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\n        Return the vertical order traversal of the binary tree.\n        Example 1:\n        Input: root = [3,9,20,null,null,15,7]\n        Output: [[9],[3,15],[20],[7]]\n        Explanation:\n        Column -1: Only node 9 is in this column.\n        Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.\n        Column 1: Only node 20 is in this column.\n        Column 2: Only node 7 is in this column.\n        Example 2:\n        Input: root = [1,2,3,4,5,6,7]\n        Output: [[4],[2],[1,5,6],[3],[7]]\n        Explanation:\n        Column -2: Only node 4 is in this column.\n        Column -1: Only node 2 is in this column.\n        Column 0: Nodes 1, 5, and 6 are in this column.\n                  1 is at the top, so it comes first.\n                  5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\n        Column 1: Only node 3 is in this column.\n        Column 2: Only node 7 is in this column.\n        Example 3:\n        Input: root = [1,2,3,4,6,5,7]\n        Output: [[4],[2],[1,5,6],[3],[7]]\n        Explanation:\n        This case is the exact same as example 2, but with nodes 5 and 6 swapped.\n        Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":799,"row":{"number":988,"difficulty":1,"question":"class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        \"\"\"\n        You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\n        Return the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\n        As a reminder, any shorter prefix of a string is lexicographically smaller.\n            For example, \"ab\" is lexicographically smaller than \"aba\".\n        A leaf of a node is a node that has no children.\n        Example 1:\n        Input: root = [0,1,2,3,4,3,4]\n        Output: \"dba\"\n        Example 2:\n        Input: root = [25,1,3,1,3,0,2]\n        Output: \"adz\"\n        Example 3:\n        Input: root = [2,2,1,null,1,0,null,0]\n        Output: \"abc\"\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}