{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1700,"row":{"number":2180,"difficulty":0,"question":"class Solution:\n    def countEven(self, num: int) -> int:\n        \"\"\"\n        Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even.\n        The digit sum of a positive integer is the sum of all its digits.\n        Example 1:\n        Input: num = 4\n        Output: 2\n        Explanation:\n        The only integers less than or equal to 4 whose digit sums are even are 2 and 4.    \n        Example 2:\n        Input: num = 30\n        Output: 14\n        Explanation:\n        The 14 integers less than or equal to 30 whose digit sums are even are\n        2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1701,"row":{"number":2181,"difficulty":1,"question":"class Solution:\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.\n        For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.\n        Return the head of the modified linked list.\n        Example 1:\n        Input: head = [0,3,1,0,4,5,2,0]\n        Output: [4,11]\n        Explanation: \n        The above figure represents the given linked list. The modified list contains\n        - The sum of the nodes marked in green: 3 + 1 = 4.\n        - The sum of the nodes marked in red: 4 + 5 + 2 = 11.\n        Example 2:\n        Input: head = [0,1,0,3,0,2,2,0]\n        Output: [1,3,4]\n        Explanation: \n        The above figure represents the given linked list. The modified list contains\n        - The sum of the nodes marked in green: 1 = 1.\n        - The sum of the nodes marked in red: 3 = 3.\n        - The sum of the nodes marked in yellow: 2 + 2 = 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1702,"row":{"number":2182,"difficulty":1,"question":"class Solution:\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n        \"\"\"\n        You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s.\n        Return the lexicographically largest repeatLimitedString possible.\n        A string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the longer string is the lexicographically larger one.\n        Example 1:\n        Input: s = \"cczazcc\", repeatLimit = 3\n        Output: \"zzcccac\"\n        Explanation: We use all of the characters from s to construct the repeatLimitedString \"zzcccac\".\n        The letter 'a' appears at most 1 time in a row.\n        The letter 'c' appears at most 3 times in a row.\n        The letter 'z' appears at most 2 times in a row.\n        Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\n        The string is the lexicographically largest repeatLimitedString possible so we return \"zzcccac\".\n        Note that the string \"zzcccca\" is lexicographically larger but the letter 'c' appears more than 3 times in a row, so it is not a valid repeatLimitedString.\n        Example 2:\n        Input: s = \"aababab\", repeatLimit = 2\n        Output: \"bbabaa\"\n        Explanation: We use only some of the characters from s to construct the repeatLimitedString \"bbabaa\". \n        The letter 'a' appears at most 2 times in a row.\n        The letter 'b' appears at most 2 times in a row.\n        Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\n        The string is the lexicographically largest repeatLimitedString possible so we return \"bbabaa\".\n        Note that the string \"bbabaaa\" is lexicographically larger but the letter 'a' appears more than 2 times in a row, so it is not a valid repeatLimitedString.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1703,"row":{"number":2183,"difficulty":2,"question":"class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that:\n            0 <= i < j <= n - 1 and\n            nums[i] * nums[j] is divisible by k.\n        Example 1:\n        Input: nums = [1,2,3,4,5], k = 2\n        Output: 7\n        Explanation: \n        The 7 pairs of indices whose corresponding products are divisible by 2 are\n        (0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4).\n        Their products are 2, 4, 6, 8, 10, 12, and 20 respectively.\n        Other pairs such as (0, 2) and (2, 4) have products 3 and 15 respectively, which are not divisible by 2.    \n        Example 2:\n        Input: nums = [1,2,3,4], k = 5\n        Output: 0\n        Explanation: There does not exist any pair of indices whose corresponding product is divisible by 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1704,"row":{"number":2194,"difficulty":0,"question":"class Solution:\n    def cellsInRange(self, s: str) -> List[str]:\n        \"\"\"\n        A cell (r, c) of an excel sheet is represented as a string \"<col><row>\" where:\n            <col> denotes the column number c of the cell. It is represented by alphabetical letters.\n                For example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd by 'C', and so on.\n            <row> is the row number r of the cell. The rth row is represented by the integer r.\n        You are given a string s in the format \"<col1><row1>:<col2><row2>\", where <col1> represents the column c1, <row1> represents the row r1, <col2> represents the column c2, and <row2> represents the row r2, such that r1 <= r2 and c1 <= c2.\n        Return the list of cells (x, y) such that r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as strings in the format mentioned above and be sorted in non-decreasing order first by columns and then by rows.\n        Example 1:\n        Input: s = \"K1:L2\"\n        Output: [\"K1\",\"K2\",\"L1\",\"L2\"]\n        Explanation:\n        The above diagram shows the cells which should be present in the list.\n        The red arrows denote the order in which the cells should be presented.\n        Example 2:\n        Input: s = \"A1:F1\"\n        Output: [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\n        Explanation:\n        The above diagram shows the cells which should be present in the list.\n        The red arrow denotes the order in which the cells should be presented.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1705,"row":{"number":2195,"difficulty":1,"question":"class Solution:\n    def minimalKSum(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum.\n        Return the sum of the k integers appended to nums.\n        Example 1:\n        Input: nums = [1,4,25,10,25], k = 2\n        Output: 5\n        Explanation: The two unique positive integers that do not appear in nums which we append are 2 and 3.\n        The resulting sum of nums is 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum.\n        The sum of the two integers appended is 2 + 3 = 5, so we return 5.\n        Example 2:\n        Input: nums = [5,6], k = 6\n        Output: 25\n        Explanation: The six unique positive integers that do not appear in nums which we append are 1, 2, 3, 4, 7, and 8.\n        The resulting sum of nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the minimum. \n        The sum of the six integers appended is 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1706,"row":{"number":2196,"difficulty":1,"question":"class Solution:\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\n        \"\"\"\n        You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,\n            If isLefti == 1, then childi is the left child of parenti.\n            If isLefti == 0, then childi is the right child of parenti.\n        Construct the binary tree described by descriptions and return its root.\n        The test cases will be generated such that the binary tree is valid.\n        Example 1:\n        Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\n        Output: [50,20,80,15,17,19]\n        Explanation: The root node is the node with value 50 since it has no parent.\n        The resulting binary tree is shown in the diagram.\n        Example 2:\n        Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]]\n        Output: [1,2,null,null,3,4]\n        Explanation: The root node is the node with value 1 since it has no parent.\n        The resulting binary tree is shown in the diagram.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1707,"row":{"number":2197,"difficulty":2,"question":"class Solution:\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given an array of integers nums. Perform the following steps:\n            Find any two adjacent numbers in nums that are non-coprime.\n            If no such numbers are found, stop the process.\n            Otherwise, delete the two numbers and replace them with their LCM (Least Common Multiple).\n            Repeat this process as long as you keep finding two adjacent non-coprime numbers.\n        Return the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\n        The test cases are generated such that the values in the final array are less than or equal to 108.\n        Two values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.\n        Example 1:\n        Input: nums = [6,4,3,2,7,6,2]\n        Output: [12,7,6]\n        Explanation: \n        - (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2].\n        - (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2].\n        - (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2].\n        - (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6].\n        There are no more adjacent non-coprime numbers in nums.\n        Thus, the final modified array is [12,7,6].\n        Note that there are other ways to obtain the same resultant array.\n        Example 2:\n        Input: nums = [2,2,1,1,3,3,3]\n        Output: [2,1,1,3]\n        Explanation: \n        - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3].\n        - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3].\n        - (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3].\n        There are no more adjacent non-coprime numbers in nums.\n        Thus, the final modified array is [2,1,1,3].\n        Note that there are other ways to obtain the same resultant array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1708,"row":{"number":2206,"difficulty":0,"question":"class Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums consisting of 2 * n integers.\n        You need to divide nums into n pairs such that:\n            Each element belongs to exactly one pair.\n            The elements present in a pair are equal.\n        Return true if nums can be divided into n pairs, otherwise return false.\n        Example 1:\n        Input: nums = [3,2,3,2,2,2]\n        Output: true\n        Explanation: \n        There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.\n        If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: false\n        Explanation: \n        There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1709,"row":{"number":2207,"difficulty":1,"question":"class Solution:\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\n        \"\"\"\n        You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.\n        You can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.\n        Return the maximum number of times pattern can occur as a subsequence of the modified text.\n        A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n        Example 1:\n        Input: text = \"abdcdbc\", pattern = \"ac\"\n        Output: 4\n        Explanation:\n        If we add pattern[0] = 'a' in between text[1] and text[2], we get \"abadcdbc\". Now, the number of times \"ac\" occurs as a subsequence is 4.\n        Some other strings which have 4 subsequences \"ac\" after adding a character to text are \"aabdcdbc\" and \"abdacdbc\".\n        However, strings such as \"abdcadbc\", \"abdccdbc\", and \"abdcdbcc\", although obtainable, have only 3 subsequences \"ac\" and are thus suboptimal.\n        It can be shown that it is not possible to get more than 4 subsequences \"ac\" by adding only one character.\n        Example 2:\n        Input: text = \"aabb\", pattern = \"ab\"\n        Output: 6\n        Explanation:\n        Some of the strings which can be obtained from text and have 6 subsequences \"ab\" are \"aaabb\", \"aaabb\", and \"aabbb\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1710,"row":{"number":2208,"difficulty":1,"question":"class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)\n        Return the minimum number of operations to reduce the sum of nums by at least half.\n        Example 1:\n        Input: nums = [5,19,8,1]\n        Output: 3\n        Explanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\n        The following is one of the ways to reduce the sum by at least half:\n        Pick the number 19 and reduce it to 9.5.\n        Pick the number 9.5 and reduce it to 4.75.\n        Pick the number 8 and reduce it to 4.\n        The final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \n        The sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.\n        Overall, 3 operations were used so we return 3.\n        It can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n        Example 2:\n        Input: nums = [3,8,20]\n        Output: 3\n        Explanation: The initial sum of nums is equal to 3 + 8 + 20 = 31.\n        The following is one of the ways to reduce the sum by at least half:\n        Pick the number 20 and reduce it to 10.\n        Pick the number 10 and reduce it to 5.\n        Pick the number 3 and reduce it to 1.5.\n        The final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. \n        The sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.\n        Overall, 3 operations were used so we return 3.\n        It can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1711,"row":{"number":2209,"difficulty":2,"question":"class Solution:\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\n        \"\"\"\n        You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor:\n            floor[i] = '0' denotes that the ith tile of the floor is colored black.\n            On the other hand, floor[i] = '1' denotes that the ith tile of the floor is colored white.\n        You are also given numCarpets and carpetLen. You have numCarpets black carpets, each of length carpetLen tiles. Cover the tiles with the given carpets such that the number of white tiles still visible is minimum. Carpets may overlap one another.\n        Return the minimum number of white tiles still visible.\n        Example 1:\n        Input: floor = \"10110101\", numCarpets = 2, carpetLen = 2\n        Output: 2\n        Explanation: \n        The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\n        No other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n        Example 2:\n        Input: floor = \"11111\", numCarpets = 2, carpetLen = 3\n        Output: 0\n        Explanation: \n        The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\n        Note that the carpets are able to overlap one another.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1712,"row":{"number":2190,"difficulty":0,"question":"class Solution:\n    def mostFrequent(self, nums: List[int], key: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums.\n        For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that:\n            0 <= i <= nums.length - 2,\n            nums[i] == key and,\n            nums[i + 1] == target.\n        Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.\n        Example 1:\n        Input: nums = [1,100,200,1,100], key = 1\n        Output: 100\n        Explanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.\n        No other integers follow an occurrence of key, so we return 100.\n        Example 2:\n        Input: nums = [2,2,2,2,3], key = 2\n        Output: 2\n        Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.\n        For target = 3, there is only one occurrence at index 4 which follows an occurrence of key.\n        target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1713,"row":{"number":2210,"difficulty":0,"question":"class Solution:\n    def countHillValley(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\n        Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\n        Return the number of hills and valleys in nums.\n        Example 1:\n        Input: nums = [2,4,1,1,6,5]\n        Output: 3\n        Explanation:\n        At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\n        At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \n        At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\n        At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\n        At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\n        At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \n        There are 3 hills and valleys so we return 3.\n        Example 2:\n        Input: nums = [6,6,5,5,4,1]\n        Output: 0\n        Explanation:\n        At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\n        At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\n        At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\n        At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\n        At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\n        At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\n        There are 0 hills and valleys so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1714,"row":{"number":2211,"difficulty":1,"question":"class Solution:\n    def countCollisions(self, directions: str) -> int:\n        \"\"\"\n        There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.\n        You are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.\n        The number of collisions can be calculated as follows:\n            When two cars moving in opposite directions collide with each other, the number of collisions increases by 2.\n            When a moving car collides with a stationary car, the number of collisions increases by 1.\n        After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\n        Return the total number of collisions that will happen on the road.\n        Example 1:\n        Input: directions = \"RLRSLL\"\n        Output: 5\n        Explanation:\n        The collisions that will happen on the road are:\n        - Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n        - Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n        - Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n        - Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\n        Thus, the total number of collisions that will happen on the road is 5. \n        Example 2:\n        Input: directions = \"LLRR\"\n        Output: 0\n        Explanation:\n        No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1715,"row":{"number":2212,"difficulty":1,"question":"class Solution:\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\n        \"\"\"\n        Alice and Bob are opponents in an archery competition. The competition has set the following rules:\n            Alice first shoots numArrows arrows and then Bob shoots numArrows arrows.\n            The points are then calculated as follows:\n                The target has integer scoring sections ranging from 0 to 11 inclusive.\n                For each section of the target with score k (in between 0 to 11), say Alice and Bob have shot ak and bk arrows on that section respectively. If ak >= bk, then Alice takes k points. If ak < bk, then Bob takes k points.\n                However, if ak == bk == 0, then nobody takes k points.\n            For example, if Alice and Bob both shot 2 arrows on the section with score 11, then Alice takes 11 points. On the other hand, if Alice shot 0 arrows on the section with score 11 and Bob shot 2 arrows on that same section, then Bob takes 11 points.\n        You are given the integer numArrows and an integer array aliceArrows of size 12, which represents the number of arrows Alice shot on each scoring section from 0 to 11. Now, Bob wants to maximize the total number of points he can obtain.\n        Return the array bobArrows which represents the number of arrows Bob shot on each scoring section from 0 to 11. The sum of the values in bobArrows should equal numArrows.\n        If there are multiple ways for Bob to earn the maximum total points, return any one of them.\n        Example 1:\n        Input: numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\n        Output: [0,0,0,0,1,1,0,0,1,2,3,1]\n        Explanation: The table above shows how the competition is scored. \n        Bob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\n        It can be shown that Bob cannot obtain a score higher than 47 points.\n        Example 2:\n        Input: numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n        Output: [0,0,0,0,0,0,0,0,1,1,1,0]\n        Explanation: The table above shows how the competition is scored.\n        Bob earns a total point of 8 + 9 + 10 = 27.\n        It can be shown that Bob cannot obtain a score higher than 27 points.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1716,"row":{"number":2213,"difficulty":2,"question":"class Solution:\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed string s. You are also given a 0-indexed string queryCharacters of length k and a 0-indexed array of integer indices queryIndices of length k, both of which are used to describe k queries.\n        The ith query updates the character in s at index queryIndices[i] to the character queryCharacters[i].\n        Return an array lengths of length k where lengths[i] is the length of the longest substring of s consisting of only one repeating character after the ith query is performed.\n        Example 1:\n        Input: s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3]\n        Output: [3,3,4]\n        Explanation: \n        - 1st query updates s = \"bbbacc\". The longest substring consisting of one repeating character is \"bbb\" with length 3.\n        - 2nd query updates s = \"bbbccc\". \n          The longest substring consisting of one repeating character can be \"bbb\" or \"ccc\" with length 3.\n        - 3rd query updates s = \"bbbbcc\". The longest substring consisting of one repeating character is \"bbbb\" with length 4.\n        Thus, we return [3,3,4].\n        Example 2:\n        Input: s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1]\n        Output: [2,3]\n        Explanation:\n        - 1st query updates s = \"abazz\". The longest substring consisting of one repeating character is \"zz\" with length 2.\n        - 2nd query updates s = \"aaazz\". The longest substring consisting of one repeating character is \"aaa\" with length 3.\n        Thus, we return [2,3].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1717,"row":{"number":2200,"difficulty":0,"question":"class Solution:\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.\n        Return a list of all k-distant indices sorted in increasing order.\n        Example 1:\n        Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1\n        Output: [1,2,3,4,5,6]\n        Explanation: Here, nums[2] == key and nums[5] == key.\n        - For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.\n        - For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.\n        - For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.\n        - For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.\n        - For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.\n        - For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.\n        - For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.\n        Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. \n        Example 2:\n        Input: nums = [2,2,2,2,2], key = 2, k = 2\n        Output: [0,1,2,3,4]\n        Explanation: For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. \n        Hence, we return [0,1,2,3,4].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1718,"row":{"number":2203,"difficulty":2,"question":"class Solution:\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n        \"\"\"\n        You are given an integer n denoting the number of nodes of a weighted directed graph. The nodes are numbered from 0 to n - 1.\n        You are also given a 2D integer array edges where edges[i] = [fromi, toi, weighti] denotes that there exists a directed edge from fromi to toi with weight weighti.\n        Lastly, you are given three distinct integers src1, src2, and dest denoting three distinct nodes of the graph.\n        Return the minimum weight of a subgraph of the graph such that it is possible to reach dest from both src1 and src2 via a set of edges of this subgraph. In case such a subgraph does not exist, return -1.\n        A subgraph is a graph whose vertices and edges are subsets of the original graph. The weight of a subgraph is the sum of weights of its constituent edges.\n        Example 1:\n        Input: n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\n        Output: 9\n        Explanation:\n        The above figure represents the input graph.\n        The blue edges represent one of the subgraphs that yield the optimal answer.\n        Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n        Example 2:\n        Input: n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\n        Output: -1\n        Explanation:\n        The above figure represents the input graph.\n        It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1719,"row":{"number":2220,"difficulty":0,"question":"class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        \"\"\"\n        A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n            For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n        Given two integers start and goal, return the minimum number of bit flips to convert start to goal.\n        Example 1:\n        Input: start = 10, goal = 7\n        Output: 3\n        Explanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n        - Flip the first bit from the right: 1010 -> 1011.\n        - Flip the third bit from the right: 1011 -> 1111.\n        - Flip the fourth bit from the right: 1111 -> 0111.\n        It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.\n        Example 2:\n        Input: start = 3, goal = 4\n        Output: 3\n        Explanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n        - Flip the first bit from the right: 011 -> 010.\n        - Flip the second bit from the right: 010 -> 000.\n        - Flip the third bit from the right: 000 -> 100.\n        It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1720,"row":{"number":2221,"difficulty":1,"question":"class Solution:\n    def triangularSum(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums, where nums[i] is a digit between 0 and 9 (inclusive).\n        The triangular sum of nums is the value of the only element present in nums after the following process terminates:\n            Let nums comprise of n elements. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n - 1.\n            For each index i, where 0 <= i < n - 1, assign the value of newNums[i] as (nums[i] + nums[i+1]) % 10, where % denotes modulo operator.\n            Replace the array nums with newNums.\n            Repeat the entire process starting from step 1.\n        Return the triangular sum of nums.\n        Example 1:\n        Input: nums = [1,2,3,4,5]\n        Output: 8\n        Explanation:\n        The above diagram depicts the process from which we obtain the triangular sum of the array.\n        Example 2:\n        Input: nums = [5]\n        Output: 5\n        Explanation:\n        Since there is only one element in nums, the triangular sum is the value of that element itself.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1721,"row":{"number":2222,"difficulty":1,"question":"class Solution:\n    def numberOfWays(self, s: str) -> int:\n        \"\"\"\n        You are given a 0-indexed binary string s which represents the types of buildings along a street where:\n            s[i] = '0' denotes that the ith building is an office and\n            s[i] = '1' denotes that the ith building is a restaurant.\n        As a city official, you would like to select 3 buildings for random inspection. However, to ensure variety, no two consecutive buildings out of the selected buildings can be of the same type.\n            For example, given s = \"001101\", we cannot select the 1st, 3rd, and 5th buildings as that would form \"011\" which is not allowed due to having two consecutive buildings of the same type.\n        Return the number of valid ways to select 3 buildings.\n        Example 1:\n        Input: s = \"001101\"\n        Output: 6\n        Explanation: \n        The following sets of indices selected are valid:\n        - [0,2,4] from \"001101\" forms \"010\"\n        - [0,3,4] from \"001101\" forms \"010\"\n        - [1,2,4] from \"001101\" forms \"010\"\n        - [1,3,4] from \"001101\" forms \"010\"\n        - [2,4,5] from \"001101\" forms \"101\"\n        - [3,4,5] from \"001101\" forms \"101\"\n        No other selection is valid. Thus, there are 6 total ways.\n        Example 2:\n        Input: s = \"11100\"\n        Output: 0\n        Explanation: It can be shown that there are no valid selections.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1722,"row":{"number":2223,"difficulty":2,"question":"class Solution:\n    def sumScores(self, s: str) -> int:\n        \"\"\"\n        You are building a string s of length n one character at a time, prepending each new character to the front of the string. The strings are labeled from 1 to n, where the string with length i is labeled si.\n            For example, for s = \"abaca\", s1 == \"a\", s2 == \"ca\", s3 == \"aca\", etc.\n        The score of si is the length of the longest common prefix between si and sn (Note that s == sn).\n        Given the final string s, return the sum of the score of every si.\n        Example 1:\n        Input: s = \"babab\"\n        Output: 9\n        Explanation:\n        For s1 == \"b\", the longest common prefix is \"b\" which has a score of 1.\n        For s2 == \"ab\", there is no common prefix so the score is 0.\n        For s3 == \"bab\", the longest common prefix is \"bab\" which has a score of 3.\n        For s4 == \"abab\", there is no common prefix so the score is 0.\n        For s5 == \"babab\", the longest common prefix is \"babab\" which has a score of 5.\n        The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.\n        Example 2:\n        Input: s = \"azbazbzaz\"\n        Output: 14\n        Explanation: \n        For s2 == \"az\", the longest common prefix is \"az\" which has a score of 2.\n        For s6 == \"azbzaz\", the longest common prefix is \"azb\" which has a score of 3.\n        For s9 == \"azbazbzaz\", the longest common prefix is \"azbazbzaz\" which has a score of 9.\n        For all other si, the score is 0.\n        The sum of the scores is 2 + 3 + 9 = 14, so we return 14.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1723,"row":{"number":2231,"difficulty":0,"question":"class Solution:\n    def largestInteger(self, num: int) -> int:\n        \"\"\"\n        You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\n        Return the largest possible value of num after any number of swaps.\n        Example 1:\n        Input: num = 1234\n        Output: 3412\n        Explanation: Swap the digit 3 with the digit 1, this results in the number 3214.\n        Swap the digit 2 with the digit 4, this results in the number 3412.\n        Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\n        Also note that we may not swap the digit 4 with the digit 1 since they are of different parities.\n        Example 2:\n        Input: num = 65875\n        Output: 87655\n        Explanation: Swap the digit 8 with the digit 6, this results in the number 85675.\n        Swap the first digit 5 with the digit 7, this results in the number 87655.\n        Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1724,"row":{"number":2232,"difficulty":1,"question":"class Solution:\n    def minimizeResult(self, expression: str) -> str:\n        \"\"\"\n        You are given a 0-indexed string expression of the form \"<num1>+<num2>\" where <num1> and <num2> represent positive integers.\n        Add a pair of parentheses to expression such that after the addition of parentheses, expression is a valid mathematical expression and evaluates to the smallest possible value. The left parenthesis must be added to the left of '+' and the right parenthesis must be added to the right of '+'.\n        Return expression after adding a pair of parentheses such that expression evaluates to the smallest possible value. If there are multiple answers that yield the same result, return any of them.\n        The input has been generated such that the original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.\n        Example 1:\n        Input: expression = \"247+38\"\n        Output: \"2(47+38)\"\n        Explanation: The expression evaluates to 2 * (47 + 38) = 2 * 85 = 170.\n        Note that \"2(4)7+38\" is invalid because the right parenthesis must be to the right of the '+'.\n        It can be shown that 170 is the smallest possible value.\n        Example 2:\n        Input: expression = \"12+34\"\n        Output: \"1(2+3)4\"\n        Explanation: The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20.\n        Example 3:\n        Input: expression = \"999+999\"\n        Output: \"(999+999)\"\n        Explanation: The expression evaluates to 999 + 999 = 1998.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1725,"row":{"number":2233,"difficulty":1,"question":"class Solution:\n    def maximumProduct(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an array of non-negative integers nums and an integer k. In one operation, you may choose any element from nums and increment it by 1.\n        Return the maximum product of nums after at most k operations. Since the answer may be very large, return it modulo 109 + 7. Note that you should maximize the product before taking the modulo. \n        Example 1:\n        Input: nums = [0,4], k = 5\n        Output: 20\n        Explanation: Increment the first number 5 times.\n        Now nums = [5, 4], with a product of 5 * 4 = 20.\n        It can be shown that 20 is maximum product possible, so we return 20.\n        Note that there may be other ways to increment nums to have the maximum product.\n        Example 2:\n        Input: nums = [6,3,3,2], k = 2\n        Output: 216\n        Explanation: Increment the second number 1 time and increment the fourth number 1 time.\n        Now nums = [6, 4, 3, 3], with a product of 6 * 4 * 3 * 3 = 216.\n        It can be shown that 216 is maximum product possible, so we return 216.\n        Note that there may be other ways to increment nums to have the maximum product.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1726,"row":{"number":2234,"difficulty":2,"question":"class Solution:\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        \"\"\"\n        Alice is a caretaker of n gardens and she wants to plant flowers to maximize the total beauty of all her gardens.\n        You are given a 0-indexed integer array flowers of size n, where flowers[i] is the number of flowers already planted in the ith garden. Flowers that are already planted cannot be removed. You are then given another integer newFlowers, which is the maximum number of flowers that Alice can additionally plant. You are also given the integers target, full, and partial.\n        A garden is considered complete if it has at least target flowers. The total beauty of the gardens is then determined as the sum of the following:\n            The number of complete gardens multiplied by full.\n            The minimum number of flowers in any of the incomplete gardens multiplied by partial. If there are no incomplete gardens, then this value will be 0.\n        Return the maximum total beauty that Alice can obtain after planting at most newFlowers flowers.\n        Example 1:\n        Input: flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1\n        Output: 14\n        Explanation: Alice can plant\n        - 2 flowers in the 0th garden\n        - 3 flowers in the 1st garden\n        - 1 flower in the 2nd garden\n        - 1 flower in the 3rd garden\n        The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.\n        There is 1 garden that is complete.\n        The minimum number of flowers in the incomplete gardens is 2.\n        Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.\n        No other way of planting flowers can obtain a total beauty higher than 14.\n        Example 2:\n        Input: flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6\n        Output: 30\n        Explanation: Alice can plant\n        - 3 flowers in the 0th garden\n        - 0 flowers in the 1st garden\n        - 0 flowers in the 2nd garden\n        - 2 flowers in the 3rd garden\n        The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.\n        There are 3 gardens that are complete.\n        The minimum number of flowers in the incomplete gardens is 4.\n        Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.\n        No other way of planting flowers can obtain a total beauty higher than 30.\n        Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1727,"row":{"number":2248,"difficulty":0,"question":"class Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\n        Example 1:\n        Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\n        Output: [3,4]\n        Explanation: \n        The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].\n        Example 2:\n        Input: nums = [[1,2,3],[4,5,6]]\n        Output: []\n        Explanation: \n        There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1728,"row":{"number":2249,"difficulty":1,"question":"class Solution:\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\n        \"\"\"\n        Given a 2D integer array circles where circles[i] = [xi, yi, ri] represents the center (xi, yi) and radius ri of the ith circle drawn on a grid, return the number of lattice points that are present inside at least one circle.\n        Note:\n            A lattice point is a point with integer coordinates.\n            Points that lie on the circumference of a circle are also considered to be inside it.\n        Example 1:\n        Input: circles = [[2,2,1]]\n        Output: 5\n        Explanation:\n        The figure above shows the given circle.\n        The lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.\n        Other points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.\n        Hence, the number of lattice points present inside at least one circle is 5.\n        Example 2:\n        Input: circles = [[2,2,2],[3,4,1]]\n        Output: 16\n        Explanation:\n        The figure above shows the given circles.\n        There are exactly 16 lattice points which are present inside at least one circle. \n        Some of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1729,"row":{"number":2250,"difficulty":1,"question":"class Solution:\n    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given a 2D integer array rectangles where rectangles[i] = [li, hi] indicates that ith rectangle has a length of li and a height of hi. You are also given a 2D integer array points where points[j] = [xj, yj] is a point with coordinates (xj, yj).\n        The ith rectangle has its bottom-left corner point at the coordinates (0, 0) and its top-right corner point at (li, hi).\n        Return an integer array count of length points.length where count[j] is the number of rectangles that contain the jth point.\n        The ith rectangle contains the jth point if 0 <= xj <= li and 0 <= yj <= hi. Note that points that lie on the edges of a rectangle are also considered to be contained by that rectangle.\n        Example 1:\n        Input: rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]\n        Output: [2,1]\n        Explanation: \n        The first rectangle contains no points.\n        The second rectangle contains only the point (2, 1).\n        The third rectangle contains the points (2, 1) and (1, 4).\n        The number of rectangles that contain the point (2, 1) is 2.\n        The number of rectangles that contain the point (1, 4) is 1.\n        Therefore, we return [2, 1].\n        Example 2:\n        Input: rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\n        Output: [1,3]\n        Explanation:\n        The first rectangle contains only the point (1, 1).\n        The second rectangle contains only the point (1, 1).\n        The third rectangle contains the points (1, 3) and (1, 1).\n        The number of rectangles that contain the point (1, 3) is 1.\n        The number of rectangles that contain the point (1, 1) is 3.\n        Therefore, we return [1, 3].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1730,"row":{"number":2251,"difficulty":2,"question":"class Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array persons of size n, where persons[i] is the time that the ith person will arrive to see the flowers.\n        Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.\n        Example 1:\n        Input: flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11]\n        Output: [1,2,2,2]\n        Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.\n        For each person, we return the number of flowers in full bloom during their arrival.\n        Example 2:\n        Input: flowers = [[1,10],[3,3]], persons = [3,3,2]\n        Output: [2,2,1]\n        Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.\n        For each person, we return the number of flowers in full bloom during their arrival.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1731,"row":{"number":2259,"difficulty":0,"question":"class Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        \"\"\"\n        You are given a string number representing a positive integer and a character digit.\n        Return the resulting string after removing exactly one occurrence of digit from number such that the value of the resulting string in decimal form is maximized. The test cases are generated such that digit occurs at least once in number.\n        Example 1:\n        Input: number = \"123\", digit = \"3\"\n        Output: \"12\"\n        Explanation: There is only one '3' in \"123\". After removing '3', the result is \"12\".\n        Example 2:\n        Input: number = \"1231\", digit = \"1\"\n        Output: \"231\"\n        Explanation: We can remove the first '1' to get \"231\" or remove the second '1' to get \"123\".\n        Since 231 > 123, we return \"231\".\n        Example 3:\n        Input: number = \"551\", digit = \"5\"\n        Output: \"51\"\n        Explanation: We can remove either the first or second '5' from \"551\".\n        Both result in the string \"51\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1732,"row":{"number":2260,"difficulty":1,"question":"class Solution:\n    def minimumCardPickup(self, cards: List[int]) -> int:\n        \"\"\"\n        You are given an integer array cards where cards[i] represents the value of the ith card. A pair of cards are matching if the cards have the same value.\n        Return the minimum number of consecutive cards you have to pick up to have a pair of matching cards among the picked cards. If it is impossible to have matching cards, return -1.\n        Example 1:\n        Input: cards = [3,4,2,3,4,7]\n        Output: 4\n        Explanation: We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal.\n        Example 2:\n        Input: cards = [1,0,5,3]\n        Output: -1\n        Explanation: There is no way to pick up a set of consecutive cards that contain a pair of matching cards.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1733,"row":{"number":2261,"difficulty":1,"question":"class Solution:\n    def countDistinct(self, nums: List[int], k: int, p: int) -> int:\n        \"\"\"\n        Given an integer array nums and two integers k and p, return the number of distinct subarrays which have at most k elements divisible by p.\n        Two arrays nums1 and nums2 are said to be distinct if:\n            They are of different lengths, or\n            There exists at least one index i where nums1[i] != nums2[i].\n        A subarray is defined as a non-empty contiguous sequence of elements in an array.\n        Example 1:\n        Input: nums = [2,3,3,2,2], k = 2, p = 2\n        Output: 11\n        Explanation:\n        The elements at indices 0, 3, and 4 are divisible by p = 2.\n        The 11 distinct subarrays which have at most k = 2 elements divisible by 2 are:\n        [2], [2,3], [2,3,3], [2,3,3,2], [3], [3,3], [3,3,2], [3,3,2,2], [3,2], [3,2,2], and [2,2].\n        Note that the subarrays [2] and [3] occur more than once in nums, but they should each be counted only once.\n        The subarray [2,3,3,2,2] should not be counted because it has 3 elements that are divisible by 2.\n        Example 2:\n        Input: nums = [1,2,3,4], k = 4, p = 1\n        Output: 10\n        Explanation:\n        All element of nums are divisible by p = 1.\n        Also, every subarray of nums will have at most 4 elements that are divisible by 1.\n        Since all subarrays are distinct, the total number of subarrays satisfying all the constraints is 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1734,"row":{"number":2262,"difficulty":2,"question":"class Solution:\n    def appealSum(self, s: str) -> int:\n        \"\"\"\n        The appeal of a string is the number of distinct characters found in the string.\n            For example, the appeal of \"abbca\" is 3 because it has 3 distinct characters: 'a', 'b', and 'c'.\n        Given a string s, return the total appeal of all of its substrings.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"abbca\"\n        Output: 28\n        Explanation: The following are the substrings of \"abbca\":\n        - Substrings of length 1: \"a\", \"b\", \"b\", \"c\", \"a\" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.\n        - Substrings of length 2: \"ab\", \"bb\", \"bc\", \"ca\" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.\n        - Substrings of length 3: \"abb\", \"bbc\", \"bca\" have an appeal of 2, 2, and 3 respectively. The sum is 7.\n        - Substrings of length 4: \"abbc\", \"bbca\" have an appeal of 3 and 3 respectively. The sum is 6.\n        - Substrings of length 5: \"abbca\" has an appeal of 3. The sum is 3.\n        The total sum is 5 + 7 + 7 + 6 + 3 = 28.\n        Example 2:\n        Input: s = \"code\"\n        Output: 20\n        Explanation: The following are the substrings of \"code\":\n        - Substrings of length 1: \"c\", \"o\", \"d\", \"e\" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4.\n        - Substrings of length 2: \"co\", \"od\", \"de\" have an appeal of 2, 2, and 2 respectively. The sum is 6.\n        - Substrings of length 3: \"cod\", \"ode\" have an appeal of 3 and 3 respectively. The sum is 6.\n        - Substrings of length 4: \"code\" has an appeal of 4. The sum is 4.\n        The total sum is 4 + 6 + 6 + 4 = 20.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1735,"row":{"number":2255,"difficulty":0,"question":"class Solution:\n    def countPrefixes(self, words: List[str], s: str) -> int:\n        \"\"\"\n        You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.\n        Return the number of strings in words that are a prefix of s.\n        A prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"\n        Output: 3\n        Explanation:\n        The strings in words which are a prefix of s = \"abc\" are:\n        \"a\", \"ab\", and \"abc\".\n        Thus the number of strings in words which are a prefix of s is 3.\n        Example 2:\n        Input: words = [\"a\",\"a\"], s = \"aa\"\n        Output: 2\n        Explanation:\n        Both of the strings are a prefix of s. \n        Note that the same string can occur multiple times in words, and it should be counted each time.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1736,"row":{"number":2256,"difficulty":1,"question":"class Solution:\n    def minimumAverageDifference(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums of length n.\n        The average difference of the index i is the absolute difference between the average of the first i + 1 elements of nums and the average of the last n - i - 1 elements. Both averages should be rounded down to the nearest integer.\n        Return the index with the minimum average difference. If there are multiple such indices, return the smallest one.\n        Note:\n            The absolute difference of two numbers is the absolute value of their difference.\n            The average of n elements is the sum of the n elements divided (integer division) by n.\n            The average of 0 elements is considered to be 0.\n        Example 1:\n        Input: nums = [2,5,3,9,5,3]\n        Output: 3\n        Explanation:\n        - The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.\n        - The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.\n        - The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.\n        - The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.\n        - The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.\n        - The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.\n        The average difference of index 3 is the minimum average difference so return 3.\n        Example 2:\n        Input: nums = [0]\n        Output: 0\n        Explanation:\n        The only index is 0 so return 0.\n        The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1737,"row":{"number":2257,"difficulty":1,"question":"class Solution:\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n        \"\"\"\n        You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.\n        A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.\n        Return the number of unoccupied cells that are not guarded.\n        Example 1:\n        Input: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\n        Output: 7\n        Explanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.\n        There are a total of 7 unguarded cells, so we return 7.\n        Example 2:\n        Input: m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\n        Output: 4\n        Explanation: The unguarded cells are shown in green in the above diagram.\n        There are a total of 4 unguarded cells, so we return 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1738,"row":{"number":2258,"difficulty":2,"question":"class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 0-indexed 2D integer array grid of size m x n which represents a field. Each cell has one of three values:\n            0 represents grass,\n            1 represents fire,\n            2 represents a wall that you and fire cannot pass through.\n        You are situated in the top-left cell, (0, 0), and you want to travel to the safehouse at the bottom-right cell, (m - 1, n - 1). Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.\n        Return the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse. If this is impossible, return -1. If you can always reach the safehouse regardless of the minutes stayed, return 109.\n        Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n        A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n        Example 1:\n        Input: grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n        Output: 3\n        Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.\n        You will still be able to safely reach the safehouse.\n        Staying for more than 3 minutes will not allow you to safely reach the safehouse.\n        Example 2:\n        Input: grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n        Output: -1\n        Explanation: The figure above shows the scenario where you immediately move towards the safehouse.\n        Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\n        Thus, -1 is returned.\n        Example 3:\n        Input: grid = [[0,0,0],[2,2,0],[1,2,0]]\n        Output: 1000000000\n        Explanation: The figure above shows the initial grid.\n        Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.\n        Thus, 109 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1739,"row":{"number":2224,"difficulty":0,"question":"class Solution:\n    def convertTime(self, current: str, correct: str) -> int:\n        \"\"\"\n        You are given two strings current and correct representing two 24-hour times.\n        24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\n        In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times.\n        Return the minimum number of operations needed to convert current to correct.\n        Example 1:\n        Input: current = \"02:30\", correct = \"04:35\"\n        Output: 3\n        Explanation:\n        We can convert current to correct in 3 operations as follows:\n        - Add 60 minutes to current. current becomes \"03:30\".\n        - Add 60 minutes to current. current becomes \"04:30\".\n        - Add 5 minutes to current. current becomes \"04:35\".\n        It can be proven that it is not possible to convert current to correct in fewer than 3 operations.\n        Example 2:\n        Input: current = \"11:00\", correct = \"11:01\"\n        Output: 1\n        Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1740,"row":{"number":2264,"difficulty":0,"question":"class Solution:\n    def largestGoodInteger(self, num: str) -> str:\n        \"\"\"\n        You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n            It is a substring of num with length 3.\n            It consists of only one unique digit.\n        Return the maximum good integer as a string or an empty string \"\" if no such integer exists.\n        Note:\n            A substring is a contiguous sequence of characters within a string.\n            There may be leading zeroes in num or a good integer.\n        Example 1:\n        Input: num = \"6777133339\"\n        Output: \"777\"\n        Explanation: There are two distinct good integers: \"777\" and \"333\".\n        \"777\" is the largest, so we return \"777\".\n        Example 2:\n        Input: num = \"2300019\"\n        Output: \"000\"\n        Explanation: \"000\" is the only good integer.\n        Example 3:\n        Input: num = \"42352338\"\n        Output: \"\"\n        Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1741,"row":{"number":2265,"difficulty":1,"question":"class Solution:\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.\n        Note:\n            The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.\n            A subtree of root is a tree consisting of root and all of its descendants.\n        Example 1:\n        Input: root = [4,8,5,0,1,null,6]\n        Output: 5\n        Explanation: \n        For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.\n        For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.\n        For the node with value 0: The average of its subtree is 0 / 1 = 0.\n        For the node with value 1: The average of its subtree is 1 / 1 = 1.\n        For the node with value 6: The average of its subtree is 6 / 1 = 6.\n        Example 2:\n        Input: root = [1]\n        Output: 1\n        Explanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1742,"row":{"number":2266,"difficulty":1,"question":"class Solution:\n    def countTexts(self, pressedKeys: str) -> int:\n        \"\"\"\n        Alice is texting Bob using her phone. The mapping of digits to letters is shown in the figure below.\n        In order to add a letter, Alice has to press the key of the corresponding digit i times, where i is the position of the letter in the key.\n            For example, to add the letter 's', Alice has to press '7' four times. Similarly, to add the letter 'k', Alice has to press '5' twice.\n            Note that the digits '0' and '1' do not map to any letters, so Alice does not use them.\n        However, due to an error in transmission, Bob did not receive Alice's text message but received a string of pressed keys instead.\n            For example, when Alice sent the message \"bob\", Bob received the string \"2266622\".\n        Given a string pressedKeys representing the string received by Bob, return the total number of possible text messages Alice could have sent.\n        Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: pressedKeys = \"22233\"\n        Output: 8\n        Explanation:\n        The possible text messages Alice could have sent are:\n        \"aaadd\", \"abdd\", \"badd\", \"cdd\", \"aaae\", \"abe\", \"bae\", and \"ce\".\n        Since there are 8 possible messages, we return 8.\n        Example 2:\n        Input: pressedKeys = \"222222222222222222222222222222222222\"\n        Output: 82876089\n        Explanation:\n        There are 2082876103 possible text messages Alice could have sent.\n        Since we need to return the answer modulo 109 + 7, we return 2082876103 % (109 + 7) = 82876089.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1743,"row":{"number":2267,"difficulty":2,"question":"class Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        \"\"\"\n        A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:\n            It is ().\n            It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.\n            It can be written as (A), where A is a valid parentheses string.\n        You are given an m x n matrix of parentheses grid. A valid parentheses string path in the grid is a path satisfying all of the following conditions:\n            The path starts from the upper left cell (0, 0).\n            The path ends at the bottom-right cell (m - 1, n - 1).\n            The path only ever moves down or right.\n            The resulting parentheses string formed by the path is valid.\n        Return true if there exists a valid parentheses string path in the grid. Otherwise, return false.\n        Example 1:\n        Input: grid = [[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]\n        Output: true\n        Explanation: The above diagram shows two possible paths that form valid parentheses strings.\n        The first path shown results in the valid parentheses string \"()(())\".\n        The second path shown results in the valid parentheses string \"((()))\".\n        Note that there may be other valid parentheses string paths.\n        Example 2:\n        Input: grid = [[\")\",\")\"],[\"(\",\"(\"]]\n        Output: false\n        Explanation: The two possible paths form the parentheses strings \"))(\" and \")((\". Since neither of them are valid parentheses strings, we return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1744,"row":{"number":2239,"difficulty":0,"question":"class Solution:\n    def findClosestNumber(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value.\n        Example 1:\n        Input: nums = [-4,-2,1,4,8]\n        Output: 1\n        Explanation:\n        The distance from -4 to 0 is |-4| = 4.\n        The distance from -2 to 0 is |-2| = 2.\n        The distance from 1 to 0 is |1| = 1.\n        The distance from 4 to 0 is |4| = 4.\n        The distance from 8 to 0 is |8| = 8.\n        Thus, the closest number to 0 in the array is 1.\n        Example 2:\n        Input: nums = [2,-1,1]\n        Output: 1\n        Explanation: 1 and -1 are both the closest numbers to 0, so 1 being larger is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1745,"row":{"number":2240,"difficulty":1,"question":"class Solution:\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n        \"\"\"\n        You are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. You can spend part or all of your money to buy multiple quantities (or none) of each kind of writing utensil.\n        Return the number of distinct ways you can buy some number of pens and pencils.\n        Example 1:\n        Input: total = 20, cost1 = 10, cost2 = 5\n        Output: 9\n        Explanation: The price of a pen is 10 and the price of a pencil is 5.\n        - If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\n        - If you buy 1 pen, you can buy 0, 1, or 2 pencils.\n        - If you buy 2 pens, you cannot buy any pencils.\n        The total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\n        Example 2:\n        Input: total = 5, cost1 = 10, cost2 = 10\n        Output: 1\n        Explanation: The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1746,"row":{"number":2241,"difficulty":1,"question":"class ATM:\n    def __init__(self):\n    def deposit(self, banknotesCount: List[int]) -> None:\n    def withdraw(self, amount: int) -> List[int]:\n        \"\"\"\n        There is an ATM machine that stores banknotes of 5 denominations: 20, 50, 100, 200, and 500 dollars. Initially the ATM is empty. The user can use the machine to deposit or withdraw any amount of money.\n        When withdrawing, the machine prioritizes using banknotes of larger values.\n            For example, if you want to withdraw $300 and there are 2 $50 banknotes, 1 $100 banknote, and 1 $200 banknote, then the machine will use the $100 and $200 banknotes.\n            However, if you try to withdraw $600 and there are 3 $200 banknotes and 1 $500 banknote, then the withdraw request will be rejected because the machine will first try to use the $500 banknote and then be unable to use banknotes to complete the remaining $100. Note that the machine is not allowed to use the $200 banknotes instead of the $500 banknote.\n        Implement the ATM class:\n            ATM() Initializes the ATM object.\n            void deposit(int[] banknotesCount) Deposits new banknotes in the order $20, $50, $100, $200, and $500.\n            int[] withdraw(int amount) Returns an array of length 5 of the number of banknotes that will be handed to the user in the order $20, $50, $100, $200, and $500, and update the number of banknotes in the ATM after withdrawing. Returns [-1] if it is not possible (do not withdraw any banknotes in this case).\n        Example 1:\n        Input\n        [\"ATM\", \"deposit\", \"withdraw\", \"deposit\", \"withdraw\", \"withdraw\"]\n        [[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]\n        Output\n        [null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]\n        Explanation\n        ATM atm = new ATM();\n        atm.deposit([0,0,1,2,1]); // Deposits 1 $100 banknote, 2 $200 banknotes,\n                                  // and 1 $500 banknote.\n        atm.withdraw(600);        // Returns [0,0,1,0,1]. The machine uses 1 $100 banknote\n                                  // and 1 $500 banknote. The banknotes left over in the\n                                  // machine are [0,0,0,2,0].\n        atm.deposit([0,1,0,1,1]); // Deposits 1 $50, $200, and $500 banknote.\n                                  // The banknotes in the machine are now [0,1,0,3,1].\n        atm.withdraw(600);        // Returns [-1]. The machine will try to use a $500 banknote\n                                  // and then be unable to complete the remaining $100,\n                                  // so the withdraw request will be rejected.\n                                  // Since the request is rejected, the number of banknotes\n                                  // in the machine is not modified.\n        atm.withdraw(550);        // Returns [0,1,0,0,1]. The machine uses 1 $50 banknote\n                                  // and 1 $500 banknote.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1747,"row":{"number":2242,"difficulty":2,"question":"class Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        \"\"\"\n        There is an undirected graph with n nodes, numbered from 0 to n - 1.\n        You are given a 0-indexed integer array scores of length n where scores[i] denotes the score of node i. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\n        A node sequence is valid if it meets the following conditions:\n            There is an edge connecting every pair of adjacent nodes in the sequence.\n            No node appears more than once in the sequence.\n        The score of a node sequence is defined as the sum of the scores of the nodes in the sequence.\n        Return the maximum score of a valid node sequence with a length of 4. If no such sequence exists, return -1.\n        Example 1:\n        Input: scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n        Output: 24\n        Explanation: The figure above shows the graph and the chosen node sequence [0,1,2,3].\n        The score of the node sequence is 5 + 2 + 9 + 8 = 24.\n        It can be shown that no other node sequence has a score of more than 24.\n        Note that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.\n        The sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3.\n        Example 2:\n        Input: scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\n        Output: -1\n        Explanation: The figure above shows the graph.\n        There are no valid node sequences of length 4, so we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1748,"row":{"number":2274,"difficulty":1,"question":"class Solution:\n    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:\n        \"\"\"\n        Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be special floors, used for relaxation only.\n        You are given two integers bottom and top, which denote that Alice has rented all the floors from bottom to top (inclusive). You are also given the integer array special, where special[i] denotes a special floor that Alice has designated for relaxation.\n        Return the maximum number of consecutive floors without a special floor.\n        Example 1:\n        Input: bottom = 2, top = 9, special = [4,6]\n        Output: 3\n        Explanation: The following are the ranges (inclusive) of consecutive floors without a special floor:\n        - (2, 3) with a total amount of 2 floors.\n        - (5, 5) with a total amount of 1 floor.\n        - (7, 9) with a total amount of 3 floors.\n        Therefore, we return the maximum number which is 3 floors.\n        Example 2:\n        Input: bottom = 6, top = 8, special = [7,6,8]\n        Output: 0\n        Explanation: Every floor rented is a special floor, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1749,"row":{"number":2275,"difficulty":1,"question":"class Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        \"\"\"\n        The bitwise AND of an array nums is the bitwise AND of all integers in nums.\n            For example, for nums = [1, 5, 3], the bitwise AND is equal to 1 & 5 & 3 = 1.\n            Also, for nums = [7], the bitwise AND is 7.\n        You are given an array of positive integers candidates. Evaluate the bitwise AND of every combination of numbers of candidates. Each number in candidates may only be used once in each combination.\n        Return the size of the largest combination of candidates with a bitwise AND greater than 0.\n        Example 1:\n        Input: candidates = [16,17,71,62,12,24,14]\n        Output: 4\n        Explanation: The combination [16,17,62,24] has a bitwise AND of 16 & 17 & 62 & 24 = 16 > 0.\n        The size of the combination is 4.\n        It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.\n        Note that more than one combination may have the largest size.\n        For example, the combination [62,12,24,14] has a bitwise AND of 62 & 12 & 24 & 14 = 8 > 0.\n        Example 2:\n        Input: candidates = [8,8]\n        Output: 2\n        Explanation: The largest combination [8,8] has a bitwise AND of 8 & 8 = 8 > 0.\n        The size of the combination is 2, so we return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1750,"row":{"number":2276,"difficulty":2,"question":"class CountIntervals:\n    def __init__(self):\n    def add(self, left: int, right: int) -> None:\n    def count(self) -> int:\n        \"\"\"\n        Given an empty set of intervals, implement a data structure that can:\n            Add an interval to the set of intervals.\n            Count the number of integers that are present in at least one interval.\n        Implement the CountIntervals class:\n            CountIntervals() Initializes the object with an empty set of intervals.\n            void add(int left, int right) Adds the interval [left, right] to the set of intervals.\n            int count() Returns the number of integers that are present in at least one interval.\n        Note that an interval [left, right] denotes all the integers x where left <= x <= right.\n        Example 1:\n        Input\n        [\"CountIntervals\", \"add\", \"add\", \"count\", \"add\", \"count\"]\n        [[], [2, 3], [7, 10], [], [5, 8], []]\n        Output\n        [null, null, null, 6, null, 8]\n        Explanation\n        CountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals. \n        countIntervals.add(2, 3);  // add [2, 3] to the set of intervals.\n        countIntervals.add(7, 10); // add [7, 10] to the set of intervals.\n        countIntervals.count();    // return 6\n                                   // the integers 2 and 3 are present in the interval [2, 3].\n                                   // the integers 7, 8, 9, and 10 are present in the interval [7, 10].\n        countIntervals.add(5, 8);  // add [5, 8] to the set of intervals.\n        countIntervals.count();    // return 8\n                                   // the integers 2 and 3 are present in the interval [2, 3].\n                                   // the integers 5 and 6 are present in the interval [5, 8].\n                                   // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].\n                                   // the integers 9 and 10 are present in the interval [7, 10].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1751,"row":{"number":2270,"difficulty":1,"question":"class Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums of length n.\n        nums contains a valid split at index i if the following are true:\n            The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.\n            There is at least one element to the right of i. That is, 0 <= i < n - 1.\n        Return the number of valid splits in nums.\n        Example 1:\n        Input: nums = [10,4,-8,7]\n        Output: 2\n        Explanation: \n        There are three ways of splitting nums into two non-empty parts:\n        - Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split.\n        - Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split.\n        - Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split.\n        Thus, the number of valid splits in nums is 2.\n        Example 2:\n        Input: nums = [2,3,1,0]\n        Output: 2\n        Explanation: \n        There are two valid splits in nums:\n        - Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. \n        - Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1752,"row":{"number":2271,"difficulty":1,"question":"class Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        \"\"\"\n        You are given a 2D integer array tiles where tiles[i] = [li, ri] represents that every tile j in the range li <= j <= ri is colored white.\n        You are also given an integer carpetLen, the length of a single carpet that can be placed anywhere.\n        Return the maximum number of white tiles that can be covered by the carpet.\n        Example 1:\n        Input: tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10\n        Output: 9\n        Explanation: Place the carpet starting on tile 10. \n        It covers 9 white tiles, so we return 9.\n        Note that there may be other places where the carpet covers 9 white tiles.\n        It can be shown that the carpet cannot cover more than 9 white tiles.\n        Example 2:\n        Input: tiles = [[10,11],[1,1]], carpetLen = 2\n        Output: 2\n        Explanation: Place the carpet starting on tile 10. \n        It covers 2 white tiles, so we return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1753,"row":{"number":2272,"difficulty":2,"question":"class Solution:\n    def largestVariance(self, s: str) -> int:\n        \"\"\"\n        The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.\n        Given a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.\n        A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"aababbb\"\n        Output: 3\n        Explanation:\n        All possible variances along with their respective substrings are listed below:\n        - Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".\n        - Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".\n        - Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\".\n        - Variance 3 for substring \"babbb\".\n        Since the largest possible variance is 3, we return it.\n        Example 2:\n        Input: s = \"abcde\"\n        Output: 0\n        Explanation:\n        No letter occurs more than once in s, so the variance of every substring is 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1754,"row":{"number":2243,"difficulty":0,"question":"class Solution:\n    def digitSum(self, s: str, k: int) -> str:\n        \"\"\"\n        You are given a string s consisting of digits and an integer k.\n        A round can be completed if the length of s is greater than k. In one round, do the following:\n            Divide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters are in the second group, and so on. Note that the size of the last group can be smaller than k.\n            Replace each group of s with a string representing the sum of all its digits. For example, \"346\" is replaced with \"13\" because 3 + 4 + 6 = 13.\n            Merge consecutive groups together to form a new string. If the length of the string is greater than k, repeat from step 1.\n        Return s after all rounds have been completed.\n        Example 1:\n        Input: s = \"11111222223\", k = 3\n        Output: \"135\"\n        Explanation: \n        - For the first round, we divide s into groups of size 3: \"111\", \"112\", \"222\", and \"23\".\n          ​​​​​Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. \n          So, s becomes \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" after the first round.\n        - For the second round, we divide s into \"346\" and \"5\".\n          Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. \n          So, s becomes \"13\" + \"5\" = \"135\" after second round. \n        Now, s.length <= k, so we return \"135\" as the answer.\n        Example 2:\n        Input: s = \"00000000\", k = 3\n        Output: \"000\"\n        Explanation: \n        We divide s into \"000\", \"000\", and \"00\".\n        Then we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. \n        s becomes \"0\" + \"0\" + \"0\" = \"000\", whose length is equal to k, so we return \"000\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1755,"row":{"number":2244,"difficulty":1,"question":"class Solution:\n    def minimumRounds(self, tasks: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.\n        Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.\n        Example 1:\n        Input: tasks = [2,2,3,3,2,4,4,4,4,4]\n        Output: 4\n        Explanation: To complete all the tasks, a possible plan is:\n        - In the first round, you complete 3 tasks of difficulty level 2. \n        - In the second round, you complete 2 tasks of difficulty level 3. \n        - In the third round, you complete 3 tasks of difficulty level 4. \n        - In the fourth round, you complete 2 tasks of difficulty level 4.  \n        It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n        Example 2:\n        Input: tasks = [2,3,3]\n        Output: -1\n        Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1756,"row":{"number":2245,"difficulty":1,"question":"class Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D integer array grid of size m x n, where each cell contains a positive integer.\n        A cornered path is defined as a set of adjacent cells with at most one turn. More specifically, the path should exclusively move either horizontally or vertically up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the alternate direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\n        The product of a path is defined as the product of all the values in the path.\n        Return the maximum number of trailing zeros in the product of a cornered path found in grid.\n        Note:\n            Horizontal movement means moving in either the left or right direction.\n            Vertical movement means moving in either the up or down direction.\n        Example 1:\n        Input: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n        Output: 3\n        Explanation: The grid on the left shows a valid cornered path.\n        It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\n        It can be shown that this is the maximum trailing zeros in the product of a cornered path.\n        The grid in the middle is not a cornered path as it has more than one turn.\n        The grid on the right is not a cornered path as it requires a return to a previously visited cell.\n        Example 2:\n        Input: grid = [[4,3,2],[7,6,1],[8,8,8]]\n        Output: 0\n        Explanation: The grid is shown in the figure above.\n        There are no cornered paths in the grid that result in a product with a trailing zero.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1757,"row":{"number":2246,"difficulty":2,"question":"class Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        \"\"\"\n        You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1.\n        You are also given a string s of length n, where s[i] is the character assigned to node i.\n        Return the length of the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them.\n        Example 1:\n        Input: parent = [-1,0,0,1,1,2], s = \"abacbe\"\n        Output: 3\n        Explanation: The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\n        It can be proven that there is no longer path that satisfies the conditions. \n        Example 2:\n        Input: parent = [-1,0,0,0], s = \"aabc\"\n        Output: 3\n        Explanation: The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1758,"row":{"number":2278,"difficulty":0,"question":"class Solution:\n    def percentageLetter(self, s: str, letter: str) -> int:\n        \"\"\"\n        Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.\n        Example 1:\n        Input: s = \"foobar\", letter = \"o\"\n        Output: 33\n        Explanation:\n        The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.\n        Example 2:\n        Input: s = \"jjjj\", letter = \"k\"\n        Output: 0\n        Explanation:\n        The percentage of characters in s that equal the letter 'k' is 0%, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1759,"row":{"number":2279,"difficulty":1,"question":"class Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        \"\"\"\n        You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.\n        Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\n        Example 1:\n        Input: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2\n        Output: 3\n        Explanation:\n        Place 1 rock in bag 0 and 1 rock in bag 1.\n        The number of rocks in each bag are now [2,3,4,4].\n        Bags 0, 1, and 2 have full capacity.\n        There are 3 bags at full capacity, so we return 3.\n        It can be shown that it is not possible to have more than 3 bags at full capacity.\n        Note that there may be other ways of placing the rocks that result in an answer of 3.\n        Example 2:\n        Input: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100\n        Output: 3\n        Explanation:\n        Place 8 rocks in bag 0 and 2 rocks in bag 2.\n        The number of rocks in each bag are now [10,2,2].\n        Bags 0, 1, and 2 have full capacity.\n        There are 3 bags at full capacity, so we return 3.\n        It can be shown that it is not possible to have more than 3 bags at full capacity.\n        Note that we did not use all of the additional rocks.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1760,"row":{"number":2280,"difficulty":1,"question":"class Solution:\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D integer array stockPrices where stockPrices[i] = [dayi, pricei] indicates the price of the stock on day dayi is pricei. A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:\n        Return the minimum number of lines needed to represent the line chart.\n        Example 1:\n        Input: stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]\n        Output: 3\n        Explanation:\n        The diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.\n        The following 3 lines can be drawn to represent the line chart:\n        - Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).\n        - Line 2 (in blue) from (4,4) to (5,4).\n        - Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).\n        It can be shown that it is not possible to represent the line chart using less than 3 lines.\n        Example 2:\n        Input: stockPrices = [[3,4],[1,2],[7,8],[2,3]]\n        Output: 1\n        Explanation:\n        As shown in the diagram above, the line chart can be represented with a single line.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1761,"row":{"number":2281,"difficulty":2,"question":"class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        \"\"\"\n        As the ruler of a kingdom, you have an army of wizards at your command.\n        You are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\n            The strength of the weakest wizard in the group.\n            The total of all the individual strengths of the wizards in the group.\n        Return the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: strength = [1,3,1,2]\n        Output: 44\n        Explanation: The following are all the contiguous groups of wizards:\n        - [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n        - [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n        - [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n        - [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n        - [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n        - [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n        - [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n        - [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n        - [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n        - [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\n        The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.\n        Example 2:\n        Input: strength = [5,4,6]\n        Output: 213\n        Explanation: The following are all the contiguous groups of wizards: \n        - [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n        - [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n        - [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n        - [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n        - [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n        - [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\n        The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1762,"row":{"number":2287,"difficulty":0,"question":"class Solution:\n    def rearrangeCharacters(self, s: str, target: str) -> int:\n        \"\"\"\n        You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings.\n        Return the maximum number of copies of target that can be formed by taking letters from s and rearranging them.\n        Example 1:\n        Input: s = \"ilovecodingonleetcode\", target = \"code\"\n        Output: 2\n        Explanation:\n        For the first copy of \"code\", take the letters at indices 4, 5, 6, and 7.\n        For the second copy of \"code\", take the letters at indices 17, 18, 19, and 20.\n        The strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\".\n        We can make at most two copies of \"code\", so we return 2.\n        Example 2:\n        Input: s = \"abcba\", target = \"abc\"\n        Output: 1\n        Explanation:\n        We can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2.\n        We can make at most one copy of \"abc\", so we return 1.\n        Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\".\n        Example 3:\n        Input: s = \"abbaccaddaeea\", target = \"aaaaa\"\n        Output: 1\n        Explanation:\n        We can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12.\n        We can make at most one copy of \"aaaaa\", so we return 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1763,"row":{"number":2288,"difficulty":1,"question":"class Solution:\n    def discountPrices(self, sentence: str, discount: int) -> str:\n        \"\"\"\n        A sentence is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign '$'. A word represents a price if it is a sequence of digits preceded by a dollar sign.\n            For example, \"$100\", \"$23\", and \"$6\" represent prices while \"100\", \"$\", and \"$1e5\" do not.\n        You are given a string sentence representing a sentence and an integer discount. For each word representing a price, apply a discount of discount% on the price and update the word in the sentence. All updated prices should be represented with exactly two decimal places.\n        Return a string representing the modified sentence.\n        Note that all prices will contain at most 10 digits.\n        Example 1:\n        Input: sentence = \"there are $1 $2 and 5$ candies in the shop\", discount = 50\n        Output: \"there are $0.50 $1.00 and 5$ candies in the shop\"\n        Explanation: \n        The words which represent prices are \"$1\" and \"$2\". \n        - A 50% discount on \"$1\" yields \"$0.50\", so \"$1\" is replaced by \"$0.50\".\n        - A 50% discount on \"$2\" yields \"$1\". Since we need to have exactly 2 decimal places after a price, we replace \"$2\" with \"$1.00\".\n        Example 2:\n        Input: sentence = \"1 2 $3 4 $5 $6 7 8$ $9 $10$\", discount = 100\n        Output: \"1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$\"\n        Explanation: \n        Applying a 100% discount on any price will result in 0.\n        The words representing prices are \"$3\", \"$5\", \"$6\", and \"$9\".\n        Each of them is replaced by \"$0.00\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1764,"row":{"number":2289,"difficulty":1,"question":"class Solution:\n    def totalSteps(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. In one step, remove all elements nums[i] where nums[i - 1] > nums[i] for all 0 < i < nums.length.\n        Return the number of steps performed until nums becomes a non-decreasing array.\n        Example 1:\n        Input: nums = [5,3,4,4,7,3,6,11,8,5,11]\n        Output: 3\n        Explanation: The following are the steps performed:\n        - Step 1: [5,3,4,4,7,3,6,11,8,5,11] becomes [5,4,4,7,6,11,11]\n        - Step 2: [5,4,4,7,6,11,11] becomes [5,4,7,11,11]\n        - Step 3: [5,4,7,11,11] becomes [5,7,11,11]\n        [5,7,11,11] is a non-decreasing array. Therefore, we return 3.\n        Example 2:\n        Input: nums = [4,5,7,7,13]\n        Output: 0\n        Explanation: nums is already a non-decreasing array. Therefore, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1765,"row":{"number":2290,"difficulty":2,"question":"class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n            0 represents an empty cell,\n            1 represents an obstacle that may be removed.\n        You can move up, down, left, or right from and to an empty cell.\n        Return the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).\n        Example 1:\n        Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\n        Output: 2\n        Explanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\n        It can be shown that we need to remove at least 2 obstacles, so we return 2.\n        Note that there may be other ways to remove 2 obstacles to create a path.\n        Example 2:\n        Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\n        Output: 0\n        Explanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1766,"row":{"number":2283,"difficulty":0,"question":"class Solution:\n    def digitCount(self, num: str) -> bool:\n        \"\"\"\n        You are given a 0-indexed string num of length n consisting of digits.\n        Return true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false.\n        Example 1:\n        Input: num = \"1210\"\n        Output: true\n        Explanation:\n        num[0] = '1'. The digit 0 occurs once in num.\n        num[1] = '2'. The digit 1 occurs twice in num.\n        num[2] = '1'. The digit 2 occurs once in num.\n        num[3] = '0'. The digit 3 occurs zero times in num.\n        The condition holds true for every index in \"1210\", so return true.\n        Example 2:\n        Input: num = \"030\"\n        Output: false\n        Explanation:\n        num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.\n        num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.\n        num[2] = '0'. The digit 2 occurs zero times in num.\n        The indices 0 and 1 both violate the condition, so return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1767,"row":{"number":2284,"difficulty":1,"question":"class Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        \"\"\"\n        You have a chat log of n messages. You are given two string arrays messages and senders where messages[i] is a message sent by senders[i].\n        A message is list of words that are separated by a single space with no leading or trailing spaces. The word count of a sender is the total number of words sent by the sender. Note that a sender may send more than one message.\n        Return the sender with the largest word count. If there is more than one sender with the largest word count, return the one with the lexicographically largest name.\n        Note:\n            Uppercase letters come before lowercase letters in lexicographical order.\n            \"Alice\" and \"alice\" are distinct.\n        Example 1:\n        Input: messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"]\n        Output: \"Alice\"\n        Explanation: Alice sends a total of 2 + 3 = 5 words.\n        userTwo sends a total of 2 words.\n        userThree sends a total of 3 words.\n        Since Alice has the largest word count, we return \"Alice\".\n        Example 2:\n        Input: messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"]\n        Output: \"Charlie\"\n        Explanation: Bob sends a total of 5 words.\n        Charlie sends a total of 5 words.\n        Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1768,"row":{"number":2285,"difficulty":1,"question":"class Solution:\n    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:\n        \"\"\"\n        You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.\n        You are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\n        You need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.\n        Return the maximum total importance of all roads possible after assigning the values optimally.\n        Example 1:\n        Input: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n        Output: 43\n        Explanation: The figure above shows the country and the assigned values of [2,4,5,3,1].\n        - The road (0,1) has an importance of 2 + 4 = 6.\n        - The road (1,2) has an importance of 4 + 5 = 9.\n        - The road (2,3) has an importance of 5 + 3 = 8.\n        - The road (0,2) has an importance of 2 + 5 = 7.\n        - The road (1,3) has an importance of 4 + 3 = 7.\n        - The road (2,4) has an importance of 5 + 1 = 6.\n        The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.\n        It can be shown that we cannot obtain a greater total importance than 43.\n        Example 2:\n        Input: n = 5, roads = [[0,3],[2,4],[1,3]]\n        Output: 20\n        Explanation: The figure above shows the country and the assigned values of [4,3,2,5,1].\n        - The road (0,3) has an importance of 4 + 5 = 9.\n        - The road (2,4) has an importance of 2 + 1 = 3.\n        - The road (1,3) has an importance of 3 + 5 = 8.\n        The total importance of all roads is 9 + 3 + 8 = 20.\n        It can be shown that we cannot obtain a greater total importance than 20.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1769,"row":{"number":2286,"difficulty":2,"question":"class BookMyShow:\n    def __init__(self, n: int, m: int):\n    def gather(self, k: int, maxRow: int) -> List[int]:\n    def scatter(self, k: int, maxRow: int) -> bool:\n        \"\"\"\n        A concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered from 0 to m - 1. You need to design a ticketing system that can allocate seats in the following cases:\n            If a group of k spectators can sit together in a row.\n            If every member of a group of k spectators can get a seat. They may or may not sit together.\n        Note that the spectators are very picky. Hence:\n            They will book seats only if each member of their group can get a seat with row number less than or equal to maxRow. maxRow can vary from group to group.\n            In case there are multiple rows to choose from, the row with the smallest number is chosen. If there are multiple seats to choose in the same row, the seat with the smallest number is chosen.\n        Implement the BookMyShow class:\n            BookMyShow(int n, int m) Initializes the object with n as number of rows and m as number of seats per row.\n            int[] gather(int k, int maxRow) Returns an array of length 2 denoting the row and seat number (respectively) of the first seat being allocated to the k members of the group, who must sit together. In other words, it returns the smallest possible r and c such that all [c, c + k - 1] seats are valid and empty in row r, and r <= maxRow. Returns [] in case it is not possible to allocate seats to the group.\n            boolean scatter(int k, int maxRow) Returns true if all k members of the group can be allocated seats in rows 0 to maxRow, who may or may not sit together. If the seats can be allocated, it allocates k seats to the group with the smallest row numbers, and the smallest possible seat numbers in each row. Otherwise, returns false.\n        Example 1:\n        Input\n        [\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"]\n        [[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\n        Output\n        [null, [0, 0], [], true, false]\n        Explanation\n        BookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each \n        bms.gather(4, 0); // return [0, 0]\n                          // The group books seats [0, 3] of row 0. \n        bms.gather(2, 0); // return []\n                          // There is only 1 seat left in row 0,\n                          // so it is not possible to book 2 consecutive seats. \n        bms.scatter(5, 1); // return True\n                           // The group books seat 4 of row 0 and seats [0, 3] of row 1. \n        bms.scatter(5, 1); // return False\n                           // There is only one seat left in the hall.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1770,"row":{"number":2235,"difficulty":0,"question":"class Solution:\n    def sum(self, num1: int, num2: int) -> int:\n        \"\"\"\n        Given two integers num1 and num2, return the sum of the two integers.\n        Example 1:\n        Input: num1 = 12, num2 = 5\n        Output: 17\n        Explanation: num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.\n        Example 2:\n        Input: num1 = -10, num2 = 4\n        Output: -6\n        Explanation: num1 + num2 = -6, so -6 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1771,"row":{"number":2236,"difficulty":0,"question":"class Solution:\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.\n        Return true if the value of the root is equal to the sum of the values of its two children, or false otherwise.\n        Example 1:\n        Input: root = [10,4,6]\n        Output: true\n        Explanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n        10 is equal to 4 + 6, so we return true.\n        Example 2:\n        Input: root = [5,3,1]\n        Output: false\n        Explanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n        5 is not equal to 3 + 1, so we return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1772,"row":{"number":2293,"difficulty":0,"question":"class Solution:\n    def minMaxGame(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums whose length is a power of 2.\n        Apply the following algorithm on nums:\n            Let n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2.\n            For every even index i where 0 <= i < n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]).\n            For every odd index i where 0 <= i < n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]).\n            Replace the array nums with newNums.\n            Repeat the entire process starting from step 1.\n        Return the last number that remains in nums after applying the algorithm.\n        Example 1:\n        Input: nums = [1,3,5,2,4,8,2,2]\n        Output: 1\n        Explanation: The following arrays are the results of applying the algorithm repeatedly.\n        First: nums = [1,5,4,2]\n        Second: nums = [1,4]\n        Third: nums = [1]\n        1 is the last remaining number, so we return 1.\n        Example 2:\n        Input: nums = [3]\n        Output: 3\n        Explanation: 3 is already the last remaining number, so we return 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1773,"row":{"number":2294,"difficulty":1,"question":"class Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences.\n        Return the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k.\n        A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: nums = [3,6,1,2,5], k = 2\n        Output: 2\n        Explanation:\n        We can partition nums into the two subsequences [3,1,2] and [6,5].\n        The difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\n        The difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\n        Since two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.\n        Example 2:\n        Input: nums = [1,2,3], k = 1\n        Output: 2\n        Explanation:\n        We can partition nums into the two subsequences [1,2] and [3].\n        The difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\n        The difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\n        Since two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].\n        Example 3:\n        Input: nums = [2,2,4,5], k = 0\n        Output: 3\n        Explanation:\n        We can partition nums into the three subsequences [2,2], [4], and [5].\n        The difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\n        The difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\n        The difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\n        Since three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1774,"row":{"number":2295,"difficulty":1,"question":"class Solution:\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array nums that consists of n distinct positive integers. Apply m operations to this array, where in the ith operation you replace the number operations[i][0] with operations[i][1].\n        It is guaranteed that in the ith operation:\n            operations[i][0] exists in nums.\n            operations[i][1] does not exist in nums.\n        Return the array obtained after applying all the operations.\n        Example 1:\n        Input: nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]\n        Output: [3,2,7,1]\n        Explanation: We perform the following operations on nums:\n        - Replace the number 1 with 3. nums becomes [3,2,4,6].\n        - Replace the number 4 with 7. nums becomes [3,2,7,6].\n        - Replace the number 6 with 1. nums becomes [3,2,7,1].\n        We return the final array [3,2,7,1].\n        Example 2:\n        Input: nums = [1,2], operations = [[1,3],[2,1],[3,2]]\n        Output: [2,1]\n        Explanation: We perform the following operations to nums:\n        - Replace the number 1 with 3. nums becomes [3,2].\n        - Replace the number 2 with 1. nums becomes [3,1].\n        - Replace the number 3 with 2. nums becomes [2,1].\n        We return the array [2,1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1775,"row":{"number":2296,"difficulty":2,"question":"class TextEditor:\n    def __init__(self):\n    def addText(self, text: str) -> None:\n    def deleteText(self, k: int) -> int:\n    def cursorLeft(self, k: int) -> str:\n    def cursorRight(self, k: int) -> str:\n        \"\"\"\n        Design a text editor with a cursor that can do the following:\n            Add text to where the cursor is.\n            Delete text from where the cursor is (simulating the backspace key).\n            Move the cursor either left or right.\n        When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.\n        Implement the TextEditor class:\n            TextEditor() Initializes the object with empty text.\n            void addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.\n            int deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.\n            string cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\n            string cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\n        Example 1:\n        Input\n        [\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"]\n        [[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]]\n        Output\n        [null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"]\n        Explanation\n        TextEditor textEditor = new TextEditor(); // The current text is \"|\". (The '|' character represents the cursor)\n        textEditor.addText(\"leetcode\"); // The current text is \"leetcode|\".\n        textEditor.deleteText(4); // return 4\n                                  // The current text is \"leet|\". \n                                  // 4 characters were deleted.\n        textEditor.addText(\"practice\"); // The current text is \"leetpractice|\". \n        textEditor.cursorRight(3); // return \"etpractice\"\n                                   // The current text is \"leetpractice|\". \n                                   // The cursor cannot be moved beyond the actual text and thus did not move.\n                                   // \"etpractice\" is the last 10 characters to the left of the cursor.\n        textEditor.cursorLeft(8); // return \"leet\"\n                                  // The current text is \"leet|practice\".\n                                  // \"leet\" is the last min(10, 4) = 4 characters to the left of the cursor.\n        textEditor.deleteText(10); // return 4\n                                   // The current text is \"|practice\".\n                                   // Only 4 characters were deleted.\n        textEditor.cursorLeft(2); // return \"\"\n                                  // The current text is \"|practice\".\n                                  // The cursor cannot be moved beyond the actual text and thus did not move. \n                                  // \"\" is the last min(10, 0) = 0 characters to the left of the cursor.\n        textEditor.cursorRight(6); // return \"practi\"\n                                   // The current text is \"practi|ce\".\n                                   // \"practi\" is the last min(10, 6) = 6 characters to the left of the cursor.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1776,"row":{"number":2306,"difficulty":2,"question":"class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        \"\"\"\n        You are given an array of strings ideas that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:\n            Choose 2 distinct names from ideas, call them ideaA and ideaB.\n            Swap the first letters of ideaA and ideaB with each other.\n            If both of the new names are not found in the original ideas, then the name ideaA ideaB (the concatenation of ideaA and ideaB, separated by a space) is a valid company name.\n            Otherwise, it is not a valid name.\n        Return the number of distinct valid names for the company.\n        Example 1:\n        Input: ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]\n        Output: 6\n        Explanation: The following selections are valid:\n        - (\"coffee\", \"donuts\"): The company name created is \"doffee conuts\".\n        - (\"donuts\", \"coffee\"): The company name created is \"conuts doffee\".\n        - (\"donuts\", \"time\"): The company name created is \"tonuts dime\".\n        - (\"donuts\", \"toffee\"): The company name created is \"tonuts doffee\".\n        - (\"time\", \"donuts\"): The company name created is \"dime tonuts\".\n        - (\"toffee\", \"donuts\"): The company name created is \"doffee tonuts\".\n        Therefore, there are a total of 6 distinct company names.\n        The following are some examples of invalid selections:\n        - (\"coffee\", \"time\"): The name \"toffee\" formed after swapping already exists in the original array.\n        - (\"time\", \"toffee\"): Both names are still the same after swapping and exist in the original array.\n        - (\"coffee\", \"toffee\"): Both names formed after swapping already exist in the original array.\n        Example 2:\n        Input: ideas = [\"lack\",\"back\"]\n        Output: 0\n        Explanation: There are no valid selections. Therefore, 0 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1777,"row":{"number":2299,"difficulty":0,"question":"class Solution:\n    def strongPasswordCheckerII(self, password: str) -> bool:\n        \"\"\"\n        A password is said to be strong if it satisfies all the following criteria:\n            It has at least 8 characters.\n            It contains at least one lowercase letter.\n            It contains at least one uppercase letter.\n            It contains at least one digit.\n            It contains at least one special character. The special characters are the characters in the following string: \"!@#$%^&*()-+\".\n            It does not contain 2 of the same character in adjacent positions (i.e., \"aab\" violates this condition, but \"aba\" does not).\n        Given a string password, return true if it is a strong password. Otherwise, return false.\n        Example 1:\n        Input: password = \"IloveLe3tcode!\"\n        Output: true\n        Explanation: The password meets all the requirements. Therefore, we return true.\n        Example 2:\n        Input: password = \"Me+You--IsMyDream\"\n        Output: false\n        Explanation: The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false.\n        Example 3:\n        Input: password = \"1aB!\"\n        Output: false\n        Explanation: The password does not meet the length requirement. Therefore, we return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1778,"row":{"number":2300,"difficulty":1,"question":"class Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        \"\"\"\n        You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.\n        You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.\n        Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.\n        Example 1:\n        Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7\n        Output: [4,0,3]\n        Explanation:\n        - 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.\n        - 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n        - 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.\n        Thus, [4,0,3] is returned.\n        Example 2:\n        Input: spells = [3,1,2], potions = [8,5,8], success = 16\n        Output: [2,0,2]\n        Explanation:\n        - 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.\n        - 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n        - 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. \n        Thus, [2,0,2] is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1779,"row":{"number":2301,"difficulty":2,"question":"class Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        \"\"\"\n        You are given two strings s and sub. You are also given a 2D character array mappings where mappings[i] = [oldi, newi] indicates that you may perform the following operation any number of times:\n            Replace a character oldi of sub with newi.\n        Each character in sub cannot be replaced more than once.\n        Return true if it is possible to make sub a substring of s by replacing zero or more characters according to mappings. Otherwise, return false.\n        A substring is a contiguous non-empty sequence of characters within a string.\n        Example 1:\n        Input: s = \"fool3e7bar\", sub = \"leet\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]\n        Output: true\n        Explanation: Replace the first 'e' in sub with '3' and 't' in sub with '7'.\n        Now sub = \"l3e7\" is a substring of s, so we return true.\n        Example 2:\n        Input: s = \"fooleetbar\", sub = \"f00l\", mappings = [[\"o\",\"0\"]]\n        Output: false\n        Explanation: The string \"f00l\" is not a substring of s and no replacements can be made.\n        Note that we cannot replace '0' with 'o'.\n        Example 3:\n        Input: s = \"Fool33tbaR\", sub = \"leetd\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]\n        Output: true\n        Explanation: Replace the first and second 'e' in sub with '3' and 'd' in sub with 'b'.\n        Now sub = \"l33tb\" is a substring of s, so we return true.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1780,"row":{"number":2302,"difficulty":2,"question":"class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        The score of an array is defined as the product of its sum and its length.\n            For example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5 = 75.\n        Given a positive integer array nums and an integer k, return the number of non-empty subarrays of nums whose score is strictly less than k.\n        A subarray is a contiguous sequence of elements within an array.\n        Example 1:\n        Input: nums = [2,1,4,3,5], k = 10\n        Output: 6\n        Explanation:\n        The 6 subarrays having scores less than 10 are:\n        - [2] with score 2 * 1 = 2.\n        - [1] with score 1 * 1 = 1.\n        - [4] with score 4 * 1 = 4.\n        - [3] with score 3 * 1 = 3. \n        - [5] with score 5 * 1 = 5.\n        - [2,1] with score (2 + 1) * 2 = 6.\n        Note that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.\n        Example 2:\n        Input: nums = [1,1,1], k = 5\n        Output: 5\n        Explanation:\n        Every subarray except [1,1,1] has a score less than 5.\n        [1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.\n        Thus, there are 5 subarrays having scores less than 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1781,"row":{"number":2311,"difficulty":1,"question":"class Solution:\n    def longestSubsequence(self, s: str, k: int) -> int:\n        \"\"\"\n        You are given a binary string s and a positive integer k.\n        Return the length of the longest subsequence of s that makes up a binary number less than or equal to k.\n        Note:\n            The subsequence can contain leading zeroes.\n            The empty string is considered to be equal to 0.\n            A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n        Example 1:\n        Input: s = \"1001010\", k = 5\n        Output: 5\n        Explanation: The longest subsequence of s that makes up a binary number less than or equal to 5 is \"00010\", as this number is equal to 2 in decimal.\n        Note that \"00100\" and \"00101\" are also possible, which are equal to 4 and 5 in decimal, respectively.\n        The length of this subsequence is 5, so 5 is returned.\n        Example 2:\n        Input: s = \"00101001\", k = 1\n        Output: 6\n        Explanation: \"000001\" is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal.\n        The length of this subsequence is 6, so 6 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1782,"row":{"number":2320,"difficulty":1,"question":"class Solution:\n    def countHousePlacements(self, n: int) -> int:\n        \"\"\"\n        There is a street with n * 2 plots, where there are n plots on each side of the street. The plots on each side are numbered from 1 to n. On each plot, a house can be placed.\n        Return the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street. Since the answer may be very large, return it modulo 109 + 7.\n        Note that if a house is placed on the ith plot on one side of the street, a house can also be placed on the ith plot on the other side of the street.\n        Example 1:\n        Input: n = 1\n        Output: 4\n        Explanation: \n        Possible arrangements:\n        1. All plots are empty.\n        2. A house is placed on one side of the street.\n        3. A house is placed on the other side of the street.\n        4. Two houses are placed, one on each side of the street.\n        Example 2:\n        Input: n = 2\n        Output: 9\n        Explanation: The 9 possible arrangements are shown in the diagram above.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1783,"row":{"number":2319,"difficulty":0,"question":"class Solution:\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\n        \"\"\"\n        A square matrix is said to be an X-Matrix if both of the following conditions hold:\n            All the elements in the diagonals of the matrix are non-zero.\n            All other elements are 0.\n        Given a 2D integer array grid of size n x n representing a square matrix, return true if grid is an X-Matrix. Otherwise, return false.\n        Example 1:\n        Input: grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]\n        Output: true\n        Explanation: Refer to the diagram above. \n        An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\n        Thus, grid is an X-Matrix.\n        Example 2:\n        Input: grid = [[5,7,0],[0,3,1],[0,5,0]]\n        Output: false\n        Explanation: Refer to the diagram above.\n        An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\n        Thus, grid is not an X-Matrix.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1784,"row":{"number":2322,"difficulty":2,"question":"class Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        \"\"\"\n        There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\n        You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\n        Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n            Get the XOR of all the values of the nodes for each of the three components respectively.\n            The difference between the largest XOR value and the smallest XOR value is the score of the pair.\n            For example, say the three components have the node values: [4,5,7], [1,9], and [3,3,3]. The three XOR values are 4 ^ 5 ^ 7 = 6, 1 ^ 9 = 8, and 3 ^ 3 ^ 3 = 3. The largest XOR value is 8 and the smallest XOR value is 3. The score is then 8 - 3 = 5.\n        Return the minimum score of any possible pair of edge removals on the given tree.\n        Example 1:\n        Input: nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]\n        Output: 9\n        Explanation: The diagram above shows a way to make a pair of removals.\n        - The 1st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n        - The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1.\n        - The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5.\n        The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\n        It can be shown that no other pair of removals will obtain a smaller score than 9.\n        Example 2:\n        Input: nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]\n        Output: 0\n        Explanation: The diagram above shows a way to make a pair of removals.\n        - The 1st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0.\n        - The 2nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0.\n        - The 3rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0.\n        The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\n        We cannot obtain a smaller score than 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1785,"row":{"number":2315,"difficulty":0,"question":"class Solution:\n    def countAsterisks(self, s: str) -> int:\n        \"\"\"\n        You are given a string s, where every two consecutive vertical bars '|' are grouped into a pair. In other words, the 1st and 2nd '|' make a pair, the 3rd and 4th '|' make a pair, and so forth.\n        Return the number of '*' in s, excluding the '*' between each pair of '|'.\n        Note that each '|' will belong to exactly one pair.\n        Example 1:\n        Input: s = \"l|*e*et|c**o|*de|\"\n        Output: 2\n        Explanation: The considered characters are underlined: \"l|*e*et|c**o|*de|\".\n        The characters between the first and second '|' are excluded from the answer.\n        Also, the characters between the third and fourth '|' are excluded from the answer.\n        There are 2 asterisks considered. Therefore, we return 2.\n        Example 2:\n        Input: s = \"iamprogrammer\"\n        Output: 0\n        Explanation: In this example, there are no asterisks in s. Therefore, we return 0.\n        Example 3:\n        Input: s = \"yo|uar|e**|b|e***au|tifu|l\"\n        Output: 5\n        Explanation: The considered characters are underlined: \"yo|uar|e**|b|e***au|tifu|l\". There are 5 asterisks considered. Therefore, we return 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1786,"row":{"number":2317,"difficulty":1,"question":"class Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x).\n        Note that AND is the bitwise AND operation and XOR is the bitwise XOR operation.\n        Return the maximum possible bitwise XOR of all elements of nums after applying the operation any number of times.\n        Example 1:\n        Input: nums = [3,2,4,6]\n        Output: 7\n        Explanation: Apply the operation with x = 4 and i = 3, num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2.\n        Now, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7.\n        It can be shown that 7 is the maximum possible bitwise XOR.\n        Note that other operations may be used to achieve a bitwise XOR of 7.\n        Example 2:\n        Input: nums = [1,2,3,9,2]\n        Output: 11\n        Explanation: Apply the operation zero times.\n        The bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.\n        It can be shown that 11 is the maximum possible bitwise XOR.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1787,"row":{"number":2316,"difficulty":1,"question":"class Solution:\n    def countPairs(self, n: int, edges: List[List[int]]) -> int:\n        \"\"\"\n        You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\n        Return the number of pairs of different nodes that are unreachable from each other.\n        Example 1:\n        Input: n = 3, edges = [[0,1],[0,2],[1,2]]\n        Output: 0\n        Explanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.\n        Example 2:\n        Input: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]\n        Output: 14\n        Explanation: There are 14 pairs of nodes that are unreachable from each other:\n        [[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].\n        Therefore, we return 14.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1788,"row":{"number":2318,"difficulty":2,"question":"class Solution:\n    def distinctSequences(self, n: int) -> int:\n        \"\"\"\n        You are given an integer n. You roll a fair 6-sided dice n times. Determine the total number of distinct sequences of rolls possible such that the following conditions are satisfied:\n            The greatest common divisor of any adjacent values in the sequence is equal to 1.\n            There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2.\n        Return the total number of distinct sequences possible. Since the answer may be very large, return it modulo 109 + 7.\n        Two sequences are considered distinct if at least one element is different.\n        Example 1:\n        Input: n = 4\n        Output: 184\n        Explanation: Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.\n        Some invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).\n        (1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).\n        (1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.\n        There are a total of 184 distinct sequences possible, so we return 184.\n        Example 2:\n        Input: n = 2\n        Output: 22\n        Explanation: Some of the possible sequences are (1, 2), (2, 1), (3, 2).\n        Some invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.\n        There are a total of 22 distinct sequences possible, so we return 22.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1789,"row":{"number":2325,"difficulty":0,"question":"class Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        \"\"\"\n        You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows:\n            Use the first appearance of all 26 lowercase English letters in key as the order of the substitution table.\n            Align the substitution table with the regular English alphabet.\n            Each letter in message is then substituted using the table.\n            Spaces ' ' are transformed to themselves.\n            For example, given key = \"happy boy\" (actual key would have at least one instance of each letter in the alphabet), we have the partial substitution table of ('h' -> 'a', 'a' -> 'b', 'p' -> 'c', 'y' -> 'd', 'b' -> 'e', 'o' -> 'f').\n        Return the decoded message.\n        Example 1:\n        Input: key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\"\n        Output: \"this is a secret\"\n        Explanation: The diagram above shows the substitution table.\n        It is obtained by taking the first appearance of each letter in \"the quick brown fox jumps over the lazy dog\".\n        Example 2:\n        Input: key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\"\n        Output: \"the five boxing wizards jump quickly\"\n        Explanation: The diagram above shows the substitution table.\n        It is obtained by taking the first appearance of each letter in \"eljuxhpwnyrdgtqkviszcfmabo\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1790,"row":{"number":2327,"difficulty":1,"question":"class Solution:\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\n        \"\"\"\n        On day 1, one person discovers a secret.\n        You are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards.\n        Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 6, delay = 2, forget = 4\n        Output: 5\n        Explanation:\n        Day 1: Suppose the first person is named A. (1 person)\n        Day 2: A is the only person who knows the secret. (1 person)\n        Day 3: A shares the secret with a new person, B. (2 people)\n        Day 4: A shares the secret with a new person, C. (3 people)\n        Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\n        Day 6: B shares the secret with E, and C shares the secret with F. (5 people)\n        Example 2:\n        Input: n = 4, delay = 1, forget = 3\n        Output: 6\n        Explanation:\n        Day 1: The first person is named A. (1 person)\n        Day 2: A shares the secret with B. (2 people)\n        Day 3: A and B share the secret with 2 new people, C and D. (4 people)\n        Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1791,"row":{"number":2328,"difficulty":2,"question":"class Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer matrix grid, where you can move from a cell to any adjacent cell in all 4 directions.\n        Return the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. Since the answer may be very large, return it modulo 109 + 7.\n        Two paths are considered different if they do not have exactly the same sequence of visited cells.\n        Example 1:\n        Input: grid = [[1,1],[3,4]]\n        Output: 8\n        Explanation: The strictly increasing paths are:\n        - Paths with length 1: [1], [1], [3], [4].\n        - Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4].\n        - Paths with length 3: [1 -> 3 -> 4].\n        The total number of paths is 4 + 3 + 1 = 8.\n        Example 2:\n        Input: grid = [[1],[2]]\n        Output: 3\n        Explanation: The strictly increasing paths are:\n        - Paths with length 1: [1], [2].\n        - Paths with length 2: [1 -> 2].\n        The total number of paths is 2 + 1 = 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1792,"row":{"number":2326,"difficulty":1,"question":"class Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        \"\"\"\n        You are given two integers m and n, which represent the dimensions of a matrix.\n        You are also given the head of a linked list of integers.\n        Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.\n        Return the generated matrix.\n        Example 1:\n        Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\n        Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\n        Explanation: The diagram above shows how the values are printed in the matrix.\n        Note that the remaining spaces in the matrix are filled with -1.\n        Example 2:\n        Input: m = 1, n = 4, head = [0,1,2]\n        Output: [[0,1,2,-1]]\n        Explanation: The diagram above shows how the values are printed from left to right in the matrix.\n        The last space in the matrix is set to -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1793,"row":{"number":2335,"difficulty":0,"question":"class Solution:\n    def fillCups(self, amount: List[int]) -> int:\n        \"\"\"\n        You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water.\n        You are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. Return the minimum number of seconds needed to fill up all the cups.\n        Example 1:\n        Input: amount = [1,4,2]\n        Output: 4\n        Explanation: One way to fill up the cups is:\n        Second 1: Fill up a cold cup and a warm cup.\n        Second 2: Fill up a warm cup and a hot cup.\n        Second 3: Fill up a warm cup and a hot cup.\n        Second 4: Fill up a warm cup.\n        It can be proven that 4 is the minimum number of seconds needed.\n        Example 2:\n        Input: amount = [5,4,4]\n        Output: 7\n        Explanation: One way to fill up the cups is:\n        Second 1: Fill up a cold cup, and a hot cup.\n        Second 2: Fill up a cold cup, and a warm cup.\n        Second 3: Fill up a cold cup, and a warm cup.\n        Second 4: Fill up a warm cup, and a hot cup.\n        Second 5: Fill up a cold cup, and a hot cup.\n        Second 6: Fill up a cold cup, and a warm cup.\n        Second 7: Fill up a hot cup.\n        Example 3:\n        Input: amount = [5,0,0]\n        Output: 5\n        Explanation: Every second, we fill up a cold cup.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1794,"row":{"number":2336,"difficulty":1,"question":"class SmallestInfiniteSet:\n    def __init__(self):\n    def popSmallest(self) -> int:\n    def addBack(self, num: int) -> None:\n        \"\"\"\n        You have a set which contains all positive integers [1, 2, 3, 4, 5, ...].\n        Implement the SmallestInfiniteSet class:\n            SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers.\n            int popSmallest() Removes and returns the smallest integer contained in the infinite set.\n            void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\n        Example 1:\n        Input\n        [\"SmallestInfiniteSet\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\"]\n        [[], [2], [], [], [], [1], [], [], []]\n        Output\n        [null, null, 1, 2, 3, null, 1, 4, 5]\n        Explanation\n        SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();\n        smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.\n        smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.\n        smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.\n        smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.\n        smallestInfiniteSet.addBack(1);    // 1 is added back to the set.\n        smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and\n                                           // is the smallest number, and remove it from the set.\n        smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.\n        smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1795,"row":{"number":2337,"difficulty":1,"question":"class Solution:\n    def canChange(self, start: str, target: str) -> bool:\n        \"\"\"\n        You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where:\n            The characters 'L' and 'R' represent pieces, where a piece 'L' can move to the left only if there is a blank space directly to its left, and a piece 'R' can move to the right only if there is a blank space directly to its right.\n            The character '_' represents a blank space that can be occupied by any of the 'L' or 'R' pieces.\n        Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.\n        Example 1:\n        Input: start = \"_L__R__R_\", target = \"L______RR\"\n        Output: true\n        Explanation: We can obtain the string target from start by doing the following moves:\n        - Move the first piece one step to the left, start becomes equal to \"L___R__R_\".\n        - Move the last piece one step to the right, start becomes equal to \"L___R___R\".\n        - Move the second piece three steps to the right, start becomes equal to \"L______RR\".\n        Since it is possible to get the string target from start, we return true.\n        Example 2:\n        Input: start = \"R_L_\", target = \"__LR\"\n        Output: false\n        Explanation: The 'R' piece in the string start can move one step to the right to obtain \"_RL_\".\n        After that, no pieces can move anymore, so it is impossible to obtain the string target from start.\n        Example 3:\n        Input: start = \"_R\", target = \"R_\"\n        Output: false\n        Explanation: The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1796,"row":{"number":2338,"difficulty":2,"question":"class Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        \"\"\"\n        You are given two integers n and maxValue, which are used to describe an ideal array.\n        A 0-indexed integer array arr of length n is considered ideal if the following conditions hold:\n            Every arr[i] is a value from 1 to maxValue, for 0 <= i < n.\n            Every arr[i] is divisible by arr[i - 1], for 0 < i < n.\n        Return the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: n = 2, maxValue = 5\n        Output: 10\n        Explanation: The following are the possible ideal arrays:\n        - Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]\n        - Arrays starting with the value 2 (2 arrays): [2,2], [2,4]\n        - Arrays starting with the value 3 (1 array): [3,3]\n        - Arrays starting with the value 4 (1 array): [4,4]\n        - Arrays starting with the value 5 (1 array): [5,5]\n        There are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.\n        Example 2:\n        Input: n = 5, maxValue = 3\n        Output: 11\n        Explanation: The following are the possible ideal arrays:\n        - Arrays starting with the value 1 (9 arrays): \n           - With no other distinct values (1 array): [1,1,1,1,1] \n           - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]\n           - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]\n        - Arrays starting with the value 2 (1 array): [2,2,2,2,2]\n        - Arrays starting with the value 3 (1 array): [3,3,3,3,3]\n        There are a total of 9 + 1 + 1 = 11 distinct ideal arrays.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1797,"row":{"number":2331,"difficulty":0,"question":"class Solution:\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        You are given the root of a full binary tree with the following properties:\n            Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.\n            Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.\n        The evaluation of a node is as follows:\n            If the node is a leaf node, the evaluation is the value of the node, i.e. True or False.\n            Otherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.\n        Return the boolean result of evaluating the root node.\n        A full binary tree is a binary tree where each node has either 0 or 2 children.\n        A leaf node is a node that has zero children.\n        Example 1:\n        Input: root = [2,1,3,null,null,0,1]\n        Output: true\n        Explanation: The above diagram illustrates the evaluation process.\n        The AND node evaluates to False AND True = False.\n        The OR node evaluates to True OR False = True.\n        The root node evaluates to True, so we return true.\n        Example 2:\n        Input: root = [0]\n        Output: false\n        Explanation: The root node is a leaf node and it evaluates to false, so we return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1798,"row":{"number":2332,"difficulty":1,"question":"class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array buses of length n, where buses[i] represents the departure time of the ith bus. You are also given a 0-indexed integer array passengers of length m, where passengers[j] represents the arrival time of the jth passenger. All bus departure times are unique. All passenger arrival times are unique.\n        You are given an integer capacity, which represents the maximum number of passengers that can get on each bus.\n        When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x, and the bus is not full. Passengers with the earliest arrival times get on the bus first.\n        More formally when a bus arrives, either:\n            If capacity or fewer passengers are waiting for a bus, they will all get on the bus, or\n            The capacity passengers with the earliest arrival times will get on the bus.\n        Return the latest time you may arrive at the bus station to catch a bus. You cannot arrive at the same time as another passenger.\n        Note: The arrays buses and passengers are not necessarily sorted.\n        Example 1:\n        Input: buses = [10,20], passengers = [2,17,18,19], capacity = 2\n        Output: 16\n        Explanation: Suppose you arrive at time 16.\n        At time 10, the first bus departs with the 0th passenger. \n        At time 20, the second bus departs with you and the 1st passenger.\n        Note that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus.\n        Example 2:\n        Input: buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2\n        Output: 20\n        Explanation: Suppose you arrive at time 20.\n        At time 10, the first bus departs with the 3rd passenger. \n        At time 20, the second bus departs with the 5th and 1st passengers.\n        At time 30, the third bus departs with the 0th passenger and you.\n        Notice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1799,"row":{"number":2333,"difficulty":1,"question":"class Solution:\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        \"\"\"\n        You are given two positive 0-indexed integer arrays nums1 and nums2, both of length n.\n        The sum of squared difference of arrays nums1 and nums2 is defined as the sum of (nums1[i] - nums2[i])2 for each 0 <= i < n.\n        You are also given two positive integers k1 and k2. You can modify any of the elements of nums1 by +1 or -1 at most k1 times. Similarly, you can modify any of the elements of nums2 by +1 or -1 at most k2 times.\n        Return the minimum sum of squared difference after modifying array nums1 at most k1 times and modifying array nums2 at most k2 times.\n        Note: You are allowed to modify the array elements to become negative integers.\n        Example 1:\n        Input: nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0\n        Output: 579\n        Explanation: The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. \n        The sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579.\n        Example 2:\n        Input: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1\n        Output: 43\n        Explanation: One way to obtain the minimum sum of square difference is: \n        - Increase nums1[0] once.\n        - Increase nums2[2] once.\n        The minimum of the sum of square difference will be: \n        (2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43.\n        Note that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43.\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}