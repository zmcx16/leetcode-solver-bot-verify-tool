{"features":[{"feature_idx":0,"name":"number","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":1,"name":"difficulty","type":{"dtype":"int64","_type":"Value"}},{"feature_idx":2,"name":"question","type":{"dtype":"string","_type":"Value"}}],"rows":[{"row_idx":1800,"row":{"number":2334,"difficulty":2,"question":"class Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer threshold.\n        Find any subarray of nums of length k such that every element in the subarray is greater than threshold / k.\n        Return the size of any such subarray. If there is no such subarray, return -1.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,3,4,3,1], threshold = 6\n        Output: 3\n        Explanation: The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2.\n        Note that this is the only valid subarray.\n        Example 2:\n        Input: nums = [6,5,6,5,8], threshold = 7\n        Output: 1\n        Explanation: The subarray [8] has a size of 1, and 8 > 7 / 1 = 7. So 1 is returned.\n        Note that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. \n        Similarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions.\n        Therefore, 2, 3, 4, or 5 may also be returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1801,"row":{"number":2341,"difficulty":0,"question":"class Solution:\n    def numberOfPairs(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed integer array nums. In one operation, you may do the following:\n            Choose two integers in nums that are equal.\n            Remove both integers from nums, forming a pair.\n        The operation is done on nums as many times as possible.\n        Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.\n        Example 1:\n        Input: nums = [1,3,2,1,3,2,2]\n        Output: [3,1]\n        Explanation:\n        Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].\n        Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].\n        Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].\n        No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.\n        Example 2:\n        Input: nums = [1,1]\n        Output: [1,0]\n        Explanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].\n        No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.\n        Example 3:\n        Input: nums = [0]\n        Output: [0,1]\n        Explanation: No pairs can be formed, and there is 1 number leftover in nums.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1802,"row":{"number":2343,"difficulty":1,"question":"class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array of strings nums, where each string is of equal length and consists of only digits.\n        You are also given a 0-indexed 2D integer array queries where queries[i] = [ki, trimi]. For each queries[i], you need to:\n            Trim each number in nums to its rightmost trimi digits.\n            Determine the index of the kith smallest trimmed number in nums. If two trimmed numbers are equal, the number with the lower index is considered to be smaller.\n            Reset each number in nums to its original length.\n        Return an array answer of the same length as queries, where answer[i] is the answer to the ith query.\n        Note:\n            To trim to the rightmost x digits means to keep removing the leftmost digit, until only x digits remain.\n            Strings in nums may contain leading zeros.\n        Example 1:\n        Input: nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\n        Output: [2,2,1,0]\n        Explanation:\n        1. After trimming to the last digit, nums = [\"2\",\"3\",\"1\",\"4\"]. The smallest number is 1 at index 2.\n        2. Trimmed to the last 3 digits, nums is unchanged. The 2nd smallest number is 251 at index 2.\n        3. Trimmed to the last 2 digits, nums = [\"02\",\"73\",\"51\",\"14\"]. The 4th smallest number is 73.\n        4. Trimmed to the last 2 digits, the smallest number is 2 at index 0.\n           Note that the trimmed number \"02\" is evaluated as 2.\n        Example 2:\n        Input: nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\n        Output: [3,0]\n        Explanation:\n        1. Trimmed to the last digit, nums = [\"4\",\"7\",\"6\",\"4\"]. The 2nd smallest number is 4 at index 3.\n           There are two occurrences of 4, but the one at index 0 is considered smaller than the one at index 3.\n        2. Trimmed to the last 2 digits, nums is unchanged. The 2nd smallest number is 24.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1803,"row":{"number":2344,"difficulty":2,"question":"class Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        \"\"\"\n        You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.\n        Return the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.\n        Note that an integer x divides y if y % x == 0.\n        Example 1:\n        Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\n        Output: 2\n        Explanation: \n        The smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.\n        We use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].\n        The smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.\n        It can be shown that 2 is the minimum number of deletions needed.\n        Example 2:\n        Input: nums = [4,3,6], numsDivide = [8,2,6,10]\n        Output: -1\n        Explanation: \n        We want the smallest element in nums to divide all the elements of numsDivide.\n        There is no way to delete elements from nums to allow this.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1804,"row":{"number":2351,"difficulty":0,"question":"class Solution:\n    def repeatedCharacter(self, s: str) -> str:\n        \"\"\"\n        Given a string s consisting of lowercase English letters, return the first letter to appear twice.\n        Note:\n            A letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b.\n            s will contain at least one letter that appears twice.\n        Example 1:\n        Input: s = \"abccbaacz\"\n        Output: \"c\"\n        Explanation:\n        The letter 'a' appears on the indexes 0, 5 and 6.\n        The letter 'b' appears on the indexes 1 and 4.\n        The letter 'c' appears on the indexes 2, 3 and 7.\n        The letter 'z' appears on the index 8.\n        The letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.\n        Example 2:\n        Input: s = \"abcdd\"\n        Output: \"d\"\n        Explanation:\n        The only letter that appears twice is 'd' so we return 'd'.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1805,"row":{"number":2352,"difficulty":1,"question":"class Solution:\n    def equalPairs(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.\n        A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).\n        Example 1:\n        Input: grid = [[3,2,1],[1,7,6],[2,7,7]]\n        Output: 1\n        Explanation: There is 1 equal row and column pair:\n        - (Row 2, Column 1): [2,7,7]\n        Example 2:\n        Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\n        Output: 3\n        Explanation: There are 3 equal row and column pairs:\n        - (Row 0, Column 0): [3,1,2,2]\n        - (Row 2, Column 2): [2,4,2,2]\n        - (Row 3, Column 2): [2,4,2,2]\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1806,"row":{"number":2353,"difficulty":1,"question":"class FoodRatings:\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n    def changeRating(self, food: str, newRating: int) -> None:\n    def highestRated(self, cuisine: str) -> str:\n        \"\"\"\n        Design a food rating system that can do the following:\n            Modify the rating of a food item listed in the system.\n            Return the highest-rated food item for a type of cuisine in the system.\n        Implement the FoodRatings class:\n            FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.\n                foods[i] is the name of the ith food,\n                cuisines[i] is the type of cuisine of the ith food, and\n                ratings[i] is the initial rating of the ith food.\n            void changeRating(String food, int newRating) Changes the rating of the food item with the name food.\n            String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.\n        Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.\n        Example 1:\n        Input\n        [\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n        [[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\n        Output\n        [null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n        Explanation\n        FoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\n        foodRatings.highestRated(\"korean\"); // return \"kimchi\"\n                                            // \"kimchi\" is the highest rated korean food with a rating of 9.\n        foodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                              // \"ramen\" is the highest rated japanese food with a rating of 14.\n        foodRatings.changeRating(\"sushi\", 16); // \"sushi\" now has a rating of 16.\n        foodRatings.highestRated(\"japanese\"); // return \"sushi\"\n                                              // \"sushi\" is the highest rated japanese food with a rating of 16.\n        foodRatings.changeRating(\"ramen\", 16); // \"ramen\" now has a rating of 16.\n        foodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                              // Both \"sushi\" and \"ramen\" have a rating of 16.\n                                              // However, \"ramen\" is lexicographically smaller than \"sushi\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1807,"row":{"number":2354,"difficulty":2,"question":"class Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed positive integer array nums and a positive integer k.\n        A pair of numbers (num1, num2) is called excellent if the following conditions are satisfied:\n            Both the numbers num1 and num2 exist in the array nums.\n            The sum of the number of set bits in num1 OR num2 and num1 AND num2 is greater than or equal to k, where OR is the bitwise OR operation and AND is the bitwise AND operation.\n        Return the number of distinct excellent pairs.\n        Two pairs (a, b) and (c, d) are considered distinct if either a != c or b != d. For example, (1, 2) and (2, 1) are distinct.\n        Note that a pair (num1, num2) such that num1 == num2 can also be excellent if you have at least one occurrence of num1 in the array.\n        Example 1:\n        Input: nums = [1,2,3,1], k = 3\n        Output: 5\n        Explanation: The excellent pairs are the following:\n        - (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.\n        - (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\n        - (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\n        So the number of excellent pairs is 5.\n        Example 2:\n        Input: nums = [5,1,1], k = 10\n        Output: 0\n        Explanation: There are no excellent pairs for this array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1808,"row":{"number":2348,"difficulty":1,"question":"class Solution:\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the number of subarrays filled with 0.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,3,0,0,2,0,0,4]\n        Output: 6\n        Explanation: \n        There are 4 occurrences of [0] as a subarray.\n        There are 2 occurrences of [0,0] as a subarray.\n        There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.\n        Example 2:\n        Input: nums = [0,0,0,2,0,0]\n        Output: 9\n        Explanation:\n        There are 5 occurrences of [0] as a subarray.\n        There are 3 occurrences of [0,0] as a subarray.\n        There is 1 occurrence of [0,0,0] as a subarray.\n        There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\n        Example 3:\n        Input: nums = [2,10,2019]\n        Output: 0\n        Explanation: There is no subarray filled with 0. Therefore, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1809,"row":{"number":2347,"difficulty":0,"question":"class Solution:\n    def bestHand(self, ranks: List[int], suits: List[str]) -> str:\n        \"\"\"\n        You are given an integer array ranks and a character array suits. You have 5 cards where the ith card has a rank of ranks[i] and a suit of suits[i].\n        The following are the types of poker hands you can make from best to worst:\n            \"Flush\": Five cards of the same suit.\n            \"Three of a Kind\": Three cards of the same rank.\n            \"Pair\": Two cards of the same rank.\n            \"High Card\": Any single card.\n        Return a string representing the best type of poker hand you can make with the given cards.\n        Note that the return values are case-sensitive.\n        Example 1:\n        Input: ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"]\n        Output: \"Flush\"\n        Explanation: The hand with all the cards consists of 5 cards with the same suit, so we have a \"Flush\".\n        Example 2:\n        Input: ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"]\n        Output: \"Three of a Kind\"\n        Explanation: The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a \"Three of a Kind\".\n        Note that we could also make a \"Pair\" hand but \"Three of a Kind\" is a better hand.\n        Also note that other cards could be used to make the \"Three of a Kind\" hand.\n        Example 3:\n        Input: ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"]\n        Output: \"Pair\"\n        Explanation: The hand with the first and second card consists of 2 cards with the same rank, so we have a \"Pair\".\n        Note that we cannot make a \"Flush\" or a \"Three of a Kind\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1810,"row":{"number":2349,"difficulty":1,"question":"class NumberContainers:\n    def __init__(self):\n    def change(self, index: int, number: int) -> None:\n    def find(self, number: int) -> int:\n        \"\"\"\n        Design a number container system that can do the following:\n            Insert or Replace a number at the given index in the system.\n            Return the smallest index for the given number in the system.\n        Implement the NumberContainers class:\n            NumberContainers() Initializes the number container system.\n            void change(int index, int number) Fills the container at index with the number. If there is already a number at that index, replace it.\n            int find(int number) Returns the smallest index for the given number, or -1 if there is no index that is filled by number in the system.\n        Example 1:\n        Input\n        [\"NumberContainers\", \"find\", \"change\", \"change\", \"change\", \"change\", \"find\", \"change\", \"find\"]\n        [[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]\n        Output\n        [null, -1, null, null, null, null, 1, null, 2]\n        Explanation\n        NumberContainers nc = new NumberContainers();\n        nc.find(10); // There is no index that is filled with number 10. Therefore, we return -1.\n        nc.change(2, 10); // Your container at index 2 will be filled with number 10.\n        nc.change(1, 10); // Your container at index 1 will be filled with number 10.\n        nc.change(3, 10); // Your container at index 3 will be filled with number 10.\n        nc.change(5, 10); // Your container at index 5 will be filled with number 10.\n        nc.find(10); // Number 10 is at the indices 1, 2, 3, and 5. Since the smallest index that is filled with 10 is 1, we return 1.\n        nc.change(1, 20); // Your container at index 1 will be filled with number 20. Note that index 1 was filled with 10 and then replaced with 20. \n        nc.find(10); // Number 10 is at the indices 2, 3, and 5. The smallest index that is filled with 10 is 2. Therefore, we return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1811,"row":{"number":2350,"difficulty":2,"question":"class Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array rolls of length n and an integer k. You roll a k sided dice numbered from 1 to k, n times, where the result of the ith roll is rolls[i].\n        Return the length of the shortest sequence of rolls that cannot be taken from rolls.\n        A sequence of rolls of length len is the result of rolling a k sided dice len times.\n        Note that the sequence taken does not have to be consecutive as long as it is in order.\n        Example 1:\n        Input: rolls = [4,2,1,2,3,3,2,4,1], k = 4\n        Output: 3\n        Explanation: Every sequence of rolls of length 1, [1], [2], [3], [4], can be taken from rolls.\n        Every sequence of rolls of length 2, [1, 1], [1, 2], ..., [4, 4], can be taken from rolls.\n        The sequence [1, 4, 2] cannot be taken from rolls, so we return 3.\n        Note that there are other sequences that cannot be taken from rolls.\n        Example 2:\n        Input: rolls = [1,1,2,2], k = 2\n        Output: 2\n        Explanation: Every sequence of rolls of length 1, [1], [2], can be taken from rolls.\n        The sequence [2, 1] cannot be taken from rolls, so we return 2.\n        Note that there are other sequences that cannot be taken from rolls but [2, 1] is the shortest.\n        Example 3:\n        Input: rolls = [1,1,3,2,2,2,3,3], k = 4\n        Output: 1\n        Explanation: The sequence [4] cannot be taken from rolls, so we return 1.\n        Note that there are other sequences that cannot be taken from rolls but [4] is the shortest.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1812,"row":{"number":2357,"difficulty":0,"question":"class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a non-negative integer array nums. In one operation, you must:\n            Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\n            Subtract x from every positive element in nums.\n        Return the minimum number of operations to make every element in nums equal to 0.\n        Example 1:\n        Input: nums = [1,5,0,3,5]\n        Output: 3\n        Explanation:\n        In the first operation, choose x = 1. Now, nums = [0,4,0,2,4].\n        In the second operation, choose x = 2. Now, nums = [0,2,0,0,2].\n        In the third operation, choose x = 2. Now, nums = [0,0,0,0,0].\n        Example 2:\n        Input: nums = [0]\n        Output: 0\n        Explanation: Each element in nums is already 0 so no operations are needed.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1813,"row":{"number":2358,"difficulty":1,"question":"class Solution:\n    def maximumGroups(self, grades: List[int]) -> int:\n        \"\"\"\n        You are given a positive integer array grades which represents the grades of students in a university. You would like to enter all these students into a competition in ordered non-empty groups, such that the ordering meets the following conditions:\n            The sum of the grades of students in the ith group is less than the sum of the grades of students in the (i + 1)th group, for all groups (except the last).\n            The total number of students in the ith group is less than the total number of students in the (i + 1)th group, for all groups (except the last).\n        Return the maximum number of groups that can be formed.\n        Example 1:\n        Input: grades = [10,6,12,7,3,5]\n        Output: 3\n        Explanation: The following is a possible way to form 3 groups of students:\n        - 1st group has the students with grades = [12]. Sum of grades: 12. Student count: 1\n        - 2nd group has the students with grades = [6,7]. Sum of grades: 6 + 7 = 13. Student count: 2\n        - 3rd group has the students with grades = [10,3,5]. Sum of grades: 10 + 3 + 5 = 18. Student count: 3\n        It can be shown that it is not possible to form more than 3 groups.\n        Example 2:\n        Input: grades = [8,8]\n        Output: 1\n        Explanation: We can only form 1 group, since forming 2 groups would lead to an equal number of students in both groups.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1814,"row":{"number":2359,"difficulty":1,"question":"class Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        \"\"\"\n        You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\n        The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\n        You are also given two integers node1 and node2.\n        Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\n        Note that edges may contain cycles.\n        Example 1:\n        Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\n        Output: 2\n        Explanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\n        The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n        Example 2:\n        Input: edges = [1,2,-1], node1 = 0, node2 = 2\n        Output: 2\n        Explanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\n        The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1815,"row":{"number":2360,"difficulty":2,"question":"class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        \"\"\"\n        You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\n        The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\n        Return the length of the longest cycle in the graph. If no cycle exists, return -1.\n        A cycle is a path that starts and ends at the same node.\n        Example 1:\n        Input: edges = [3,3,4,2,3]\n        Output: 3\n        Explanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\n        The length of this cycle is 3, so 3 is returned.\n        Example 2:\n        Input: edges = [2,-1,3,1]\n        Output: -1\n        Explanation: There are no cycles in this graph.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1816,"row":{"number":2367,"difficulty":0,"question":"class Solution:\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\n        \"\"\"\n        You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\n            i < j < k,\n            nums[j] - nums[i] == diff, and\n            nums[k] - nums[j] == diff.\n        Return the number of unique arithmetic triplets.\n        Example 1:\n        Input: nums = [0,1,4,6,7,10], diff = 3\n        Output: 2\n        Explanation:\n        (1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n        (2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. \n        Example 2:\n        Input: nums = [4,5,6,7,8,9], diff = 2\n        Output: 2\n        Explanation:\n        (0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n        (1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1817,"row":{"number":2369,"difficulty":1,"question":"class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\n        We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n            The subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\n            The subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\n            The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n        Return true if the array has at least one valid partition. Otherwise, return false.\n        Example 1:\n        Input: nums = [4,4,4,5,6]\n        Output: true\n        Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\n        This partition is valid, so we return true.\n        Example 2:\n        Input: nums = [1,1,1,2]\n        Output: false\n        Explanation: There is no valid partition for this array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1818,"row":{"number":2370,"difficulty":1,"question":"class Solution:\n    def longestIdealString(self, s: str, k: int) -> int:\n        \"\"\"\n        You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n            t is a subsequence of the string s.\n            The absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n        Return the length of the longest ideal string.\n        A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n        Note that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n        Example 1:\n        Input: s = \"acfgbd\", k = 2\n        Output: 4\n        Explanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\n        Note that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.\n        Example 2:\n        Input: s = \"abcd\", k = 3\n        Output: 4\n        Explanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1819,"row":{"number":2368,"difficulty":1,"question":"class Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        \"\"\"\n        There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\n        You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.\n        Return the maximum number of nodes you can reach from node 0 without visiting a restricted node.\n        Note that node 0 will not be a restricted node.\n        Example 1:\n        Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\n        Output: 4\n        Explanation: The diagram above shows the tree.\n        We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.\n        Example 2:\n        Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\n        Output: 3\n        Explanation: The diagram above shows the tree.\n        We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1820,"row":{"number":2363,"difficulty":0,"question":"class Solution:\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:\n            items[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.\n            The value of each item in items is unique.\n        Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.\n        Note: ret should be returned in ascending order by value.\n        Example 1:\n        Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\n        Output: [[1,6],[3,9],[4,5]]\n        Explanation: \n        The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.\n        The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.\n        The item with value = 4 occurs in items1 with weight = 5, total weight = 5.  \n        Therefore, we return [[1,6],[3,9],[4,5]].\n        Example 2:\n        Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\n        Output: [[1,4],[2,4],[3,4]]\n        Explanation: \n        The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.\n        The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.\n        The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.\n        Therefore, we return [[1,4],[2,4],[3,4]].\n        Example 3:\n        Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\n        Output: [[1,7],[2,4],[7,1]]\n        Explanation:\n        The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. \n        The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. \n        The item with value = 7 occurs in items2 with weight = 1, total weight = 1.\n        Therefore, we return [[1,7],[2,4],[7,1]].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1821,"row":{"number":2364,"difficulty":1,"question":"class Solution:\n    def countBadPairs(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].\n        Return the total number of bad pairs in nums.\n        Example 1:\n        Input: nums = [4,1,3,3]\n        Output: 5\n        Explanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.\n        The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.\n        The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.\n        The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.\n        The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.\n        There are a total of 5 bad pairs, so we return 5.\n        Example 2:\n        Input: nums = [1,2,3,4,5]\n        Output: 0\n        Explanation: There are no bad pairs.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1822,"row":{"number":2398,"difficulty":2,"question":"class Solution:\n    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        \"\"\"\n        You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The ith robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget.\n        The total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots.\n        Return the maximum number of consecutive robots you can run such that the total cost does not exceed budget.\n        Example 1:\n        Input: chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25\n        Output: 3\n        Explanation: \n        It is possible to run all individual and consecutive pairs of robots within budget.\n        To obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25.\n        It can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.\n        Example 2:\n        Input: chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19\n        Output: 0\n        Explanation: No robot can be run that does not exceed the budget, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1823,"row":{"number":2366,"difficulty":2,"question":"class Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array nums. In one operation you can replace any element of the array with any two elements that sum to it.\n            For example, consider nums = [5,6,7]. In one operation, we can replace nums[1] with 2 and 4 and convert nums to [5,2,4,7].\n        Return the minimum number of operations to make an array that is sorted in non-decreasing order.\n        Example 1:\n        Input: nums = [3,9,3]\n        Output: 2\n        Explanation: Here are the steps to sort the array in non-decreasing order:\n        - From [3,9,3], replace the 9 with 3 and 6 so the array becomes [3,3,6,3]\n        - From [3,3,6,3], replace the 6 with 3 and 3 so the array becomes [3,3,3,3,3]\n        There are 2 steps to sort the array in non-decreasing order. Therefore, we return 2.\n        Example 2:\n        Input: nums = [1,2,3,4,5]\n        Output: 0\n        Explanation: The array is already in non-decreasing order. Therefore, we return 0. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1824,"row":{"number":2373,"difficulty":0,"question":"class Solution:\n    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given an n x n integer matrix grid.\n        Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:\n            maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.\n        In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.\n        Return the generated matrix.\n        Example 1:\n        Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n        Output: [[9,9],[8,6]]\n        Explanation: The diagram above shows the original matrix and the generated matrix.\n        Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.\n        Example 2:\n        Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n        Output: [[2,2,2],[2,2,2],[2,2,2]]\n        Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1825,"row":{"number":2374,"difficulty":1,"question":"class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        \"\"\"\n        You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\n        The graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\n        The edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\n        Return the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.\n        Example 1:\n        Input: edges = [1,0,0,0,0,7,7,5]\n        Output: 7\n        Explanation:\n        - The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n        - The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n        - The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n        - The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\n        Node 7 has the highest edge score so return 7.\n        Example 2:\n        Input: edges = [2,0,0,2]\n        Output: 0\n        Explanation:\n        - The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n        - The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\n        Nodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1826,"row":{"number":2375,"difficulty":1,"question":"class Solution:\n    def smallestNumber(self, pattern: str) -> str:\n        \"\"\"\n        You are given a 0-indexed string pattern of length n consisting of the characters 'I' meaning increasing and 'D' meaning decreasing.\n        A 0-indexed string num of length n + 1 is created using the following conditions:\n            num consists of the digits '1' to '9', where each digit is used at most once.\n            If pattern[i] == 'I', then num[i] < num[i + 1].\n            If pattern[i] == 'D', then num[i] > num[i + 1].\n        Return the lexicographically smallest possible string num that meets the conditions.\n        Example 1:\n        Input: pattern = \"IIIDIDDD\"\n        Output: \"123549876\"\n        Explanation:\n        At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].\n        At indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].\n        Some possible values of num are \"245639871\", \"135749862\", and \"123849765\".\n        It can be proven that \"123549876\" is the smallest possible num that meets the conditions.\n        Note that \"123414321\" is not possible because the digit '1' is used more than once.\n        Example 2:\n        Input: pattern = \"DDD\"\n        Output: \"4321\"\n        Explanation:\n        Some possible values of num are \"9876\", \"7321\", and \"8742\".\n        It can be proven that \"4321\" is the smallest possible num that meets the conditions.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1827,"row":{"number":2376,"difficulty":2,"question":"class Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        \"\"\"\n        We call a positive integer special if all of its digits are distinct.\n        Given a positive integer n, return the number of special integers that belong to the interval [1, n].\n        Example 1:\n        Input: n = 20\n        Output: 19\n        Explanation: All the integers from 1 to 20, except 11, are special. Thus, there are 19 special integers.\n        Example 2:\n        Input: n = 5\n        Output: 5\n        Explanation: All the integers from 1 to 5 are special.\n        Example 3:\n        Input: n = 135\n        Output: 110\n        Explanation: There are 110 integers from 1 to 135 that are special.\n        Some of the integers that are not special are: 22, 114, and 131.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1828,"row":{"number":2383,"difficulty":0,"question":"class Solution:\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\n        \"\"\"\n        You are entering a competition, and are given two positive integers initialEnergy and initialExperience denoting your initial energy and initial experience respectively.\n        You are also given two 0-indexed integer arrays energy and experience, both of length n.\n        You will face n opponents in order. The energy and experience of the ith opponent is denoted by energy[i] and experience[i] respectively. When you face an opponent, you need to have both strictly greater experience and energy to defeat them and move to the next opponent if available.\n        Defeating the ith opponent increases your experience by experience[i], but decreases your energy by energy[i].\n        Before starting the competition, you can train for some number of hours. After each hour of training, you can either choose to increase your initial experience by one, or increase your initial energy by one.\n        Return the minimum number of training hours required to defeat all n opponents.\n        Example 1:\n        Input: initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n        Output: 8\n        Explanation: You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\n        You face the opponents in the following order:\n        - You have more energy and experience than the 0th opponent so you win.\n          Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n        - You have more energy and experience than the 1st opponent so you win.\n          Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n        - You have more energy and experience than the 2nd opponent so you win.\n          Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n        - You have more energy and experience than the 3rd opponent so you win.\n          Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\n        You did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\n        It can be proven that no smaller answer exists.\n        Example 2:\n        Input: initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n        Output: 0\n        Explanation: You do not need any additional energy or experience to win the competition, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1829,"row":{"number":2385,"difficulty":1,"question":"class Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        \"\"\"\n        You are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.\n        Each minute, a node becomes infected if:\n            The node is currently uninfected.\n            The node is adjacent to an infected node.\n        Return the number of minutes needed for the entire tree to be infected.\n        Example 1:\n        Input: root = [1,5,3,null,4,10,6,9,2], start = 3\n        Output: 4\n        Explanation: The following nodes are infected during:\n        - Minute 0: Node 3\n        - Minute 1: Nodes 1, 10 and 6\n        - Minute 2: Node 5\n        - Minute 3: Node 4\n        - Minute 4: Nodes 9 and 2\n        It takes 4 minutes for the whole tree to be infected so we return 4.\n        Example 2:\n        Input: root = [1], start = 1\n        Output: 0\n        Explanation: At minute 0, the only node in the tree is infected so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1830,"row":{"number":2386,"difficulty":2,"question":"class Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and a positive integer k. You can choose any subsequence of the array and sum all of its elements together.\n        We define the K-Sum of the array as the kth largest subsequence sum that can be obtained (not necessarily distinct).\n        Return the K-Sum of the array.\n        A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n        Note that the empty subsequence is considered to have a sum of 0.\n        Example 1:\n        Input: nums = [2,4,-2], k = 5\n        Output: 2\n        Explanation: All the possible subsequence sums that we can obtain are the following sorted in decreasing order:\n        - 6, 4, 4, 2, 2, 0, 0, -2.\n        The 5-Sum of the array is 2.\n        Example 2:\n        Input: nums = [1,-2,3,4,-10,12], k = 16\n        Output: 10\n        Explanation: The 16-Sum of the array is 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1831,"row":{"number":2379,"difficulty":0,"question":"class Solution:\n    def minimumRecolors(self, blocks: str, k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively.\n        You are also given an integer k, which is the desired number of consecutive black blocks.\n        In one operation, you can recolor a white block such that it becomes a black block.\n        Return the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.\n        Example 1:\n        Input: blocks = \"WBBWWBBWBW\", k = 7\n        Output: 3\n        Explanation:\n        One way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks\n        so that blocks = \"BBBBBBBWBW\". \n        It can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations.\n        Therefore, we return 3.\n        Example 2:\n        Input: blocks = \"WBWBBBW\", k = 2\n        Output: 0\n        Explanation:\n        No changes need to be made, since 2 consecutive black blocks already exist.\n        Therefore, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1832,"row":{"number":2380,"difficulty":1,"question":"class Solution:\n    def secondsToRemoveOccurrences(self, s: str) -> int:\n        \"\"\"\n        You are given a binary string s. In one second, all occurrences of \"01\" are simultaneously replaced with \"10\". This process repeats until no occurrences of \"01\" exist.\n        Return the number of seconds needed to complete this process.\n        Example 1:\n        Input: s = \"0110101\"\n        Output: 4\n        Explanation: \n        After one second, s becomes \"1011010\".\n        After another second, s becomes \"1101100\".\n        After the third second, s becomes \"1110100\".\n        After the fourth second, s becomes \"1111000\".\n        No occurrence of \"01\" exists any longer, and the process needed 4 seconds to complete,\n        so we return 4.\n        Example 2:\n        Input: s = \"11100\"\n        Output: 0\n        Explanation:\n        No occurrence of \"01\" exists in s, and the processes needed 0 seconds to complete,\n        so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1833,"row":{"number":2381,"difficulty":1,"question":"class Solution:\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\n        \"\"\"\n        You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0.\n        Shifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z').\n        Return the final string after all such shifts to s are applied.\n        Example 1:\n        Input: s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\n        Output: \"ace\"\n        Explanation: Firstly, shift the characters from index 0 to index 1 backward. Now s = \"zac\".\n        Secondly, shift the characters from index 1 to index 2 forward. Now s = \"zbd\".\n        Finally, shift the characters from index 0 to index 2 forward. Now s = \"ace\".\n        Example 2:\n        Input: s = \"dztz\", shifts = [[0,0,0],[1,1,1]]\n        Output: \"catz\"\n        Explanation: Firstly, shift the characters from index 0 to index 0 backward. Now s = \"cztz\".\n        Finally, shift the characters from index 1 to index 1 forward. Now s = \"catz\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1834,"row":{"number":2382,"difficulty":2,"question":"class Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        \"\"\"\n        You are given two 0-indexed integer arrays nums and removeQueries, both of length n. For the ith query, the element in nums at the index removeQueries[i] is removed, splitting nums into different segments.\n        A segment is a contiguous sequence of positive integers in nums. A segment sum is the sum of every element in a segment.\n        Return an integer array answer, of length n, where answer[i] is the maximum segment sum after applying the ith removal.\n        Note: The same index will not be removed more than once.\n        Example 1:\n        Input: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\n        Output: [14,7,2,2,0]\n        Explanation: Using 0 to indicate a removed element, the answer is as follows:\n        Query 1: Remove the 0th element, nums becomes [0,2,5,6,1] and the maximum segment sum is 14 for segment [2,5,6,1].\n        Query 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and the maximum segment sum is 7 for segment [2,5].\n        Query 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and the maximum segment sum is 2 for segment [2]. \n        Query 4: Remove the 4th element, nums becomes [0,2,0,0,0] and the maximum segment sum is 2 for segment [2]. \n        Query 5: Remove the 1st element, nums becomes [0,0,0,0,0] and the maximum segment sum is 0, since there are no segments.\n        Finally, we return [14,7,2,2,0].\n        Example 2:\n        Input: nums = [3,2,11,1], removeQueries = [3,2,1,0]\n        Output: [16,5,3,0]\n        Explanation: Using 0 to indicate a removed element, the answer is as follows:\n        Query 1: Remove the 3rd element, nums becomes [3,2,11,0] and the maximum segment sum is 16 for segment [3,2,11].\n        Query 2: Remove the 2nd element, nums becomes [3,2,0,0] and the maximum segment sum is 5 for segment [3,2].\n        Query 3: Remove the 1st element, nums becomes [3,0,0,0] and the maximum segment sum is 3 for segment [3].\n        Query 4: Remove the 0th element, nums becomes [0,0,0,0] and the maximum segment sum is 0, since there are no segments.\n        Finally, we return [16,5,3,0].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1835,"row":{"number":2389,"difficulty":0,"question":"class Solution:\n    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer array nums of length n, and an integer array queries of length m.\n        Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].\n        A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: nums = [4,5,2,1], queries = [3,10,21]\n        Output: [2,3,4]\n        Explanation: We answer the queries as follows:\n        - The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.\n        - The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.\n        - The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.\n        Example 2:\n        Input: nums = [2,3,4,5], queries = [1]\n        Output: [0]\n        Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1836,"row":{"number":2390,"difficulty":1,"question":"class Solution:\n    def removeStars(self, s: str) -> str:\n        \"\"\"\n        You are given a string s, which contains stars *.\n        In one operation, you can:\n            Choose a star in s.\n            Remove the closest non-star character to its left, as well as remove the star itself.\n        Return the string after all stars have been removed.\n        Note:\n            The input will be generated such that the operation is always possible.\n            It can be shown that the resulting string will always be unique.\n        Example 1:\n        Input: s = \"leet**cod*e\"\n        Output: \"lecoe\"\n        Explanation: Performing the removals from left to right:\n        - The closest character to the 1st star is 't' in \"leet**cod*e\". s becomes \"lee*cod*e\".\n        - The closest character to the 2nd star is 'e' in \"lee*cod*e\". s becomes \"lecod*e\".\n        - The closest character to the 3rd star is 'd' in \"lecod*e\". s becomes \"lecoe\".\n        There are no more stars, so we return \"lecoe\".\n        Example 2:\n        Input: s = \"erase*****\"\n        Output: \"\"\n        Explanation: The entire string is removed, so we return an empty string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1837,"row":{"number":2391,"difficulty":1,"question":"class Solution:\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.\n        You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.\n        There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.\n        Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.\n        Return the minimum number of minutes needed to pick up all the garbage.\n        Example 1:\n        Input: garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\n        Output: 21\n        Explanation:\n        The paper garbage truck:\n        1. Travels from house 0 to house 1\n        2. Collects the paper garbage at house 1\n        3. Travels from house 1 to house 2\n        4. Collects the paper garbage at house 2\n        Altogether, it takes 8 minutes to pick up all the paper garbage.\n        The glass garbage truck:\n        1. Collects the glass garbage at house 0\n        2. Travels from house 0 to house 1\n        3. Travels from house 1 to house 2\n        4. Collects the glass garbage at house 2\n        5. Travels from house 2 to house 3\n        6. Collects the glass garbage at house 3\n        Altogether, it takes 13 minutes to pick up all the glass garbage.\n        Since there is no metal garbage, we do not need to consider the metal garbage truck.\n        Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.\n        Example 2:\n        Input: garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\n        Output: 37\n        Explanation:\n        The metal garbage truck takes 7 minutes to pick up all the metal garbage.\n        The paper garbage truck takes 15 minutes to pick up all the paper garbage.\n        The glass garbage truck takes 15 minutes to pick up all the glass garbage.\n        It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1838,"row":{"number":2392,"difficulty":2,"question":"class Solution:\n    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        You are given a positive integer k. You are also given:\n            a 2D integer array rowConditions of size n where rowConditions[i] = [abovei, belowi], and\n            a 2D integer array colConditions of size m where colConditions[i] = [lefti, righti].\n        The two arrays contain integers from 1 to k.\n        You have to build a k x k matrix that contains each of the numbers from 1 to k exactly once. The remaining cells should have the value 0.\n        The matrix should also satisfy the following conditions:\n            The number abovei should appear in a row that is strictly above the row at which the number belowi appears for all i from 0 to n - 1.\n            The number lefti should appear in a column that is strictly left of the column at which the number righti appears for all i from 0 to m - 1.\n        Return any matrix that satisfies the conditions. If no answer exists, return an empty matrix.\n        Example 1:\n        Input: k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]\n        Output: [[3,0,0],[0,0,1],[0,2,0]]\n        Explanation: The diagram above shows a valid example of a matrix that satisfies all the conditions.\n        The row conditions are the following:\n        - Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix.\n        - Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix.\n        The column conditions are the following:\n        - Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix.\n        - Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix.\n        Note that there may be multiple correct answers.\n        Example 2:\n        Input: k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]\n        Output: []\n        Explanation: From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.\n        No matrix can satisfy all the conditions, so we return the empty matrix.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1839,"row":{"number":2342,"difficulty":1,"question":"class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j].\n        Return the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions.\n        Example 1:\n        Input: nums = [18,43,36,13,7]\n        Output: 54\n        Explanation: The pairs (i, j) that satisfy the conditions are:\n        - (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.\n        - (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.\n        So the maximum sum that we can obtain is 54.\n        Example 2:\n        Input: nums = [10,12,19,14]\n        Output: -1\n        Explanation: There are no two numbers that satisfy the conditions, so we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1840,"row":{"number":2384,"difficulty":1,"question":"class Solution:\n    def largestPalindromic(self, num: str) -> str:\n        \"\"\"\n        You are given a string num consisting of digits only.\n        Return the largest palindromic integer (in the form of a string) that can be formed using digits taken from num. It should not contain leading zeroes.\n        Notes:\n            You do not need to use all the digits of num, but you must use at least one digit.\n            The digits can be reordered.\n        Example 1:\n        Input: num = \"444947137\"\n        Output: \"7449447\"\n        Explanation: \n        Use the digits \"4449477\" from \"444947137\" to form the palindromic integer \"7449447\".\n        It can be shown that \"7449447\" is the largest palindromic integer that can be formed.\n        Example 2:\n        Input: num = \"00009\"\n        Output: \"9\"\n        Explanation: \n        It can be shown that \"9\" is the largest palindromic integer that can be formed.\n        Note that the integer returned should not contain leading zeroes.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1841,"row":{"number":2399,"difficulty":0,"question":"class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        \"\"\"\n        You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26.\n        Each letter in the alphabet is numbered from 0 to 25 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25).\n        In a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored.\n        Return true if s is a well-spaced string, otherwise return false.\n        Example 1:\n        Input: s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        Output: true\n        Explanation:\n        - 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1.\n        - 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3.\n        - 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0.\n        Note that distance[3] = 5, but since 'd' does not appear in s, it can be ignored.\n        Return true because s is a well-spaced string.\n        Example 2:\n        Input: s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        Output: false\n        Explanation:\n        - 'a' appears at indices 0 and 1 so there are zero letters between them.\n        Because distance[0] = 1, s is not a well-spaced string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1842,"row":{"number":2400,"difficulty":1,"question":"class Solution:\n    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n        \"\"\"\n        You are given two positive integers startPos and endPos. Initially, you are standing at position startPos on an infinite number line. With one step, you can move either one position to the left, or one position to the right.\n        Given a positive integer k, return the number of different ways to reach the position endPos starting from startPos, such that you perform exactly k steps. Since the answer may be very large, return it modulo 109 + 7.\n        Two ways are considered different if the order of the steps made is not exactly the same.\n        Note that the number line includes negative integers.\n        Example 1:\n        Input: startPos = 1, endPos = 2, k = 3\n        Output: 3\n        Explanation: We can reach position 2 from 1 in exactly 3 steps in three ways:\n        - 1 -> 2 -> 3 -> 2.\n        - 1 -> 2 -> 1 -> 2.\n        - 1 -> 0 -> 1 -> 2.\n        It can be proven that no other way is possible, so we return 3.\n        Example 2:\n        Input: startPos = 2, endPos = 5, k = 10\n        Output: 0\n        Explanation: It is impossible to reach position 5 from position 2 in exactly 10 steps.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1843,"row":{"number":2401,"difficulty":1,"question":"class Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums consisting of positive integers.\n        We call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\n        Return the length of the longest nice subarray.\n        A subarray is a contiguous part of an array.\n        Note that subarrays of length 1 are always considered nice.\n        Example 1:\n        Input: nums = [1,3,8,48,10]\n        Output: 3\n        Explanation: The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:\n        - 3 AND 8 = 0.\n        - 3 AND 48 = 0.\n        - 8 AND 48 = 0.\n        It can be proven that no longer nice subarray can be obtained, so we return 3.\n        Example 2:\n        Input: nums = [3,1,5,11,13]\n        Output: 1\n        Explanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1844,"row":{"number":2402,"difficulty":2,"question":"class Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        \"\"\"\n        You are given an integer n. There are n rooms numbered from 0 to n - 1.\n        You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.\n        Meetings are allocated to rooms in the following manner:\n            Each meeting will take place in the unused room with the lowest number.\n            If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.\n            When a room becomes unused, meetings that have an earlier original start time should be given the room.\n        Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.\n        A half-closed interval [a, b) is the interval between a and b including a and not including b.\n        Example 1:\n        Input: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]\n        Output: 0\n        Explanation:\n        - At time 0, both rooms are not being used. The first meeting starts in room 0.\n        - At time 1, only room 1 is not being used. The second meeting starts in room 1.\n        - At time 2, both rooms are being used. The third meeting is delayed.\n        - At time 3, both rooms are being used. The fourth meeting is delayed.\n        - At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).\n        - At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).\n        Both rooms 0 and 1 held 2 meetings, so we return 0. \n        Example 2:\n        Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\n        Output: 1\n        Explanation:\n        - At time 1, all three rooms are not being used. The first meeting starts in room 0.\n        - At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n        - At time 3, only room 2 is not being used. The third meeting starts in room 2.\n        - At time 4, all three rooms are being used. The fourth meeting is delayed.\n        - At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).\n        - At time 6, all three rooms are being used. The fifth meeting is delayed.\n        - At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).\n        Room 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1845,"row":{"number":2395,"difficulty":0,"question":"class Solution:\n    def findSubarrays(self, nums: List[int]) -> bool:\n        \"\"\"\n        Given a 0-indexed integer array nums, determine whether there exist two subarrays of length 2 with equal sum. Note that the two subarrays must begin at different indices.\n        Return true if these subarrays exist, and false otherwise.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [4,2,4]\n        Output: true\n        Explanation: The subarrays with elements [4,2] and [2,4] have the same sum of 6.\n        Example 2:\n        Input: nums = [1,2,3,4,5]\n        Output: false\n        Explanation: No two subarrays of size 2 have the same sum.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: true\n        Explanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. \n        Note that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1846,"row":{"number":2396,"difficulty":1,"question":"class Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        \"\"\"\n        An integer n is strictly palindromic if, for every base b between 2 and n - 2 (inclusive), the string representation of the integer n in base b is palindromic.\n        Given an integer n, return true if n is strictly palindromic and false otherwise.\n        A string is palindromic if it reads the same forward and backward.\n        Example 1:\n        Input: n = 9\n        Output: false\n        Explanation: In base 2: 9 = 1001 (base 2), which is palindromic.\n        In base 3: 9 = 100 (base 3), which is not palindromic.\n        Therefore, 9 is not strictly palindromic so we return false.\n        Note that in bases 4, 5, 6, and 7, n = 9 is also not palindromic.\n        Example 2:\n        Input: n = 4\n        Output: false\n        Explanation: We only consider base 2: 4 = 100 (base 2), which is not palindromic.\n        Therefore, we return false.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1847,"row":{"number":2397,"difficulty":1,"question":"class Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        \"\"\"\n        You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\n        Let us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n            For each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\n            No cell in row has a value of 1.\n        You need to choose numSelect columns such that the number of rows that are covered is maximized.\n        Return the maximum number of rows that can be covered by a set of numSelect columns.\n        Example 1:\n        Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\n        Output: 3\n        Explanation: One possible way to cover 3 rows is shown in the diagram above.\n        We choose s = {0, 2}.\n        - Row 0 is covered because it has no occurrences of 1.\n        - Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n        - Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n        - Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\n        Thus, we can cover three rows.\n        Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.\n        Example 2:\n        Input: matrix = [[1],[0]], numSelect = 1\n        Output: 2\n        Explanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\n        Therefore, we return 2.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1848,"row":{"number":2365,"difficulty":1,"question":"class Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        \"\"\"\n        You are given a 0-indexed array of positive integers tasks, representing tasks that need to be completed in order, where tasks[i] represents the type of the ith task.\n        You are also given a positive integer space, which represents the minimum number of days that must pass after the completion of a task before another task of the same type can be performed.\n        Each day, until all tasks have been completed, you must either:\n            Complete the next task from tasks, or\n            Take a break.\n        Return the minimum number of days needed to complete all tasks.\n        Example 1:\n        Input: tasks = [1,2,1,2,3,1], space = 3\n        Output: 9\n        Explanation:\n        One way to complete all tasks in 9 days is as follows:\n        Day 1: Complete the 0th task.\n        Day 2: Complete the 1st task.\n        Day 3: Take a break.\n        Day 4: Take a break.\n        Day 5: Complete the 2nd task.\n        Day 6: Complete the 3rd task.\n        Day 7: Take a break.\n        Day 8: Complete the 4th task.\n        Day 9: Complete the 5th task.\n        It can be shown that the tasks cannot be completed in less than 9 days.\n        Example 2:\n        Input: tasks = [5,8,8,5], space = 2\n        Output: 6\n        Explanation:\n        One way to complete all tasks in 6 days is as follows:\n        Day 1: Complete the 0th task.\n        Day 2: Complete the 1st task.\n        Day 3: Take a break.\n        Day 4: Take a break.\n        Day 5: Complete the 2nd task.\n        Day 6: Complete the 3rd task.\n        It can be shown that the tasks cannot be completed in less than 6 days.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1849,"row":{"number":2404,"difficulty":0,"question":"class Solution:\n    def mostFrequentEven(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, return the most frequent even element.\n        If there is a tie, return the smallest one. If there is no such element, return -1.\n        Example 1:\n        Input: nums = [0,1,2,2,4,4,1]\n        Output: 2\n        Explanation:\n        The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\n        We return the smallest one, which is 2.\n        Example 2:\n        Input: nums = [4,4,4,9,2,4]\n        Output: 4\n        Explanation: 4 is the even element appears the most.\n        Example 3:\n        Input: nums = [29,47,21,41,13,37,25,7]\n        Output: -1\n        Explanation: There is no even element.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1850,"row":{"number":2405,"difficulty":1,"question":"class Solution:\n    def partitionString(self, s: str) -> int:\n        \"\"\"\n        Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once.\n        Return the minimum number of substrings in such a partition.\n        Note that each character should belong to exactly one substring in a partition.\n        Example 1:\n        Input: s = \"abacaba\"\n        Output: 4\n        Explanation:\n        Two possible partitions are (\"a\",\"ba\",\"cab\",\"a\") and (\"ab\",\"a\",\"ca\",\"ba\").\n        It can be shown that 4 is the minimum number of substrings needed.\n        Example 2:\n        Input: s = \"ssssss\"\n        Output: 6\n        Explanation:\n        The only valid partition is (\"s\",\"s\",\"s\",\"s\",\"s\",\"s\").\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1851,"row":{"number":2406,"difficulty":1,"question":"class Solution:\n    def minGroups(self, intervals: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 2D integer array intervals where intervals[i] = [lefti, righti] represents the inclusive interval [lefti, righti].\n        You have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other.\n        Return the minimum number of groups you need to make.\n        Two intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.\n        Example 1:\n        Input: intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]\n        Output: 3\n        Explanation: We can divide the intervals into the following groups:\n        - Group 1: [1, 5], [6, 8].\n        - Group 2: [2, 3], [5, 10].\n        - Group 3: [1, 10].\n        It can be proven that it is not possible to divide the intervals into fewer than 3 groups.\n        Example 2:\n        Input: intervals = [[1,3],[5,6],[8,10],[11,13]]\n        Output: 1\n        Explanation: None of the intervals overlap, so we can put all of them in one group.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1852,"row":{"number":2413,"difficulty":0,"question":"class Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        \"\"\"\n        Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.\n        Example 1:\n        Input: n = 5\n        Output: 10\n        Explanation: The smallest multiple of both 5 and 2 is 10.\n        Example 2:\n        Input: n = 6\n        Output: 6\n        Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1853,"row":{"number":2414,"difficulty":1,"question":"class Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        \"\"\"\n        An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string \"abcdefghijklmnopqrstuvwxyz\".\n            For example, \"abc\" is an alphabetical continuous string, while \"acb\" and \"za\" are not.\n        Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.\n        Example 1:\n        Input: s = \"abacaba\"\n        Output: 2\n        Explanation: There are 4 distinct continuous substrings: \"a\", \"b\", \"c\" and \"ab\".\n        \"ab\" is the longest continuous substring.\n        Example 2:\n        Input: s = \"abcde\"\n        Output: 5\n        Explanation: \"abcde\" is the longest continuous substring.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1854,"row":{"number":2415,"difficulty":1,"question":"class Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n            For example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n        Return the root of the reversed tree.\n        A binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\n        The level of a node is the number of edges along the path between it and the root node.\n        Example 1:\n        Input: root = [2,3,5,8,13,21,34]\n        Output: [2,5,3,8,13,21,34]\n        Explanation: \n        The tree has only one odd level.\n        The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.\n        Example 2:\n        Input: root = [7,13,11]\n        Output: [7,11,13]\n        Explanation: \n        The nodes at level 1 are 13, 11, which are reversed and become 11, 13.\n        Example 3:\n        Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\n        Output: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\n        Explanation: \n        The odd levels have non-zero values.\n        The nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\n        The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1855,"row":{"number":2416,"difficulty":2,"question":"class Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given an array words of size n consisting of non-empty strings.\n        We define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].\n            For example, if words = [\"a\", \"ab\", \"abc\", \"cab\"], then the score of \"ab\" is 2, since \"ab\" is a prefix of both \"ab\" and \"abc\".\n        Return an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i].\n        Note that a string is considered as a prefix of itself.\n        Example 1:\n        Input: words = [\"abc\",\"ab\",\"bc\",\"b\"]\n        Output: [5,4,3,2]\n        Explanation: The answer for each string is the following:\n        - \"abc\" has 3 prefixes: \"a\", \"ab\", and \"abc\".\n        - There are 2 strings with the prefix \"a\", 2 strings with the prefix \"ab\", and 1 string with the prefix \"abc\".\n        The total is answer[0] = 2 + 2 + 1 = 5.\n        - \"ab\" has 2 prefixes: \"a\" and \"ab\".\n        - There are 2 strings with the prefix \"a\", and 2 strings with the prefix \"ab\".\n        The total is answer[1] = 2 + 2 = 4.\n        - \"bc\" has 2 prefixes: \"b\" and \"bc\".\n        - There are 2 strings with the prefix \"b\", and 1 string with the prefix \"bc\".\n        The total is answer[2] = 2 + 1 = 3.\n        - \"b\" has 1 prefix: \"b\".\n        - There are 2 strings with the prefix \"b\".\n        The total is answer[3] = 2.\n        Example 2:\n        Input: words = [\"abcd\"]\n        Output: [4]\n        Explanation:\n        \"abcd\" has 4 prefixes: \"a\", \"ab\", \"abc\", and \"abcd\".\n        Each prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1856,"row":{"number":2409,"difficulty":0,"question":"class Solution:\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n        \"\"\"\n        Alice and Bob are traveling to Rome for separate business meetings.\n        You are given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice will be in the city from the dates arriveAlice to leaveAlice (inclusive), while Bob will be in the city from the dates arriveBob to leaveBob (inclusive). Each will be a 5-character string in the format \"MM-DD\", corresponding to the month and day of the date.\n        Return the total number of days that Alice and Bob are in Rome together.\n        You can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].\n        Example 1:\n        Input: arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"\n        Output: 3\n        Explanation: Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n        Example 2:\n        Input: arriveAlice = \"10-01\", leaveAlice = \"10-31\", arriveBob = \"11-01\", leaveBob = \"12-31\"\n        Output: 0\n        Explanation: There is no day when Alice and Bob are in Rome together, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1857,"row":{"number":2410,"difficulty":1,"question":"class Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer.\n        The ith player can match with the jth trainer if the player's ability is less than or equal to the trainer's training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player.\n        Return the maximum number of matchings between players and trainers that satisfy these conditions.\n        Example 1:\n        Input: players = [4,7,9], trainers = [8,2,5,8]\n        Output: 2\n        Explanation:\n        One of the ways we can form two matchings is as follows:\n        - players[0] can be matched with trainers[0] since 4 <= 8.\n        - players[1] can be matched with trainers[3] since 7 <= 8.\n        It can be proven that 2 is the maximum number of matchings that can be formed.\n        Example 2:\n        Input: players = [1,1,1], trainers = [10]\n        Output: 1\n        Explanation:\n        The trainer can be matched with any of the 3 players.\n        Each player can only be matched with one trainer, so the maximum answer is 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1858,"row":{"number":2411,"difficulty":1,"question":"class Solution:\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array nums of length n, consisting of non-negative integers. For each index i from 0 to n - 1, you must determine the size of the minimum sized non-empty subarray of nums starting at i (inclusive) that has the maximum possible bitwise OR.\n            In other words, let Bij be the bitwise OR of the subarray nums[i...j]. You need to find the smallest subarray starting at i, such that bitwise OR of this subarray is equal to max(Bik) where i <= k <= n - 1.\n        The bitwise OR of an array is the bitwise OR of all the numbers in it.\n        Return an integer array answer of size n where answer[i] is the length of the minimum sized subarray starting at i with maximum bitwise OR.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,0,2,1,3]\n        Output: [3,3,2,2,1]\n        Explanation:\n        The maximum possible bitwise OR starting at any index is 3. \n        - Starting at index 0, the shortest subarray that yields it is [1,0,2].\n        - Starting at index 1, the shortest subarray that yields the maximum bitwise OR is [0,2,1].\n        - Starting at index 2, the shortest subarray that yields the maximum bitwise OR is [2,1].\n        - Starting at index 3, the shortest subarray that yields the maximum bitwise OR is [1,3].\n        - Starting at index 4, the shortest subarray that yields the maximum bitwise OR is [3].\n        Therefore, we return [3,3,2,2,1]. \n        Example 2:\n        Input: nums = [1,2]\n        Output: [2,1]\n        Explanation:\n        Starting at index 0, the shortest subarray that yields the maximum bitwise OR is of length 2.\n        Starting at index 1, the shortest subarray that yields the maximum bitwise OR is of length 1.\n        Therefore, we return [2,1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1859,"row":{"number":2412,"difficulty":2,"question":"class Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        \"\"\"\n        You are given a 0-indexed 2D integer array transactions, where transactions[i] = [costi, cashbacki].\n        The array describes transactions, where each transaction must be completed exactly once in some order. At any given moment, you have a certain amount of money. In order to complete transaction i, money >= costi must hold true. After performing a transaction, money becomes money - costi + cashbacki.\n        Return the minimum amount of money required before any transaction so that all of the transactions can be completed regardless of the order of the transactions.\n        Example 1:\n        Input: transactions = [[2,1],[5,0],[4,2]]\n        Output: 10\n        Explanation:\n        Starting with money = 10, the transactions can be performed in any order.\n        It can be shown that starting with money < 10 will fail to complete all transactions in some order.\n        Example 2:\n        Input: transactions = [[3,0],[0,3]]\n        Output: 3\n        Explanation:\n        - If transactions are in the order [[3,0],[0,3]], the minimum money required to complete the transactions is 3.\n        - If transactions are in the order [[0,3],[3,0]], the minimum money required to complete the transactions is 0.\n        Thus, starting with money = 3, the transactions can be performed in any order.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1860,"row":{"number":2418,"difficulty":0,"question":"class Solution:\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\n        \"\"\"\n        You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.\n        For each index i, names[i] and heights[i] denote the name and height of the ith person.\n        Return names sorted in descending order by the people's heights.\n        Example 1:\n        Input: names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170]\n        Output: [\"Mary\",\"Emma\",\"John\"]\n        Explanation: Mary is the tallest, followed by Emma and John.\n        Example 2:\n        Input: names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150]\n        Output: [\"Bob\",\"Alice\",\"Bob\"]\n        Explanation: The first Bob is the tallest, followed by Alice and the second Bob.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1861,"row":{"number":2419,"difficulty":1,"question":"class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an integer array nums of size n.\n        Consider a non-empty subarray from nums that has the maximum possible bitwise AND.\n            In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.\n        Return the length of the longest such subarray.\n        The bitwise AND of an array is the bitwise AND of all the numbers in it.\n        A subarray is a contiguous sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,2,3,3,2,2]\n        Output: 2\n        Explanation:\n        The maximum possible bitwise AND of a subarray is 3.\n        The longest subarray with that value is [3,3], so we return 2.\n        Example 2:\n        Input: nums = [1,2,3,4]\n        Output: 1\n        Explanation:\n        The maximum possible bitwise AND of a subarray is 4.\n        The longest subarray with that value is [4], so we return 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1862,"row":{"number":2420,"difficulty":1,"question":"class Solution:\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed integer array nums of size n and a positive integer k.\n        We call an index i in the range k <= i < n - k good if the following conditions are satisfied:\n            The k elements that are just before the index i are in non-increasing order.\n            The k elements that are just after the index i are in non-decreasing order.\n        Return an array of all good indices sorted in increasing order.\n        Example 1:\n        Input: nums = [2,1,1,1,3,4,1], k = 2\n        Output: [2,3]\n        Explanation: There are two good indices in the array:\n        - Index 2. The subarray [2,1] is in non-increasing order, and the subarray [1,3] is in non-decreasing order.\n        - Index 3. The subarray [1,1] is in non-increasing order, and the subarray [3,4] is in non-decreasing order.\n        Note that the index 4 is not good because [4,1] is not non-decreasing.\n        Example 2:\n        Input: nums = [2,1,1,2], k = 2\n        Output: []\n        Explanation: There are no good indices in this array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1863,"row":{"number":2421,"difficulty":2,"question":"class Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        \"\"\"\n        There is a tree (i.e. a connected, undirected graph with no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges.\n        You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\n        A good path is a simple path that satisfies the following conditions:\n            The starting node and the ending node have the same value.\n            All nodes between the starting node and the ending node have values less than or equal to the starting node (i.e. the starting node's value should be the maximum value along the path).\n        Return the number of distinct good paths.\n        Note that a path and its reverse are counted as the same path. For example, 0 -> 1 is considered to be the same as 1 -> 0. A single node is also considered as a valid path.\n        Example 1:\n        Input: vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]\n        Output: 6\n        Explanation: There are 5 good paths consisting of a single node.\n        There is 1 additional good path: 1 -> 0 -> 2 -> 4.\n        (The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\n        Note that 0 -> 2 -> 3 is not a good path because vals[2] > vals[0].\n        Example 2:\n        Input: vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]\n        Output: 7\n        Explanation: There are 5 good paths consisting of a single node.\n        There are 2 additional good paths: 0 -> 1 and 2 -> 3.\n        Example 3:\n        Input: vals = [1], edges = []\n        Output: 1\n        Explanation: The tree consists of only one node, so there is one good path.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1864,"row":{"number":2427,"difficulty":0,"question":"class Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        \"\"\"\n        Given two positive integers a and b, return the number of common factors of a and b.\n        An integer x is a common factor of a and b if x divides both a and b.\n        Example 1:\n        Input: a = 12, b = 6\n        Output: 4\n        Explanation: The common factors of 12 and 6 are 1, 2, 3, 6.\n        Example 2:\n        Input: a = 25, b = 30\n        Output: 2\n        Explanation: The common factors of 25 and 30 are 1, 5.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1865,"row":{"number":2428,"difficulty":1,"question":"class Solution:\n    def maxSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer matrix grid.\n        We define an hourglass as a part of the matrix with the following form:\n        Return the maximum sum of the elements of an hourglass.\n        Note that an hourglass cannot be rotated and must be entirely contained within the matrix.\n        Example 1:\n        Input: grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\n        Output: 30\n        Explanation: The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: 35\n        Explanation: There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1866,"row":{"number":2429,"difficulty":1,"question":"class Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        \"\"\"\n        Given two positive integers num1 and num2, find the positive integer x such that:\n            x has the same number of set bits as num2, and\n            The value x XOR num1 is minimal.\n        Note that XOR is the bitwise XOR operation.\n        Return the integer x. The test cases are generated such that x is uniquely determined.\n        The number of set bits of an integer is the number of 1's in its binary representation.\n        Example 1:\n        Input: num1 = 3, num2 = 5\n        Output: 3\n        Explanation:\n        The binary representations of num1 and num2 are 0011 and 0101, respectively.\n        The integer 3 has the same number of set bits as num2, and the value 3 XOR 3 = 0 is minimal.\n        Example 2:\n        Input: num1 = 1, num2 = 12\n        Output: 3\n        Explanation:\n        The binary representations of num1 and num2 are 0001 and 1100, respectively.\n        The integer 3 has the same number of set bits as num2, and the value 3 XOR 1 = 2 is minimal.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1867,"row":{"number":2430,"difficulty":2,"question":"class Solution:\n    def deleteString(self, s: str) -> int:\n        \"\"\"\n        You are given a string s consisting of only lowercase English letters. In one operation, you can:\n            Delete the entire string s, or\n            Delete the first i letters of s if the first i letters of s are equal to the following i letters in s, for any i in the range 1 <= i <= s.length / 2.\n        For example, if s = \"ababc\", then in one operation, you could delete the first two letters of s to get \"abc\", since the first two letters of s and the following two letters of s are both equal to \"ab\".\n        Return the maximum number of operations needed to delete all of s.\n        Example 1:\n        Input: s = \"abcabcdabc\"\n        Output: 2\n        Explanation:\n        - Delete the first 3 letters (\"abc\") since the next 3 letters are equal. Now, s = \"abcdabc\".\n        - Delete all the letters.\n        We used 2 operations so return 2. It can be proven that 2 is the maximum number of operations needed.\n        Note that in the second operation we cannot delete \"abc\" again because the next occurrence of \"abc\" does not happen in the next 3 letters.\n        Example 2:\n        Input: s = \"aaabaab\"\n        Output: 4\n        Explanation:\n        - Delete the first letter (\"a\") since the next letter is equal. Now, s = \"aabaab\".\n        - Delete the first 3 letters (\"aab\") since the next 3 letters are equal. Now, s = \"aab\".\n        - Delete the first letter (\"a\") since the next letter is equal. Now, s = \"ab\".\n        - Delete all the letters.\n        We used 4 operations so return 4. It can be proven that 4 is the maximum number of operations needed.\n        Example 3:\n        Input: s = \"aaaaa\"\n        Output: 5\n        Explanation: In each operation, we can delete the first letter of s.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1868,"row":{"number":2522,"difficulty":1,"question":"class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        \"\"\"\n        You are given a string s consisting of digits from 1 to 9 and an integer k.\n        A partition of a string s is called good if:\n            Each digit of s is part of exactly one substring.\n            The value of each substring is less than or equal to k.\n        Return the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\n        Note that:\n            The value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\n            A substring is a contiguous sequence of characters within a string.\n        Example 1:\n        Input: s = \"165462\", k = 60\n        Output: 4\n        Explanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\n        It can be shown that we cannot partition the string into less than 4 substrings.\n        Example 2:\n        Input: s = \"238182\", k = 5\n        Output: -1\n        Explanation: There is no good partition for this string.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1869,"row":{"number":2424,"difficulty":1,"question":"class LUPrefix:\n    def __init__(self, n: int):\n    def upload(self, video: int) -> None:\n    def longest(self) -> int:\n        \"\"\"\n        You are given a stream of n videos, each represented by a distinct number from 1 to n that you need to \"upload\" to a server. You need to implement a data structure that calculates the length of the longest uploaded prefix at various points in the upload process.\n        We consider i to be an uploaded prefix if all videos in the range 1 to i (inclusive) have been uploaded to the server. The longest uploaded prefix is the maximum value of i that satisfies this definition.\n        Implement the LUPrefix class:\n            LUPrefix(int n) Initializes the object for a stream of n videos.\n            void upload(int video) Uploads video to the server.\n            int longest() Returns the length of the longest uploaded prefix defined above.\n        Example 1:\n        Input\n        [\"LUPrefix\", \"upload\", \"longest\", \"upload\", \"longest\", \"upload\", \"longest\"]\n        [[4], [3], [], [1], [], [2], []]\n        Output\n        [null, null, 0, null, 1, null, 3]\n        Explanation\n        LUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos.\n        server.upload(3);                    // Upload video 3.\n        server.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.\n                                             // So, we return 0.\n        server.upload(1);                    // Upload video 1.\n        server.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1.\n        server.upload(2);                    // Upload video 2.\n        server.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1870,"row":{"number":2426,"difficulty":2,"question":"class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        \"\"\"\n        You are given two 0-indexed integer arrays nums1 and nums2, each of size n, and an integer diff. Find the number of pairs (i, j) such that:\n            0 <= i < j <= n - 1 and\n            nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.\n        Return the number of pairs that satisfy the conditions.\n        Example 1:\n        Input: nums1 = [3,2,5], nums2 = [2,2,1], diff = 1\n        Output: 3\n        Explanation:\n        There are 3 pairs that satisfy the conditions:\n        1. i = 0, j = 1: 3 - 2 <= 2 - 2 + 1. Since i < j and 1 <= 1, this pair satisfies the conditions.\n        2. i = 0, j = 2: 3 - 5 <= 2 - 1 + 1. Since i < j and -2 <= 2, this pair satisfies the conditions.\n        3. i = 1, j = 2: 2 - 5 <= 2 - 1 + 1. Since i < j and -3 <= 2, this pair satisfies the conditions.\n        Therefore, we return 3.\n        Example 2:\n        Input: nums1 = [3,-1], nums2 = [-2,2], diff = -1\n        Output: 0\n        Explanation:\n        Since there does not exist any pair that satisfies the conditions, we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1871,"row":{"number":2432,"difficulty":0,"question":"class Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        \"\"\"\n        There are n employees, each with a unique id from 0 to n - 1.\n        You are given a 2D integer array logs where logs[i] = [idi, leaveTimei] where:\n            idi is the id of the employee that worked on the ith task, and\n            leaveTimei is the time at which the employee finished the ith task. All the values leaveTimei are unique.\n        Note that the ith task starts the moment right after the (i - 1)th task ends, and the 0th task starts at time 0.\n        Return the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them.\n        Example 1:\n        Input: n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]\n        Output: 1\n        Explanation: \n        Task 0 started at 0 and ended at 3 with 3 units of times.\n        Task 1 started at 3 and ended at 5 with 2 units of times.\n        Task 2 started at 5 and ended at 9 with 4 units of times.\n        Task 3 started at 9 and ended at 15 with 6 units of times.\n        The task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n        Example 2:\n        Input: n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]\n        Output: 3\n        Explanation: \n        Task 0 started at 0 and ended at 1 with 1 unit of times.\n        Task 1 started at 1 and ended at 7 with 6 units of times.\n        Task 2 started at 7 and ended at 12 with 5 units of times.\n        Task 3 started at 12 and ended at 17 with 5 units of times.\n        The tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3.\n        Example 3:\n        Input: n = 2, logs = [[0,10],[1,20]]\n        Output: 0\n        Explanation: \n        Task 0 started at 0 and ended at 10 with 10 units of times.\n        Task 1 started at 10 and ended at 20 with 10 units of times.\n        The tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1872,"row":{"number":2433,"difficulty":1,"question":"class Solution:\n    def findArray(self, pref: List[int]) -> List[int]:\n        \"\"\"\n        You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n            pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n        Note that ^ denotes the bitwise-xor operation.\n        It can be proven that the answer is unique.\n        Example 1:\n        Input: pref = [5,2,0,3,1]\n        Output: [5,7,2,3,2]\n        Explanation: From the array [5,7,2,3,2] we have the following:\n        - pref[0] = 5.\n        - pref[1] = 5 ^ 7 = 2.\n        - pref[2] = 5 ^ 7 ^ 2 = 0.\n        - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n        - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n        Example 2:\n        Input: pref = [13]\n        Output: [13]\n        Explanation: We have pref[0] = arr[0] = 13.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1873,"row":{"number":2434,"difficulty":1,"question":"class Solution:\n    def robotWithString(self, s: str) -> str:\n        \"\"\"\n        You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:\n            Remove the first character of a string s and give it to the robot. The robot will append this character to the string t.\n            Remove the last character of a string t and give it to the robot. The robot will write this character on paper.\n        Return the lexicographically smallest string that can be written on the paper.\n        Example 1:\n        Input: s = \"zza\"\n        Output: \"azz\"\n        Explanation: Let p denote the written string.\n        Initially p=\"\", s=\"zza\", t=\"\".\n        Perform first operation three times p=\"\", s=\"\", t=\"zza\".\n        Perform second operation three times p=\"azz\", s=\"\", t=\"\".\n        Example 2:\n        Input: s = \"bac\"\n        Output: \"abc\"\n        Explanation: Let p denote the written string.\n        Perform first operation twice p=\"\", s=\"c\", t=\"ba\". \n        Perform second operation twice p=\"ab\", s=\"c\", t=\"\". \n        Perform first operation p=\"ab\", s=\"\", t=\"c\". \n        Perform second operation p=\"abc\", s=\"\", t=\"\".\n        Example 3:\n        Input: s = \"bdda\"\n        Output: \"addb\"\n        Explanation: Let p denote the written string.\n        Initially p=\"\", s=\"bdda\", t=\"\".\n        Perform first operation four times p=\"\", s=\"\", t=\"bdda\".\n        Perform second operation four times p=\"addb\", s=\"\", t=\"\".\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1874,"row":{"number":2435,"difficulty":2,"question":"class Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        \"\"\"\n        You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.\n        Return the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.\n        Example 1:\n        Input: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\n        Output: 2\n        Explanation: There are two paths where the sum of the elements on the path is divisible by k.\n        The first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.\n        The second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.\n        Example 2:\n        Input: grid = [[0,0]], k = 5\n        Output: 1\n        Explanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.\n        Example 3:\n        Input: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\n        Output: 10\n        Explanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1875,"row":{"number":2441,"difficulty":0,"question":"class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\n        Return the positive integer k. If there is no such integer, return -1.\n        Example 1:\n        Input: nums = [-1,2,-3,3]\n        Output: 3\n        Explanation: 3 is the only valid k we can find in the array.\n        Example 2:\n        Input: nums = [-1,10,6,7,-7,1]\n        Output: 7\n        Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.\n        Example 3:\n        Input: nums = [-10,8,6,7,-2,-3]\n        Output: -1\n        Explanation: There is no a single valid k, we return -1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1876,"row":{"number":2442,"difficulty":1,"question":"class Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given an array nums consisting of positive integers.\n        You have to take each integer in the array, reverse its digits, and add it to the end of the array. You should apply this operation to the original integers in nums.\n        Return the number of distinct integers in the final array.\n        Example 1:\n        Input: nums = [1,13,10,12,31]\n        Output: 6\n        Explanation: After including the reverse of each number, the resulting array is [1,13,10,12,31,1,31,1,21,13].\n        The reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1.\n        The number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31).\n        Example 2:\n        Input: nums = [2,2,2]\n        Output: 1\n        Explanation: After including the reverse of each number, the resulting array is [2,2,2,2,2,2].\n        The number of distinct integers in this array is 1 (The number 2).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1877,"row":{"number":2407,"difficulty":2,"question":"class Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer k.\n        Find the longest subsequence of nums that meets the following requirements:\n            The subsequence is strictly increasing and\n            The difference between adjacent elements in the subsequence is at most k.\n        Return the length of the longest subsequence that meets the requirements.\n        A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n        Example 1:\n        Input: nums = [4,2,1,4,3,4,5,8,15], k = 3\n        Output: 5\n        Explanation:\n        The longest subsequence that meets the requirements is [1,3,4,5,8].\n        The subsequence has a length of 5, so we return 5.\n        Note that the subsequence [1,3,4,5,8,15] does not meet the requirements because 15 - 8 = 7 is larger than 3.\n        Example 2:\n        Input: nums = [7,4,5,1,8,12,4,7], k = 5\n        Output: 4\n        Explanation:\n        The longest subsequence that meets the requirements is [4,5,8,12].\n        The subsequence has a length of 4, so we return 4.\n        Example 3:\n        Input: nums = [1,5], k = 1\n        Output: 1\n        Explanation:\n        The longest subsequence that meets the requirements is [1].\n        The subsequence has a length of 1, so we return 1.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1878,"row":{"number":2444,"difficulty":2,"question":"class Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        \"\"\"\n        You are given an integer array nums and two integers minK and maxK.\n        A fixed-bound subarray of nums is a subarray that satisfies the following conditions:\n            The minimum value in the subarray is equal to minK.\n            The maximum value in the subarray is equal to maxK.\n        Return the number of fixed-bound subarrays.\n        A subarray is a contiguous part of an array.\n        Example 1:\n        Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5\n        Output: 2\n        Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].\n        Example 2:\n        Input: nums = [1,1,1,1], minK = 1, maxK = 1\n        Output: 10\n        Explanation: Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1879,"row":{"number":2437,"difficulty":0,"question":"class Solution:\n    def countTime(self, time: str) -> int:\n        \"\"\"\n        You are given a string of length 5 called time, representing the current time on a digital clock in the format \"hh:mm\". The earliest possible time is \"00:00\" and the latest possible time is \"23:59\".\n        In the string time, the digits represented by the ? symbol are unknown, and must be replaced with a digit from 0 to 9.\n        Return an integer answer, the number of valid clock times that can be created by replacing every ? with a digit from 0 to 9.\n        Example 1:\n        Input: time = \"?5:00\"\n        Output: 2\n        Explanation: We can replace the ? with either a 0 or 1, producing \"05:00\" or \"15:00\". Note that we cannot replace it with a 2, since the time \"25:00\" is invalid. In total, we have two choices.\n        Example 2:\n        Input: time = \"0?:0?\"\n        Output: 100\n        Explanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.\n        Example 3:\n        Input: time = \"??:??\"\n        Output: 1440\n        Explanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1880,"row":{"number":2438,"difficulty":1,"question":"class Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given a positive integer n, there exists a 0-indexed array called powers, composed of the minimum number of powers of 2 that sum to n. The array is sorted in non-decreasing order, and there is only one way to form the array.\n        You are also given a 0-indexed 2D integer array queries, where queries[i] = [lefti, righti]. Each queries[i] represents a query where you have to find the product of all powers[j] with lefti <= j <= righti.\n        Return an array answers, equal in length to queries, where answers[i] is the answer to the ith query. Since the answer to the ith query may be too large, each answers[i] should be returned modulo 109 + 7.\n        Example 1:\n        Input: n = 15, queries = [[0,1],[2,2],[0,3]]\n        Output: [2,4,64]\n        Explanation:\n        For n = 15, powers = [1,2,4,8]. It can be shown that powers cannot be a smaller size.\n        Answer to 1st query: powers[0] * powers[1] = 1 * 2 = 2.\n        Answer to 2nd query: powers[2] = 4.\n        Answer to 3rd query: powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64.\n        Each answer modulo 109 + 7 yields the same answer, so [2,4,64] is returned.\n        Example 2:\n        Input: n = 2, queries = [[0,0]]\n        Output: [2]\n        Explanation:\n        For n = 2, powers = [2].\n        The answer to the only query is powers[0] = 2. The answer modulo 109 + 7 is the same, so [2] is returned.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1881,"row":{"number":2439,"difficulty":1,"question":"class Solution:\n    def minimizeArrayValue(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array nums comprising of n non-negative integers.\n        In one operation, you must:\n            Choose an integer i such that 1 <= i < n and nums[i] > 0.\n            Decrease nums[i] by 1.\n            Increase nums[i - 1] by 1.\n        Return the minimum possible value of the maximum integer of nums after performing any number of operations.\n        Example 1:\n        Input: nums = [3,7,1,6]\n        Output: 5\n        Explanation:\n        One set of optimal operations is as follows:\n        1. Choose i = 1, and nums becomes [4,6,1,6].\n        2. Choose i = 3, and nums becomes [4,6,2,5].\n        3. Choose i = 1, and nums becomes [5,5,2,5].\n        The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.\n        Therefore, we return 5.\n        Example 2:\n        Input: nums = [10,1]\n        Output: 10\n        Explanation:\n        It is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1882,"row":{"number":2440,"difficulty":2,"question":"class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        \"\"\"\n        There is an undirected tree with n nodes labeled from 0 to n - 1.\n        You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\n        You are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\n        Return the maximum number of edges you can delete, such that every connected component in the tree has the same value.\n        Example 1:\n        Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \n        Output: 2 \n        Explanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n        Example 2:\n        Input: nums = [2], edges = []\n        Output: 0\n        Explanation: There are no edges to be deleted.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1883,"row":{"number":2423,"difficulty":0,"question":"class Solution:\n    def equalFrequency(self, word: str) -> bool:\n        \"\"\"\n        You are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal.\n        Return true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise.\n        Note:\n            The frequency of a letter x is the number of times it occurs in the string.\n            You must remove exactly one letter and cannot chose to do nothing.\n        Example 1:\n        Input: word = \"abcc\"\n        Output: true\n        Explanation: Select index 3 and delete it: word becomes \"abc\" and each character has a frequency of 1.\n        Example 2:\n        Input: word = \"aazz\"\n        Output: false\n        Explanation: We must delete a character, so either the frequency of \"a\" is 1 and the frequency of \"z\" is 2, or vice versa. It is impossible to make all present letters have equal frequency.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1884,"row":{"number":2425,"difficulty":1,"question":"class Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        \"\"\"\n        You are given two 0-indexed arrays, nums1 and nums2, consisting of non-negative integers. There exists another array, nums3, which contains the bitwise XOR of all pairings of integers between nums1 and nums2 (every integer in nums1 is paired with every integer in nums2 exactly once).\n        Return the bitwise XOR of all integers in nums3.\n        Example 1:\n        Input: nums1 = [2,1,3], nums2 = [10,2,5,0]\n        Output: 13\n        Explanation:\n        A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3].\n        The bitwise XOR of all these numbers is 13, so we return 13.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 0\n        Explanation:\n        All possible pairs of bitwise XORs are nums1[0] ^ nums2[0], nums1[0] ^ nums2[1], nums1[1] ^ nums2[0],\n        and nums1[1] ^ nums2[1].\n        Thus, one possible nums3 array is [2,5,1,6].\n        2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1885,"row":{"number":2446,"difficulty":0,"question":"class Solution:\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\n        \"\"\"\n        You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:\n            event1 = [startTime1, endTime1] and\n            event2 = [startTime2, endTime2].\n        Event times are valid 24 hours format in the form of HH:MM.\n        A conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).\n        Return true if there is a conflict between two events. Otherwise, return false.\n        Example 1:\n        Input: event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"]\n        Output: true\n        Explanation: The two events intersect at time 2:00.\n        Example 2:\n        Input: event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"]\n        Output: true\n        Explanation: The two events intersect starting from 01:20 to 02:00.\n        Example 3:\n        Input: event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"]\n        Output: false\n        Explanation: The two events do not intersect.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1886,"row":{"number":2448,"difficulty":2,"question":"class Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        \"\"\"\n        You are given two 0-indexed arrays nums and cost consisting each of n positive integers.\n        You can do the following operation any number of times:\n            Increase or decrease any element of the array nums by 1.\n        The cost of doing one operation on the ith element is cost[i].\n        Return the minimum total cost such that all the elements of the array nums become equal.\n        Example 1:\n        Input: nums = [1,3,5,2], cost = [2,3,1,14]\n        Output: 8\n        Explanation: We can make all the elements equal to 2 in the following way:\n        - Increase the 0th element one time. The cost is 2.\n        - Decrease the 1st element one time. The cost is 3.\n        - Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3.\n        The total cost is 2 + 3 + 3 = 8.\n        It can be shown that we cannot make the array equal with a smaller cost.\n        Example 2:\n        Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3]\n        Output: 0\n        Explanation: All the elements are already equal, so no operations are needed.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1887,"row":{"number":2449,"difficulty":2,"question":"class Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        \"\"\"\n        You are given two positive integer arrays nums and target, of the same length.\n        In one operation, you can choose any two distinct indices i and j where 0 <= i, j < nums.length and:\n            set nums[i] = nums[i] + 2 and\n            set nums[j] = nums[j] - 2.\n        Two arrays are considered to be similar if the frequency of each element is the same.\n        Return the minimum number of operations required to make nums similar to target. The test cases are generated such that nums can always be similar to target.\n        Example 1:\n        Input: nums = [8,12,6], target = [2,14,10]\n        Output: 2\n        Explanation: It is possible to make nums similar to target in two operations:\n        - Choose i = 0 and j = 2, nums = [10,12,4].\n        - Choose i = 1 and j = 2, nums = [10,14,2].\n        It can be shown that 2 is the minimum number of operations needed.\n        Example 2:\n        Input: nums = [1,2,5], target = [4,1,3]\n        Output: 1\n        Explanation: We can make nums similar to target in one operation:\n        - Choose i = 1 and j = 2, nums = [1,4,3].\n        Example 3:\n        Input: nums = [1,1,1,1,1], target = [1,1,1,1,1]\n        Output: 0\n        Explanation: The array nums is already similiar to target.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1888,"row":{"number":2443,"difficulty":1,"question":"class Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        \"\"\"\n        Given a non-negative integer num, return true if num can be expressed as the sum of any non-negative integer and its reverse, or false otherwise.\n        Example 1:\n        Input: num = 443\n        Output: true\n        Explanation: 172 + 271 = 443 so we return true.\n        Example 2:\n        Input: num = 63\n        Output: false\n        Explanation: 63 cannot be expressed as the sum of a non-negative integer and its reverse so we return false.\n        Example 3:\n        Input: num = 181\n        Output: true\n        Explanation: 140 + 041 = 181 so we return true. Note that when a number is reversed, there may be leading zeros.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1889,"row":{"number":2455,"difficulty":0,"question":"class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\n        Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.\n        Example 1:\n        Input: nums = [1,3,6,10,12,15]\n        Output: 9\n        Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.\n        Example 2:\n        Input: nums = [1,2,4,7,10]\n        Output: 0\n        Explanation: There is no single number that satisfies the requirement, so return 0.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1890,"row":{"number":2456,"difficulty":1,"question":"class Solution:\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n        \"\"\"\n        You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creator[i], has an id of ids[i], and has views[i] views.\n        The popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video.\n            If multiple creators have the highest popularity, find all of them.\n            If multiple videos have the highest view count for a creator, find the lexicographically smallest id.\n        Return a 2D array of strings answer where answer[i] = [creatori, idi] means that creatori has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order.\n        Example 1:\n        Input: creators = [\"alice\",\"bob\",\"alice\",\"chris\"], ids = [\"one\",\"two\",\"three\",\"four\"], views = [5,10,5,4]\n        Output: [[\"alice\",\"one\"],[\"bob\",\"two\"]]\n        Explanation:\n        The popularity of alice is 5 + 5 = 10.\n        The popularity of bob is 10.\n        The popularity of chris is 4.\n        alice and bob are the most popular creators.\n        For bob, the video with the highest view count is \"two\".\n        For alice, the videos with the highest view count are \"one\" and \"three\". Since \"one\" is lexicographically smaller than \"three\", it is included in the answer.\n        Example 2:\n        Input: creators = [\"alice\",\"alice\",\"alice\"], ids = [\"a\",\"b\",\"c\"], views = [1,2,2]\n        Output: [[\"alice\",\"b\"]]\n        Explanation:\n        The videos with id \"b\" and \"c\" have the highest view count.\n        Since \"b\" is lexicographically smaller than \"c\", it is included in the answer.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1891,"row":{"number":2457,"difficulty":1,"question":"class Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        \"\"\"\n        You are given two positive integers n and target.\n        An integer is considered beautiful if the sum of its digits is less than or equal to target.\n        Return the minimum non-negative integer x such that n + x is beautiful. The input will be generated such that it is always possible to make n beautiful.\n        Example 1:\n        Input: n = 16, target = 6\n        Output: 4\n        Explanation: Initially n is 16 and its digit sum is 1 + 6 = 7. After adding 4, n becomes 20 and digit sum becomes 2 + 0 = 2. It can be shown that we can not make n beautiful with adding non-negative integer less than 4.\n        Example 2:\n        Input: n = 467, target = 6\n        Output: 33\n        Explanation: Initially n is 467 and its digit sum is 4 + 6 + 7 = 17. After adding 33, n becomes 500 and digit sum becomes 5 + 0 + 0 = 5. It can be shown that we can not make n beautiful with adding non-negative integer less than 33.\n        Example 3:\n        Input: n = 1, target = 1\n        Output: 0\n        Explanation: Initially n is 1 and its digit sum is 1, which is already smaller than or equal to target.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1892,"row":{"number":2458,"difficulty":2,"question":"class Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        \"\"\"\n        You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m.\n        You have to perform m independent queries on the tree where in the ith query you do the following:\n            Remove the subtree rooted at the node with the value queries[i] from the tree. It is guaranteed that queries[i] will not be equal to the value of the root.\n        Return an array answer of size m where answer[i] is the height of the tree after performing the ith query.\n        Note:\n            The queries are independent, so the tree returns to its initial state after each query.\n            The height of a tree is the number of edges in the longest simple path from the root to some node in the tree.\n        Example 1:\n        Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\n        Output: [2]\n        Explanation: The diagram above shows the tree after removing the subtree rooted at node with value 4.\n        The height of the tree is 2 (The path 1 -> 3 -> 2).\n        Example 2:\n        Input: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\n        Output: [3,2,3,2]\n        Explanation: We have the following queries:\n        - Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).\n        - Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).\n        - Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).\n        - Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1893,"row":{"number":2447,"difficulty":1,"question":"class Solution:\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        The greatest common divisor of an array is the largest integer that evenly divides all the array elements.\n        Example 1:\n        Input: nums = [9,3,1,2,6,3], k = 3\n        Output: 4\n        Explanation: The subarrays of nums where 3 is the greatest common divisor of all the subarray's elements are:\n        - [9,3,1,2,6,3]\n        - [9,3,1,2,6,3]\n        - [9,3,1,2,6,3]\n        - [9,3,1,2,6,3]\n        Example 2:\n        Input: nums = [4], k = 7\n        Output: 0\n        Explanation: There are no subarrays of nums where 7 is the greatest common divisor of all the subarray's elements.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1894,"row":{"number":2451,"difficulty":0,"question":"class Solution:\n    def oddString(self, words: List[str]) -> str:\n        \"\"\"\n        You are given an array of equal-length strings words. Assume that the length of each string is n.\n        Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25.\n            For example, for the string \"acb\", the difference integer array is [2 - 0, 1 - 2] = [2, -1].\n        All the strings in words have the same difference integer array, except one. You should find that string.\n        Return the string in words that has different difference integer array.\n        Example 1:\n        Input: words = [\"adc\",\"wzy\",\"abc\"]\n        Output: \"abc\"\n        Explanation: \n        - The difference integer array of \"adc\" is [3 - 0, 2 - 3] = [3, -1].\n        - The difference integer array of \"wzy\" is [25 - 22, 24 - 25]= [3, -1].\n        - The difference integer array of \"abc\" is [1 - 0, 2 - 1] = [1, 1]. \n        The odd array out is [1, 1], so we return the corresponding string, \"abc\".\n        Example 2:\n        Input: words = [\"aaa\",\"bob\",\"ccc\",\"ddd\"]\n        Output: \"bob\"\n        Explanation: All the integer arrays are [0, 0] except for \"bob\", which corresponds to [13, -13].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1895,"row":{"number":2453,"difficulty":1,"question":"class Solution:\n    def destroyTargets(self, nums: List[int], space: int) -> int:\n        \"\"\"\n        You are given a 0-indexed array nums consisting of positive integers, representing targets on a number line. You are also given an integer space.\n        You have a machine which can destroy targets. Seeding the machine with some nums[i] allows it to destroy all targets with values that can be represented as nums[i] + c * space, where c is any non-negative integer. You want to destroy the maximum number of targets in nums.\n        Return the minimum value of nums[i] you can seed the machine with to destroy the maximum number of targets.\n        Example 1:\n        Input: nums = [3,7,8,1,1,5], space = 2\n        Output: 1\n        Explanation: If we seed the machine with nums[3], then we destroy all targets equal to 1,3,5,7,9,... \n        In this case, we would destroy 5 total targets (all except for nums[2]). \n        It is impossible to destroy more than 5 targets, so we return nums[3].\n        Example 2:\n        Input: nums = [1,3,5,2,4,6], space = 2\n        Output: 1\n        Explanation: Seeding the machine with nums[0], or nums[3] destroys 3 targets. \n        It is not possible to destroy more than 3 targets.\n        Since nums[0] is the minimal integer that can destroy 3 targets, we return 1.\n        Example 3:\n        Input: nums = [6,2,5], space = 100\n        Output: 2\n        Explanation: Whatever initial seed we select, we can only destroy 1 target. The minimal seed is nums[1].\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1896,"row":{"number":2454,"difficulty":2,"question":"class Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.\n        The second greater integer of nums[i] is nums[j] such that:\n            j > i\n            nums[j] > nums[i]\n            There exists exactly one index k such that nums[k] > nums[i] and i < k < j.\n        If there is no such nums[j], the second greater integer is considered to be -1.\n            For example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3, and that of 3 and 4 is -1.\n        Return an integer array answer, where answer[i] is the second greater integer of nums[i].\n        Example 1:\n        Input: nums = [2,4,0,9,6]\n        Output: [9,6,6,-1,-1]\n        Explanation:\n        0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n        1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n        2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n        3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n        4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\n        Thus, we return [9,6,6,-1,-1].\n        Example 2:\n        Input: nums = [3,3]\n        Output: [-1,-1]\n        Explanation:\n        We return [-1,-1] since neither integer has any integer greater than it.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1897,"row":{"number":2452,"difficulty":1,"question":"class Solution:\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\n        \"\"\"\n        You are given two string arrays, queries and dictionary. All words in each array comprise of lowercase English letters and have the same length.\n        In one edit you can take a word from queries, and change any letter in it to any other letter. Find all words from queries that, after a maximum of two edits, equal some word from dictionary.\n        Return a list of all words from queries, that match with some word from dictionary after a maximum of two edits. Return the words in the same order they appear in queries.\n        Example 1:\n        Input: queries = [\"word\",\"note\",\"ants\",\"wood\"], dictionary = [\"wood\",\"joke\",\"moat\"]\n        Output: [\"word\",\"note\",\"wood\"]\n        Explanation:\n        - Changing the 'r' in \"word\" to 'o' allows it to equal the dictionary word \"wood\".\n        - Changing the 'n' to 'j' and the 't' to 'k' in \"note\" changes it to \"joke\".\n        - It would take more than 2 edits for \"ants\" to equal a dictionary word.\n        - \"wood\" can remain unchanged (0 edits) and match the corresponding dictionary word.\n        Thus, we return [\"word\",\"note\",\"wood\"].\n        Example 2:\n        Input: queries = [\"yes\"], dictionary = [\"not\"]\n        Output: []\n        Explanation:\n        Applying any two edits to \"yes\" cannot make it equal to \"not\". Thus, we return an empty array.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1898,"row":{"number":2460,"difficulty":0,"question":"class Solution:\n    def applyOperations(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        You are given a 0-indexed array nums of size n consisting of non-negative integers.\n        You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n            If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n        After performing all the operations, shift all the 0's to the end of the array.\n            For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n        Return the resulting array.\n        Note that the operations are applied sequentially, not all at once.\n        Example 1:\n        Input: nums = [1,2,2,1,1,0]\n        Output: [1,4,2,0,0,0]\n        Explanation: We do the following operations:\n        - i = 0: nums[0] and nums[1] are not equal, so we skip this operation.\n        - i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].\n        - i = 2: nums[2] and nums[3] are not equal, so we skip this operation.\n        - i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].\n        - i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].\n        After that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].\n        Example 2:\n        Input: nums = [0,1]\n        Output: [1,0]\n        Explanation: No operation can be applied, we just shift the 0 to the end.\n        \"\"\"\n"},"truncated_cells":[]},{"row_idx":1899,"row":{"number":2461,"difficulty":1,"question":"class Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:\n            The length of the subarray is k, and\n            All the elements of the subarray are distinct.\n        Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.\n        A subarray is a contiguous non-empty sequence of elements within an array.\n        Example 1:\n        Input: nums = [1,5,4,2,9,9,9], k = 3\n        Output: 15\n        Explanation: The subarrays of nums with length 3 are:\n        - [1,5,4] which meets the requirements and has a sum of 10.\n        - [5,4,2] which meets the requirements and has a sum of 11.\n        - [4,2,9] which meets the requirements and has a sum of 15.\n        - [2,9,9] which does not meet the requirements because the element 9 is repeated.\n        - [9,9,9] which does not meet the requirements because the element 9 is repeated.\n        We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions\n        Example 2:\n        Input: nums = [4,4,4], k = 3\n        Output: 0\n        Explanation: The subarrays of nums with length 3 are:\n        - [4,4,4] which does not meet the requirements because the element 4 is repeated.\n        We return 0 because no subarrays meet the conditions.\n        \"\"\"\n"},"truncated_cells":[]}],"num_rows_total":2017,"num_rows_per_page":100}